From f2d8aa6432b22e22d278bfff30d47b33e77b4f81 Mon Sep 17 00:00:00 2001
From: Huacai Chen <chenhc@lemote.com>
Date: Tue, 7 Nov 2017 08:28:32 +0800
Subject: [PATCH 085/131] drm: Add SMI SM750/SM768 GPU driver

Signed-off-by: Huacai Chen <chenhc@lemote.com>
---
 drivers/gpu/drm/Kconfig                       |    2 +
 drivers/gpu/drm/Makefile                      |    1 +
 drivers/gpu/drm/smi/Kconfig                   |   25 +
 drivers/gpu/drm/smi/Makefile                  |   25 +
 drivers/gpu/drm/smi/ddk750/ddk750_2d.c        | 2956 ++++++++++++++
 drivers/gpu/drm/smi/ddk750/ddk750_2d.h        |  480 +++
 drivers/gpu/drm/smi/ddk750/ddk750_chip.c      |  234 ++
 drivers/gpu/drm/smi/ddk750/ddk750_chip.h      |  194 +
 drivers/gpu/drm/smi/ddk750/ddk750_clock.c     |  564 +++
 drivers/gpu/drm/smi/ddk750/ddk750_clock.h     |  178 +
 drivers/gpu/drm/smi/ddk750/ddk750_cursor.c    |  104 +
 drivers/gpu/drm/smi/ddk750/ddk750_cursor.h    |   48 +
 drivers/gpu/drm/smi/ddk750/ddk750_defs.h      |   83 +
 drivers/gpu/drm/smi/ddk750/ddk750_display.c   | 1707 ++++++++
 drivers/gpu/drm/smi/ddk750/ddk750_display.h   |  226 ++
 drivers/gpu/drm/smi/ddk750/ddk750_edid.c      | 2223 +++++++++++
 drivers/gpu/drm/smi/ddk750/ddk750_edid.h      | 1024 +++++
 drivers/gpu/drm/smi/ddk750/ddk750_hardware.h  |  191 +
 drivers/gpu/drm/smi/ddk750/ddk750_help.c      |   18 +
 drivers/gpu/drm/smi/ddk750/ddk750_help.h      |  213 +
 drivers/gpu/drm/smi/ddk750/ddk750_helper.c    |   47 +
 drivers/gpu/drm/smi/ddk750/ddk750_helper.h    |   30 +
 drivers/gpu/drm/smi/ddk750/ddk750_hwi2c.c     |  378 ++
 drivers/gpu/drm/smi/ddk750/ddk750_hwi2c.h     |   67 +
 drivers/gpu/drm/smi/ddk750/ddk750_mode.c      | 1001 +++++
 drivers/gpu/drm/smi/ddk750/ddk750_mode.h      |  565 +++
 drivers/gpu/drm/smi/ddk750/ddk750_power.c     |  495 +++
 drivers/gpu/drm/smi/ddk750/ddk750_power.h     |  121 +
 drivers/gpu/drm/smi/ddk750/ddk750_regdc.h     |  960 +++++
 drivers/gpu/drm/smi/ddk750/ddk750_regde.h     |  359 ++
 drivers/gpu/drm/smi/ddk750/ddk750_reggpio.h   |  239 ++
 drivers/gpu/drm/smi/ddk750/ddk750_regi2c.h    |   69 +
 drivers/gpu/drm/smi/ddk750/ddk750_regsc.h     |  900 +++++
 drivers/gpu/drm/smi/ddk750/ddk750_sii9022.c   |   67 +
 drivers/gpu/drm/smi/ddk750/ddk750_sii9022.h   |    3 +
 drivers/gpu/drm/smi/ddk750/ddk750_sw2d.h      |  200 +
 drivers/gpu/drm/smi/ddk750/ddk750_swi2c.c     |  463 +++
 drivers/gpu/drm/smi/ddk750/ddk750_swi2c.h     |   92 +
 drivers/gpu/drm/smi/ddk750/ddkdebug.h         |  141 +
 .../gpu/drm/smi/ddk750/siHdmiTx_902x_TPI.c    | 3514 +++++++++++++++++
 .../gpu/drm/smi/ddk750/siHdmiTx_902x_TPI.h    | 1124 ++++++
 drivers/gpu/drm/smi/ddk750/vdif.h             |   63 +
 drivers/gpu/drm/smi/ddk768/ddk768.h           |   23 +
 drivers/gpu/drm/smi/ddk768/ddk768_2d.c        | 1213 ++++++
 drivers/gpu/drm/smi/ddk768/ddk768_2d.h        |  503 +++
 drivers/gpu/drm/smi/ddk768/ddk768_chip.c      |  183 +
 drivers/gpu/drm/smi/ddk768/ddk768_chip.h      |   84 +
 drivers/gpu/drm/smi/ddk768/ddk768_clock.c     |  182 +
 drivers/gpu/drm/smi/ddk768/ddk768_clock.h     |   68 +
 drivers/gpu/drm/smi/ddk768/ddk768_cursor.c    |  100 +
 drivers/gpu/drm/smi/ddk768/ddk768_cursor.h    |   54 +
 drivers/gpu/drm/smi/ddk768/ddk768_display.c   |  628 +++
 drivers/gpu/drm/smi/ddk768/ddk768_display.h   |  234 ++
 drivers/gpu/drm/smi/ddk768/ddk768_edid.c      | 2116 ++++++++++
 drivers/gpu/drm/smi/ddk768/ddk768_edid.h      | 1049 +++++
 drivers/gpu/drm/smi/ddk768/ddk768_hdmi.c      | 1363 +++++++
 drivers/gpu/drm/smi/ddk768/ddk768_hdmi.h      |  459 +++
 drivers/gpu/drm/smi/ddk768/ddk768_help.c      |   16 +
 drivers/gpu/drm/smi/ddk768/ddk768_help.h      |   32 +
 drivers/gpu/drm/smi/ddk768/ddk768_helper.c    |   84 +
 drivers/gpu/drm/smi/ddk768/ddk768_helper.h    |   44 +
 drivers/gpu/drm/smi/ddk768/ddk768_hwi2c.c     |  294 ++
 drivers/gpu/drm/smi/ddk768/ddk768_hwi2c.h     |   69 +
 drivers/gpu/drm/smi/ddk768/ddk768_iis.c       |  254 ++
 drivers/gpu/drm/smi/ddk768/ddk768_iis.h       |  109 +
 drivers/gpu/drm/smi/ddk768/ddk768_intr.c      |   62 +
 drivers/gpu/drm/smi/ddk768/ddk768_intr.h      |  116 +
 drivers/gpu/drm/smi/ddk768/ddk768_mode.c      |  922 +++++
 drivers/gpu/drm/smi/ddk768/ddk768_mode.h      |  380 ++
 drivers/gpu/drm/smi/ddk768/ddk768_power.c     |  269 ++
 drivers/gpu/drm/smi/ddk768/ddk768_power.h     |   58 +
 drivers/gpu/drm/smi/ddk768/ddk768_reg.h       | 2785 +++++++++++++
 drivers/gpu/drm/smi/ddk768/ddk768_swi2c.c     |  465 +++
 drivers/gpu/drm/smi/ddk768/ddk768_swi2c.h     |   95 +
 drivers/gpu/drm/smi/ddk768/ddk768_timer.c     |  341 ++
 drivers/gpu/drm/smi/ddk768/ddk768_timer.h     |  150 +
 drivers/gpu/drm/smi/ddk768/ddk768_video.c     | 1076 +++++
 drivers/gpu/drm/smi/ddk768/ddk768_video.h     |  564 +++
 drivers/gpu/drm/smi/ddk768/ddkdebug.c         |  227 ++
 drivers/gpu/drm/smi/ddk768/ddkdebug.h         |  141 +
 drivers/gpu/drm/smi/ddk768/hdmiregs.h         |  945 +++++
 drivers/gpu/drm/smi/ddk768/l3.c               |   65 +
 drivers/gpu/drm/smi/ddk768/l3.h               |   22 +
 drivers/gpu/drm/smi/ddk768/uda1345.c          |  368 ++
 drivers/gpu/drm/smi/ddk768/uda1345.h          |  131 +
 drivers/gpu/drm/smi/ddk768/vdif.h             |   63 +
 drivers/gpu/drm/smi/hw750.c                   |  292 ++
 drivers/gpu/drm/smi/hw750.h                   |  154 +
 drivers/gpu/drm/smi/hw768.c                   |  255 ++
 drivers/gpu/drm/smi/hw768.h                   |  149 +
 drivers/gpu/drm/smi/hw_com.h                  |   86 +
 drivers/gpu/drm/smi/smi_drv.c                 |  510 +++
 drivers/gpu/drm/smi/smi_drv.h                 |  419 ++
 drivers/gpu/drm/smi/smi_fbdev.c               |  403 ++
 drivers/gpu/drm/smi/smi_main.c                |  639 +++
 drivers/gpu/drm/smi/smi_mode.c                | 1177 ++++++
 drivers/gpu/drm/smi/smi_plane.c               |  488 +++
 drivers/gpu/drm/smi/smi_prime.c               |  108 +
 drivers/gpu/drm/smi/smi_snd.c                 |  673 ++++
 drivers/gpu/drm/smi/smi_snd.h                 |   90 +
 drivers/gpu/drm/smi/smi_ttm.c                 |  561 +++
 101 files changed, 45804 insertions(+)
 create mode 100644 drivers/gpu/drm/smi/Kconfig
 create mode 100644 drivers/gpu/drm/smi/Makefile
 create mode 100644 drivers/gpu/drm/smi/ddk750/ddk750_2d.c
 create mode 100644 drivers/gpu/drm/smi/ddk750/ddk750_2d.h
 create mode 100644 drivers/gpu/drm/smi/ddk750/ddk750_chip.c
 create mode 100644 drivers/gpu/drm/smi/ddk750/ddk750_chip.h
 create mode 100644 drivers/gpu/drm/smi/ddk750/ddk750_clock.c
 create mode 100644 drivers/gpu/drm/smi/ddk750/ddk750_clock.h
 create mode 100644 drivers/gpu/drm/smi/ddk750/ddk750_cursor.c
 create mode 100644 drivers/gpu/drm/smi/ddk750/ddk750_cursor.h
 create mode 100644 drivers/gpu/drm/smi/ddk750/ddk750_defs.h
 create mode 100644 drivers/gpu/drm/smi/ddk750/ddk750_display.c
 create mode 100644 drivers/gpu/drm/smi/ddk750/ddk750_display.h
 create mode 100644 drivers/gpu/drm/smi/ddk750/ddk750_edid.c
 create mode 100644 drivers/gpu/drm/smi/ddk750/ddk750_edid.h
 create mode 100644 drivers/gpu/drm/smi/ddk750/ddk750_hardware.h
 create mode 100644 drivers/gpu/drm/smi/ddk750/ddk750_help.c
 create mode 100644 drivers/gpu/drm/smi/ddk750/ddk750_help.h
 create mode 100644 drivers/gpu/drm/smi/ddk750/ddk750_helper.c
 create mode 100644 drivers/gpu/drm/smi/ddk750/ddk750_helper.h
 create mode 100644 drivers/gpu/drm/smi/ddk750/ddk750_hwi2c.c
 create mode 100644 drivers/gpu/drm/smi/ddk750/ddk750_hwi2c.h
 create mode 100644 drivers/gpu/drm/smi/ddk750/ddk750_mode.c
 create mode 100644 drivers/gpu/drm/smi/ddk750/ddk750_mode.h
 create mode 100644 drivers/gpu/drm/smi/ddk750/ddk750_power.c
 create mode 100644 drivers/gpu/drm/smi/ddk750/ddk750_power.h
 create mode 100644 drivers/gpu/drm/smi/ddk750/ddk750_regdc.h
 create mode 100644 drivers/gpu/drm/smi/ddk750/ddk750_regde.h
 create mode 100644 drivers/gpu/drm/smi/ddk750/ddk750_reggpio.h
 create mode 100644 drivers/gpu/drm/smi/ddk750/ddk750_regi2c.h
 create mode 100644 drivers/gpu/drm/smi/ddk750/ddk750_regsc.h
 create mode 100644 drivers/gpu/drm/smi/ddk750/ddk750_sii9022.c
 create mode 100644 drivers/gpu/drm/smi/ddk750/ddk750_sii9022.h
 create mode 100644 drivers/gpu/drm/smi/ddk750/ddk750_sw2d.h
 create mode 100644 drivers/gpu/drm/smi/ddk750/ddk750_swi2c.c
 create mode 100644 drivers/gpu/drm/smi/ddk750/ddk750_swi2c.h
 create mode 100644 drivers/gpu/drm/smi/ddk750/ddkdebug.h
 create mode 100644 drivers/gpu/drm/smi/ddk750/siHdmiTx_902x_TPI.c
 create mode 100644 drivers/gpu/drm/smi/ddk750/siHdmiTx_902x_TPI.h
 create mode 100644 drivers/gpu/drm/smi/ddk750/vdif.h
 create mode 100644 drivers/gpu/drm/smi/ddk768/ddk768.h
 create mode 100644 drivers/gpu/drm/smi/ddk768/ddk768_2d.c
 create mode 100644 drivers/gpu/drm/smi/ddk768/ddk768_2d.h
 create mode 100644 drivers/gpu/drm/smi/ddk768/ddk768_chip.c
 create mode 100644 drivers/gpu/drm/smi/ddk768/ddk768_chip.h
 create mode 100644 drivers/gpu/drm/smi/ddk768/ddk768_clock.c
 create mode 100644 drivers/gpu/drm/smi/ddk768/ddk768_clock.h
 create mode 100644 drivers/gpu/drm/smi/ddk768/ddk768_cursor.c
 create mode 100644 drivers/gpu/drm/smi/ddk768/ddk768_cursor.h
 create mode 100644 drivers/gpu/drm/smi/ddk768/ddk768_display.c
 create mode 100644 drivers/gpu/drm/smi/ddk768/ddk768_display.h
 create mode 100644 drivers/gpu/drm/smi/ddk768/ddk768_edid.c
 create mode 100644 drivers/gpu/drm/smi/ddk768/ddk768_edid.h
 create mode 100644 drivers/gpu/drm/smi/ddk768/ddk768_hdmi.c
 create mode 100644 drivers/gpu/drm/smi/ddk768/ddk768_hdmi.h
 create mode 100644 drivers/gpu/drm/smi/ddk768/ddk768_help.c
 create mode 100644 drivers/gpu/drm/smi/ddk768/ddk768_help.h
 create mode 100644 drivers/gpu/drm/smi/ddk768/ddk768_helper.c
 create mode 100644 drivers/gpu/drm/smi/ddk768/ddk768_helper.h
 create mode 100644 drivers/gpu/drm/smi/ddk768/ddk768_hwi2c.c
 create mode 100644 drivers/gpu/drm/smi/ddk768/ddk768_hwi2c.h
 create mode 100644 drivers/gpu/drm/smi/ddk768/ddk768_iis.c
 create mode 100644 drivers/gpu/drm/smi/ddk768/ddk768_iis.h
 create mode 100644 drivers/gpu/drm/smi/ddk768/ddk768_intr.c
 create mode 100644 drivers/gpu/drm/smi/ddk768/ddk768_intr.h
 create mode 100644 drivers/gpu/drm/smi/ddk768/ddk768_mode.c
 create mode 100644 drivers/gpu/drm/smi/ddk768/ddk768_mode.h
 create mode 100644 drivers/gpu/drm/smi/ddk768/ddk768_power.c
 create mode 100644 drivers/gpu/drm/smi/ddk768/ddk768_power.h
 create mode 100644 drivers/gpu/drm/smi/ddk768/ddk768_reg.h
 create mode 100644 drivers/gpu/drm/smi/ddk768/ddk768_swi2c.c
 create mode 100644 drivers/gpu/drm/smi/ddk768/ddk768_swi2c.h
 create mode 100644 drivers/gpu/drm/smi/ddk768/ddk768_timer.c
 create mode 100644 drivers/gpu/drm/smi/ddk768/ddk768_timer.h
 create mode 100644 drivers/gpu/drm/smi/ddk768/ddk768_video.c
 create mode 100644 drivers/gpu/drm/smi/ddk768/ddk768_video.h
 create mode 100644 drivers/gpu/drm/smi/ddk768/ddkdebug.c
 create mode 100644 drivers/gpu/drm/smi/ddk768/ddkdebug.h
 create mode 100644 drivers/gpu/drm/smi/ddk768/hdmiregs.h
 create mode 100644 drivers/gpu/drm/smi/ddk768/l3.c
 create mode 100644 drivers/gpu/drm/smi/ddk768/l3.h
 create mode 100644 drivers/gpu/drm/smi/ddk768/uda1345.c
 create mode 100644 drivers/gpu/drm/smi/ddk768/uda1345.h
 create mode 100644 drivers/gpu/drm/smi/ddk768/vdif.h
 create mode 100644 drivers/gpu/drm/smi/hw750.c
 create mode 100644 drivers/gpu/drm/smi/hw750.h
 create mode 100644 drivers/gpu/drm/smi/hw768.c
 create mode 100644 drivers/gpu/drm/smi/hw768.h
 create mode 100644 drivers/gpu/drm/smi/hw_com.h
 create mode 100644 drivers/gpu/drm/smi/smi_drv.c
 create mode 100644 drivers/gpu/drm/smi/smi_drv.h
 create mode 100644 drivers/gpu/drm/smi/smi_fbdev.c
 create mode 100644 drivers/gpu/drm/smi/smi_main.c
 create mode 100644 drivers/gpu/drm/smi/smi_mode.c
 create mode 100644 drivers/gpu/drm/smi/smi_plane.c
 create mode 100644 drivers/gpu/drm/smi/smi_prime.c
 create mode 100644 drivers/gpu/drm/smi/smi_snd.c
 create mode 100644 drivers/gpu/drm/smi/smi_snd.h
 create mode 100644 drivers/gpu/drm/smi/smi_ttm.c

diff --git a/drivers/gpu/drm/Kconfig b/drivers/gpu/drm/Kconfig
index e67c194c2aca..b583eeee603b 100644
--- a/drivers/gpu/drm/Kconfig
+++ b/drivers/gpu/drm/Kconfig
@@ -280,6 +280,8 @@ source "drivers/gpu/drm/udl/Kconfig"
 
 source "drivers/gpu/drm/ast/Kconfig"
 
+source "drivers/gpu/drm/smi/Kconfig"
+
 source "drivers/gpu/drm/mgag200/Kconfig"
 
 source "drivers/gpu/drm/cirrus/Kconfig"
diff --git a/drivers/gpu/drm/Makefile b/drivers/gpu/drm/Makefile
index 82ff826b33cc..97604380c615 100644
--- a/drivers/gpu/drm/Makefile
+++ b/drivers/gpu/drm/Makefile
@@ -84,6 +84,7 @@ obj-$(CONFIG_DRM_ROCKCHIP) +=rockchip/
 obj-$(CONFIG_DRM_GMA500) += gma500/
 obj-$(CONFIG_DRM_UDL) += udl/
 obj-$(CONFIG_DRM_AST) += ast/
+obj-$(CONFIG_DRM_SMI) += smi/
 obj-$(CONFIG_DRM_ARMADA) += armada/
 obj-$(CONFIG_DRM_ATMEL_HLCDC)	+= atmel-hlcdc/
 obj-y			+= rcar-du/
diff --git a/drivers/gpu/drm/smi/Kconfig b/drivers/gpu/drm/smi/Kconfig
new file mode 100644
index 000000000000..bc41edfc1ce4
--- /dev/null
+++ b/drivers/gpu/drm/smi/Kconfig
@@ -0,0 +1,25 @@
+config DRM_SMI
+	tristate "SMI DRM driver"
+	depends on DRM && PCI
+	select DRM_TTM
+	select DRM_KMS_HELPER
+	help
+	 Say yes for SMI GPU driver (SM750 & SM768).
+
+config DRM_SMI_HDMI
+	bool "enable SMI HDMI"
+	depends on DRM_SMI
+	help
+	  Compile in support for HDMI.
+
+config DRM_SMI_AUDIO
+	bool "enable SMI Audio"
+	depends on DRM_SMI
+	help
+	  Compile in support for Audio.
+
+config DRM_SMI_PRIME
+	bool "enable SMI PRIME"
+	depends on DRM_SMI
+	help
+	  Compile in support for PRIME.
diff --git a/drivers/gpu/drm/smi/Makefile b/drivers/gpu/drm/smi/Makefile
new file mode 100644
index 000000000000..55c27024d135
--- /dev/null
+++ b/drivers/gpu/drm/smi/Makefile
@@ -0,0 +1,25 @@
+obj-$(CONFIG_DRM_SMI) := smifb.o
+smifb-objs :=smi_drv.o smi_fbdev.o smi_main.o smi_mode.o smi_plane.o smi_ttm.o smi_prime.o hw750.o hw768.o
+smifb-objs += ddk750/ddk750_help.o  ddk750/ddk750_chip.o  ddk750/ddk750_clock.o  ddk750/ddk750_mode.o ddk750/ddk750_power.o ddk750/ddk750_helper.o ddk750/ddk750_display.o ddk750/ddk750_2d.o ddk750/ddk750_edid.o ddk750/ddk750_swi2c.o ddk750/ddk750_hwi2c.o ddk750/ddk750_cursor.o
+smifb-objs += ddk768/ddk768_help.o  ddk768/ddk768_chip.o  ddk768/ddk768_clock.o  ddk768/ddk768_mode.o ddk768/ddk768_power.o ddk768/ddk768_helper.o ddk768/ddk768_display.o ddk768/ddk768_2d.o \
+ddk768/ddk768_edid.o ddk768/ddk768_swi2c.o ddk768/ddk768_hwi2c.o ddk768/ddk768_cursor.o ddk768/ddk768_video.o ddk768/ddk768_hdmi.o  ddk768/ddk768_timer.o ddk768/ddk768_intr.o
+
+ifeq ($(CONFIG_DRM_SMI_HDMI),y)
+EXTRA_CFLAGS += -DUSE_HDMICHIP
+smifb-y += ddk750/ddk750_sii9022.o
+smifb-y += ddk750/siHdmiTx_902x_TPI.o
+endif
+
+ifeq ($(CONFIG_DRM_SMI_AUDIO),y)
+EXTRA_CFLAGS += -DAUDIO_EN
+smifb-y += smi_snd.o
+smifb-y += ddk768/ddk768_iis.o
+smifb-y += ddk768/uda1345.o
+smifb-y += ddk768/l3.o
+endif
+
+ifeq ($(CONFIG_DRM_SMI_PRIME),y)
+EXTRA_CFLAGS += -DPRIME
+endif
+
+ccflags-y :=-O2 -Iinclude/drm -fno-tree-scev-cprop -D_D_SMI -D_D_SMI_D -D__cdecl
diff --git a/drivers/gpu/drm/smi/ddk750/ddk750_2d.c b/drivers/gpu/drm/smi/ddk750/ddk750_2d.c
new file mode 100644
index 000000000000..7bdbebec45fd
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk750/ddk750_2d.c
@@ -0,0 +1,2956 @@
+/*******************************************************************
+*
+*         Copyright (c) 2007 by Silicon Motion, Inc. (SMI)
+*
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+*
+*  2d.C --- SM750/SM718 DDK
+*  This file contains the definitions for the 2D functions.
+*
+*******************************************************************/
+
+#include "ddk750_defs.h"
+#include "ddk750_hardware.h"
+#include "ddk750_chip.h"
+#include "ddk750_power.h"
+#include "ddk750_sw2d.h"
+#include "ddk750_2d.h"
+#include "ddk750_help.h"
+#include "ddk750_regde.h"
+
+/* Flag to enable the 192 bytes patch to workaround the 2D errata, where the engine
+   will draws incorrectly for BITBLT function that involves READ from memory. 
+   Currently, this definition flag is only used for testing. */
+#define ENABLE_192_BYTES_PATCH
+
+/* Static macro */
+#define BYTE_PER_PIXEL(bpp)         (bpp / 8)
+
+/*
+ * 2D Engine Initialization.
+ * This function must be called before other 2D functions.
+ * Assumption: A specific video mode has been properly set up.
+ */
+void ddk750_deInit(void)
+{
+    enable2DEngine(1);
+
+    deReset(); /* Just be sure no left-over operations from other applications */
+
+    /* Set up 2D registers that won't change for a specific mode. */
+
+    /* Drawing engine bus and pixel mask, always want to enable. */
+    POKE_32(DE_MASKS, 0xFFFFFFFF);
+
+    /* Pixel format, which can be 8, 16 or 32.
+       Assuming setmode is call before 2D init, then pixel format
+       is available in reg 0x80000 (Panel Display Control)
+    */
+    POKE_32(DE_STRETCH_FORMAT,
+        FIELD_SET  (0, DE_STRETCH_FORMAT, PATTERN_XY,   NORMAL)  |
+        FIELD_VALUE(0, DE_STRETCH_FORMAT, PATTERN_Y,    0)       |
+        FIELD_VALUE(0, DE_STRETCH_FORMAT, PATTERN_X,    0)       |
+        FIELD_SET  (0, DE_STRETCH_FORMAT, ADDRESSING,   XY)      |
+        FIELD_VALUE(0, DE_STRETCH_FORMAT, SOURCE_HEIGHT,3));
+
+    /* Clipping and transparent are disable after INIT */
+    deSetClipping(0, 0, 0, 0, 0);
+    deSetTransparency(0, 0, 0, 0);
+}
+
+/*
+ * Reset 2D engine by 
+ * 1) Aborting the current 2D operation.
+ * 2) Re-enable 2D engine to normal state.
+ */
+void deReset()
+{
+    unsigned long sysCtrl;
+	logical_chip_type_t chipType = ddk750_getChipType();
+
+	if (chipType == SM750 || chipType == SM718)
+	{
+    	/* Abort current 2D operation */
+    	sysCtrl = PEEK_32(SYSTEM_CTRL);
+    	sysCtrl = FIELD_SET(sysCtrl, SYSTEM_CTRL, DE_ABORT, ON);
+    	POKE_32(SYSTEM_CTRL, sysCtrl);
+
+    	/* Re-enable 2D engine to normal state */
+    	sysCtrl = PEEK_32(SYSTEM_CTRL);
+    	sysCtrl = FIELD_SET(sysCtrl, SYSTEM_CTRL, DE_ABORT, OFF);
+    	POKE_32(SYSTEM_CTRL, sysCtrl);
+	}
+	else /* For SM750LE and SM750HS series */
+	{
+	    /* Abort current 2D operation */
+		sysCtrl = PEEK_32(DE_STATE1);
+		sysCtrl = FIELD_SET(sysCtrl, DE_STATE1, DE_ABORT, ON);
+		POKE_32(DE_STATE1, sysCtrl);
+
+		/* Re-enable 2D engine to normal state */
+        sysCtrl = PEEK_32(DE_STATE1);
+		sysCtrl = FIELD_SET(sysCtrl, DE_STATE1, DE_ABORT, OFF);
+		POKE_32(DE_STATE1, sysCtrl);
+	}
+}
+ 
+/*
+ * Wait until 2D engine is not busy.
+ * All 2D operations are recommand to check 2D engine idle before start.
+ *
+ * Return: 0 = return because engine is idle and normal.
+ *        -1 = return because time out (2D engine may have problem).
+ */
+long deWaitForNotBusy(void)
+{
+	unsigned long dwVal;
+	logical_chip_type_t chipType;
+    unsigned long i = 0x100000;
+
+	chipType = ddk750_getChipType();
+
+	if (chipType == SM750 || chipType == SM718)
+	{
+    	while (i--)
+    	{
+    	    dwVal = PEEK_32(SYSTEM_CTRL);
+    	    if ((FIELD_GET(dwVal, SYSTEM_CTRL, DE_STATUS)      == SYSTEM_CTRL_DE_STATUS_IDLE) &&
+    	        (FIELD_GET(dwVal, SYSTEM_CTRL, DE_FIFO)        == SYSTEM_CTRL_DE_FIFO_EMPTY) &&
+    	        (FIELD_GET(dwVal, SYSTEM_CTRL, CSC_STATUS)     == SYSTEM_CTRL_CSC_STATUS_IDLE) &&
+    	        (FIELD_GET(dwVal, SYSTEM_CTRL, DE_MEM_FIFO)    == SYSTEM_CTRL_DE_MEM_FIFO_EMPTY))
+    	    {
+    	        return 0; /* Return because engine idle */
+    	    }
+    	}
+
+    	return -1; /* Return because time out */
+	}
+    else /* For SM750LE & SM750HS */
+    {
+        while (i--)
+        {
+            dwVal = PEEK_32(DE_STATE2);
+            if ((FIELD_GET(dwVal, DE_STATE2, DE_STATUS)      == DE_STATE2_DE_STATUS_IDLE) &&
+                (FIELD_GET(dwVal, DE_STATE2, DE_FIFO)        == DE_STATE2_DE_FIFO_EMPTY) &&
+                (FIELD_GET(dwVal, DE_STATE2, DE_MEM_FIFO)    == DE_STATE2_DE_MEM_FIFO_EMPTY))
+            {
+                return 0; /* Return because engine idle */
+			}
+        }
+		return -1; /* Return because of timeout */
+    }
+}
+
+#if 0 /* Cheok_2013_0118: Delete this funciton since no other functions are calling it. */
+/* deWaitIdle() function.
+ *
+ * This function is same as deWaitForNotBusy(), except application can
+ * input the maximum number of times that this function will check 
+ * the idle register.
+ *
+ * Its usage is mainly for debugging purpose.
+ *
+ * Wait until 2D engine is not busy.
+ * All 2D operations are recommand to check 2D engine idle before start.
+ *
+ * Return: 0 = return because engine is idle and normal.
+ *        -1 = return because time out (2D engine may have problem).
+ */
+long deWaitIdle(unsigned long i)
+{
+	unsigned long dwVal;
+
+    if (ddk750_getChipType() == SM750LE)
+    {
+#if 0
+		while (i--)
+		{
+			dwVal = PEEK_32(DE_CONTROL);
+			if (FIELD_GET(dwVal, DE_CONTROL, STATUS) == DE_CONTROL_STATUS_STOP)
+				return 0;
+		}
+		return -1;
+#else
+        while (i--)
+        {
+            dwVal = PEEK_32(DE_STATE2);
+            if ((FIELD_GET(dwVal, DE_STATE2, DE_STATUS)      == DE_STATE2_DE_STATUS_IDLE) && 
+                (FIELD_GET(dwVal, DE_STATE2, DE_FIFO)        == DE_STATE2_DE_FIFO_EMPTY) &&
+                (FIELD_GET(dwVal, DE_STATE2, DE_MEM_FIFO)    == DE_STATE2_DE_MEM_FIFO_EMPTY))
+            {
+                return 0; /* Return because engine idle */
+            }
+        }
+
+        return -1; /* Return because time out */
+#endif
+    }
+
+    while (i--)
+    {
+        dwVal = PEEK_32(SYSTEM_CTRL);
+        if ((FIELD_GET(dwVal, SYSTEM_CTRL, DE_STATUS)      == SYSTEM_CTRL_DE_STATUS_IDLE) &&
+            (FIELD_GET(dwVal, SYSTEM_CTRL, DE_FIFO)        == SYSTEM_CTRL_DE_FIFO_EMPTY) &&
+            (FIELD_GET(dwVal, SYSTEM_CTRL, CSC_STATUS)     == SYSTEM_CTRL_CSC_STATUS_IDLE) &&
+            (FIELD_GET(dwVal, SYSTEM_CTRL, DE_MEM_FIFO)    == SYSTEM_CTRL_DE_MEM_FIFO_EMPTY))
+        {
+            return 0; /* Return because engine idle */
+        }
+    }
+
+    return -1; /* Return because time out */
+}
+#endif
+
+/*
+ * This function enable/disable clipping area for the 2d engine.
+ * Note that the clipping area is always rectangular.
+ * 
+ */
+long deSetClipping(
+unsigned long enable, /* 0 = disable clipping, 1 = enable clipping */
+unsigned long x1,     /* x1, y1 is the upper left corner of the clipping area */
+unsigned long y1,     /* Note that the region includes x1 and y1 */
+unsigned long x2,     /* x2, y2 is the lower right corner of the clippiing area */
+unsigned long y2)     /* Note that the region will not include x2 and y2 */
+{
+    if (deWaitForNotBusy() != 0)
+    {
+        /* The 2D engine is always busy for some unknown reason.
+           Application can choose to return ERROR, or reset it and
+           continue the operation.
+        */
+
+        return -1;
+
+        /* or */
+        /* deReset(); */
+    }
+
+    /* Upper left corner and enable/disable bit
+       Note: This module defautls to clip outside region.
+       "Clip inside" is not a useful feature since nothing gets drawn.
+     */
+    POKE_32(DE_CLIP_TL,
+        FIELD_VALUE(0, DE_CLIP_TL, TOP, y1) |
+        ((enable)?
+          FIELD_SET(0, DE_CLIP_TL, STATUS, ENABLE)
+        : FIELD_SET(0, DE_CLIP_TL, STATUS, DISABLE))|
+        FIELD_SET  (0, DE_CLIP_TL, INHIBIT,OUTSIDE) |
+        FIELD_VALUE(0, DE_CLIP_TL, LEFT, x1));
+
+    /* Lower right corner */
+    POKE_32(DE_CLIP_BR,
+        FIELD_VALUE(0, DE_CLIP_BR, BOTTOM,y2) |
+        FIELD_VALUE(0, DE_CLIP_BR, RIGHT, x2));
+
+    return 0;
+}
+
+/* 
+ * Function description:
+ * When transparency is enable, the blt engine compares each pixel value 
+ * (either source or destination) with DE_COLOR_COMPARE register.
+ * If match, the destination pixel will NOT be updated.
+ * If not match, the destination pixel will be updated.
+ */
+long deSetTransparency(
+unsigned long enable,     /* 0 = disable, 1 = enable transparency feature */
+unsigned long tSelect,    /* 0 = compare source, 1 = compare destination */
+unsigned long tMatch,     /* 0 = Opaque mode, 1 = transparent mode */
+unsigned long ulColor)    /* Color to compare. */
+{
+    unsigned long de_ctrl;
+
+    if (deWaitForNotBusy() != 0)
+    {
+        /* The 2D engine is always busy for some unknown reason.
+           Application can choose to return ERROR, or reset it and
+           continue the operation.
+        */
+
+        return -1;
+
+        /* or */
+        /* deReset(); */
+    }
+
+    /* Set mask */
+    if (enable)
+    {
+        POKE_32(DE_COLOR_COMPARE_MASK, 0x00ffffff);
+
+        /* Set compare color */
+        POKE_32(DE_COLOR_COMPARE, ulColor);
+    }
+    else
+    {
+        POKE_32(DE_COLOR_COMPARE_MASK, 0x0);
+        POKE_32(DE_COLOR_COMPARE, 0x0);
+    }
+
+    /* Set up transparency control, without affecting other bits
+       Note: There are two operatiing modes: Transparent and Opague.
+       We only use transparent mode because Opaque mode may have bug.
+    */
+    de_ctrl = PEEK_32(DE_CONTROL)
+              & FIELD_CLEAR(DE_CONTROL, TRANSPARENCY)
+              & FIELD_CLEAR(DE_CONTROL, TRANSPARENCY_MATCH)
+              & FIELD_CLEAR(DE_CONTROL, TRANSPARENCY_SELECT);
+
+    /* For DE_CONTROL_TRANSPARENCY_MATCH bit, always set it
+       to TRANSPARENT mode, OPAQUE mode don't seem working.
+    */
+    de_ctrl |=
+    ((enable)?
+      FIELD_SET(0, DE_CONTROL, TRANSPARENCY, ENABLE)
+    : FIELD_SET(0, DE_CONTROL, TRANSPARENCY, DISABLE))        |
+    ((tMatch)?
+      FIELD_SET(0, DE_CONTROL, TRANSPARENCY_MATCH, TRANSPARENT)
+    : FIELD_SET(0, DE_CONTROL, TRANSPARENCY_MATCH, OPAQUE)) |
+    ((tSelect)?
+      FIELD_SET(0, DE_CONTROL, TRANSPARENCY_SELECT, DESTINATION)
+    : FIELD_SET(0, DE_CONTROL, TRANSPARENCY_SELECT, SOURCE));
+
+    POKE_32(DE_CONTROL, de_ctrl);
+
+    return 0;
+}
+
+/*
+ * This function gets the transparency status from DE_CONTROL register.
+ * It returns a double word with the transparent fields properly set,
+ * while other fields are 0.
+ */
+unsigned long deGetTransparency(void)
+{
+    unsigned long de_ctrl;
+
+    de_ctrl = PEEK_32(DE_CONTROL);
+
+    de_ctrl &= 
+        FIELD_MASK(DE_CONTROL_TRANSPARENCY_MATCH) | 
+        FIELD_MASK(DE_CONTROL_TRANSPARENCY_SELECT)| 
+        FIELD_MASK(DE_CONTROL_TRANSPARENCY);
+
+    return de_ctrl;
+}
+
+/*
+ * This function sets the pixel format that will apply to the 2D Engine.
+ */
+void deSetPixelFormat(
+    unsigned long bpp
+)
+{
+    unsigned long de_format;
+    
+    de_format = PEEK_32(DE_STRETCH_FORMAT);
+    
+    switch (bpp)
+    {
+        case 8:
+            de_format = FIELD_SET(de_format, DE_STRETCH_FORMAT, PIXEL_FORMAT, 8);
+            break;
+        default:
+        case 16:
+            de_format = FIELD_SET(de_format, DE_STRETCH_FORMAT, PIXEL_FORMAT, 16);
+            break;
+        case 32:
+            de_format = FIELD_SET(de_format, DE_STRETCH_FORMAT, PIXEL_FORMAT, 32);
+            break;
+    }
+    
+    POKE_32(DE_STRETCH_FORMAT, de_format);
+}
+
+/*
+ * This function uses 2D engine to fill a rectangular area with a specific color.
+ * The filled area includes the starting points.
+ */
+long deRectFill( /*resolution_t resolution, point_t p0, point_t p1, unsigned long color, unsigned long rop2)*/
+unsigned long dBase,  /* Base address of destination surface counted from beginning of video frame buffer */
+unsigned long dPitch, /* Pitch value of destination surface in BYTES */
+unsigned long bpp,    /* Color depth of destination surface: 8, 16 or 32 */
+unsigned long x,
+unsigned long y,      /* Upper left corner (X, Y) of rectangle in pixel value */
+unsigned long width, 
+unsigned long height, /* width and height of rectange in pixel value */
+unsigned long color,  /* Color to be filled */
+unsigned long rop2)   /* ROP value */
+{
+    unsigned long de_ctrl, bytePerPixel;
+
+    bytePerPixel = bpp/8;
+    
+    if (deWaitForNotBusy() != 0)
+    {
+        /* The 2D engine is always busy for some unknown reason.
+           Application can choose to return ERROR, or reset it and
+           continue the operation.
+        */
+
+        return -1;
+
+        /* or */
+        /* deReset(); */
+    }
+
+    /* 2D Destination Base.
+       It is an address offset (128 bit aligned) from the beginning of frame buffer.
+    */
+    POKE_32(DE_WINDOW_DESTINATION_BASE, dBase);
+
+    /* Program pitch (distance between the 1st points of two adjacent lines).
+       Note that input pitch is BYTE value, but the 2D Pitch register uses
+       pixel values. Need Byte to pixel convertion.
+    */
+    POKE_32(DE_PITCH,
+        FIELD_VALUE(0, DE_PITCH, DESTINATION, (dPitch/bytePerPixel)) |
+        FIELD_VALUE(0, DE_PITCH, SOURCE,      (dPitch/bytePerPixel)));
+
+    /* Screen Window width in Pixels.
+       2D engine uses this value to calculate the linear address in frame buffer for a given point.
+    */
+    POKE_32(DE_WINDOW_WIDTH,
+        FIELD_VALUE(0, DE_WINDOW_WIDTH, DESTINATION, (dPitch/bytePerPixel)) |
+        FIELD_VALUE(0, DE_WINDOW_WIDTH, SOURCE,      (dPitch/bytePerPixel)));
+
+    POKE_32(DE_FOREGROUND, color);
+
+    /* Set the pixel format of the destination */
+    deSetPixelFormat(bpp);
+
+#ifdef ENABLE_192_BYTES_PATCH
+    /* Workaround for 192 byte requirement when ROP is not COPY */
+    if (((rop2 != ROP2_COPY) || (rop2 != ROP2_Sn) || (rop2 != ROP2_Dn) || 
+         (rop2 != ROP2_D) || (rop2 != ROP2_BLACK) || (rop2 != ROP2_WHITE)) && 
+        ((width * bytePerPixel) > 192))
+    {
+        /* Perform the ROP2 operation in chunks of (xWidth * nHeight) */
+        unsigned long xChunk = 192 / bytePerPixel; /* chunk width is in pixels */
+        
+//        DDKDEBUGPRINT((DE_LEVEL, "ROP != ROP_COPY, width * bytePerPixel = %x (> 192 bytes)\n", width * bytePerPixel));
+
+        while (1)
+        {
+            deWaitForNotBusy();
+            
+            POKE_32(DE_DESTINATION,
+                FIELD_SET  (0, DE_DESTINATION, WRAP, DISABLE) |
+                FIELD_VALUE(0, DE_DESTINATION, X,    x)  |
+                FIELD_VALUE(0, DE_DESTINATION, Y,    y));
+                
+            POKE_32(DE_DIMENSION,
+                FIELD_VALUE(0, DE_DIMENSION, X,    xChunk) |
+                FIELD_VALUE(0, DE_DIMENSION, Y_ET, height));
+
+            de_ctrl = 
+                FIELD_SET  (0, DE_CONTROL,  STATUS,     START)          |
+                FIELD_SET  (0, DE_CONTROL,  DIRECTION,  LEFT_TO_RIGHT)  |
+                //FIELD_SET  (0, DE_CONTROL,LAST_PIXEL, OFF)            |
+                FIELD_SET  (0, DE_CONTROL,  COMMAND,    RECTANGLE_FILL) |
+                FIELD_SET  (0, DE_CONTROL,  ROP_SELECT, ROP2)           |
+                FIELD_VALUE(0, DE_CONTROL,  ROP,        rop2);
+
+            POKE_32(DE_CONTROL, de_ctrl | deGetTransparency());
+
+            if (xChunk == width) break;
+
+            x += xChunk;
+            width -= xChunk;
+
+            if (xChunk > width)
+            {
+                /* This is the last chunk. */
+                xChunk = width;
+            }
+        }
+    }
+    else
+#endif
+    {
+        POKE_32(DE_DESTINATION,
+            FIELD_SET  (0, DE_DESTINATION, WRAP, DISABLE) |
+            FIELD_VALUE(0, DE_DESTINATION, X,    x)       |
+            FIELD_VALUE(0, DE_DESTINATION, Y,    y));
+
+        POKE_32(DE_DIMENSION,
+            FIELD_VALUE(0, DE_DIMENSION, X,    width) |
+            FIELD_VALUE(0, DE_DIMENSION, Y_ET, height));
+
+        de_ctrl = 
+            FIELD_SET  (0, DE_CONTROL,  STATUS,     START)          |
+            FIELD_SET  (0, DE_CONTROL,  DIRECTION,  LEFT_TO_RIGHT)  |
+            //FIELD_SET  (0, DE_CONTROL,LAST_PIXEL, OFF)            |
+            FIELD_SET  (0, DE_CONTROL,  COMMAND,    RECTANGLE_FILL) |
+            FIELD_SET  (0, DE_CONTROL,  ROP_SELECT, ROP2)           |
+            FIELD_VALUE(0, DE_CONTROL,  ROP,        rop2);
+
+        POKE_32(DE_CONTROL, de_ctrl | deGetTransparency());
+    }
+    
+    return 0;
+}
+
+/*
+ * This function uses 2D engine to draw a trapezoid with a specific color.
+ * The filled area includes the starting points.
+ */
+long deStartTrapezoidFill(
+    unsigned long dBase,  /* Base address of destination surface counted from beginning of video frame buffer */
+    unsigned long dPitch, /* Pitch value of destination surface in BYTES */
+    unsigned long bpp,    /* Color depth of destination surface: 8, 16 or 32 */
+    unsigned long x,
+    unsigned long y,      /* Starting (X, Y) coordinate inside the polygon to be filled */
+    unsigned long length, /* Length of the line */
+    unsigned long color,  /* Color to be filled */
+    unsigned long rop2    /* ROP value */
+)
+{
+    unsigned long dx, dy;
+    unsigned long de_ctrl =
+        FIELD_SET  (0, DE_CONTROL, STATUS,      START)           |
+        FIELD_SET  (0, DE_CONTROL, QUICK_START, ENABLE)          |
+        FIELD_SET  (0, DE_CONTROL, LAST_PIXEL,  OFF)             |
+        FIELD_SET  (0, DE_CONTROL, DIRECTION,   LEFT_TO_RIGHT)   |
+        FIELD_SET  (0, DE_CONTROL, COMMAND,     TRAPEZOID_FILL)  |
+        FIELD_SET  (0, DE_CONTROL, ROP_SELECT,  ROP2)            |
+        FIELD_VALUE(0, DE_CONTROL, ROP,         rop2);
+
+    if (deWaitForNotBusy() != 0)
+    {
+        /* The 2D engine is always busy for some unknown reason.
+           Application can choose to return ERROR, or reset it and
+           continue the operation.
+        */
+
+        return -1;
+
+        /* or */
+        /* deReset(); */
+    }
+    
+    /* 2D Destination Base.
+       It is an address offset (128 bit aligned) from the beginning of frame buffer.
+    */
+    POKE_32(DE_WINDOW_DESTINATION_BASE, dBase);
+
+    /* Program pitch (distance between the 1st points of two adjacent lines).
+       Note that input pitch is BYTE value, but the 2D Pitch register uses
+       pixel values. Need Byte to pixel convertion.
+    */
+    POKE_32(DE_PITCH,
+        FIELD_VALUE(0, DE_PITCH, DESTINATION, dPitch / BYTE_PER_PIXEL(bpp)) |
+        FIELD_VALUE(0, DE_PITCH, SOURCE, dPitch / BYTE_PER_PIXEL(bpp)));
+
+    /* Screen Window width in Pixels.
+       2D engine uses this value to calculate the linear address in frame buffer for a given point.
+    */
+    POKE_32(DE_WINDOW_WIDTH,
+        FIELD_VALUE(0, DE_WINDOW_WIDTH, DESTINATION, dPitch / BYTE_PER_PIXEL(bpp)) |
+        FIELD_VALUE(0, DE_WINDOW_WIDTH, SOURCE,      dPitch / BYTE_PER_PIXEL(bpp)));
+
+    /* Set the Line Color */
+    POKE_32(DE_FOREGROUND, color);
+    
+    /* Set the destination coordinate */
+    POKE_32(DE_DESTINATION,
+        FIELD_SET  (0, DE_DESTINATION, WRAP, DISABLE) |
+        FIELD_VALUE(0, DE_DESTINATION, X,    x)       |
+        FIELD_VALUE(0, DE_DESTINATION, Y,    y));
+    
+    /* Set the pixel format of the destination */
+    deSetPixelFormat(bpp);
+    
+    /* Set the line length and width */
+    POKE_32(DE_DIMENSION,
+        FIELD_VALUE(0, DE_DIMENSION, X,    length) |
+        FIELD_VALUE(0, DE_DIMENSION, Y_ET, 0));
+
+    /* Enable the 2D Engine. */
+    POKE_32(DE_CONTROL, de_ctrl | deGetTransparency());
+    
+    return 0;
+}
+
+/* 
+ * Function to continue drawing a line using Trapezoid Fill method.
+ */
+long deNextTrapezoidFill(
+    unsigned long x,            /* Starting X location. */
+    unsigned long length        /* Line length */
+)
+{
+    unsigned long de_ctrl;
+    
+    if (deWaitForNotBusy() != 0)
+    {
+        /* The 2D engine is always busy for some unknown reason.
+           Application can choose to return ERROR, or reset it and
+           continue the operation.
+        */
+
+        return -1;
+
+        /* or */
+        /* deReset(); */
+    }
+    
+    /* Set the X destination coordinate */
+    POKE_32(DE_DESTINATION,
+        FIELD_VALUE(PEEK_32(DE_DESTINATION), DE_DESTINATION, X,    x));
+        
+    /* Set the line length */
+    POKE_32(DE_DIMENSION,
+        FIELD_VALUE(PEEK_32(DE_DIMENSION), DE_DIMENSION, X,    length));
+        
+    return 0;
+}
+
+/* 
+ * Function to stop the Trapezoid Fill drawing.
+ * This function has to be called to end the Trapezoid Fill drawing.
+ * Otherwise, the next 2D function might still use this function.
+ */
+long deStopTrapezoidFill(void)
+{
+    if (deWaitForNotBusy() != 0)
+    {
+        /* The 2D engine is always busy for some unknown reason.
+           Application can choose to return ERROR, or reset it and
+           continue the operation.
+        */
+
+        return -1;
+
+        /* or */
+        /* deReset(); */
+    }
+    
+    POKE_32(DE_CONTROL, FIELD_SET(PEEK_32(DE_CONTROL), DE_CONTROL, QUICK_START, DISABLE));
+    
+    return 0;
+}
+
+/*
+ * Video Memory to Video Memory data transfer.
+ * Note: 
+ *        It works whether the Video Memroy is off-screeen or on-screen.
+ *        This function is a one to one transfer without stretching or 
+ *        mono expansion.
+ */
+long ddk750_deVideoMem2VideoMemBlt(
+unsigned long sBase,  /* Address of source: offset in frame buffer */
+unsigned long sPitch, /* Pitch value of source surface in BYTE */
+unsigned long sx,
+unsigned long sy,     /* Starting coordinate of source surface */
+unsigned long dBase,  /* Address of destination: offset in frame buffer */
+unsigned long dPitch, /* Pitch value of destination surface in BYTE */
+unsigned long bpp,    /* Color depth of destination surface */
+unsigned long dx,
+unsigned long dy,     /* Starting coordinate of destination surface */
+unsigned long width, 
+unsigned long height, /* width and height of rectangle in pixel value */
+unsigned long rop2)   /* ROP value */
+{
+    unsigned long nDirection, de_ctrl, bytePerPixel;
+    long opSign;
+
+    if (deWaitForNotBusy() != 0)
+    {
+        /* The 2D engine is always busy for some unknown reason.
+           Application can choose to return ERROR, or reset it and
+           continue the operation.
+        */
+
+        return -1;
+
+        /* or */
+        /* deReset(); */
+    }
+
+    nDirection = LEFT_TO_RIGHT;
+    opSign = 1;    /* Direction of ROP2 operation: 1 = Left to Right, (-1) = Right to Left */
+    bytePerPixel = bpp/8;
+    de_ctrl = 0;
+
+    /* If source and destination are the same surface, need to check for overlay cases */
+    if (sBase == dBase && sPitch == dPitch)
+    {
+        /* Determine direction of operation */
+        if (sy < dy)
+        {
+            /* +----------+
+               |S         |
+               |   +----------+
+               |   |      |   |
+               |   |      |   |
+               +---|------+   |
+                   |         D|
+                   +----------+ */
+    
+            nDirection = BOTTOM_TO_TOP;
+        }
+        else if (sy > dy)
+        {
+            /* +----------+
+               |D         |
+               |   +----------+
+               |   |      |   |
+               |   |      |   |
+               +---|------+   |
+                   |         S|
+                   +----------+ */
+    
+            nDirection = TOP_TO_BOTTOM;
+        }
+        else
+        {
+            /* sy == dy */
+    
+            if (sx <= dx)
+            {
+                /* +------+---+------+
+                   |S     |   |     D|
+                   |      |   |      |
+                   |      |   |      |
+                   |      |   |      |
+                   +------+---+------+ */
+    
+                nDirection = RIGHT_TO_LEFT;
+            }
+            else
+            {
+                /* sx > dx */
+    
+                /* +------+---+------+
+                   |D     |   |     S|
+                   |      |   |      |
+                   |      |   |      |
+                   |      |   |      |
+                   +------+---+------+ */
+    
+                nDirection = LEFT_TO_RIGHT;
+            }
+        }
+    }
+
+    if ((nDirection == BOTTOM_TO_TOP) || (nDirection == RIGHT_TO_LEFT))
+    {
+        sx += width - 1;
+        sy += height - 1;
+        dx += width - 1;
+        dy += height - 1;
+        opSign = (-1);
+    }
+
+    /* Note:
+       DE_FOREGROUND are DE_BACKGROUND are don't care.
+       DE_COLOR_COMPARE and DE_COLOR_COMPARE_MAKS are set by set deSetTransparency().
+    */
+
+    /* 2D Source Base.
+       It is an address offset (128 bit aligned) from the beginning of frame buffer.
+    */
+    POKE_32(DE_WINDOW_SOURCE_BASE, sBase);
+
+    /* 2D Destination Base.
+       It is an address offset (128 bit aligned) from the beginning of frame buffer.
+    */
+    POKE_32(DE_WINDOW_DESTINATION_BASE, dBase);
+
+    /* Program pitch (distance between the 1st points of two adjacent lines).
+       Note that input pitch is BYTE value, but the 2D Pitch register uses
+       pixel values. Need Byte to pixel convertion.
+    */
+    POKE_32(DE_PITCH,
+        FIELD_VALUE(0, DE_PITCH, DESTINATION, (dPitch/bytePerPixel)) |
+        FIELD_VALUE(0, DE_PITCH, SOURCE,      (sPitch/bytePerPixel)));
+
+    /* Screen Window width in Pixels.
+       2D engine uses this value to calculate the linear address in frame buffer for a given point.
+    */
+    POKE_32(DE_WINDOW_WIDTH,
+        FIELD_VALUE(0, DE_WINDOW_WIDTH, DESTINATION, (dPitch/bytePerPixel)) |
+        FIELD_VALUE(0, DE_WINDOW_WIDTH, SOURCE,      (sPitch/bytePerPixel)));
+
+    /* Set the pixel format of the destination */
+    deSetPixelFormat(bpp);
+    
+#ifdef ENABLE_192_BYTES_PATCH
+    /* This bug is fixed in SM718 for 16 and 32 bpp. However, in 8-bpp, the problem still exists. 
+       The Version AA also have this problem on higher clock with 32-bit memory data bus, 
+       therefore, it needs to be enabled here. 
+       In version AA, the problem happens on the following configurations:
+        1. M2XCLK = 336MHz w/ 32-bit, MCLK = 112MHz, and color depth set to 32bpp
+        2. M2XCLK = 336MHz w/ 32-bit, MCLK = 84MHz, and color depth set to 16bpp or 32bpp.
+       Somehow, the problem does not appears in 64-bit memory setting.
+     */
+
+    /* Workaround for 192 byte requirement when ROP is not COPY */
+    if ((rop2 != ROP2_COPY) && ((width * bytePerPixel) > 192))
+    {
+        /* Perform the ROP2 operation in chunks of (xWidth * nHeight) */
+        unsigned long xChunk = 192 / bytePerPixel; /* chunk width is in pixels */
+        
+        //DDKDEBUGPRINT((DE_LEVEL, "ROP != ROP_COPY, width * bytePerPixel = %x (> 192 bytes)\n", width * bytePerPixel));
+
+        while (1)
+        {
+            deWaitForNotBusy();
+            POKE_32(DE_SOURCE,
+                FIELD_SET  (0, DE_SOURCE, WRAP, DISABLE) |
+                FIELD_VALUE(0, DE_SOURCE, X_K1, sx)   |
+                FIELD_VALUE(0, DE_SOURCE, Y_K2, sy));
+            POKE_32(DE_DESTINATION,
+                FIELD_SET  (0, DE_DESTINATION, WRAP, DISABLE) |
+                FIELD_VALUE(0, DE_DESTINATION, X,    dx)  |
+                FIELD_VALUE(0, DE_DESTINATION, Y,    dy));
+            POKE_32(DE_DIMENSION,
+                FIELD_VALUE(0, DE_DIMENSION, X,    xChunk) |
+                FIELD_VALUE(0, DE_DIMENSION, Y_ET, height));
+
+            de_ctrl = 
+                FIELD_VALUE(0, DE_CONTROL, ROP, rop2) |
+                FIELD_SET(0, DE_CONTROL, ROP_SELECT, ROP2) |
+                FIELD_SET(0, DE_CONTROL, COMMAND, BITBLT) |
+                ((nDirection == RIGHT_TO_LEFT) ? 
+                FIELD_SET(0, DE_CONTROL, DIRECTION, RIGHT_TO_LEFT)
+                : FIELD_SET(0, DE_CONTROL, DIRECTION, LEFT_TO_RIGHT)) |
+                FIELD_SET(0, DE_CONTROL, STATUS, START);
+
+            POKE_32(DE_CONTROL, de_ctrl | deGetTransparency());
+
+            if (xChunk == width) break;
+
+            sx += (opSign * xChunk);
+            dx += (opSign * xChunk);
+            width -= xChunk;
+
+            if (xChunk > width)
+            {
+                /* This is the last chunk. */
+                xChunk = width;
+            }
+        }
+    }
+    else
+#endif
+    {
+        deWaitForNotBusy();
+
+        POKE_32(DE_SOURCE,
+            FIELD_SET  (0, DE_SOURCE, WRAP, DISABLE) |
+            FIELD_VALUE(0, DE_SOURCE, X_K1, sx)   |
+            FIELD_VALUE(0, DE_SOURCE, Y_K2, sy));
+        POKE_32(DE_DESTINATION,
+            FIELD_SET  (0, DE_DESTINATION, WRAP, DISABLE) |
+            FIELD_VALUE(0, DE_DESTINATION, X,    dx)  |
+            FIELD_VALUE(0, DE_DESTINATION, Y,    dy));
+        POKE_32(DE_DIMENSION,
+            FIELD_VALUE(0, DE_DIMENSION, X,    width) |
+            FIELD_VALUE(0, DE_DIMENSION, Y_ET, height));
+
+        de_ctrl = 
+            FIELD_VALUE(0, DE_CONTROL, ROP, rop2) |
+            FIELD_SET(0, DE_CONTROL, ROP_SELECT, ROP2) |
+            FIELD_SET(0, DE_CONTROL, COMMAND, BITBLT) |
+            ((nDirection == RIGHT_TO_LEFT) ? 
+            FIELD_SET(0, DE_CONTROL, DIRECTION, RIGHT_TO_LEFT)
+            : FIELD_SET(0, DE_CONTROL, DIRECTION, LEFT_TO_RIGHT)) |
+            FIELD_SET(0, DE_CONTROL, STATUS, START);
+
+        POKE_32(DE_CONTROL, de_ctrl | deGetTransparency());
+    }
+
+    return 0;
+}
+
+/*
+ * System Memory to Video Memory data transfer.
+ * Only works in D, S, ~D, and ~S ROP.
+ */
+long deSystemMem2VideoMemBusMasterBlt(
+    unsigned char *pSBase,  /* Address of source in the system memory.
+                               The memory must be a continuous physical address. */
+    unsigned long sPitch,   /* Pitch value of source surface in BYTE */
+    unsigned long sx,
+    unsigned long sy,       /* Starting coordinate of source surface */
+    unsigned long dBase,    /* Address of destination in frame buffer */
+    unsigned long dPitch,   /* Pitch value of destination surface in BYTE */
+    unsigned long bpp,      /* Color depth of destination surface */
+    unsigned long dx,
+    unsigned long dy,       /* Starting coordinate of destination surface */
+    unsigned long width, 
+    unsigned long height,   /* width and height of rectangle in pixel value */
+    unsigned long rop2      /* ROP value */
+)
+{
+    unsigned long de_ctrl, bytePerPixel;
+    unsigned long value, pciMasterBaseAddress;
+    long opSign;
+
+    if (deWaitForNotBusy() != 0)
+    {
+        /* The 2D engine is always busy for some unknown reason.
+           Application can choose to return ERROR, or reset it and
+           continue the operation.
+        */
+
+        return -1;
+
+        /* or */
+        /* deReset(); */
+    }
+
+    bytePerPixel = bpp/8;
+    de_ctrl = 0;
+
+    /* Note:
+       DE_FOREGROUND are DE_BACKGROUND are don't care.
+       DE_COLOR_COMPARE and DE_COLOR_COMPARE_MAKS are set by set deSetTransparency().
+    */
+
+    /* 2D Source Base.
+       It is an address offset (128 bit aligned) from the given PCI Master base address
+    */
+    /* Set 2D Source Base Address */
+    value = FIELD_VALUE(0, DE_WINDOW_SOURCE_BASE, ADDRESS, (unsigned long)pSBase);        
+    pciMasterBaseAddress = ((unsigned long)pSBase & 0xFC000000) >> 24;
+    POKE_32(PCI_MASTER_BASE, FIELD_VALUE(0, PCI_MASTER_BASE, ADDRESS, pciMasterBaseAddress));
+    value = FIELD_SET(value, DE_WINDOW_SOURCE_BASE, EXT, EXTERNAL);
+    POKE_32(DE_WINDOW_SOURCE_BASE, value);
+
+    /* 2D Destination Base.
+       It is an address offset (128 bit aligned) from the beginning of frame buffer.
+    */
+    POKE_32(DE_WINDOW_DESTINATION_BASE, dBase);
+
+    /* Program pitch (distance between the 1st points of two adjacent lines).
+       Note that input pitch is BYTE value, but the 2D Pitch register uses
+       pixel values. Need Byte to pixel convertion.
+    */
+    POKE_32(DE_PITCH,
+        FIELD_VALUE(0, DE_PITCH, DESTINATION, (dPitch/bytePerPixel)) |
+        FIELD_VALUE(0, DE_PITCH, SOURCE,      (sPitch/bytePerPixel)));
+
+    /* Screen Window width in Pixels.
+       2D engine uses this value to calculate the linear address in frame buffer for a given point.
+    */
+    POKE_32(DE_WINDOW_WIDTH,
+        FIELD_VALUE(0, DE_WINDOW_WIDTH, DESTINATION, (dPitch/bytePerPixel)) |
+        FIELD_VALUE(0, DE_WINDOW_WIDTH, SOURCE,      (sPitch/bytePerPixel)));
+
+    /* Set the pixel format of the destination */
+    deSetPixelFormat(bpp);
+    
+#ifdef ENABLE_192_BYTES_PATCH
+    /* This bug is fixed in SM718 for 16 and 32 bpp. However, in 8-bpp, the problem still exists. 
+       The Version AA also have this problem on higher clock with 32-bit memory data bus, 
+       therefore, it needs to be enabled here. 
+       In version AA, the problem happens on the following configurations:
+        1. M2XCLK = 336MHz w/ 32-bit, MCLK = 112MHz, and color depth set to 32bpp
+        2. M2XCLK = 336MHz w/ 32-bit, MCLK = 84MHz, and color depth set to 16bpp or 32bpp.
+       Somehow, the problem does not appears in 64-bit memory setting.
+     */
+
+    /* Workaround for 192 byte requirement when ROP is not COPY */
+    if ((rop2 != ROP2_COPY) && ((width * bytePerPixel) > 192))
+    {
+        /* Perform the ROP2 operation in chunks of (xWidth * nHeight) */
+        unsigned long xChunk = 192 / bytePerPixel; /* chunk width is in pixels */
+        
+        //DDKDEBUGPRINT((DE_LEVEL, "ROP != ROP_COPY, width * bytePerPixel = %x (> 192 bytes)\n", width * bytePerPixel));
+
+        while (1)
+        {
+            deWaitForNotBusy();
+            POKE_32(DE_SOURCE,
+                FIELD_SET  (0, DE_SOURCE, WRAP, DISABLE) |
+                FIELD_VALUE(0, DE_SOURCE, X_K1, sx)   |
+                FIELD_VALUE(0, DE_SOURCE, Y_K2, sy));
+                
+            POKE_32(DE_DESTINATION,
+                FIELD_SET  (0, DE_DESTINATION, WRAP, DISABLE) |
+                FIELD_VALUE(0, DE_DESTINATION, X,    dx)  |
+                FIELD_VALUE(0, DE_DESTINATION, Y,    dy));
+                
+            POKE_32(DE_DIMENSION,
+                FIELD_VALUE(0, DE_DIMENSION, X,    xChunk) |
+                FIELD_VALUE(0, DE_DIMENSION, Y_ET, height));
+
+            de_ctrl = 
+                FIELD_VALUE(0, DE_CONTROL, ROP, rop2) |
+                FIELD_SET(0, DE_CONTROL, ROP_SELECT, ROP2) |
+                FIELD_SET(0, DE_CONTROL, COMMAND, BITBLT) |
+                FIELD_SET(0, DE_CONTROL, DIRECTION, LEFT_TO_RIGHT) |
+                FIELD_SET(0, DE_CONTROL, STATUS, START);
+
+            POKE_32(DE_CONTROL, de_ctrl | deGetTransparency());
+
+            if (xChunk == width) break;
+
+            sx += xChunk;
+            dx += xChunk;
+            width -= xChunk;
+
+            if (xChunk > width)
+            {
+                /* This is the last chunk. */
+                xChunk = width;
+            }
+        }
+    }
+    else
+#endif
+    {
+        deWaitForNotBusy();
+
+        POKE_32(DE_SOURCE,
+            FIELD_SET  (0, DE_SOURCE, WRAP, DISABLE) |
+            FIELD_VALUE(0, DE_SOURCE, X_K1, sx)   |
+            FIELD_VALUE(0, DE_SOURCE, Y_K2, sy));
+        POKE_32(DE_DESTINATION,
+            FIELD_SET  (0, DE_DESTINATION, WRAP, DISABLE) |
+            FIELD_VALUE(0, DE_DESTINATION, X,    dx)  |
+            FIELD_VALUE(0, DE_DESTINATION, Y,    dy));
+        POKE_32(DE_DIMENSION,
+            FIELD_VALUE(0, DE_DIMENSION, X,    width) |
+            FIELD_VALUE(0, DE_DIMENSION, Y_ET, height));
+
+        de_ctrl = 
+            FIELD_VALUE(0, DE_CONTROL, ROP, rop2) |
+            FIELD_SET(0, DE_CONTROL, ROP_SELECT, ROP2) |
+            FIELD_SET(0, DE_CONTROL, COMMAND, BITBLT) |
+            FIELD_SET(0, DE_CONTROL, DIRECTION, LEFT_TO_RIGHT) |
+            FIELD_SET(0, DE_CONTROL, STATUS, START);
+
+        POKE_32(DE_CONTROL, de_ctrl | deGetTransparency());
+    }
+
+    return 0;
+}
+
+/* 
+ * System memory to Video memory data transfer
+ * Note: 
+ *         We also call it HOST Blt.
+ *        This function is a one to one transfer without stretching or 
+ *        mono expansion.
+ */
+long deSystemMem2VideoMemBlt(
+    unsigned char *pSrcbuf, /* pointer to source data in system memory */
+    long srcDelta,          /* width (in Bytes) of the source data, +ive means top down and -ive mean button up */
+    unsigned long dBase,    /* Address of destination: offset in frame buffer */
+    unsigned long dPitch,   /* Pitch value of destination surface in BYTE */
+    unsigned long bpp,      /* Color depth of destination surface */
+    unsigned long dx,
+    unsigned long dy,       /* Starting coordinate of destination surface */
+    unsigned long width, 
+    unsigned long height,   /* width and height of rectange in pixel value */
+    unsigned long rop2      /* ROP value */
+)
+{
+    unsigned long bytePerPixel;
+    unsigned long ulBytesPerScan;
+    unsigned long ul8BytesPerScan;
+    unsigned long ulBytesRemain;
+    unsigned long de_ctrl = 0;
+    unsigned char ajRemain[8];
+    long i, j;
+
+    bytePerPixel = bpp/8;
+
+    /* HOST blt data port must take multiple of 8 bytes as input.
+       If the source width does not match that requirement,
+       we need to split it into two portions. The first portion
+       is 8 byte multiple. The 2nd portion is the remaining bytes.
+       The remaining bytes will be buffered to an 8 byte array and
+       and send it to the host blt data port.
+    */
+    ulBytesPerScan = width * bpp / 8;
+    ul8BytesPerScan = ulBytesPerScan & ~7;
+    ulBytesRemain = ulBytesPerScan & 7;
+
+    /* Program 2D Drawing Engine */
+    if (deWaitForNotBusy() != 0)
+    {
+        /* The 2D engine is always busy for some unknown reason.
+           Application can choose to return ERROR, or reset it and
+           continue the operation.
+        */
+
+        return -1;
+
+        /* or */
+        /* deReset(); */
+    }
+
+    /* 2D Source Base.
+       Use 0 for HOST Blt.
+    */
+    POKE_32(DE_WINDOW_SOURCE_BASE, 0);
+
+    /* 2D Destination Base.
+       It is an address offset (128 bit aligned) from the beginning of frame buffer.
+    */
+    POKE_32(DE_WINDOW_DESTINATION_BASE, dBase);
+
+    /* Program pitch (distance between the 1st points of two adjacent lines).
+       Note that input pitch is BYTE value, but the 2D Pitch register uses
+       pixel values. Need Byte to pixel convertion.
+    */
+    POKE_32(DE_PITCH,
+        FIELD_VALUE(0, DE_PITCH, DESTINATION, dPitch/bytePerPixel) |
+        FIELD_VALUE(0, DE_PITCH, SOURCE,      dPitch/bytePerPixel));
+
+    /* Screen Window width in Pixels.
+       2D engine uses this value to calculate the linear address in frame buffer for a given point.
+    */
+    POKE_32(DE_WINDOW_WIDTH,
+        FIELD_VALUE(0, DE_WINDOW_WIDTH, DESTINATION, (dPitch/bytePerPixel)) |
+        FIELD_VALUE(0, DE_WINDOW_WIDTH, SOURCE,      (dPitch/bytePerPixel)));
+
+    /* Note: For 2D Source in Host Write, only X_K1 field is needed, and Y_K2 field is not used.
+             For 1 to 1 bitmap transfer, use 0 for X_K1 means source alignment from byte 0. */
+    POKE_32(DE_SOURCE,
+        FIELD_SET  (0, DE_SOURCE, WRAP, DISABLE) |
+        FIELD_VALUE(0, DE_SOURCE, X_K1, 0)       |
+        FIELD_VALUE(0, DE_SOURCE, Y_K2, 0));
+
+    POKE_32(DE_DESTINATION,
+        FIELD_SET  (0, DE_DESTINATION, WRAP, DISABLE) |
+        FIELD_VALUE(0, DE_DESTINATION, X,    dx)    |
+        FIELD_VALUE(0, DE_DESTINATION, Y,    dy));
+
+    POKE_32(DE_DIMENSION,
+        FIELD_VALUE(0, DE_DIMENSION, X,    width) |
+        FIELD_VALUE(0, DE_DIMENSION, Y_ET, height));
+        
+    /* Set the pixel format of the destination */
+    deSetPixelFormat(bpp);
+
+    de_ctrl = 
+        FIELD_VALUE(0, DE_CONTROL, ROP, rop2)         |
+        FIELD_SET(0, DE_CONTROL, ROP_SELECT, ROP2)    |
+        FIELD_SET(0, DE_CONTROL, COMMAND, HOST_WRITE) |
+        FIELD_SET(0, DE_CONTROL, HOST, COLOR)         |
+        FIELD_SET(0, DE_CONTROL, STATUS, START);
+
+    POKE_32(DE_CONTROL, de_ctrl | deGetTransparency());
+
+    /* Write bitmap/image data (line by line) to 2D Engine data port */
+    for (i = 0; i < height; i++)
+    {
+        /* For each line, send the data in chunks of 4 bytes. */
+        for (j=0; j < (ul8BytesPerScan/4);  j++)
+            POKE_32(DE_DATA_PORT, *(unsigned long *)(pSrcbuf + (j * 4)));
+
+        if (ulBytesRemain)
+        {
+            memcpy(ajRemain, pSrcbuf+ul8BytesPerScan, ulBytesRemain);
+            POKE_32(DE_DATA_PORT, *(unsigned long *)ajRemain);
+            POKE_32(DE_DATA_PORT, *(unsigned long *)(ajRemain+4));
+        }
+
+        pSrcbuf += srcDelta;
+    }
+
+    return 0;
+}
+
+/*
+ * System memory to Video memory monochrome expansion.
+ * Source is monochrome image in system memory.
+ * This function expands the monochrome data to color image in video memory.
+ */
+long deSystemMem2VideoMemMonoBlt(
+unsigned char *pSrcbuf, /* pointer to start of source buffer in system memory */
+long srcDelta,          /* Pitch value (in bytes) of the source buffer, +ive means top down and -ive mean button up */
+unsigned long startBit, /* Mono data can start at any bit in a byte, this value should be 0 to 7 */
+unsigned long dBase,    /* Address of destination: offset in frame buffer */
+unsigned long dPitch,   /* Pitch value of destination surface in BYTE */
+unsigned long bpp,      /* Color depth of destination surface */
+unsigned long dx,
+unsigned long dy,       /* Starting coordinate of destination surface */
+unsigned long width, 
+unsigned long height,   /* width and height of rectange in pixel value */
+unsigned long fColor,   /* Foreground color (corresponding to a 1 in the monochrome data */
+unsigned long bColor,   /* Background color (corresponding to a 0 in the monochrome data */
+unsigned long rop2)     /* ROP value */
+{
+    unsigned long bytePerPixel;
+    unsigned long ulBytesPerScan;
+    unsigned long ul4BytesPerScan;
+    unsigned long ulBytesRemain;
+    unsigned long de_ctrl = 0;
+    unsigned char ajRemain[4];
+    long i, j;
+
+    bytePerPixel = bpp/8;
+
+    startBit &= 7; /* Just make sure the start bit is within legal range */
+    ulBytesPerScan = (width + startBit + 7) / 8;
+    ul4BytesPerScan = ulBytesPerScan & ~3;
+    ulBytesRemain = ulBytesPerScan & 3;
+
+    if (deWaitForNotBusy() != 0)
+    {
+        /* The 2D engine is always busy for some unknown reason.
+           Application can choose to return ERROR, or reset it and
+           continue the operation.
+        */
+
+        return -1;
+
+        /* or */
+        /* deReset(); */
+    }
+
+    /* 2D Source Base.
+       Use 0 for HOST Blt.
+    */
+    POKE_32(DE_WINDOW_SOURCE_BASE, 0);
+
+    /* 2D Destination Base.
+       It is an address offset (128 bit aligned) from the beginning of frame buffer.
+    */
+    POKE_32(DE_WINDOW_DESTINATION_BASE, dBase);
+
+    /* Program pitch (distance between the 1st points of two adjacent lines).
+       Note that input pitch is BYTE value, but the 2D Pitch register uses
+       pixel values. Need Byte to pixel convertion.
+    */
+    POKE_32(DE_PITCH,
+        FIELD_VALUE(0, DE_PITCH, DESTINATION, dPitch/bytePerPixel) |
+        FIELD_VALUE(0, DE_PITCH, SOURCE,      dPitch/bytePerPixel));
+
+    /* Screen Window width in Pixels.
+       2D engine uses this value to calculate the linear address in frame buffer for a given point.
+    */
+    POKE_32(DE_WINDOW_WIDTH,
+        FIELD_VALUE(0, DE_WINDOW_WIDTH, DESTINATION, (dPitch/bytePerPixel)) |
+        FIELD_VALUE(0, DE_WINDOW_WIDTH, SOURCE,      (dPitch/bytePerPixel)));
+
+    /* Note: For 2D Source in Host Write, only X_K1_MONO field is needed, and Y_K2 field is not used.
+             For mono bitmap, use startBit for X_K1. */
+    POKE_32(DE_SOURCE,
+        FIELD_SET  (0, DE_SOURCE, WRAP, DISABLE)       |
+        FIELD_VALUE(0, DE_SOURCE, X_K1_MONO, startBit));
+
+    POKE_32(DE_DESTINATION,
+        FIELD_SET  (0, DE_DESTINATION, WRAP, DISABLE) |
+        FIELD_VALUE(0, DE_DESTINATION, X,    dx)    |
+        FIELD_VALUE(0, DE_DESTINATION, Y,    dy));
+
+    POKE_32(DE_DIMENSION,
+        FIELD_VALUE(0, DE_DIMENSION, X,    width) |
+        FIELD_VALUE(0, DE_DIMENSION, Y_ET, height));
+
+    POKE_32(DE_FOREGROUND, fColor);
+    POKE_32(DE_BACKGROUND, bColor);
+    
+    /* Set the pixel format of the destination */
+    deSetPixelFormat(bpp);
+
+    de_ctrl = FIELD_VALUE(0, DE_CONTROL, ROP, rop2)         |
+              FIELD_SET(0, DE_CONTROL, ROP_SELECT, ROP2)    |
+              FIELD_SET(0, DE_CONTROL, COMMAND, HOST_WRITE) |
+              FIELD_SET(0, DE_CONTROL, HOST, MONO)          |
+              FIELD_SET(0, DE_CONTROL, STATUS, START);
+
+    POKE_32(DE_CONTROL, de_ctrl | deGetTransparency());
+
+    /* Write MONO data (line by line) to 2D Engine data port */
+    for (i=0; i<height; i++)
+    {
+        /* For each line, send the data in chunks of 4 bytes */
+        for (j=0; j<(ul4BytesPerScan/4); j++)
+        {
+            POKE_32(DE_DATA_PORT, *(unsigned long *)(pSrcbuf + (j * 4)));
+        }
+
+        if (ulBytesRemain)
+        {
+            memcpy(ajRemain, pSrcbuf+ul4BytesPerScan, ulBytesRemain);
+            POKE_32(DE_DATA_PORT, *(unsigned long *)ajRemain);
+        }
+
+        pSrcbuf += srcDelta;
+    }
+
+    return 0;
+}
+
+#if 0   /* Does not work. Errata. */
+/*
+ * System memory to Video memory monochrome expansion.
+ * Source is the starting location of monochrome image in System memory.
+ * This function expands the monochrome data to color image.
+ *
+ * Note:
+ * This fnnction can be used to diaplay a mono-font charater to the screen.
+ * Input source points to the starting location of the font character.
+ */
+long deSystemMem2VideoMemMonoBusMasterBlt(
+    unsigned char *pSBase,  /* Address of mono-chrome source data in frame buffer */
+    unsigned long sPitch,   /* Pitch value (in bytes) of the source buffer. */
+    unsigned long startBit, /* Mono data can start at any bit in a byte, this value should be 0 to 7 */
+    unsigned long dBase,    /* Base address of destination in frame buffer */
+    unsigned long dPitch,   /* Pitch value of destination surface in BYTE */
+    unsigned long bpp,      /* Color depth of destination surface */
+    unsigned long dx,
+    unsigned long dy,       /* Starting coordinate of destination surface */
+    unsigned long width,    /* width of mono-chrome picture in pixel value */
+    unsigned long height,   /* height of mono-chrome picture in pixel value */
+    unsigned long fColor,   /* Foreground color (corresponding to a 1 in the monochrome data */
+    unsigned long bColor,   /* Background color (corresponding to a 0 in the monochrome data */
+    unsigned long rop2      /* ROP value */
+)
+{
+    unsigned long bytePerPixel, de_ctrl, packed;
+    unsigned long value, pciMasterBaseAddress;
+
+    bytePerPixel = bpp/8;
+
+    switch ( width )
+    {
+        case 8:
+            packed = DE_CONTROL_MONO_DATA_8_PACKED;
+            break;
+        case 16:
+            packed = DE_CONTROL_MONO_DATA_16_PACKED;
+            break;
+        case 32:
+            packed = DE_CONTROL_MONO_DATA_32_PACKED;
+            break;
+        default:
+            packed = DE_CONTROL_MONO_DATA_NOT_PACKED;
+    }
+
+    if (deWaitForNotBusy() != 0)
+    {
+        /* The 2D engine is always busy for some unknown reason.
+           Application can choose to return ERROR, or reset it and
+           continue the operation.
+        */
+
+        return -1;
+
+        /* or */
+        /* deReset(); */
+    }
+
+    /* Note:
+       DE_COLOR_COMPARE and DE_COLOR_COMPARE_MAKS are set by set deSetTransparency().
+    */
+
+    /* Monochrome source data in system memory.
+       It is an address offset (128 bit aligned) from the given PCI Master base address
+    */
+    /* Set 2D Source Base Address */
+    value = FIELD_VALUE(0, DE_WINDOW_SOURCE_BASE, ADDRESS, (unsigned long)pSBase);        
+    pciMasterBaseAddress = ((unsigned long)pSBase & 0xFC000000) >> 24;
+    POKE_32(PCI_MASTER_BASE, FIELD_VALUE(0, PCI_MASTER_BASE, ADDRESS, pciMasterBaseAddress));
+    value = FIELD_SET(value, DE_WINDOW_SOURCE_BASE, EXT, EXTERNAL);
+    POKE_32(DE_WINDOW_SOURCE_BASE, value);
+
+    /* 2D Destination Base.
+       It is an address offset (128 bit aligned) from the beginning of frame buffer.
+    */
+    POKE_32(DE_WINDOW_DESTINATION_BASE, dBase);
+
+    /* Program pitch (distance between the 1st points of two adjacent lines).
+       Note that input pitch is BYTE value, but the 2D Pitch register uses
+       pixel values. Need Byte to pixel conversion.
+    */
+    POKE_32(DE_PITCH,
+        FIELD_VALUE(0, DE_PITCH, DESTINATION, (dPitch/bytePerPixel)) |
+        FIELD_VALUE(0, DE_PITCH, SOURCE,      1));
+
+    /* Screen Window width in Pixels.
+       2D engine uses this value to calculate the linear address in frame buffer for a given point.
+    */
+    POKE_32(DE_WINDOW_WIDTH,
+        FIELD_VALUE(0, DE_WINDOW_WIDTH, DESTINATION, (dPitch/bytePerPixel)) |
+        FIELD_VALUE(0, DE_WINDOW_WIDTH, SOURCE,      0)); /* Source window width is don't care */
+
+    POKE_32(DE_SOURCE,
+        FIELD_SET  (0, DE_SOURCE, WRAP, DISABLE) |
+        FIELD_VALUE(0, DE_SOURCE, X_K1, startBit)   |
+        FIELD_VALUE(0, DE_SOURCE, Y_K2, 0));
+
+    POKE_32(DE_DESTINATION,
+        FIELD_SET  (0, DE_DESTINATION, WRAP, DISABLE) |
+        FIELD_VALUE(0, DE_DESTINATION, X,    dx)  |
+        FIELD_VALUE(0, DE_DESTINATION, Y,    dy));
+
+    POKE_32(DE_DIMENSION,
+        FIELD_VALUE(0, DE_DIMENSION, X,    width) |
+        FIELD_VALUE(0, DE_DIMENSION, Y_ET, height));
+
+    POKE_32(DE_FOREGROUND, fColor);
+    POKE_32(DE_BACKGROUND, bColor);
+    
+    /* Set the pixel format of the destination */
+    deSetPixelFormat(bpp);
+
+    de_ctrl = 
+        FIELD_VALUE(0, DE_CONTROL, ROP, rop2) |
+        FIELD_SET(0, DE_CONTROL, ROP_SELECT, ROP2) |
+        FIELD_SET(0, DE_CONTROL, COMMAND, FONT) |
+        FIELD_SET(0, DE_CONTROL, HOST, MONO) |
+        FIELD_VALUE(0, DE_CONTROL, MONO_DATA, packed) |
+        FIELD_SET(0, DE_CONTROL, STATUS, START);
+
+    POKE_32(DE_CONTROL, de_ctrl | deGetTransparency());
+
+    return 0;
+}
+#endif
+
+
+/*
+ * Video memory to Video memory monochrome expansion.
+ * Source is the starting location of monochrome image in Video memory.
+ * This function expands the monochrome data to color image.
+ *
+ * Note:
+ * This fnnction can be used to diaplay a mono-font charater to the screen.
+ * Input source points to the starting location of the font character.
+ */
+long deVideoMem2VideoMemMonoBlt(
+unsigned long sBase,  /* Address of mono-chrome source data in frame buffer */
+unsigned long dBase,  /* Base address of destination in frame buffer */
+unsigned long dPitch, /* Pitch value of destination surface in BYTE */
+unsigned long bpp,    /* Color depth of destination surface */
+unsigned long dx,
+unsigned long dy,     /* Starting coordinate of destination surface */
+unsigned long width,  /* width of mono-chrome picture in pixel value */
+unsigned long height, /* height of mono-chrome picture in pixel value */
+unsigned long fColor, /* Foreground color (corresponding to a 1 in the monochrome data */
+unsigned long bColor, /* Background color (corresponding to a 0 in the monochrome data */
+unsigned long rop2)   /* ROP value */
+{
+    unsigned long bytePerPixel, de_ctrl, packed;
+
+    bytePerPixel = bpp/8;
+
+    switch ( width )
+    {
+        case 8:
+            packed = DE_CONTROL_MONO_DATA_8_PACKED;
+            break;
+        case 16:
+            packed = DE_CONTROL_MONO_DATA_16_PACKED;
+            break;
+        case 32:
+            packed = DE_CONTROL_MONO_DATA_32_PACKED;
+            break;
+        default:
+            packed = DE_CONTROL_MONO_DATA_NOT_PACKED;
+    }
+
+    if (deWaitForNotBusy() != 0)
+    {
+        /* The 2D engine is always busy for some unknown reason.
+           Application can choose to return ERROR, or reset it and
+           continue the operation.
+        */
+
+        return -1;
+
+        /* or */
+        /* deReset(); */
+    }
+
+    /* Note:
+       DE_COLOR_COMPARE and DE_COLOR_COMPARE_MAKS are set by set deSetTransparency().
+    */
+
+    /* Monochrome source data in frame buffer.
+       It is an address offset (128 bit aligned) from the beginning of frame buffer.
+    */
+    POKE_32(DE_WINDOW_SOURCE_BASE, sBase);
+
+    /* 2D Destination Base.
+       It is an address offset (128 bit aligned) from the beginning of frame buffer.
+    */
+    POKE_32(DE_WINDOW_DESTINATION_BASE, dBase);
+
+    /* Program pitch (distance between the 1st points of two adjacent lines).
+       Note that input pitch is BYTE value, but the 2D Pitch register uses
+       pixel values. Need Byte to pixel convertion.
+    */
+    POKE_32(DE_PITCH,
+        FIELD_VALUE(0, DE_PITCH, DESTINATION, (dPitch/bytePerPixel)) |
+        FIELD_VALUE(0, DE_PITCH, SOURCE,      0));      /* Source pitch is don't care */
+
+    /* Screen Window width in Pixels.
+       2D engine uses this value to calculate the linear address in frame buffer for a given point.
+    */
+    POKE_32(DE_WINDOW_WIDTH,
+        FIELD_VALUE(0, DE_WINDOW_WIDTH, DESTINATION, (dPitch/bytePerPixel)) |
+        FIELD_VALUE(0, DE_WINDOW_WIDTH, SOURCE,      0 )); /* Source window width is don't care */
+
+    POKE_32(DE_SOURCE,
+        FIELD_SET  (0, DE_SOURCE, WRAP, DISABLE) |
+        FIELD_VALUE(0, DE_SOURCE, X_K1, 0)   |
+        FIELD_VALUE(0, DE_SOURCE, Y_K2, 0));    /* Source data starts at location (0, 0) */
+
+    POKE_32(DE_DESTINATION,
+        FIELD_SET  (0, DE_DESTINATION, WRAP, DISABLE) |
+        FIELD_VALUE(0, DE_DESTINATION, X,    dx)  |
+        FIELD_VALUE(0, DE_DESTINATION, Y,    dy));
+
+    POKE_32(DE_DIMENSION,
+        FIELD_VALUE(0, DE_DIMENSION, X,    width) |
+        FIELD_VALUE(0, DE_DIMENSION, Y_ET, height));
+
+    POKE_32(DE_FOREGROUND, fColor);
+    POKE_32(DE_BACKGROUND, bColor);
+    POKE_32(DE_COLOR_COMPARE, bColor);
+    
+    /* Set the pixel format of the destination */
+    deSetPixelFormat(bpp);
+
+    de_ctrl = 
+        FIELD_VALUE(0, DE_CONTROL, ROP, rop2) |
+        FIELD_SET(0, DE_CONTROL, ROP_SELECT, ROP2) |
+        FIELD_SET(0, DE_CONTROL, COMMAND, FONT) |
+        FIELD_SET(0, DE_CONTROL, HOST, MONO) |
+        FIELD_VALUE(0, DE_CONTROL, MONO_DATA, packed) |
+        FIELD_SET(0, DE_CONTROL, STATUS, START);
+
+    POKE_32(DE_CONTROL, de_ctrl | deGetTransparency());
+
+    return 0;
+}
+
+/*
+ * Video memory to Video memory monochrome expansion.
+ * 
+ * Difference between this function and deVideoMem2VideoMemMonoBlt():
+ * 1) Input is base address of the whole font table.
+ * 2) An extra input about which character in the font table to display.
+ * 3) This function demos how to use registers DE_SOURCE and
+ *    DE_WINDOW_WIDTH, where they are set to 0 in deVideoMem2VideoMemMonoBlt().
+ */
+long deFontCacheTblMonoBlt(
+unsigned long fontTblBase,/* Base address of monochrome font table in frame buffer */
+unsigned long fontNumber, /* Which character in the font table, starting from 0 */
+unsigned long dBase,      /* Base address of destination in frame buffer */
+unsigned long dPitch,     /* Pitch value of destination surface in BYTE */
+unsigned long bpp,        /* Color depth of destination surface */
+unsigned long dx,
+unsigned long dy,         /* Starting coordinate of destination surface */
+unsigned long width,      /* width of each monochrome font in pixel value */
+unsigned long height,     /* height of each monochrome font in pixel value */
+unsigned long fColor,     /* Foreground color (corresponding to a 1 in the monochrome data */
+unsigned long bColor,     /* Background color (corresponding to a 0 in the monochrome data */
+unsigned long rop2)       /* ROP value */
+{
+    unsigned long bytePerPixel, distBetweenFont, de_ctrl, packed;
+
+    bytePerPixel = bpp/8;
+
+    /* Distance between fonts in pixel value */
+    distBetweenFont = width * height;
+
+    /* SM50x hardware requires each font character be a minimum of 128 
+       pixel value apart.
+       For 8x8 fonts, each font character is only 64 pixel apart.
+       However, if application uses deCacheFontToFrameBuffer()
+       to cache the font in video memory, each font character will be 
+       stored as 128 pixels apart.
+    */
+    if (distBetweenFont < 128)
+        distBetweenFont = 128;
+
+    switch ( width )
+    {
+        case 8:
+            packed = DE_CONTROL_MONO_DATA_8_PACKED;
+            break;
+        case 16:
+            packed = DE_CONTROL_MONO_DATA_16_PACKED;
+            break;
+        case 32:
+            packed = DE_CONTROL_MONO_DATA_32_PACKED;
+            break;
+        default:
+            packed = DE_CONTROL_MONO_DATA_NOT_PACKED;
+    }
+
+    if (deWaitForNotBusy() != 0)
+    {
+        /* The 2D engine is always busy for some unknown reason.
+           Application can choose to return ERROR, or reset it and
+           continue the operation.
+        */
+
+        return -1;
+
+        /* or */
+        /* deReset(); */
+    }
+
+    /* Note:
+       DE_COLOR_COMPARE and DE_COLOR_COMPARE_MAKS are set by set deSetTransparency().
+    */
+
+    /* Base address of font table in frame buffer */
+    POKE_32(DE_WINDOW_SOURCE_BASE, fontTblBase);
+
+    /* 2D Destination Base.
+       It is an address offset (128 bit aligned) from the beginning of frame buffer.
+    */
+    POKE_32(DE_WINDOW_DESTINATION_BASE, dBase);
+
+    POKE_32(DE_PITCH,
+        FIELD_VALUE(0, DE_PITCH, DESTINATION, (dPitch/bytePerPixel)) |
+        FIELD_VALUE(0, DE_PITCH, SOURCE,      0));      /* Source pitch is don't care */
+
+    /* Pay attention how DE_WINDOW_WIDTH:SOURCE is different from
+       deVideoMem2VideoMemMonoBlt()
+    */
+    POKE_32(DE_WINDOW_WIDTH,
+        FIELD_VALUE(0, DE_WINDOW_WIDTH, DESTINATION, (dPitch/bytePerPixel)) |
+        FIELD_VALUE(0, DE_WINDOW_WIDTH, SOURCE,      distBetweenFont));
+
+    /* Pay attention how DE_SOURCE:Y_K2 is different from 
+       deVideoMem2VideoMemMonoBlt()
+    */
+    POKE_32(DE_SOURCE,
+        FIELD_SET  (0, DE_SOURCE, WRAP, DISABLE) |
+        FIELD_VALUE(0, DE_SOURCE, X_K1, 0)   |
+        FIELD_VALUE(0, DE_SOURCE, Y_K2, fontNumber));
+
+    POKE_32(DE_DESTINATION,
+        FIELD_SET  (0, DE_DESTINATION, WRAP, DISABLE) |
+        FIELD_VALUE(0, DE_DESTINATION, X,    dx)  |
+        FIELD_VALUE(0, DE_DESTINATION, Y,    dy));
+
+    POKE_32(DE_DIMENSION,
+        FIELD_VALUE(0, DE_DIMENSION, X,    width) |
+        FIELD_VALUE(0, DE_DIMENSION, Y_ET, height));
+
+    POKE_32(DE_FOREGROUND, fColor);
+    POKE_32(DE_BACKGROUND, bColor);
+    POKE_32(DE_COLOR_COMPARE, bColor);
+    
+    /* Set the pixel format of the destination */
+    deSetPixelFormat(bpp);
+
+    de_ctrl = 
+        FIELD_VALUE(0, DE_CONTROL, ROP, rop2) |
+        FIELD_SET(0, DE_CONTROL, ROP_SELECT, ROP2) |
+        FIELD_SET(0, DE_CONTROL, COMMAND, FONT) |
+        FIELD_SET(0, DE_CONTROL, HOST, MONO) |
+        FIELD_VALUE(0, DE_CONTROL, MONO_DATA, packed) |
+        FIELD_SET(0, DE_CONTROL, STATUS, START);
+
+    POKE_32(DE_CONTROL, de_ctrl | deGetTransparency());
+
+    return 0;
+}
+
+
+/*
+ * Rotation helper function.
+ * 
+ * This function sets the source coordinate, destination coordinate, window
+ * dimension, and also the control register. This function is only used statically
+ * to simplify the deRotateBlt function.
+ *
+ */
+void deRotate(
+    unsigned long sx,               /* X Coordinate of the source */
+    unsigned long sy,               /* Y Coordinate of the source */
+    unsigned long dx,               /* X Coordinate of the destination */
+    unsigned long dy,               /* Y Coordinate of the destination */
+    unsigned long width,            /* Width of the window */
+    unsigned long height,           /* Height of the window */
+    unsigned long de_ctrl           /* DE_CONTROL Control Value */
+)
+{
+    /* Wait until the engine is not busy */
+    deWaitForNotBusy();
+                
+    /* Set the source coordinate */
+    POKE_32(DE_SOURCE,
+        FIELD_SET  (0, DE_SOURCE, WRAP, DISABLE) |
+        FIELD_VALUE(0, DE_SOURCE, X_K1, sx) | 
+        FIELD_VALUE(0, DE_SOURCE, Y_K2, sy));
+        
+    /* Set the destination coordinate */    
+    POKE_32(DE_DESTINATION,
+        FIELD_SET  (0, DE_DESTINATION, WRAP, DISABLE) |
+        FIELD_VALUE(0, DE_DESTINATION, X, dx) | 
+        FIELD_VALUE(0, DE_DESTINATION, Y, dy));
+
+    /* Set the source width and height dimension */
+    POKE_32(DE_DIMENSION,
+        FIELD_VALUE(0, DE_DIMENSION, X, width) | 
+        FIELD_VALUE(0, DE_DIMENSION, Y_ET, height));
+        
+    /* Start the DE Control */
+    POKE_32(DE_CONTROL, de_ctrl);
+}
+
+/*
+ * Rotation Blt.
+ * 
+ * This function rotates an image to the screen based on the given rotation direction
+ * (0, 90, 180, or 270 degree).
+ * 
+ * NOTE:
+ *      1. The function takes care of any coordinates that pass the top and left
+ *         boundary, but it does not take care of right and bottom boundary since
+ *         more information is needed in order to do so. However, it seems that
+ *         SM50x will take care the right and bottom by using wrap around.
+ *         Depending on the implementation, this function might be modified further.
+ *      2. There are 3 hardware bugs found on the rotation:
+ *         a. The rotated image sometimes is not correct when using some width number
+ *            due to FIFO bug. Therefore, the image is divided into segments and
+ *            rotated based on segment by segment using 32/byte per pixel as the width.
+ *            This value (32/byte per pixel) seems to be consistent in producing a good 
+ *            rotated image.
+ *         b. Rotating 0 degree using the actual Rotation BLT will have the same result
+ *            as rotation 270 degree.
+ *         c. Rotating 180 degree on some x destination coordinate will result in 
+ *            incorrect image. To workaround this problem, two 90 degree rotations are
+ *            used.
+ *      3. The rop parameter might not be necessary if only one ROP operation is used.
+ *         This might be deleted in the future as necessary.
+ */
+long deVideoMem2VideoMemRotateBlt(
+    unsigned long sBase,            /* Source Base Address */
+    unsigned long sPitch,           /* Source pitch */
+    unsigned long sx,               /* X Coordinate of the source */
+    unsigned long sy,               /* Y Coordinate of the source */
+    unsigned long dBase,            /* Destination Base Address */
+    unsigned long dPitch,           /* Destination pitch */
+    unsigned long bpp,              /* Color depth of destination surface */
+    unsigned long dx,               /* X Coordinate of the destination */ 
+    unsigned long dy,               /* Y Coordinate of the destination */
+    unsigned long width,            /* Width  of un-rotated image in pixel value */
+    unsigned long height,           /* Height of un-rotated image in pixel value */
+    rotate_dir_t rotateDirection,   /* Direction of the rotation */
+    unsigned long repeatEnable,     /* Enable repeat rotation control where the
+                                       drawing engine is started again every vsync */
+    unsigned long rop2              /* ROP control */
+)
+{
+    unsigned long de_ctrl = 0; 
+    unsigned long tempWidth, dxTemp, dyTemp;
+    unsigned long maxRotationWidth;
+    
+    /* Maximum rotation width BLT */
+    maxRotationWidth = 32 / BYTE_PER_PIXEL(bpp);
+
+    /* Wait for the engine to be idle */
+    if (deWaitForNotBusy() != 0)
+    {
+        /* The 2D engine is always busy for some unknown reason.
+           Application can choose to return ERROR, or reset it and
+           continue the operation.
+        */
+        return -1;
+
+        /* or */
+        /* deReset(); */
+    } 
+
+    /* Return error if either the width or height is zero */ 
+    if ((width == 0) || (height == 0))
+        return -1;
+
+    /* 2D Source Base.
+       It is an address offset (128 bit aligned) from the beginning of frame buffer.
+    */
+    POKE_32(DE_WINDOW_SOURCE_BASE, sBase);
+
+    /* 2D Destination Base.
+       It is an address offset (128 bit aligned) from the beginning of frame buffer.
+    */
+    POKE_32(DE_WINDOW_DESTINATION_BASE, dBase);
+
+    /* Program pitch (distance between the 1st points of two adjacent lines).
+       Note that input pitch is BYTE value, but the 2D Pitch register uses
+       pixel values. Need Byte to pixel convertion.
+    */
+    POKE_32(DE_PITCH,
+        FIELD_VALUE(0, DE_PITCH, DESTINATION, dPitch / BYTE_PER_PIXEL(bpp)) |
+        FIELD_VALUE(0, DE_PITCH, SOURCE, sPitch / BYTE_PER_PIXEL(bpp)));
+
+    /* Screen Window width in Pixels.
+       2D engine uses this value to calculate the linear address in frame buffer for a given point.
+    */
+    POKE_32(DE_WINDOW_WIDTH,
+        FIELD_VALUE(0, DE_WINDOW_WIDTH, DESTINATION, dPitch / BYTE_PER_PIXEL(bpp)) |
+        FIELD_VALUE(0, DE_WINDOW_WIDTH, SOURCE,      sPitch / BYTE_PER_PIXEL(bpp)));
+        
+    /* Set the pixel format of the destination */
+    deSetPixelFormat(bpp);
+       
+    /* Setup Control Register */
+    de_ctrl = FIELD_SET(0, DE_CONTROL, STATUS, START)    |
+              FIELD_SET(0, DE_CONTROL, COMMAND, ROTATE)  |
+              FIELD_SET(0, DE_CONTROL, ROP_SELECT, ROP2) |
+              FIELD_VALUE(0, DE_CONTROL, ROP, rop2)      |
+              ((repeatEnable == 1) ? 
+                    FIELD_SET(0, DE_CONTROL, REPEAT_ROTATE, ENABLE) :
+                    FIELD_SET(0, DE_CONTROL, REPEAT_ROTATE, DISABLE)) |
+              deGetTransparency();
+       
+    /* 501 Hardware cannot handle rotblits > 32 bytes. Therefore the rotation 
+       should be done part by part. Note on each rotation case. */
+    switch (rotateDirection)
+    {
+        case ROTATE_NORMAL:
+#if 0   /* Enable this on if the hardware 0 degree rotation bug has been fixed */
+
+            /* Setup rotation direction to 0 degree */
+            de_ctrl |= (FIELD_SET(0, DE_CONTROL, STEP_X, POSITIVE) |
+                        FIELD_SET(0, DE_CONTROL, STEP_Y, POSITIVE));
+
+            deRotate(sx, sy, dx, dy, width, height, de_ctrl);                        
+#else
+            /* 
+             * Due to the hardware bug on the SM750, rotate normal is simply done
+             * by calling the normal bit BLT. Calling the rotation with 0 degree
+             * will cause the hardware to rotate it 270 degree. 
+             */
+            return(ddk750_deVideoMem2VideoMemBlt(
+                    sBase,
+                    sPitch,
+                    sx,
+                    sy,
+                    dBase,
+                    dPitch,
+                    bpp,
+                    dx,
+                    dy,
+                    width, 
+                    height,
+                    rop2));
+#endif
+            break;
+
+        case ROTATE_180_DEGREE:
+            /* The 180 degree rotation that has problem */
+
+            return -1; /* Don't do anything until there is a HW fix */
+            
+            de_ctrl |= (FIELD_SET(0, DE_CONTROL, STEP_X, NEGATIVE) |
+                        FIELD_SET(0, DE_CONTROL, STEP_Y, NEGATIVE));
+
+            deRotate(sx, sy, dx, dy, width, height, de_ctrl);
+            break;
+
+        case ROTATE_90_DEGREE:
+            /* 90 degrees rotation.  Calculate destination
+			   coordinates:
+
+				*---+
+				|   |       +-----+
+				|   |       |     |
+				|   |  -->  |     |
+				|   |       |     |
+				|   |       *-----+
+				+---+
+			*/
+            /* Update the new width */
+            if (dy < width)
+                width = dy+1;
+                
+            /* Set up the rotation direction to 90 degree */                
+            de_ctrl |= (FIELD_SET(0, DE_CONTROL, STEP_X, NEGATIVE) |
+                        FIELD_SET(0, DE_CONTROL, STEP_Y, POSITIVE));
+
+#if 1   /* Disable this one if the hardware bug has been fixed */
+
+            /* Do rotation part by part based on the maxRotationWidth */
+            while (width > maxRotationWidth)
+	        {
+                deRotate(sx, sy, dx, dy, maxRotationWidth, height, de_ctrl);
+
+                width -= maxRotationWidth;
+                sx    += maxRotationWidth;
+                dy    -= maxRotationWidth;
+            }
+#endif
+            /* Rotate the rest of the segment */
+            if (width > 0)
+                deRotate(sx, sy, dx, dy, width, height, de_ctrl);
+                
+            break;
+        
+        case ROTATE_270_DEGREE:
+            /* 270 degrees (90 degree CW) rotation.  Calculate destination
+			   coordinates:
+
+				*---+
+				|   |       +-----*
+				|   |       |     |  
+				|   |  -->  |     | 
+				|   |       |     |
+				|   |       +-----+
+				+---+
+			*/
+            de_ctrl |= (FIELD_SET(0, DE_CONTROL, STEP_X, POSITIVE) |
+                        FIELD_SET(0, DE_CONTROL, STEP_Y, NEGATIVE));
+ 
+#if 1   /* Disable this one if the hardware bug has been fixed */
+
+            /* Do rotation part by part based on the maxRotationWidth */            
+            while (width > maxRotationWidth)
+	        {
+                deRotate(sx, sy, dx, dy, maxRotationWidth, height, de_ctrl);
+               
+                width -= maxRotationWidth;
+                sx    += maxRotationWidth;
+                dy    += maxRotationWidth;
+            }
+#endif            
+            /* Update the rest of the segment */
+            if (width > 0)
+                deRotate(sx, sy, dx, dy, width, height, de_ctrl);
+            break;
+    }
+
+    return 0;
+}
+
+/* 
+ * Function to draw a vertical line.
+ *
+ * Note:
+ *      This function is using Short Stroke line
+ */
+long deVerticalLine(
+    unsigned long dBase,    /* Base address of destination surface counted from beginning of video frame buffer */
+    unsigned long dPitch,   /* Pitch value of destination surface in BYTES */
+    unsigned long bpp,      /* Color depth of destination surface: 8, 16 or 32 */
+    unsigned long x,        /* Starting X Coordinate */
+    unsigned long y,        /* Starting Y Coordinate */
+    unsigned long length,   /* Length of the line */
+    unsigned long color,    /* Color of the line */
+    unsigned long rop2      /* ROP value */
+)
+{
+    unsigned long de_ctrl;
+    
+    if (deWaitForNotBusy() != 0)
+    {
+        /* The 2D engine is always busy for some unknown reason.
+           Application can choose to return ERROR, or reset it and
+           continue the operation.
+        */
+
+        return -1;
+
+        /* or */
+        /* deReset(); */
+    }
+
+    /* 2D Destination Base.
+       It is an address offset (128 bit aligned) from the beginning of frame buffer.
+    */
+    POKE_32(DE_WINDOW_DESTINATION_BASE, dBase);
+    
+    /* Program pitch (distance between the 1st points of two adjacent lines).
+       Note that input pitch is BYTE value, but the 2D Pitch register uses
+       pixel values. Need Byte to pixel convertion.
+    */
+    POKE_32(DE_PITCH,
+        FIELD_VALUE(0, DE_PITCH, DESTINATION, dPitch / BYTE_PER_PIXEL(bpp)) |
+        FIELD_VALUE(0, DE_PITCH, SOURCE, dPitch / BYTE_PER_PIXEL(bpp)));
+
+    /* Screen Window width in Pixels.
+       2D engine uses this value to calculate the linear address in frame buffer for a given point.
+    */
+    POKE_32(DE_WINDOW_WIDTH,
+        FIELD_VALUE(0, DE_WINDOW_WIDTH, DESTINATION, dPitch / BYTE_PER_PIXEL(bpp)) |
+        FIELD_VALUE(0, DE_WINDOW_WIDTH, SOURCE,      dPitch / BYTE_PER_PIXEL(bpp)));
+
+    /* Set the Line Color */
+    POKE_32(DE_FOREGROUND, color);
+
+    /* Set the destination coordinate. */
+    POKE_32(DE_DESTINATION,
+        FIELD_SET  (0, DE_DESTINATION, WRAP, DISABLE) |
+        FIELD_VALUE(0, DE_DESTINATION, X,    x)       |
+        FIELD_VALUE(0, DE_DESTINATION, Y,    y));
+
+    /* Set the line length and width */
+    POKE_32(DE_DIMENSION,
+        FIELD_VALUE(0, DE_DIMENSION, X,    1) |
+        FIELD_VALUE(0, DE_DIMENSION, Y_ET, length));
+        
+    /* Set the pixel format of the destination */
+    deSetPixelFormat(bpp);
+
+    /* Set the control register. For the Vertical line Short Stroke, the Direction Control
+       should be set to 0 (which is defined as Left to Right). */
+    de_ctrl = 
+        FIELD_SET  (0, DE_CONTROL,  STATUS,     START)         |
+        FIELD_SET  (0, DE_CONTROL,  DIRECTION,  LEFT_TO_RIGHT) |
+        FIELD_SET  (0, DE_CONTROL,  MAJOR,      Y)             |
+        FIELD_SET  (0, DE_CONTROL,  STEP_X,     NEGATIVE)      |
+        FIELD_SET  (0, DE_CONTROL,  STEP_Y,     NEGATIVE)      |
+        FIELD_SET  (0, DE_CONTROL,  LAST_PIXEL, OFF)           |
+        FIELD_SET  (0, DE_CONTROL,  COMMAND,    SHORT_STROKE)  |
+        FIELD_SET  (0, DE_CONTROL,  ROP_SELECT, ROP2)          |
+        FIELD_VALUE(0, DE_CONTROL,  ROP,        rop2);
+
+    POKE_32(DE_CONTROL, de_ctrl | deGetTransparency());
+
+    return 0;
+}
+
+/* 
+ * Function to draw a horizontal line.
+ *
+ * Note:
+ *      This function is using Short Stroke line
+ */
+long deHorizontalLine(
+    unsigned long dBase,    /* Base address of destination surface counted from beginning of video frame buffer */
+    unsigned long dPitch,   /* Pitch value of destination surface in BYTES */
+    unsigned long bpp,      /* Color depth of destination surface: 8, 16 or 32 */
+    unsigned long x,        /* Starting X Coordinate */
+    unsigned long y,        /* Starting Y Coordinate */
+    unsigned long length,   /* Length of the line */
+    unsigned long color,    /* Color of the line */
+    unsigned long rop2      /* ROP value */
+)
+{
+    unsigned long de_ctrl;
+    
+    if (deWaitForNotBusy() != 0)
+    {
+        /* The 2D engine is always busy for some unknown reason.
+           Application can choose to return ERROR, or reset it and
+           continue the operation.
+        */
+
+        return -1;
+
+        /* or */
+        /* deReset(); */
+    }
+    
+    /* 2D Destination Base.
+       It is an address offset (128 bit aligned) from the beginning of frame buffer.
+    */
+    POKE_32(DE_WINDOW_DESTINATION_BASE, dBase);
+    
+    /* Program pitch (distance between the 1st points of two adjacent lines).
+       Note that input pitch is BYTE value, but the 2D Pitch register uses
+       pixel values. Need Byte to pixel convertion.
+    */
+    POKE_32(DE_PITCH,
+        FIELD_VALUE(0, DE_PITCH, DESTINATION, dPitch / BYTE_PER_PIXEL(bpp)) |
+        FIELD_VALUE(0, DE_PITCH, SOURCE, dPitch / BYTE_PER_PIXEL(bpp)));
+        
+    /* Screen Window width in Pixels.
+       2D engine uses this value to calculate the linear address in frame buffer for a given point.
+    */
+    POKE_32(DE_WINDOW_WIDTH,
+        FIELD_VALUE(0, DE_WINDOW_WIDTH, DESTINATION, dPitch / BYTE_PER_PIXEL(bpp)) |
+        FIELD_VALUE(0, DE_WINDOW_WIDTH, SOURCE,      dPitch / BYTE_PER_PIXEL(bpp)));
+
+    /* Set the Line Color */
+    POKE_32(DE_FOREGROUND, color);
+
+    /* Set the destination coordinate */
+    POKE_32(DE_DESTINATION,
+        FIELD_SET  (0, DE_DESTINATION, WRAP, DISABLE) |
+        FIELD_VALUE(0, DE_DESTINATION, X,    x)       |
+        FIELD_VALUE(0, DE_DESTINATION, Y,    y));
+
+    /* Set the line length and width */
+    POKE_32(DE_DIMENSION,
+        FIELD_VALUE(0, DE_DIMENSION, X,    length) |
+        FIELD_VALUE(0, DE_DIMENSION, Y_ET, 1));
+        
+    /* Set the pixel format of the destination */
+    deSetPixelFormat(bpp);
+
+    /* Set the control register. For the Horizontal line Short Stroke, the Direction Control
+       should be set to 1 (which is defined as Right to Left). */
+    de_ctrl = 
+        FIELD_SET  (0, DE_CONTROL,  STATUS,     START)         |
+        FIELD_SET  (0, DE_CONTROL,  DIRECTION,  RIGHT_TO_LEFT) |
+        FIELD_SET  (0, DE_CONTROL,  MAJOR,      X)             |
+        FIELD_SET  (0, DE_CONTROL,  STEP_X,     NEGATIVE)      |
+        FIELD_SET  (0, DE_CONTROL,  STEP_Y,     NEGATIVE)      |
+        FIELD_SET  (0, DE_CONTROL,  LAST_PIXEL, OFF)           |
+        FIELD_SET  (0, DE_CONTROL,  COMMAND,    SHORT_STROKE)  |
+        FIELD_SET  (0, DE_CONTROL,  ROP_SELECT, ROP2)          |
+        FIELD_VALUE(0, DE_CONTROL,  ROP,        rop2);
+
+    POKE_32(DE_CONTROL, de_ctrl | deGetTransparency());
+    
+    return 0;
+}
+
+/* 
+ * Function to draw a line.
+ *
+ * Note:
+ *      This function is using Short Stroke Command for Vertical, Horizontal, and 
+ *      Diagonal line. Other line are drawn using the Line Draw Command.
+ */
+long deLine(
+    unsigned long dBase,    /* Base address of destination surface counted from beginning of video frame buffer */
+    unsigned long dPitch,   /* Pitch value of destination surface in BYTES */
+    unsigned long bpp,      /* Color depth of destination surface: 8, 16 or 32 */
+    long x0,                /* Starting X Coordinate */
+    long y0,                /* Starting Y Coordinate */
+    long x1,                /* Ending X Coordinate */
+    long y1,                /* Ending Y Coordinate */
+    unsigned long color,    /* Color of the line */
+    unsigned long rop2      /* ROP value */
+)
+{
+    unsigned long de_ctrl =
+        FIELD_SET  (0, DE_CONTROL, STATUS,     START)         |
+        FIELD_SET  (0, DE_CONTROL, DIRECTION,  LEFT_TO_RIGHT) |
+        FIELD_SET  (0, DE_CONTROL, MAJOR,      X)             |
+        FIELD_SET  (0, DE_CONTROL, STEP_X,     POSITIVE)      |
+        FIELD_SET  (0, DE_CONTROL, STEP_Y,     POSITIVE)      |
+        FIELD_SET  (0, DE_CONTROL, LAST_PIXEL, ON)            |
+        FIELD_SET  (0, DE_CONTROL, ROP_SELECT, ROP2)          |
+        FIELD_VALUE(0, DE_CONTROL, ROP,        rop2);
+
+    unsigned long dx, dy;
+    
+    if (deWaitForNotBusy() != 0)
+    {
+        /* The 2D engine is always busy for some unknown reason.
+           Application can choose to return ERROR, or reset it and
+           continue the operation.
+        */
+
+        return -1;
+
+        /* or */
+        /* deReset(); */
+    }
+    
+    //DDKDEBUGPRINT((DE_LEVEL, "x0=%d(%x), y0=%d(%0x)\n", x0, x0, y0, y0));
+    //DDKDEBUGPRINT((DE_LEVEL, "x1=%d(%x), y1=%d(%0x)\n", x1, x1, y1, y1));
+    
+    /* Return error if x0 and/or y0 are negative numbers. The hardware does not take
+       any negative values on these two origin line coordinate.
+       When drawing with a negative x0, the line might be drawn incorrectly.
+       When drawing with a negative y0, the system might reboot or hang.
+     */
+    if ((x0 < 0) || (y0 < 0))
+    {
+        //DDKDEBUGPRINT((ERROR_LEVEL, "Negative origin coordinates are not allowed (x0, y0) = (%d, %d).\n", x0, y0));
+        return (-1);
+    }
+
+    /* Calculate delta X */
+    if (x0 <= x1)
+    {
+        dx = x1 - x0;
+        de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, STEP_X, NEGATIVE);
+    }
+    else
+        dx = x0 - x1;
+
+    /* Calculate delta Y */
+    if (y0 <= y1)
+    {
+        dy = y1 - y0;
+        de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, STEP_Y, NEGATIVE);
+    }
+    else
+        dy = y0 - y1;
+
+    /* Determine the major axis */
+    if (dx < dy)
+        de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, MAJOR, Y);        
+
+    /*****************************************************
+     * Draw the line based on the calculated information *
+     *****************************************************/
+     
+    /* Vertical line? */
+    if (x0 == x1)
+        deVerticalLine(dBase, dPitch, bpp, x0, (y0 < y1) ? y0 : y1, dy + 1, color, rop2);
+
+    /* Horizontal line? */
+    else if (y0 == y1)
+        deHorizontalLine(dBase, dPitch, bpp, (x0 < x1) ? x0 : x1, y0, dx + 1, color, rop2);
+
+    else 
+    {
+        /****************************
+         * Set the common registers *
+         ****************************/
+         
+        /* 2D Destination Base.
+           It is an address offset (128 bit aligned) from the beginning of frame buffer.
+        */
+        POKE_32(DE_WINDOW_DESTINATION_BASE, dBase);
+
+        /* Program pitch (distance between the 1st points of two adjacent lines).
+           Note that input pitch is BYTE value, but the 2D Pitch register uses
+           pixel values. Need Byte to pixel convertion.
+        */
+        POKE_32(DE_PITCH,
+            FIELD_VALUE(0, DE_PITCH, DESTINATION, dPitch / BYTE_PER_PIXEL(bpp)) |
+            FIELD_VALUE(0, DE_PITCH, SOURCE, dPitch / BYTE_PER_PIXEL(bpp)));
+    
+        /* Screen Window width in Pixels.
+           2D engine uses this value to calculate the linear address in frame buffer for a given point.
+        */
+        POKE_32(DE_WINDOW_WIDTH,
+            FIELD_VALUE(0, DE_WINDOW_WIDTH, DESTINATION, dPitch / BYTE_PER_PIXEL(bpp)) |
+            FIELD_VALUE(0, DE_WINDOW_WIDTH, SOURCE,      dPitch / BYTE_PER_PIXEL(bpp)));
+
+        /* Set the Line Color */
+        POKE_32(DE_FOREGROUND, color);
+
+        /* Set the destination coordinate */
+        POKE_32(DE_DESTINATION,
+            FIELD_SET  (0, DE_DESTINATION, WRAP, DISABLE) |
+            FIELD_VALUE(0, DE_DESTINATION, X,    x0)      |
+            FIELD_VALUE(0, DE_DESTINATION, Y,    y0));
+        
+        /* Set the pixel format of the destination */
+        deSetPixelFormat(bpp);
+    
+        /* Diagonal line? */
+        if (dx == dy)
+        {
+            /* Set the line length and width */
+            POKE_32(DE_DIMENSION,
+                FIELD_VALUE(0, DE_DIMENSION, X,    1) |
+                FIELD_VALUE(0, DE_DIMENSION, Y_ET, dx + 1));
+
+            /* Set the command register. */
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, COMMAND, SHORT_STROKE);
+
+            POKE_32(DE_CONTROL, de_ctrl | deGetTransparency());            
+        }
+
+        /* Generic line */
+        else
+        {
+            long k1, k2, et, w;
+            
+            if (dx < dy)
+            {
+                k1 = 2 * dx;
+                et = k1 - dy;
+                k2 = et - dy;
+                w  = dy + 1;
+            } 
+            else 
+            {
+                k1 = 2 * dy;
+                et = k1 - dx;
+                k2 = et - dx;
+                w  = dx + 1;
+            }
+            
+            //DDKDEBUGPRINT((DE_LEVEL, "k1=%d(%x), k2=%d(%x)\n", k1, k1, k2, k2));
+            
+            /* Return error if the value of K1 and/or K2 is/are overflowed which is 
+               determined using the following condition:
+                        0 < k1 < (2^13 - 1)
+                    -2^13 < k2 < 0
+               Bit-14 is the sign bit.
+               
+               Failing to follow this guidance will result in incorrect line drawing.
+               On failure, please use software to draw the correct line.
+             */             
+            if ((k1 > 8191) || (k2 < (0 - 8192)))
+            {
+                //DDKDEBUGPRINT((ERROR_LEVEL, "K1=%d(0x%04x) and/or K2=%d(0x%04x) is/are overflowed.\n", k1, k1, k2, k2));
+                return (-1);
+            }
+        
+            /* Set the k1 and k2 */
+            POKE_32(DE_SOURCE,
+                FIELD_SET  (0, DE_SOURCE, WRAP, DISABLE) |
+                FIELD_VALUE(0, DE_SOURCE, X_K1_LINE, k1) |
+                FIELD_VALUE(0, DE_SOURCE, Y_K2_LINE, k2));
+
+            /* Set the line length and width */
+            POKE_32(DE_DIMENSION,
+                FIELD_VALUE(0, DE_DIMENSION, X,    w) |
+                FIELD_VALUE(0, DE_DIMENSION, Y_ET, et));
+
+            /* Set the control register. */
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, COMMAND, LINE_DRAW);
+
+            POKE_32(DE_CONTROL, de_ctrl | deGetTransparency());
+        }
+    }
+    
+    return 0;
+}
+
+#if 0   /* These RLE functions are not working. */
+/*
+ *  The following functions, that uses to draw line using RLE Strip command, are not working,
+ *  as described in the following:
+ *      1. Line strips can not be used to draw line vertically.
+ *      2. Origin Y automatic update is not work. Only Origin X automatic update is working.
+ *      3. Line counter to accelerate drawing multiple strip of the same characteristics does
+ *         not work.
+ *  For more information about RLE Line Strips, please refer to "Programmer's Guide to the EGA,
+ *  VGA, and Super VGA Cards", third edition, page 727-730.
+ */
+ 
+/* 
+ * Function to draw a line using RLE line strip method.
+ */
+long deStartLineStrip(
+    unsigned long dBase,        /* Base address of destination surface counted from beginning of video frame buffer */
+    unsigned long dPitch,       /* Pitch value of destination surface in BYTES */
+    unsigned long bpp,          /* Color depth of destination surface: 8, 16 or 32 */
+    unsigned long x,            /* X Coordinate */
+    unsigned long y,            /* Y Coordinate */
+    unsigned long length,       /* Length of the line */
+    unsigned long lineCounter,  /* Line Counter */
+    unsigned long direction,    /* Direction:   0 - Left to Right
+                                                1 - Right to Left
+                                                2 - Top to Bottom
+                                                3 - Bottom to Top
+                                */
+    unsigned long color,        /* Color of the line */
+    unsigned long rop2          /* ROP value */
+)
+{
+    unsigned long dx, dy;
+    unsigned long de_ctrl =
+        FIELD_SET  (0, DE_CONTROL, STATUS,      START)      |
+        FIELD_SET  (0, DE_CONTROL, QUICK_START, ENABLE)     |
+        FIELD_SET  (0, DE_CONTROL, LAST_PIXEL,  OFF)        |
+        FIELD_SET  (0, DE_CONTROL, COMMAND,     RLE_STRIP)  |
+        FIELD_SET  (0, DE_CONTROL, ROP_SELECT,  ROP2)       |
+        FIELD_VALUE(0, DE_CONTROL, ROP,         rop2);
+
+    if (deWaitForNotBusy() != 0)
+    {
+        /* The 2D engine is always busy for some unknown reason.
+           Application can choose to return ERROR, or reset it and
+           continue the operation.
+        */
+
+        return -1;
+
+        /* or */
+        /* deReset(); */
+    }
+    
+    /* 2D Destination Base.
+       It is an address offset (128 bit aligned) from the beginning of frame buffer.
+    */
+    POKE_32(DE_WINDOW_DESTINATION_BASE, dBase);
+
+    /* Program pitch (distance between the 1st points of two adjacent lines).
+       Note that input pitch is BYTE value, but the 2D Pitch register uses
+       pixel values. Need Byte to pixel convertion.
+    */
+    POKE_32(DE_PITCH,
+        FIELD_VALUE(0, DE_PITCH, DESTINATION, dPitch / BYTE_PER_PIXEL(bpp)) |
+        FIELD_VALUE(0, DE_PITCH, SOURCE, dPitch / BYTE_PER_PIXEL(bpp)));
+
+    /* Screen Window width in Pixels.
+       2D engine uses this value to calculate the linear address in frame buffer for a given point.
+    */
+    POKE_32(DE_WINDOW_WIDTH,
+        FIELD_VALUE(0, DE_WINDOW_WIDTH, DESTINATION, dPitch / BYTE_PER_PIXEL(bpp)) |
+        FIELD_VALUE(0, DE_WINDOW_WIDTH, SOURCE,      dPitch / BYTE_PER_PIXEL(bpp)));
+
+    /* Set the Line Color */
+    POKE_32(DE_FOREGROUND, color);
+    
+    /* Set the destination coordinate */
+    POKE_32(DE_DESTINATION,
+        FIELD_SET  (0, DE_DESTINATION, WRAP, DISABLE) |
+        FIELD_VALUE(0, DE_DESTINATION, X,    x)       |
+        FIELD_VALUE(0, DE_DESTINATION, Y,    y));
+    
+    /* Set the pixel format of the destination */
+    deSetPixelFormat(bpp);
+
+#if 1   /* Testing if any of the configuration combination of the following have
+           any differences. */
+    switch (direction)
+    {
+        case 0:
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, DIRECTION, LEFT_TO_RIGHT);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, MAJOR, X);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, STEP_X, POSITIVE);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, STEP_Y, POSITIVE);
+            break;
+        case 1:
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, DIRECTION, LEFT_TO_RIGHT);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, MAJOR, X);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, STEP_X, POSITIVE);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, STEP_Y, NEGATIVE);
+            break;
+        case 2:
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, DIRECTION,  LEFT_TO_RIGHT);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, MAJOR, X);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, STEP_X, NEGATIVE);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, STEP_Y, POSITIVE);
+            break;
+        case 3:
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, DIRECTION,  LEFT_TO_RIGHT);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, MAJOR, X);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, STEP_X, NEGATIVE);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, STEP_Y, NEGATIVE);
+            break;
+        case 4:
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, DIRECTION, LEFT_TO_RIGHT);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, MAJOR, Y);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, STEP_X, POSITIVE);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, STEP_Y, POSITIVE);
+            break;
+        case 5:
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, DIRECTION, LEFT_TO_RIGHT);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, MAJOR, Y);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, STEP_X, POSITIVE);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, STEP_Y, NEGATIVE);
+            break;
+        case 6:
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, DIRECTION,  LEFT_TO_RIGHT);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, MAJOR, Y);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, STEP_X, NEGATIVE);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, STEP_Y, POSITIVE);
+            break;
+        case 7:
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, DIRECTION,  LEFT_TO_RIGHT);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, MAJOR, Y);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, STEP_X, NEGATIVE);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, STEP_Y, NEGATIVE);
+            break;
+        case 8:
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, DIRECTION, RIGHT_TO_LEFT);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, MAJOR, X);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, STEP_X, POSITIVE);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, STEP_Y, POSITIVE);
+            break;
+        case 9:
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, DIRECTION, RIGHT_TO_LEFT);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, MAJOR, X);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, STEP_X, POSITIVE);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, STEP_Y, NEGATIVE);
+            break;
+        case 10:
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, DIRECTION,  RIGHT_TO_LEFT);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, MAJOR, X);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, STEP_X, NEGATIVE);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, STEP_Y, POSITIVE);
+            break;
+        case 11:
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, DIRECTION,  RIGHT_TO_LEFT);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, MAJOR, X);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, STEP_X, NEGATIVE);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, STEP_Y, NEGATIVE);
+            break;
+        case 12:
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, DIRECTION, RIGHT_TO_LEFT);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, MAJOR, Y);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, STEP_X, POSITIVE);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, STEP_Y, POSITIVE);
+            break;
+        case 13:
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, DIRECTION, RIGHT_TO_LEFT);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, MAJOR, Y);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, STEP_X, POSITIVE);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, STEP_Y, NEGATIVE);
+            break;
+        case 14:
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, DIRECTION,  RIGHT_TO_LEFT);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, MAJOR, Y);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, STEP_X, NEGATIVE);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, STEP_Y, POSITIVE);
+            break;
+        case 15:
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, DIRECTION,  RIGHT_TO_LEFT);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, MAJOR, Y);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, STEP_X, NEGATIVE);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, STEP_Y, NEGATIVE);
+            break;
+    }
+    
+    /* Set the line length and width */
+    POKE_32(DE_DIMENSION,
+        FIELD_VALUE(0, DE_DIMENSION, X,    lineCounter) |
+        FIELD_VALUE(0, DE_DIMENSION, Y_ET, length));
+#else
+    /* Determine the x & y steps direction control and major axis */
+    switch (direction)
+    {
+        case 0:
+            /* Left to Right */
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, DIRECTION, LEFT_TO_RIGHT);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, MAJOR, X);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, STEP_X, POSITIVE);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, STEP_Y, POSITIVE);
+            
+            /* Set the line length and width */
+            POKE_32(DE_DIMENSION,
+                FIELD_VALUE(0, DE_DIMENSION, X,    length) |
+                FIELD_VALUE(0, DE_DIMENSION, Y_ET, lineCounter));
+            break;
+            
+        case 1:
+            /* Right to Left */
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, DIRECTION, RIGHT_TO_LEFT);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, MAJOR, X);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, STEP_X, NEGATIVE);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, STEP_Y, POSITIVE);
+            
+            /* Set the line length and width */
+            POKE_32(DE_DIMENSION,
+                FIELD_VALUE(0, DE_DIMENSION, X,    length) |
+                FIELD_VALUE(0, DE_DIMENSION, Y_ET, lineCounter));
+            break;
+            
+        case 2:
+            /* Top to Bottom */
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, DIRECTION,  LEFT_TO_RIGHT);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, MAJOR, Y);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, STEP_X, POSITIVE);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, STEP_Y, POSITIVE);
+            
+            /* Set the line length and width */
+            POKE_32(DE_DIMENSION,
+                FIELD_VALUE(0, DE_DIMENSION, X,    lineCounter) |
+                FIELD_VALUE(0, DE_DIMENSION, Y_ET, length));
+            break;
+            
+        case 3:
+            /* Bottom to Top */
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, DIRECTION,  RIGHT_TO_LEFT);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, MAJOR, Y);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, STEP_X, POSITIVE);
+            de_ctrl = FIELD_SET(de_ctrl, DE_CONTROL, STEP_Y, NEGATIVE);
+            
+            /* Set the line length and width */
+            POKE_32(DE_DIMENSION,
+                FIELD_VALUE(0, DE_DIMENSION, X,    lineCounter) |
+                FIELD_VALUE(0, DE_DIMENSION, Y_ET, length));
+            break;
+    }
+#endif
+
+    /* Enable the 2D Engine. */
+    POKE_32(DE_CONTROL, de_ctrl | deGetTransparency());
+    
+    return 0;
+}
+
+/* 
+ * Function to continue drawing a line using RLE line strip method.
+ */
+long deNextLineStrip(
+    unsigned long length,       /* Line strip length */
+    unsigned long lineCounter   /* Line Counter */
+)
+{
+    unsigned long de_ctrl;
+    
+    if (deWaitForNotBusy() != 0)
+    {
+        /* The 2D engine is always busy for some unknown reason.
+           Application can choose to return ERROR, or reset it and
+           continue the operation.
+        */
+
+        return -1;
+
+        /* or */
+        /* deReset(); */
+    }
+    
+    de_ctrl = PEEK_32(DE_CONTROL);
+    
+    if (FIELD_GET(de_ctrl, DE_CONTROL, MAJOR) == DE_CONTROL_MAJOR_X)
+    {
+        /* Set the line length and width */
+        POKE_32(DE_DIMENSION,
+            FIELD_VALUE(0, DE_DIMENSION, X,    length) |
+            FIELD_VALUE(0, DE_DIMENSION, Y_ET, lineCounter));
+    }
+    else
+    {
+        /* Set the line length and width */
+        POKE_32(DE_DIMENSION,
+            FIELD_VALUE(0, DE_DIMENSION, X,    lineCounter) |
+            FIELD_VALUE(0, DE_DIMENSION, Y_ET, length));
+    }
+    
+    return 0;
+}
+
+/* 
+ * Function to stop the RLE line strip drawing.
+ * This function has to be called to end the Line Strip drawing.
+ * Otherwise, the next 2D function might still use this function.
+ */
+long deStopLineStrip()
+{
+    if (deWaitForNotBusy() != 0)
+    {
+        /* The 2D engine is always busy for some unknown reason.
+           Application can choose to return ERROR, or reset it and
+           continue the operation.
+        */
+
+        return -1;
+
+        /* or */
+        /* deReset(); */
+    }
+    
+    POKE_32(DE_CONTROL, FIELD_SET(PEEK_32(DE_CONTROL), DE_CONTROL, QUICK_START, DISABLE));
+    
+    return 0;
+}
+#endif
+
+/* Define this definition to block transparency in Alpha Blend blt since
+   transparency does not work with alpha blend. */
+//#define ALPHA_BLEND_BLOCK_TRANSPARENCY
+
+/*
+ * Alpha Blend Blt.
+ * 
+ * This function blends the source with the destination image.
+ */
+long deVideoMem2VideoMemAlphaBlendBlt(
+    unsigned long sBase,            /* Source Base Address */
+    unsigned long sPitch,           /* Source pitch */
+    unsigned long sx,               /* X Coordinate of the source */
+    unsigned long sy,               /* Y Coordinate of the source */
+    unsigned long sWidth,           /* Source Width */
+    unsigned long sHeight,          /* Source Height */
+    unsigned long dBase,            /* Destination Base Address */
+    unsigned long dPitch,           /* Destination pitch */
+    unsigned long bpp,              /* Color depth of destination surface */
+    unsigned long dx,               /* X Coordinate of the destination */ 
+    unsigned long dy,               /* Y Coordinate of the destination */
+    unsigned long dHeight,          /* Destination Height (only height stretch is supported) */
+    unsigned long alphaValue,       /* Alpha value for Alpha Blend*/
+    unsigned long rop2              /* ROP control */
+)
+{
+    unsigned long de_ctrl = 0, transparency, bytePerPixel;
+    
+    bytePerPixel = bpp/8; 
+    
+    /* Wait for the engine to be idle */
+    if (deWaitForNotBusy() != 0)
+    {
+        /* The 2D engine is always busy for some unknown reason.
+           Application can choose to return ERROR, or reset it and
+           continue the operation.
+        */
+        return -1;
+
+        /* or */
+        /* deReset(); */
+    }
+
+    /* Return error if either the width or height is zero */ 
+    if ((sWidth == 0) || (sHeight == 0) || (dHeight == 0))
+        return -1;
+    
+#ifdef ALPHA_BLEND_BLOCK_TRANSPARENCY
+    /* Get the transparency settings. The transparency does not work with Alpha Blend,
+       therefore, save the transparency setting, disable, and restore it back later. */
+    transparency = deGetTransparency();
+#endif
+
+    /* 2D Source Base.
+       It is an address offset (128 bit aligned) from the beginning of frame buffer.
+    */
+    POKE_32(DE_WINDOW_SOURCE_BASE, sBase);
+
+    /* 2D Destination Base.
+       It is an address offset (128 bit aligned) from the beginning of frame buffer.
+    */
+    POKE_32(DE_WINDOW_DESTINATION_BASE, dBase);
+
+    /* Program pitch (distance between the 1st points of two adjacent lines).
+       Note that input pitch is BYTE value, but the 2D Pitch register uses
+       pixel values. Need Byte to pixel conversion.
+    */
+    POKE_32(DE_PITCH,
+        FIELD_VALUE(0, DE_PITCH, DESTINATION, dPitch / BYTE_PER_PIXEL(bpp)) |
+        FIELD_VALUE(0, DE_PITCH, SOURCE, sPitch / BYTE_PER_PIXEL(bpp)));
+
+    /* Screen Window width in Pixels.
+       2D engine uses this value to calculate the linear address in frame buffer for a given point.
+    */
+    POKE_32(DE_WINDOW_WIDTH,
+        FIELD_VALUE(0, DE_WINDOW_WIDTH, DESTINATION, dPitch / BYTE_PER_PIXEL(bpp)) |
+        FIELD_VALUE(0, DE_WINDOW_WIDTH, SOURCE,      sPitch / BYTE_PER_PIXEL(bpp)));
+        
+    /* Set the Source Height */
+    POKE_32(DE_STRETCH_FORMAT, 
+        FIELD_VALUE(PEEK_32(DE_STRETCH_FORMAT), DE_STRETCH_FORMAT, SOURCE_HEIGHT, sHeight));
+        
+    /* Set the alpha blend value */
+    POKE_32(DE_ALPHA,
+        FIELD_VALUE(0, DE_ALPHA, VALUE, alphaValue));
+
+    /* Set the pixel format of the destination */
+    deSetPixelFormat(bpp);
+
+#ifdef ENABLE_192_BYTES_PATCH
+    /* Workaround for 192 byte requirement */
+    if ((sWidth * bytePerPixel) > 192)
+    {
+        /* Perform the ROP2 operation in chunks of (xWidth * nHeight) */
+        unsigned long xChunk = 192 / bytePerPixel; /* chunk width is in pixels */
+        
+        //DDKDEBUGPRINT((DE_LEVEL, "width * bytePerPixel = %x (> 192 bytes)\n", sWidth * bytePerPixel));
+
+        while (1)
+        {
+            deWaitForNotBusy();
+            
+            /* Set the source coordinate */    
+            POKE_32(DE_SOURCE,
+                FIELD_SET  (0, DE_SOURCE, WRAP, DISABLE) |
+                FIELD_VALUE(0, DE_SOURCE, X_K1, sx)   |
+                FIELD_VALUE(0, DE_SOURCE, Y_K2, sy));
+
+            /* Set the destination coordinate */        
+            POKE_32(DE_DESTINATION,
+                FIELD_SET  (0, DE_DESTINATION, WRAP, DISABLE) |
+                FIELD_VALUE(0, DE_DESTINATION, X,    dx)  |
+                FIELD_VALUE(0, DE_DESTINATION, Y,    dy));
+
+            /* Set the Destination Dimension */    
+            POKE_32(DE_DIMENSION,
+                FIELD_VALUE(0, DE_DIMENSION, X,    xChunk) |
+                FIELD_VALUE(0, DE_DIMENSION, Y_ET, dHeight));
+
+            /* Setup Control Register */
+            de_ctrl = FIELD_SET(0, DE_CONTROL, STATUS, START)    |
+                      FIELD_SET(0, DE_CONTROL, COMMAND, ALPHA_BLEND)  |
+                      FIELD_SET(0, DE_CONTROL, ROP_SELECT, ROP2) |
+                      FIELD_VALUE(0, DE_CONTROL, ROP, rop2)      |
+                      ((sHeight < dHeight) ?
+                            FIELD_SET(0, DE_CONTROL, STRETCH, ENABLE) :
+                            FIELD_SET(0, DE_CONTROL, STRETCH, DISABLE));
+
+            POKE_32(DE_CONTROL, de_ctrl);
+
+            if (xChunk == sWidth)
+                break;
+
+            sx += xChunk;
+            dx += xChunk;
+            sWidth -= xChunk;
+
+            if (xChunk > sWidth)
+            {
+                /* This is the last chunk. */
+                xChunk = sWidth;
+            }
+        }
+    }
+    else
+#endif
+    {
+        deWaitForNotBusy();
+            
+        /* Set the source coordinate */    
+        POKE_32(DE_SOURCE,
+            FIELD_SET  (0, DE_SOURCE, WRAP, DISABLE) |
+            FIELD_VALUE(0, DE_SOURCE, X_K1, sx)   |
+            FIELD_VALUE(0, DE_SOURCE, Y_K2, sy));
+
+        /* Set the destination coordinate */        
+        POKE_32(DE_DESTINATION,
+            FIELD_SET  (0, DE_DESTINATION, WRAP, DISABLE) |
+            FIELD_VALUE(0, DE_DESTINATION, X,    dx)  |
+            FIELD_VALUE(0, DE_DESTINATION, Y,    dy));
+
+        /* Set the Destination Dimension */    
+        POKE_32(DE_DIMENSION,
+            FIELD_VALUE(0, DE_DIMENSION, X,    sWidth) |
+            FIELD_VALUE(0, DE_DIMENSION, Y_ET, dHeight));
+
+        /* Setup Control Register */
+        de_ctrl = FIELD_SET(0, DE_CONTROL, STATUS, START)    |
+                  FIELD_SET(0, DE_CONTROL, COMMAND, ALPHA_BLEND)  |
+                  FIELD_SET(0, DE_CONTROL, ROP_SELECT, ROP2) |
+                  FIELD_VALUE(0, DE_CONTROL, ROP, rop2)      |
+                  ((sHeight < dHeight) ?
+                        FIELD_SET(0, DE_CONTROL, STRETCH, ENABLE) :
+                        FIELD_SET(0, DE_CONTROL, STRETCH, DISABLE));
+
+        POKE_32(DE_CONTROL, de_ctrl);
+    }
+
+#ifdef ALPHA_BLEND_BLOCK_TRANSPARENCY
+    /* Restore back the transparency */
+    deWaitForNotBusy();
+    de_ctrl = PEEK_32(de_ctrl) | transparency;
+    POKE_32(DE_CONTROL, de_ctrl);
+#endif
+
+    return 0;
+}
+
+/*
+ * This function sets the monochrome pattern on the pattern registers.
+ */
+void deSetPattern(
+    unsigned long monoPatternLow,
+    unsigned long monoPatternHigh
+)
+{
+    POKE_32(DE_MONO_PATTERN_LOW, monoPatternLow);
+    POKE_32(DE_MONO_PATTERN_HIGH, monoPatternHigh);
+}
+
+/*
+ * This function uses 2D engine to fill a rectangular area with a specific pattern.
+ * The filled area includes the starting points.
+ */
+long deRectPatternFill(
+    unsigned long dBase,  /* Base address of destination surface counted from beginning of video frame buffer */
+    unsigned long dPitch, /* Pitch value of destination surface in BYTES */
+    unsigned long bpp,    /* Color depth of destination surface: 8, 16 or 32 */
+    unsigned long x,
+    unsigned long y,      /* Upper left corner (X, Y) of rectangle in pixel value */
+    unsigned long width, 
+    unsigned long height, /* width and height of rectange in pixel value */
+    unsigned long color,  /* Color to be filled */
+    unsigned long rop3)   /* ROP value */
+{
+    unsigned long de_ctrl, bytePerPixel;
+
+    bytePerPixel = bpp/8;
+    
+    if (deWaitForNotBusy() != 0)
+    {
+        /* The 2D engine is always busy for some unknown reason.
+           Application can choose to return ERROR, or reset it and
+           continue the operation.
+        */
+
+        return -1;
+
+        /* or */
+        /* deReset(); */
+    }
+
+    /* 2D Destination Base.
+       It is an address offset (128 bit aligned) from the beginning of frame buffer.
+    */
+    POKE_32(DE_WINDOW_DESTINATION_BASE, dBase);
+
+    /* Program pitch (distance between the 1st points of two adjacent lines).
+       Note that input pitch is BYTE value, but the 2D Pitch register uses
+       pixel values. Need Byte to pixel convertion.
+    */
+    POKE_32(DE_PITCH,
+        FIELD_VALUE(0, DE_PITCH, DESTINATION, (dPitch/bytePerPixel)) |
+        FIELD_VALUE(0, DE_PITCH, SOURCE,      (dPitch/bytePerPixel)));
+
+    /* Screen Window width in Pixels.
+       2D engine uses this value to calculate the linear address in frame buffer for a given point.
+    */
+    POKE_32(DE_WINDOW_WIDTH,
+        FIELD_VALUE(0, DE_WINDOW_WIDTH, DESTINATION, (dPitch/bytePerPixel)) |
+        FIELD_VALUE(0, DE_WINDOW_WIDTH, SOURCE,      (dPitch/bytePerPixel)));
+
+    POKE_32(DE_FOREGROUND, color);
+    
+    /* Set the pixel format of the destination */
+    deSetPixelFormat(bpp);
+
+#ifdef ENABLE_192_BYTES_PATCH
+    /* Workaround for 192 byte requirement when ROP is not COPY */
+    if (((rop3 != ROP2_COPY) || (rop3 != ROP2_Sn) || (rop3 != ROP2_Dn) || 
+         (rop3 != ROP2_D) || (rop3 != ROP2_BLACK) || (rop3 != ROP2_WHITE)) && 
+        ((width * bytePerPixel) > 192))
+    {
+        /* Perform the ROP2 operation in chunks of (xWidth * nHeight) */
+        unsigned long xChunk = 192 / bytePerPixel; /* chunk width is in pixels */
+        
+        //DDKDEBUGPRINT((DE_LEVEL, "ROP != ROP_COPY, width * bytePerPixel = %x (> 192 bytes)\n", width * bytePerPixel));
+
+        while (1)
+        {
+            deWaitForNotBusy();
+            
+            POKE_32(DE_DESTINATION,
+                FIELD_SET  (0, DE_DESTINATION, WRAP, DISABLE) |
+                FIELD_VALUE(0, DE_DESTINATION, X,    x)  |
+                FIELD_VALUE(0, DE_DESTINATION, Y,    y));
+                
+            POKE_32(DE_DIMENSION,
+                FIELD_VALUE(0, DE_DIMENSION, X,    xChunk) |
+                FIELD_VALUE(0, DE_DIMENSION, Y_ET, height));
+
+            de_ctrl = 
+                FIELD_SET  (0, DE_CONTROL,  STATUS,     START)          |
+                FIELD_SET  (0, DE_CONTROL,  DIRECTION,  LEFT_TO_RIGHT)  |
+                //FIELD_SET  (0, DE_CONTROL,LAST_PIXEL, OFF)            |
+                FIELD_SET  (0, DE_CONTROL,  COMMAND,    RECTANGLE_FILL) |
+                FIELD_SET  (0, DE_CONTROL,  ROP_SELECT, ROP2)           |
+                FIELD_VALUE(0, DE_CONTROL,  ROP,        rop3);
+
+            POKE_32(DE_CONTROL, de_ctrl | deGetTransparency());
+
+            if (xChunk == width) break;
+
+            x += xChunk;
+            width -= xChunk;
+
+            if (xChunk > width)
+            {
+                /* This is the last chunk. */
+                xChunk = width;
+            }
+        }
+    }
+    else
+#endif
+    {
+        POKE_32(DE_DESTINATION,
+            FIELD_SET  (0, DE_DESTINATION, WRAP, DISABLE) |
+            FIELD_VALUE(0, DE_DESTINATION, X,    x)       |
+            FIELD_VALUE(0, DE_DESTINATION, Y,    y));
+
+        POKE_32(DE_DIMENSION,
+            FIELD_VALUE(0, DE_DIMENSION, X,    width) |
+            FIELD_VALUE(0, DE_DIMENSION, Y_ET, height));
+
+        de_ctrl = 
+            FIELD_SET  (0, DE_CONTROL,  STATUS,     START)          |
+            FIELD_SET  (0, DE_CONTROL,  DIRECTION,  LEFT_TO_RIGHT)  |
+            //FIELD_SET  (0, DE_CONTROL,LAST_PIXEL, OFF)            |
+            FIELD_SET  (0, DE_CONTROL,  COMMAND,    RECTANGLE_FILL) |
+            FIELD_SET  (0, DE_CONTROL,  ROP_SELECT, ROP2)           |
+            FIELD_VALUE(0, DE_CONTROL,  ROP,        rop3);
+
+        POKE_32(DE_CONTROL, de_ctrl | deGetTransparency());
+    }
+    
+    return 0;
+}
diff --git a/drivers/gpu/drm/smi/ddk750/ddk750_2d.h b/drivers/gpu/drm/smi/ddk750/ddk750_2d.h
new file mode 100644
index 000000000000..00c937350c1b
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk750/ddk750_2d.h
@@ -0,0 +1,480 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2007 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  2d.h --- SM750/SM718 DDK 
+*  This file contains the definitions for the 2D Engine interrupt.
+* 
+*******************************************************************/
+#ifndef _2D_H_
+#define _2D_H_
+
+//#include "csc.h"
+
+#define POKE_8(address, value)          pokeRegisterByte(address, value)
+#define POKE_16(address, value)         pokeRegisterWord(address, value)
+#define POKE_32(address, value)         pokeRegisterDWord(address, value)
+#define PEEK_8(address)                 peekRegisterByte(address)
+#define PEEK_16(address)                peekRegisterWord(address)
+#define PEEK_32(address)                peekRegisterDWord(address)
+
+/* Rotation Direction */
+typedef enum _rotate_dir_t
+{
+    ROTATE_NORMAL = 0,
+    ROTATE_90_DEGREE,
+    ROTATE_180_DEGREE,
+    ROTATE_270_DEGREE
+}
+rotate_dir_t;
+
+/*
+ * 2D Engine Initialization.
+ * This function must be called before other 2D functions.
+ * Assumption: A specific vidoe mode has been properly set up.
+ */
+void ddk750_deInit(void);
+
+/*
+ * Reset 2D engine by 
+ * 1) Aborting the current 2D operation.
+ * 2) Re-enable 2D engine to normal state.
+ */
+void deReset(void);
+ 
+/*
+ * Wait until 2D engine is not busy.
+ * All 2D operations are recommand to check 2D engine idle before start.
+ *
+ * Return: 0 = return because engine is idle and normal.
+ *        -1 = return because time out (2D engine may have problem).
+ */
+long deWaitForNotBusy(void);
+
+/* deWaitIdle() function.
+ *
+ * This function is same as deWaitForNotBusy(), except application can
+ * input the maximum number of times that this function will check 
+ * the idle register.
+ *
+ * Its usage is mainly for debugging purpose.
+ *
+ * Wait until 2D engine is not busy.
+ * All 2D operations are recommand to check 2D engine idle before start.
+ *
+ * Return: 0 = return because engine is idle and normal.
+ *        -1 = return because time out (2D engine may have problem).
+ */
+long deWaitIdle(unsigned long i);
+
+/*
+ * This function enable/disable clipping area for the 2d engine.
+ * Note that the clipping area is always rectangular.
+ * 
+ */
+long deSetClipping(
+unsigned long enable, /* 0 = disable clipping, 1 = enable clipping */
+unsigned long x1,     /* x1, y1 is the upper left corner of the clipping area */
+unsigned long y1,     /* Note that the region includes x1 and y1 */
+unsigned long x2,     /* x2, y2 is the lower right corner of the clippiing area */
+unsigned long y2);    /* Note that the region will not include x2 and y2 */
+
+/* 
+ * Function description:
+ * When transparency is enable, the blt engine compares each pixel value 
+ * (either source or destination) with DE_COLOR_COMPARE register.
+ * If match, the destination pixel will NOT be updated.
+ * If not match, the destination pixel will be updated.
+ */
+long deSetTransparency(
+unsigned long enable,     /* 0 = disable, 1 = enable transparency feature */
+unsigned long tSelect,    /* 0 = compare source, 1 = compare destination */
+unsigned long tMatch,     /* 0 = Opaque mode, 1 = transparent mode */
+unsigned long ulColor);   /* Color to compare. */
+
+/*
+ * This function uses 2D engine to fill a rectangular area with a specific color.
+ * The filled area includes the starting points.
+ */
+long deRectFill( /*resolution_t resolution, point_t p0, point_t p1, unsigned long color, unsigned long rop2)*/
+unsigned long dBase,  /* Base address of destination surface counted from beginning of video frame buffer */
+unsigned long dPitch, /* Pitch value of destination surface in BYTES */
+unsigned long bpp,    /* Color depth of destination surface: 8, 16 or 32 */
+unsigned long x,
+unsigned long y,      /* Upper left corner (X, Y) of rectangle in pixel value */
+unsigned long width, 
+unsigned long height, /* width and height of rectange in pixel value */
+unsigned long color,  /* Color to be filled */
+unsigned long rop2);  /* ROP value */
+
+/*
+ * Video Memory to Video Memory data transfer.
+ * Note: 
+ *        It works whether the Video Memroy is off-screeen or on-screen.
+ *        This function is a one to one transfer without stretching or 
+ *        mono expansion.
+ */
+long ddk750_deVideoMem2VideoMemBlt(
+unsigned long sBase,  /* Address of source: offset in frame buffer */
+unsigned long sPitch, /* Pitch value of source surface in BYTE */
+unsigned long sx,
+unsigned long sy,     /* Starting coordinate of source surface */
+unsigned long dBase,  /* Address of destination: offset in frame buffer */
+unsigned long dPitch, /* Pitch value of destination surface in BYTE */
+unsigned long bpp,    /* Color depth of destination surface */
+unsigned long dx,
+unsigned long dy,     /* Starting coordinate of destination surface */
+unsigned long width, 
+unsigned long height, /* width and height of rectange in pixel value */
+unsigned long rop2);  /* ROP value */
+
+/*
+ * System Memory to Video Memory data transfer.
+ * Note: 
+ *        It works whether the Video Memroy is off-screeen or on-screen.
+ *        This function is a one to one transfer without stretching or 
+ *        mono expansion.
+ */
+long deSystemMem2VideoMemBusMasterBlt(
+    unsigned char *pSBase,  /* Address of source: offset in frame buffer */
+    unsigned long sPitch,   /* Pitch value of source surface in BYTE */
+    unsigned long sx,
+    unsigned long sy,       /* Starting coordinate of source surface */
+    unsigned long dBase,    /* Address of destination: offset in frame buffer */
+    unsigned long dPitch,   /* Pitch value of destination surface in BYTE */
+    unsigned long bpp,      /* Color depth of destination surface */
+    unsigned long dx,
+    unsigned long dy,       /* Starting coordinate of destination surface */
+    unsigned long width, 
+    unsigned long height,   /* width and height of rectangle in pixel value */
+    unsigned long rop2      /* ROP value */
+);
+
+/* 
+ * System memory to Video memory data transfer
+ * Note: 
+ *         We also call it HOST Blt.
+ *        This function is a one to one transfer without stretching or 
+ *        mono expansion.
+ */
+long deSystemMem2VideoMemBlt(
+unsigned char *pSrcbuf, /* pointer to source data in system memory */
+long srcDelta,          /* width (in Bytes) of the source data, +ive means top down and -ive mean button up */
+unsigned long dBase,    /* Address of destination: offset in frame buffer */
+unsigned long dPitch,   /* Pitch value of destination surface in BYTE */
+unsigned long bpp,      /* Color depth of destination surface */
+unsigned long dx,
+unsigned long dy,       /* Starting coordinate of destination surface */
+unsigned long width, 
+unsigned long height,   /* width and height of rectange in pixel value */
+unsigned long rop2);    /* ROP value */
+
+/*
+ * System memory to Video memory monochrome expansion.
+ * Source is monochrome image in system memory.
+ * This function expands the monochrome data to color image in video memory.
+ */
+long deSystemMem2VideoMemMonoBlt(
+unsigned char *pSrcbuf, /* pointer to start of source buffer in system memory */
+long srcDelta,          /* Pitch value (in bytes) of the source buffer, +ive means top down and -ive mean button up */
+unsigned long startBit, /* Mono data can start at any bit in a byte, this value should be 0 to 7 */
+unsigned long dBase,    /* Address of destination: offset in frame buffer */
+unsigned long dPitch,   /* Pitch value of destination surface in BYTE */
+unsigned long bpp,      /* Color depth of destination surface */
+unsigned long dx,
+unsigned long dy,       /* Starting coordinate of destination surface */
+unsigned long width, 
+unsigned long height,   /* width and height of rectange in pixel value */
+unsigned long fColor,   /* Foreground color (corresponding to a 1 in the monochrome data */
+unsigned long bColor,   /* Background color (corresponding to a 0 in the monochrome data */
+unsigned long rop2);    /* ROP value */
+
+#if 0
+/*
+ * System memory to Video memory monochrome expansion.
+ * Source is the starting location of monochrome image in System memory.
+ * This function expands the monochrome data to color image.
+ *
+ * Note:
+ * This fnnction can be used to diaplay a mono-font charater to the screen.
+ * Input source points to the starting location of the font character.
+ */
+long deSystemMem2VideoMemMonoBusMasterBlt(
+    unsigned char *pSBase,  /* Address of mono-chrome source data in frame buffer */
+    unsigned long sPitch,   /* Pitch value (in bytes) of the source buffer. */
+    unsigned long startBit, /* Mono data can start at any bit in a byte, this value should be 0 to 7 */
+    unsigned long dBase,    /* Base address of destination in frame buffer */
+    unsigned long dPitch,   /* Pitch value of destination surface in BYTE */
+    unsigned long bpp,      /* Color depth of destination surface */
+    unsigned long dx,
+    unsigned long dy,       /* Starting coordinate of destination surface */
+    unsigned long width,    /* width of mono-chrome picture in pixel value */
+    unsigned long height,   /* height of mono-chrome picture in pixel value */
+    unsigned long fColor,   /* Foreground color (corresponding to a 1 in the monochrome data */
+    unsigned long bColor,   /* Background color (corresponding to a 0 in the monochrome data */
+    unsigned long rop2      /* ROP value */
+);
+#endif
+
+/*
+ * This function cache font table into frame buffer.
+ *
+ * Inputs:
+ *      Pointer to font table in system memory.
+ *      Charcter size in byte: How many bytes are used to store the font for one characer.
+ *      As an example: For 8x8 mono font, the size is 8 bytes; 
+ *                     For 8x16 mono font, the size is 16 bytes.
+ *                     For 16x32 mono font, the size is 64 bytes.
+ *      Number of characters in the font table.
+ *      Pointer to location of frame buffer to store the font: This is an offset from the beginning of frame buffer.
+ *  
+ * Rules for storing fonts in off-screen.
+ *     1) Base address of font table must be 16 byte (or 128 bit) aligned.
+ *     2) Each font character must be stored in a 16 byte (128 bit) aligned
+ *        location.
+ *
+ */
+long deCacheFontToFrameBuffer(
+unsigned char *fontTable,   /* Pointer to font table in system memory */
+unsigned long sizeOfChar,   /* How many bytes for one monochrome character */
+unsigned long numberOfChar, /* Number of characters in the font table */
+unsigned long fbAddr);      /* Destination in Video memory to store the font */
+
+/*
+ * Video memory to Video memory monochrome expansion.
+ * Source is the starting location of monochrome image in Video memory.
+ * This function expands the monochrome data to color image.
+ *
+ * Note:
+ * This fnnction can be used to diaplay a mono-font charater to the screen.
+ * Input source points to the starting location of the font character.
+ */
+long deVideoMem2VideoMemMonoBlt(
+unsigned long sBase,  /* Address of mono-chrome source data in frame buffer */
+unsigned long dBase,  /* Base address of destination in frame buffer */
+unsigned long dPitch, /* Pitch value of destination surface in BYTE */
+unsigned long bpp,    /* Color depth of destination surface */
+unsigned long dx,
+unsigned long dy,     /* Starting coordinate of destination surface */
+unsigned long width,  /* width of mono-chrome picture in pixel value */
+unsigned long height, /* height of mono-chrome picture in pixel value */
+unsigned long fColor, /* Foreground color (corresponding to a 1 in the monochrome data */
+unsigned long bColor, /* Background color (corresponding to a 0 in the monochrome data */
+unsigned long rop2);  /* ROP value */
+
+/*
+ * Video memory to Video memory monochrome expansion.
+ * 
+ * Difference between this function and deVideoMem2VideoMemMonoBlt():
+ * 1) Input is base address of the whole font table.
+ * 2) An extra input about which character in the font table to display.
+ * 3) This function demos how to use registers DE_SOURCE and
+ *    DE_WINDOW_WIDTH, where they are set to 0 in deVideoMem2VideoMemMonoBlt().
+ */
+long deFontCacheTblMonoBlt(
+unsigned long fontTblBase,/* Base address of monochrome font table in frame buffer */
+unsigned long fontNumber, /* Which character in the font table, starting from 0 */
+unsigned long dBase,      /* Base address of destination in frame buffer */
+unsigned long dPitch,     /* Pitch value of destination surface in BYTE */
+unsigned long bpp,        /* Color depth of destination surface */
+unsigned long dx,
+unsigned long dy,         /* Starting coordinate of destination surface */
+unsigned long width,      /* width of each monochrome font in pixel value */
+unsigned long height,     /* height of each monochrome font in pixel value */
+unsigned long fColor,     /* Foreground color (corresponding to a 1 in the monochrome data */
+unsigned long bColor,     /* Background color (corresponding to a 0 in the monochrome data */
+unsigned long rop2);      /* ROP value */
+
+/*
+ * Stretch Blt.
+ * 
+ * The stretch blt is done by using the CSC engine.
+ */
+long deStretchBlt(
+    unsigned long sBase,    /* Source Base address */
+    unsigned long sPitch,   /* Source pitch value in bytes */
+    unsigned long sbpp,     /* Source bits per pixel */
+    unsigned long sx,       /* Source x coordinate */            
+    unsigned long sy,       /* Source y coordinate */
+    unsigned long sWidth,   /* Width of source in pixel */
+    unsigned long sHeight,  /* Height of source in lines */
+    unsigned long dBase,    /* Destination base address */
+    unsigned long dPitch,   /* Destination pitch value in bytes */
+    unsigned long dbpp,     /* Destination bits per pixel */
+    unsigned long dx,       /* Destination x coordinate */
+    unsigned long dy,       /* Destination y coordinate */
+    unsigned long dWidth,   /* Width of the destination display */
+    unsigned long dHeight   /* Height of the destination display */
+);
+
+/*
+ * Rotation Blt.
+ * 
+ * This function rotates an image to the screen based on the given rotation direction
+ * (0, 90, 180, or 270 degree).
+ * 
+ */
+long deVideoMem2VideoMemRotateBlt(
+    unsigned long sBase,            /* Source Base Address */
+    unsigned long sPitch,           /* Source pitch */
+    unsigned long sx,               /* X Coordinate of the source */
+    unsigned long sy,               /* Y Coordinate of the source */
+    unsigned long dBase,            /* Destination Base Address */
+    unsigned long dPitch,           /* Destination pitch */
+    unsigned long bpp,              /* Color depth of destination surface */
+    unsigned long dx,               /* X Coordinate of the destination */ 
+    unsigned long dy,               /* Y Coordinate of the destination */
+    unsigned long width,            /* Width  of un-rotated image in pixel value */
+    unsigned long height,           /* Height of un-rotated image in pixel value */
+    rotate_dir_t rotateDirection,   /* Direction of the rotation */
+    unsigned long repeatEnable,     /* Enable repeat rotation control where the
+                                       drawing engine is started again every vsync */
+    unsigned long rop2              /* ROP control */
+);
+
+/* 
+ * Function to draw a vertical line.
+ *
+ * Note:
+ *      This function is using Short Stroke line
+ */
+long deVerticalLine(
+    unsigned long dBase,    /* Base address of destination surface counted from beginning of video frame buffer */
+    unsigned long dPitch,   /* Pitch value of destination surface in BYTES */
+    unsigned long bpp,      /* Color depth of destination surface: 8, 16 or 32 */
+    unsigned long x,        /* Starting X Coordinate */
+    unsigned long y,        /* Starting Y Coordinate */
+    unsigned long length,   /* Length of the line */
+    unsigned long color,    /* Color of the line */
+    unsigned long rop2      /* ROP value */
+);
+
+/* 
+ * Function to draw a horizontal line.
+ *
+ * Note:
+ *      This function is using Short Stroke line
+ */
+long deHorizontalLine(
+    unsigned long dBase,    /* Base address of destination surface counted from beginning of video frame buffer */
+    unsigned long dPitch,   /* Pitch value of destination surface in BYTES */
+    unsigned long bpp,      /* Color depth of destination surface: 8, 16 or 32 */
+    unsigned long x,        /* Starting X Coordinate */
+    unsigned long y,        /* Starting Y Coordinate */
+    unsigned long length,   /* Length of the line */
+    unsigned long color,    /* Color of the line */
+    unsigned long rop2      /* ROP value */
+);
+
+/* 
+ * Function to draw a line.
+ *
+ * Note:
+ *      This function is using Short Stroke Command for Vertical, Horizontal, and 
+ *      Diagonal line. Other line are drawn using the Line Draw Command.
+ */
+long deLine(
+    unsigned long dBase,    /* Base address of destination surface counted from beginning of video frame buffer */
+    unsigned long dPitch,   /* Pitch value of destination surface in BYTES */
+    unsigned long bpp,      /* Color depth of destination surface: 8, 16 or 32 */
+    long x0,                /* Starting X Coordinate */
+    long y0,                /* Starting Y Coordinate */
+    long x1,                /* Ending X Coordinate */
+    long y1,                /* Ending Y Coordinate */
+    unsigned long color,    /* Color of the line */
+    unsigned long rop2      /* ROP value */
+);
+
+/*
+ * Alpha Blend Blt.
+ * 
+ * This function blends the source with the destination image.
+ */
+long deVideoMem2VideoMemAlphaBlendBlt(
+    unsigned long sBase,            /* Source Base Address */
+    unsigned long sPitch,           /* Source pitch */
+    unsigned long sx,               /* X Coordinate of the source */
+    unsigned long sy,               /* Y Coordinate of the source */
+    unsigned long sWidth,           /* Source Width */
+    unsigned long sHeight,          /* Source Height */
+    unsigned long dBase,            /* Destination Base Address */
+    unsigned long dPitch,           /* Destination pitch */
+    unsigned long bpp,              /* Color depth of destination surface */
+    unsigned long dx,               /* X Coordinate of the destination */ 
+    unsigned long dy,               /* Y Coordinate of the destination */
+    unsigned long dHeight,          /* Destination Height (only height stretch is supported) */
+    unsigned long alphaValue,       /* Alpha value for Alpha Blend*/
+    unsigned long rop2              /* ROP control */
+);
+
+#if 0   /* These RLE functions are not working. */
+/* 
+ * Function to draw a line using RLE line strip method.
+ */
+long deStartLineStrip(
+    unsigned long dBase,        /* Base address of destination surface counted from beginning of video frame buffer */
+    unsigned long dPitch,       /* Pitch value of destination surface in BYTES */
+    unsigned long bpp,          /* Color depth of destination surface: 8, 16 or 32 */
+    unsigned long x,            /* X Coordinate */
+    unsigned long y,            /* Y Coordinate */
+    unsigned long length,       /* Length of the line */
+    unsigned long lineCounter,  /* Line Counter */
+    unsigned long direction,    /* Direction:   0 - Left to Right
+                                                1 - Right to Left
+                                                2 - Top to Bottom
+                                                3 - Bottom to Top
+                                */
+    unsigned long color,        /* Color of the line */
+    unsigned long rop2          /* ROP value */
+);
+
+/* 
+ * Function to continue drawing a line using RLE line strip method.
+ */
+long deNextLineStrip(
+    unsigned long length,       /* Line strip length */
+    unsigned long lineCounter   /* Line Counter */
+);
+
+/* 
+ * Function to stop the RLE line strip drawing.
+ * This function has to be called to end the Line Strip drawing.
+ * Otherwise, the next 2D function might still use this function.
+ */
+long deStopLineStrip();
+#endif
+
+
+/*
+ * This function uses 2D engine to draw a trapezoid with a specific color.
+ * The filled area includes the starting points.
+ */
+long deStartTrapezoidFill(
+    unsigned long dBase,  /* Base address of destination surface counted from beginning of video frame buffer */
+    unsigned long dPitch, /* Pitch value of destination surface in BYTES */
+    unsigned long bpp,    /* Color depth of destination surface: 8, 16 or 32 */
+    unsigned long x,
+    unsigned long y,      /* Starting (X, Y) coordinate inside the polygon to be filled */
+    unsigned long length, /* Length of the line */
+    unsigned long color,  /* Color to be filled */
+    unsigned long rop2);
+
+/* 
+ * Function to continue drawing a line using Trapezoid Fill method.
+ */
+long deNextTrapezoidFill(
+    unsigned long x,            /* Starting X location. */
+    unsigned long length        /* Line length */
+);
+
+/* 
+ * Function to stop the Trapezoid Fill drawing.
+ * This function has to be called to end the Trapezoid Fill drawing.
+ * Otherwise, the next 2D function might still use this function.
+ */
+long deStopTrapezoidFill(void);
+
+#endif /* _2D_H_ */
diff --git a/drivers/gpu/drm/smi/ddk750/ddk750_chip.c b/drivers/gpu/drm/smi/ddk750/ddk750_chip.c
new file mode 100644
index 000000000000..0d5ddf1b81ce
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk750/ddk750_chip.c
@@ -0,0 +1,234 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2007 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  CHIP.C --- SMI DDK 
+*  This file contains the source code for the mode table.
+* 
+*******************************************************************/
+#include "ddk750_defs.h"
+#include "ddk750_regdc.h"
+#include "ddk750_helper.h"
+#include "ddk750_power.h"
+#include "ddk750_clock.h"
+#include "ddk750_chip.h"
+#include "ddk750_help.h"
+
+/*
+ *  Get the default memory clock value used by this DDK
+ */
+unsigned long ddk750_getDefaultMemoryClock(void)
+{
+    switch(ddk750_getChipType())
+    {
+        case SM718:
+            return DEFAULT_SM718_MEMORY_CLK;
+            break;
+        case SM750:
+        	return DEFAULT_SM750_MEMORY_CLK;
+            break;
+		case SM750LE:
+        	return SM750LE_MEMORY_CLK;
+			break;
+		case SM750HS_F:
+			return SM750HS_F_MEMORY_CLK;
+			break;
+		case SM750HS_A:
+			return SM750HS_A_MEMORY_CLK;
+			break;
+		case SM750HS:
+        default:
+			return SM750HS_MEMORY_CLK;
+			break;
+    }
+}
+
+/*
+ * This function returns frame buffer memory size in Byte units.
+ */
+unsigned long ddk750_getFrameBufSize(void)
+{
+    unsigned long sizeSymbol, memSize;
+
+	sizeSymbol = FIELD_GET(peekRegisterDWord(MISC_CTRL), MISC_CTRL, LOCALMEM_SIZE);
+	switch(sizeSymbol)
+	{
+    	case MISC_CTRL_LOCALMEM_SIZE_8M:  memSize = MB(8);  break; /* 8  Mega byte */
+    	case MISC_CTRL_LOCALMEM_SIZE_16M: memSize = MB(16); break; /* 16 Mega byte */
+    	case MISC_CTRL_LOCALMEM_SIZE_32M: memSize = MB(32); break; /* 32 Mega byte */
+    	case MISC_CTRL_LOCALMEM_SIZE_64M: memSize = MB(64); break; /* 64 Mega byte */
+    	default:                          memSize = MB(0);  break; /* 0  Mege byte */
+	}
+
+    return memSize;
+}
+
+
+/*
+ * This function returns the logical chip type defined in chip.h
+ * It is one of the following: SM501, SM502, SM107, SM718, SM 750 or
+ * SM_UNKNOWN.
+ */
+logical_chip_type_t ddk750_getChipType()
+{
+    return SM750;
+}
+
+/*
+ *  ddk750_resetFrameBufferMemory
+ *      This function resets the Frame Buffer Memory
+ */
+void ddk750_resetFrameBufferMemory()
+{
+    unsigned long ulReg;
+	logical_chip_type_t chipType = ddk750_getChipType();
+    
+	/* Only SM718 and SM750 has register to reset video memory */
+	if (chipType == SM718 || chipType == SM750)
+	{        
+    	ulReg = peekRegisterDWord(MISC_CTRL);
+    	ulReg = FIELD_SET(ulReg, MISC_CTRL, LOCALMEM_RESET, RESET);
+    	pokeRegisterDWord(MISC_CTRL, ulReg);
+
+    	ulReg = FIELD_SET(ulReg, MISC_CTRL, LOCALMEM_RESET, NORMAL);
+    	pokeRegisterDWord(MISC_CTRL, ulReg);
+	}
+}
+
+/*
+ * Initialize a single chip and environment according to input parameters.
+ *
+ * Input: initchip_param_t structure.
+ *
+ * Return: 0 (or NO_ERROR) if successful.
+ *        -1 if fail.
+ *
+ * Note:
+ *      Caller needs to call the detectDevice and setCurrentDevice
+ *      to set the device before calling this initChipParamEx.
+ */
+long ddk750_initChipParamEx(initchip_param_t * pInitParam)
+{
+    unsigned long ulReg;
+
+
+    /* Set power mode.
+       Check parameter validity first.
+       If calling function didn't set it up properly or set to some
+       weird value, always default it to 0.
+     */
+    if (pInitParam->powerMode > 1) 
+        pInitParam->powerMode = 0;
+    setPowerMode(pInitParam->powerMode);
+    
+    /* Set the Main Chip Clock */
+    setChipClock(MHz(pInitParam->chipClock));
+
+    /* Set up memory clock. */
+    setMemoryClock(MHz(pInitParam->memClock));
+
+    /* Set up master clock */
+    setMasterClock(MHz(pInitParam->masterClock));    
+    
+    /* Reset the memory controller. If the memory controller is not reset in SM750, 
+       the system might hang when sw accesses the memory. 
+       The memory should be resetted after changing the MXCLK.
+     */
+    if (pInitParam->resetMemory == 1)
+        ddk750_resetFrameBufferMemory();    
+    
+    if (pInitParam->setAllEngOff == 1)
+    {
+        enable2DEngine(0);
+
+        /* Disable Overlay, if a former application left it on */
+        ulReg = peekRegisterDWord(VIDEO_DISPLAY_CTRL);
+        ulReg = FIELD_SET(ulReg, VIDEO_DISPLAY_CTRL, PLANE, DISABLE); 
+        pokeRegisterDWord(VIDEO_DISPLAY_CTRL, ulReg);
+
+        /* Disable video alpha, if a former application left it on */
+        ulReg = peekRegisterDWord(VIDEO_ALPHA_DISPLAY_CTRL);
+        ulReg = FIELD_SET(ulReg, VIDEO_ALPHA_DISPLAY_CTRL, PLANE, DISABLE); 
+        pokeRegisterDWord(VIDEO_ALPHA_DISPLAY_CTRL, ulReg);
+
+        /* Disable alpha plane, if a former application left it on */
+        ulReg = peekRegisterDWord(ALPHA_DISPLAY_CTRL);
+        ulReg = FIELD_SET(ulReg, ALPHA_DISPLAY_CTRL, PLANE, DISABLE); 
+        pokeRegisterDWord(ALPHA_DISPLAY_CTRL, ulReg);
+
+        /* Disable Primary hardware cursor, if a former application left it on */
+        ulReg = peekRegisterDWord(PRIMARY_HWC_ADDRESS);
+        ulReg = FIELD_SET(ulReg, PRIMARY_HWC_ADDRESS, ENABLE, DISABLE); 
+        pokeRegisterDWord(PRIMARY_HWC_ADDRESS, ulReg);
+
+        /* Disable Secondary hardware cursor, if a former application left it on */
+        ulReg = peekRegisterDWord(SECONDARY_HWC_ADDRESS);
+        ulReg = FIELD_SET(ulReg, SECONDARY_HWC_ADDRESS, ENABLE, DISABLE); 
+        pokeRegisterDWord(SECONDARY_HWC_ADDRESS, ulReg);
+#if 0
+        /* Disable ZV Port 0, if a former application left it on */
+        ulReg = peekRegisterDWord(ZV0_CAPTURE_CTRL);
+        ulReg = FIELD_SET(ulReg, ZV0_CAPTURE_CTRL, CAP, DISABLE); 
+        pokeRegisterDWord(ZV0_CAPTURE_CTRL, ulReg);
+
+        /* Disable ZV Port 1, if a former application left it on */
+        ulReg = peekRegisterDWord(ZV1_CAPTURE_CTRL);
+        ulReg = FIELD_SET(ulReg, ZV1_CAPTURE_CTRL, CAP, DISABLE); 
+        pokeRegisterDWord(ZV1_CAPTURE_CTRL, ulReg);
+       
+        /* Disable ZV Port Power, if a former application left it on */
+        enableZVPort(0);
+        
+        /* Disable i2c */
+        enableI2C(0);
+        
+        /* Disable DMA Channel, if a former application left it on */
+        ulReg = peekRegisterDWord(DMA_ABORT_INTERRUPT);
+        ulReg = FIELD_SET(ulReg, DMA_ABORT_INTERRUPT, ABORT_1, ABORT);
+        pokeRegisterDWord(DMA_ABORT_INTERRUPT, ulReg);
+        
+        /* Disable DMA Power, if a former application left it on */
+        enableDMA(0);
+#endif 		
+    }
+
+    /* We can add more initialization as needed. */
+        
+    return 0;
+}
+
+/*
+ * Initialize chip with default parameters.
+ *
+ * Input: none.
+ *
+ * Return: 0 (or NO_ERROR) if successful.
+ *        -1 if fail.
+ *
+ * Note:
+ *      This function initialize with a default set of parameters.
+ *      Use initChipParam() if you don't want default parameters.
+ */
+long ddk750_initChip()
+{
+    initchip_param_t initParam;
+    
+    /* Check if any SMI VGX family chip exist and alive */
+//	if (detectDevices() == 0)
+//        return (-1);
+
+    /* Initialize the chip with some default parameters */
+    initParam.powerMode = 0;
+    initParam.memClock = ddk750_getDefaultMemoryClock();
+    initParam.chipClock = initParam.memClock;
+    initParam.masterClock = initParam.chipClock/3;
+
+    initParam.setAllEngOff = 1;
+    initParam.resetMemory = 1;
+    
+    return(ddk750_initChipParamEx(&initParam));
+}
+
diff --git a/drivers/gpu/drm/smi/ddk750/ddk750_chip.h b/drivers/gpu/drm/smi/ddk750/ddk750_chip.h
new file mode 100644
index 000000000000..94e54d75894c
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk750/ddk750_chip.h
@@ -0,0 +1,194 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2008 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  CHIP.H --- SMI DDK 
+*  This file contains the source code for the SM750/SM718 chip.
+* 
+*******************************************************************/
+#ifndef _CHIP_H_
+#define _CHIP_H_
+
+/* This is all the chips recognized by this library */
+typedef enum _logical_chip_type_t
+{
+    SM_UNKNOWN = 0,
+    SM718 = 1,
+    SM750 = 2,
+    SM750LE = 3,
+	/* There will 3 versions of SM750HS because of different interfaces connected to the Graphic IP.
+	   The major difference between them are the methods to set up the PLL for pixel clock. */
+	SM750HS = 4,	/* SMI FPGA verification version */
+	SM750HS_F = 5,  /* HiS FPGA verification version */
+	SM750HS_A = 6	/* HiS ASIC version */
+}
+logical_chip_type_t;
+
+/* input struct to initChipParam() function */
+typedef struct _initchip_param_t
+{
+    unsigned short powerMode;    /* Use power mode 0 or 1 */
+    unsigned short chipClock;    /* Speed of main chip clock in MHz unit
+                                    0 = keep the current clock setting
+                                    Others = the new main chip clock
+                                  */
+    unsigned short memClock;     /* Speed of memory clock in MHz unit
+                                    0 = keep the current clock setting
+                                    Others = the new memory clock
+                                  */
+    unsigned short masterClock;  /* Speed of master clock in MHz unit 
+                                    0 = keep the current clock setting
+                                    Others = the new master clock
+                                  */
+    unsigned short setAllEngOff; /* 0 = leave all engine state untouched.
+                                    1 = make sure they are off: 2D, Overlay,
+                                    video alpha, alpha, hardware cursors
+                                 */
+    unsigned char resetMemory;   /* 0 = Do not reset the memory controller
+                                    1 = Reset the memory controller
+                                  */
+
+    /* More initialization parameter can be added if needed */
+}
+initchip_param_t;
+
+/*
+ *  Get the default memory clock value used by this DDK
+ */
+unsigned long ddk750_getDefaultMemoryClock(void);
+
+/*
+ * This function returns frame buffer memory size in Byte units.
+ */
+unsigned long ddk750_getFrameBufSize(void);
+
+/*
+ * This function gets the Frame buffer location.
+ */
+unsigned char ddk750_getFrameBufLocation(void);
+
+/*
+ * This function returns the logical chip type defined in chip.h
+ * It is one of the following: SM501, SM502, SM107, SM718, SM 750 or
+ * SM_UNKNOWN.
+ */
+logical_chip_type_t ddk750_getChipType(void);
+
+/*
+ * Return a char string name of the current chip.
+ * It's convenient for application need to display the chip name.
+ */
+char * ddk750_getChipTypeString(void);
+
+/*
+ *  resetFrameBufferMemory
+ *      This function resets the Frame Buffer Memory
+ */
+void ddk750_resetFrameBufferMemory(void);
+
+/*
+ * Initialize a single chip and environment according to input parameters.
+ *
+ * Input: initchip_param_t structure.
+ *
+ * Return: 0 (or NO_ERROR) if successful.
+ *        -1 if fail.
+ *
+ * Note:
+ *      Caller needs to call the detectDevice and setCurrentDevice
+ *      to set the device before calling this initChipParamEx.
+ */
+long ddk750_initChipParamEx(initchip_param_t * pInitParam);
+
+/*
+ * Initialize every chip and environment according to input parameters. 
+ * (Obsolete)
+ *
+ * Input: initchip_param_t structure.
+ *
+ * Return: 0 (or NO_ERROR) if successful.
+ *        -1 if fail.
+ */
+long ddk750_initChipParam(initchip_param_t * pInitParam);
+
+/*
+ * Initialize a single chip with default parameters.
+ *
+ * Input: none.
+ *
+ * Return: 0 (or NO_ERROR) if successful.
+ *        -1 if fail.
+ *
+ * Note:
+ *      Caller needs to call the detectDevice and setCurrentDevice
+ *      to set the device before calling this initChipEx.
+ */
+long ddk750_initChipEx(void);
+
+/*
+ * Initialize the chip with default parameters.
+ *
+ * Input: none.
+ *
+ * Return: 0 (or NO_ERROR) if successful.
+ *        -1 if fail.
+ */
+long ddk750_initChip(void);
+
+/*******************************************************************
+ * Scratch Data implementation (To be used by DDK library only)
+ *******************************************************************/
+ 
+/*
+ * Set Scratch Data
+ */
+void setScratchData(
+    unsigned long dataFlag,
+    unsigned long data
+);
+
+/*
+ * Get Scratch Data
+ */
+unsigned long getScratchData(
+    unsigned long dataFlag
+);
+
+
+#define MB(x) (x*0x100000) /* Don't use this macro if x is fraction number */
+
+/* Memory Clock Default Values */
+#define DEFAULT_SM750_MEMORY_CLK        290
+#define DEFAULT_SM718_MEMORY_CLK        290
+
+/* Cheok_0509: Define some fixed values for SM750LE */
+#define SM750LE_REVISION_ID 0XFE
+#define SM750LE_MEMORY_CLK  333    /* In MHz */
+#define SM750LE_MASTER_CLK  130    /* in MHz */
+#define SM750LE_MEM_SIZE    MB(16) /* SP605 has 64M, but Huawei's actual system has only 16M */
+#define SM750LE_I2C_SCL     0      /* GPIO 0 is used as I2C clk */
+#define SM750LE_I2C_SDA     1      /* GPIO 1 is used as I2C data */
+#define CH7301_I2C_ADDRESS  0xEC /* I2C address of CH7301 in Xilinx SP605 */
+
+/* Cheok_2012_1211: Define some fixed values for SM750HS */
+/* The following values are fixed in FPGA and cannot be adjusted */
+#define SM750HS_REVISION_ID 0XE0
+#define SM750HS_MEMORY_CLK  333    /* In MHz */
+#define SM750HS_MASTER_CLK  100    /* in MHz */
+#define SM750HS_MEM_SIZE    MB(16) /* Actual size unknown at the moment */
+
+#define SM750HS_F_REVISION_ID 0X00
+#define SM750HS_F_MEMORY_CLK  333    /* In MHz */
+#define SM750HS_F_MASTER_CLK  100    /* in MHz */
+#define SM750HS_F_MEM_SIZE    MB(16) /* Actual size unknown at the moment */
+
+#define SM750HS_A_REVISION_ID 0X10
+#define SM750HS_A_MEMORY_CLK  333    /* In MHz */
+#define SM750HS_A_MASTER_CLK  100    /* in MHz */
+#define SM750HS_A_MEM_SIZE    MB(16) /* Actual size unknown at the moment */
+
+#endif /* _CHIP_H_ */
+
diff --git a/drivers/gpu/drm/smi/ddk750/ddk750_clock.c b/drivers/gpu/drm/smi/ddk750/ddk750_clock.c
new file mode 100644
index 000000000000..565af8b37063
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk750/ddk750_clock.c
@@ -0,0 +1,564 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2007 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  CLOCK.C --- Voyager GX DDK 
+*  This file contains source code for the Voyager Family PLL's
+* 
+*******************************************************************/
+#include "ddk750_defs.h"
+//#include "ddk750_hardware.h"
+#include "ddk750_helper.h"
+#include "ddk750_power.h"
+#include "ddk750_clock.h"
+#include "ddk750_chip.h"
+#include "ddk750_helper.h"
+#include "ddk750_help.h"
+
+//#include "ddkdebug.h"
+
+static unsigned char g_ucMemoryClockDivider[] = { 1, 2, 3, 4 };
+static unsigned char g_ucMasterClockDivider[] = { 3, 4, 6, 8 };
+
+/*
+ * A local function to calculate the clock value of the given PLL.
+ *
+ * Input:
+ *      Pointer to a PLL structure to be calculated based on the
+ *      following formula:
+ *      inputFreq * M / N / (2 to the power of OD) / (2 to the power of POD)
+ */
+unsigned long calcPLL(pll_value_t *pPLL)
+{
+    return (pPLL->inputFreq * pPLL->M / pPLL->N / twoToPowerOfx(pPLL->OD) / twoToPowerOfx(pPLL->POD));
+}
+
+/*
+ * Given a requested clock frequency, this function calculates the 
+ * best M, N & OD values for the PLL.
+ * 
+ * Input: Requested pixel clock in Hz unit.
+ *        The followiing fields of PLL has to be set up properly:
+ *        pPLL->clockType, pPLL->inputFreq.
+ *
+ * Output: Update the PLL structure with the proper M, N and OD values
+ * Return: The actual clock in Hz that the PLL is able to set up.
+ *
+ * The PLL uses this formula to operate: 
+ * requestClk = inputFreq * M / N / (2 to the power of OD) / (2 to the power of POD)
+ *
+ * The PLL specification mention the following restrictions:
+ *      1 MHz <= inputFrequency / N <= 25 MHz
+ *      200 MHz <= outputFrequency <= 1000 MHz --> However, it seems that it can 
+ *                                                 be set to lower than 200 MHz.
+ */
+unsigned long calcPllValue(
+unsigned long ulRequestClk, /* Required pixel clock in Hz unit */
+pll_value_t *pPLL           /* Structure to hold the value to be set in PLL */
+)
+{
+    unsigned long M, N, OD, POD = 0, diff, pllClk, odPower, podPower, tempRequestClk;
+    unsigned long bestDiff = 0xffffffff; /* biggest 32 bit unsigned number */
+
+    /* Init PLL structure to know states */
+    pPLL->M = 0;
+    pPLL->N = 0;
+    pPLL->OD = 0;
+    pPLL->POD = 0;
+
+	//if (getChipType() == SM750LE)
+	if (ddk750_getChipType() >= SM750LE)
+    {
+        /* SM750LE don't have prgrammable PLL and M/N values to work on.
+           Just return the requested clock. */
+        return ulRequestClk;
+    }
+
+    /* Convert everything in Khz range in order to avoid calculation overflow */
+    pPLL->inputFreq /= 1000;
+    tempRequestClk = ulRequestClk / 1000;
+
+    /* If the requested clock is higher than 1 GHz, then set it to the maximum, which is
+       1 GHz. */
+    if (tempRequestClk > MHz(1))
+        tempRequestClk = MHz(1);
+
+    /* The maximum of post divider is 8. */
+    for (POD=0; POD<=3; POD++)
+    {
+        /* MXCLK_PLL does not have post divider. */
+        if ((POD > 0) && (pPLL->clockType == MXCLK_PLL))
+            break;
+    
+        /* Work out 2 to the power of POD */
+        podPower = twoToPowerOfx(POD);
+        
+        /* OD has only 2 bits [15:14] and its value must between 0 to 3 */
+        for (OD=0; OD<=3; OD++)
+        {
+            /* Work out 2 to the power of OD */
+            odPower = twoToPowerOfx(OD);            
+
+            /* N has 4 bits [11:8] and its value must between 2 and 15. 
+               The N == 1 will behave differently --> Result is not correct. */
+            for (N=2; N<=15; N++)
+            {
+                /* The formula for PLL is ulRequestClk = inputFreq * M / N / (2^OD)
+                   In the following steps, we try to work out a best M value given the others are known.
+                   To avoid decimal calculation, we use 1000 as multiplier for up to 3 decimal places of accuracy.
+                */
+                M = tempRequestClk * N * odPower * podPower / pPLL->inputFreq;
+
+                /* M field has only 8 bits, reject value bigger than 8 bits */
+                if (M < 256)
+                {
+                    /* Calculate the actual clock for a given M & N */        
+                    pllClk = pPLL->inputFreq * M / N / odPower / podPower;
+
+                    /* How much are we different from the requirement */
+                    diff = absDiff(pllClk, tempRequestClk);
+        
+                    if (diff < bestDiff)
+                    {
+                        bestDiff = diff;
+
+                        /* Store M and N values */
+                        pPLL->M  = M;
+                        pPLL->N  = N;
+                        pPLL->OD = OD;
+                        pPLL->POD = POD;
+                    }
+                }
+            }
+        }
+    }
+    
+    /* Restore input frequency from Khz to hz unit */
+    pPLL->inputFreq *= 1000;
+
+    /* Output debug information */
+//    DDKDEBUGPRINT((DISPLAY_LEVEL, "calcPllValue: Requested Frequency = %d\n", ulRequestClk));
+//    DDKDEBUGPRINT((DISPLAY_LEVEL, "calcPllValue: Input CLK = %dHz, M=%d, N=%d, OD=%d, POD=%d\n", pPLL->inputFreq, pPLL->M, pPLL->N, pPLL->OD, pPLL->POD));
+
+    /* Return actual frequency that the PLL can set */
+    return calcPLL(pPLL);
+}
+
+/*
+ * Set up the corresponding bit field of the programmable PLL register.
+ *
+ * Input: Pointer to PLL structure with type and values set up properly.
+ *        Usually, calcPllValue() function will be called before this to calculate the values first.
+ *
+ */
+unsigned long formatPllReg(pll_value_t *pPLL)
+{
+    unsigned long ulPllReg = 0;
+
+    /* Note that all PLL's have the same format. Here, we just use Panel PLL parameter
+       to work out the bit fields in the register.
+       On returning a 32 bit number, the value can be applied to any PLL in the calling function.
+    */
+    ulPllReg =
+        FIELD_SET(  0, PRIMARY_PLL_CTRL, BYPASS, OFF)
+      | FIELD_SET(  0, PRIMARY_PLL_CTRL, POWER,  ON)
+      | FIELD_SET(  0, PRIMARY_PLL_CTRL, INPUT,  OSC)
+      | FIELD_VALUE(0, PRIMARY_PLL_CTRL, POD,    pPLL->POD)      
+      | FIELD_VALUE(0, PRIMARY_PLL_CTRL, OD,     pPLL->OD)
+      | FIELD_VALUE(0, PRIMARY_PLL_CTRL, N,      pPLL->N)
+      | FIELD_VALUE(0, PRIMARY_PLL_CTRL, M,      pPLL->M);
+
+ //   DDKDEBUGPRINT((DISPLAY_LEVEL, "formatPllReg: PLL register value = 0x%08x\n", ulPllReg));
+
+    return(ulPllReg);
+}
+
+/*
+ * Get the programmable PLL register value.
+ *
+ * Input:
+ *      clockType   - The clock Type that the PLL is associated with.
+ *      pPLL        - Pointer to a PLL structure to be filled with the
+ *                    PLL value read from the register.
+ * Output:
+ *      The actual clock value calculated, together with the values of
+ *      PLL register stored in the pPLL pointer.
+ */
+unsigned long getPllValue(clock_type_t clockType, pll_value_t *pPLL)
+{
+    unsigned long ulPllReg = 0;
+    
+    pPLL->inputFreq = DEFAULT_INPUT_CLOCK;
+    pPLL->clockType = clockType;
+    
+    switch (clockType)
+    {
+        case MXCLK_PLL:
+            ulPllReg = peekRegisterDWord(MXCLK_PLL_CTRL);
+            break;
+        case PRIMARY_PLL:
+            ulPllReg = peekRegisterDWord(PRIMARY_PLL_CTRL);
+            break;
+        case SECONDARY_PLL:
+            ulPllReg = peekRegisterDWord(SECONDARY_PLL_CTRL);
+            break;
+        case VGA0_PLL:
+            ulPllReg = peekRegisterDWord(VGA_PLL0_CTRL);
+            break;
+        case VGA1_PLL:
+            ulPllReg = peekRegisterDWord(VGA_PLL1_CTRL);
+            break;
+    }
+    
+    pPLL->M = FIELD_GET(ulPllReg, PRIMARY_PLL_CTRL, M);
+    pPLL->N = FIELD_GET(ulPllReg, PRIMARY_PLL_CTRL, N);
+    pPLL->OD = FIELD_GET(ulPllReg, PRIMARY_PLL_CTRL, OD);
+    pPLL->POD = FIELD_GET(ulPllReg, PRIMARY_PLL_CTRL, POD);    
+
+    return calcPLL(pPLL);
+}
+
+/*
+ * This function set up the main chip clock.
+ *
+ * Input: Frequency to be set.
+ */
+void setChipClock(unsigned long frequency)
+{
+    pll_value_t pll;
+    unsigned long ulActualMxClk;
+
+#if 1
+	/* Cheok_0509: For SM750LE, the chip clock is fixed. Nothing to set. */
+	//if (getChipType() == SM750LE)
+	if (ddk750_getChipType() >= SM750LE)
+		return;
+#endif 
+
+    if (frequency != 0)
+    {
+        /*
+         * Set up PLL, a structure to hold the value to be set in clocks.
+         */
+        pll.inputFreq = DEFAULT_INPUT_CLOCK; /* Defined in CLOCK.H */
+        pll.clockType = MXCLK_PLL;
+
+        /* 
+         * Call calcPllValue() to fill up the other fields for PLL structure.
+         * Sometime, the chip cannot set up the exact clock required by User.
+         * Return value from calcPllValue() gives the actual possible clock.
+         */
+ //       DDKDEBUGPRINT((INIT_LEVEL, "setMemoryClock: frequency = 0x%08x\n", frequency));
+        ulActualMxClk = calcPllValue(frequency, &pll);
+ //       DDKDEBUGPRINT((INIT_LEVEL, "setMemoryClock: Current Clock = 0x%08x\n", ulActualMxClk));
+
+        /* Master Clock Control: MXCLK_PLL */
+        pokeRegisterDWord(MXCLK_PLL_CTRL, formatPllReg(&pll));
+    }
+}
+
+/*
+ * This function gets the Main Chip Clock value.
+ *
+ * Output:
+ *      The Actual Main Chip clock value.
+ */
+unsigned long getChipClock()
+{
+    pll_value_t pll;
+
+#if 1
+	/* Cheok_0509: For SM750LE, the chip clock is fixed */
+	//if (getChipType() == SM750LE)
+	if (ddk750_getChipType() >= SM750LE)
+		return (MHz(SM750LE_MASTER_CLK));
+#endif 
+
+    return getPllValue(MXCLK_PLL, &pll);
+}
+
+/*
+ * This function set up the memory clock.
+ *
+ * Input: Frequency to be set.
+ *
+ * NOTE:
+ *      The maximum frequency that the DDR Memory clock can be set is 336MHz.
+ */
+void setMemoryClock(unsigned long frequency)
+{
+    unsigned long ulReg, divisor;
+
+#if 1
+	/* Cheok_0509: For SM750LE, the memory clock is fixed. Nothing to set. */
+	//if (getChipType() == SM750LE)
+	if (ddk750_getChipType() >= SM750LE)
+		return;
+#endif 
+    
+    if (frequency != 0)        
+    {
+        /* Set the frequency to the maximum frequency that the DDR Memory can take
+           which is 336MHz. */
+        if (frequency > MHz(336))
+            frequency = MHz(336);
+        
+        /* Calculate the divisor */
+        divisor = (unsigned long) roundedDiv(getChipClock(), frequency);
+        
+        /* Set the corresponding divisor in the register. */
+        ulReg = peekRegisterDWord(CURRENT_GATE);
+        switch(divisor)
+        {   
+            default:
+            case 1:
+                ulReg = FIELD_SET(ulReg, CURRENT_GATE, M2XCLK, DIV_1);
+                break;
+            case 2:
+                ulReg = FIELD_SET(ulReg, CURRENT_GATE, M2XCLK, DIV_2);
+                break;
+            case 3:
+                ulReg = FIELD_SET(ulReg, CURRENT_GATE, M2XCLK, DIV_3);
+                break;
+            case 4:
+                ulReg = FIELD_SET(ulReg, CURRENT_GATE, M2XCLK, DIV_4);
+                break;
+        }
+        
+        setCurrentGate(ulReg);
+    }
+}
+
+/*
+ * This function set up the master clock (MCLK).
+ *
+ * Input: Frequency to be set.
+ *
+ * NOTE:
+ *      The maximum frequency the engine can run is 168MHz.
+ */
+void setMasterClock(unsigned long frequency)
+{
+    unsigned long ulReg, divisor;
+
+#if 1
+	/* Cheok_0509: For SM750LE, the master clock is fixed. Nothing to set. */
+	//if (getChipType() == SM750LE)
+	if (ddk750_getChipType() >= SM750LE)
+		return;
+#endif 
+    
+    if (frequency != 0)
+    {
+        /* Set the frequency to the maximum frequency that the SM750 engine can
+           run, which is about 190 MHz. */
+        if (frequency > MHz(190))
+            frequency = MHz(190);
+               
+        /* Calculate the divisor */
+        divisor = (unsigned long) roundedDiv(getChipClock(), frequency);
+        
+        /* Set the corresponding divisor in the register. */
+        ulReg = peekRegisterDWord(CURRENT_GATE);
+        switch(divisor)
+        {
+            default:
+            case 3:
+                ulReg = FIELD_SET(ulReg, CURRENT_GATE, MCLK, DIV_3);
+                break;
+            case 4:
+                ulReg = FIELD_SET(ulReg, CURRENT_GATE, MCLK, DIV_4);
+                break;
+            case 6:
+                ulReg = FIELD_SET(ulReg, CURRENT_GATE, MCLK, DIV_6);
+                break;
+            case 8:
+                ulReg = FIELD_SET(ulReg, CURRENT_GATE, MCLK, DIV_8);
+                break;
+        }
+        
+        setCurrentGate(ulReg);
+    }
+}
+
+/*
+ * This function get the Primary Display Control Pixel Clock value.
+ *
+ * Output:
+ *      The Primary Display Control Pixel Clock value in whole number.
+ */
+unsigned long getPrimaryDispCtrlClock()
+{
+    pll_value_t pll;
+    return getPllValue(PRIMARY_PLL, &pll);
+}
+
+/*
+ * This function get the Secondary Display Control Pixel Clock value.
+ *
+ * Output:
+ *      The Secondary Display Control Pixel Clock value in whole number.
+ */
+unsigned long getSecondaryDispCtrlClock()
+{
+    pll_value_t pll;
+    return getPllValue(SECONDARY_PLL, &pll);
+}
+
+/*
+ * This function gets the Master Clock value.
+ *
+ * Output:
+ *      The Master Clock value in whole number.
+ */
+unsigned long getMasterClock()
+{
+    unsigned long value, divisor;
+
+#if 1
+	/* Cheok_0509: For SM750LE, the chip clock is fixed */
+	//if (getChipType() == SM750LE)
+	if (ddk750_getChipType() >= SM750LE)
+		return(MHz(SM750LE_MASTER_CLK));
+#endif 
+    
+    /* Get the divisor */
+    value = peekRegisterDWord(CURRENT_GATE);
+    switch (FIELD_GET(value, CURRENT_GATE, MCLK))
+    {
+        case CURRENT_GATE_MCLK_DIV_3:
+            divisor = 3;
+            break;
+        case CURRENT_GATE_MCLK_DIV_4:
+            divisor = 4;
+            break;
+        case CURRENT_GATE_MCLK_DIV_6:
+            divisor = 6;
+            break;
+        case CURRENT_GATE_MCLK_DIV_8:
+            divisor = 8;
+            break;
+    }
+
+    return (getChipClock() / divisor);
+}
+
+/*
+ * This function gets the Memory Clock value.
+ *
+ * Output:
+ *      The Memory Clock value in whole number.
+ */
+unsigned long getMemoryClock()
+{
+    unsigned long value, divisor;
+
+#if 1
+	/* Cheok_0509: For SM750LE, the memory clock is fixed. */
+	//if (getChipType() == SM750LE)
+	if (ddk750_getChipType() >= SM750LE)
+		return (MHz(SM750LE_MEMORY_CLK));
+#endif 
+    
+    /* Get the divisor */
+    value = peekRegisterDWord(CURRENT_GATE);
+    switch (FIELD_GET(value, CURRENT_GATE, M2XCLK))
+    {
+        case CURRENT_GATE_M2XCLK_DIV_1:
+            divisor = 1;
+            break;
+        case CURRENT_GATE_M2XCLK_DIV_2:
+            divisor = 2;
+            break;
+        case CURRENT_GATE_M2XCLK_DIV_3:
+            divisor = 3;
+            break;
+        case CURRENT_GATE_M2XCLK_DIV_4:
+            divisor = 4;
+            break;
+    }
+
+    return (getChipClock() / divisor);
+}
+
+/*
+ * This function gets the Master Clock Divider Values List.
+ *
+ * Output:
+ *      The list of Master Clock divider values.
+ */
+unsigned char *getMasterClockDivider()
+{
+    return g_ucMasterClockDivider;
+}
+
+/*
+ * This function gets the total number of Master Clock Divider Values.
+ */
+unsigned long getTotalMasterClockDivider()
+{
+    return (sizeof(g_ucMasterClockDivider)/sizeof(unsigned char));
+}
+
+/*
+ * This function gets the Memory Clock Divider Values List.
+ *
+ * Output:
+ *      The list of Memory Clock divider values.
+ */
+unsigned char *getMemoryClockDivider()
+{
+    return g_ucMemoryClockDivider;
+}
+
+/*
+ * This function gets the total number of Memory Clock Divider Values.
+ */
+unsigned long getTotalMemoryClockDivider()
+{
+    return (sizeof(g_ucMemoryClockDivider)/sizeof(unsigned char));
+}
+
+/*
+ * This function uses the Master Clock PLL clock counter to provide some delay in ms.
+ */
+void waitMasterClock(
+    unsigned long miliseconds
+)
+{
+    unsigned long totalClockCount, startCount, endCount, diff, value;
+    
+    /* Calculate the clock counter needed for the delay */
+    totalClockCount = roundedDiv(getMasterClock(), 1000) * miliseconds;
+    
+    /* Enable PLL Clock Count*/
+    pokeRegisterDWord(MISC_CTRL, FIELD_SET(peekRegisterDWord(MISC_CTRL), MISC_CTRL, PLL_CLK_COUNT, ON));
+    
+    /* Start the counter */
+    endCount = 0;
+    while (totalClockCount > 0)
+    {
+        startCount = endCount;
+        value = FIELD_GET(peekRegisterDWord(PLL_CLK_COUNT), PLL_CLK_COUNT, COUNTER);
+        endCount = value;
+        
+        /* Check if the counter has overflown */
+        if (startCount > endCount)
+            endCount += 0x10000;
+        
+        /* Find the counter difference from last to start counter. */
+        diff = endCount - startCount;
+        
+        /* Decrement the total clock counter with the difference until it reaches 0. */
+        if (totalClockCount > diff)
+            totalClockCount -= diff;
+        else
+            totalClockCount = 0;
+    }
+    
+    /* Disable the PLL Clock Count to reset the counter the next time this function is called. */
+    pokeRegisterDWord(MISC_CTRL, FIELD_SET(peekRegisterDWord(MISC_CTRL), MISC_CTRL, PLL_CLK_COUNT, OFF));
+}
diff --git a/drivers/gpu/drm/smi/ddk750/ddk750_clock.h b/drivers/gpu/drm/smi/ddk750/ddk750_clock.h
new file mode 100644
index 000000000000..6c880450526d
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk750/ddk750_clock.h
@@ -0,0 +1,178 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2007 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  CLOCK.H --- Voyager GX DDK 
+* 
+*******************************************************************/
+#ifndef _CLOCK_H_
+#define _CLOCK_H_
+
+#define DEFAULT_INPUT_CLOCK 14318181 /* Default reference clock */
+#define MHz(x) (x*1000000) /* Don't use this macro if x is fraction number */
+
+/* The following maximum value is not the optimum value. */
+/* Maximum Master Clock is about 190MHz */
+#define MAXIMUM_MASTER_CLOCK        MHz(190)
+
+/* Maximum Chip Clock (MXCLK) is 1 GHz */
+#define MAXIMUM_CHIP_CLOCK          MHz(1000)
+
+typedef enum _clock_type_t
+{
+    MXCLK_PLL,      /* Programmable Master clock */
+    PRIMARY_PLL,    /* Programmable Primary pixel clock */
+    SECONDARY_PLL,  /* Programmable Secondary pixel clock */
+    VGA0_PLL,
+    VGA1_PLL,
+}
+clock_type_t;
+
+typedef struct pll_value_t
+{
+    clock_type_t clockType;
+    unsigned long inputFreq; /* Input clock frequency to the PLL */
+    unsigned long M;
+    unsigned long N;
+    unsigned long OD;
+    unsigned long POD;
+}
+pll_value_t;
+
+/*
+ * Given a requested clock frequency, this function calculates the 
+ * best M, N & OD values for the PLL.
+ * 
+ * Input: Requested pixel clock in Hz unit.
+ *        The followiing fields of PLL has to be set up properly:
+ *        pPLL->clockType, pPLL->inputFreq.
+ *
+ * Output: Update the PLL structure with the proper N, N and OD values
+ * Return: The actual clock in Hz that the PLL is able to set up.
+ *
+ * The PLL uses this formula to operate: 
+ * requestClk = inputFreq * M / N / (2 to the power of OD)
+ *
+ */
+unsigned long calcPllValue(
+unsigned long ulRequestClk, /* Required pixel clock in Hz unit */
+pll_value_t *pPLL           /* Structure to hold the value to be set in PLL */
+);
+
+/*
+ * Set up the corresponding bit field of the programmable PLL register.
+ *
+ * Input: Pointer to PLL structure with type and values set up properly.
+ *        Usually, calcPllValue() function will be called before this to calculate the values first.
+ *
+ */
+unsigned long formatPllReg(pll_value_t *pPLL);
+
+/*
+ * This function set up the main chip clock.
+ *
+ * Input: Frequency to be set.
+ */
+void setChipClock(unsigned long frequency);
+
+/*
+ * This function gets the Main Chip Clock value.
+ *
+ * Output:
+ *      The Actual Main Chip clock value.
+ */
+unsigned long getChipClock(void);
+
+/*
+ * This function set up the memory clock.
+ *
+ * Input: Frequency to be set.
+ */
+void setMemoryClock(unsigned long frequency);
+
+/*
+ *  getMemoryClock
+ *      This function gets the Memory Clock value.
+ *
+ *  Output:
+ *      The Memory Clock value in whole number.
+ */
+unsigned long getMemoryClock(void);
+
+/*
+ * This function set up the master clock (MCLK).
+ *
+ * Input: Frequency to be set.
+ */
+void setMasterClock(unsigned long frequency);
+
+/*
+ *  getMasterClock
+ *      This function gets the Master Clock value.
+ *
+ *  Output:
+ *      The Master Clock value in whole number.
+ */
+unsigned long getMasterClock(void);
+
+/*
+ * This function get the Primary display control Pixel Clock value.
+ *
+ * Output:
+ *      The Primary display control Pixel Clock value in whole number.
+ */
+unsigned long getPrimaryDispCtrlClock(void);
+
+/*
+ * This function get the Secondary display control Pixel Clock value.
+ *
+ * Output:
+ *      The Secondary display control Pixel Clock value in whole number.
+ */
+unsigned long getSecondaryDispCtrlClock(void);
+
+/*
+ * This function gets the Master Clock Divider Values List.
+ *
+ * Output:
+ *      The list of Master Clock divider values.
+ */
+unsigned char *getMasterClockDivider(void);
+
+/*
+ * This function gets the total number of Master Clock Divider Values.
+ */
+unsigned long getTotalMasterClockDivider(void);
+
+/*
+ * This function gets the Memory Clock Divider Values List.
+ *
+ * Output:
+ *      The list of Memory Clock divider values.
+ */
+unsigned char *getMemoryClockDivider(void);
+
+/*
+ * This function gets the total number of Memory Clock Divider Values.
+ */
+unsigned long getTotalMemoryClockDivider(void);
+
+/*
+ * This function uses the Master Clock PLL clock counter to provide some delay in ms.
+ */
+void waitMasterClock(
+    unsigned long miliseconds
+);
+
+/*
+  * This function provides new logic to program the PLL registers for HiSilicon ASIC. 
+  *
+  * Input: 
+  *	The value of HiSilicon PLL register. 
+  */
+void setVclock_HiSilicon(unsigned long pll);
+
+#endif /*_CLOCK_H_*/
diff --git a/drivers/gpu/drm/smi/ddk750/ddk750_cursor.c b/drivers/gpu/drm/smi/ddk750/ddk750_cursor.c
new file mode 100644
index 000000000000..672cd51f1809
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk750/ddk750_cursor.c
@@ -0,0 +1,104 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2007 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  CURSOR.C --- Voyager GX SDK 
+*  This file contains the definitions for the Panel cursor functions.
+* 
+*******************************************************************/
+#include "ddk750_defs.h"
+#include "ddk750_hardware.h"
+#include "ddk750_cursor.h"
+#include "ddk750_help.h"
+/*
+ * This function initializes the cursor attributes.
+ */
+void ddk750_initCursor(
+    disp_control_t dispControl,     /* Display control (PRIMARY_CTRL or SECONDARY_CTRL) */
+    unsigned long base,             /* Base Address */ 
+    unsigned long color1,           /* Cursor color 1 in RGB 5:6:5 format */
+    unsigned long color2,           /* Cursor color 2 in RGB 5:6:5 format */
+    unsigned long color3            /* Cursor color 3 in RGB 5:6:5 format */
+)
+{
+    /*
+     * 1. Set the cursor source address 
+     */
+    pokeRegisterDWord(
+        (dispControl == PRIMARY_CTRL) ? PRIMARY_HWC_ADDRESS : SECONDARY_HWC_ADDRESS,
+        FIELD_SET(0, PRIMARY_HWC_ADDRESS, EXT, LOCAL) |
+        FIELD_VALUE(0, PRIMARY_HWC_ADDRESS, ADDRESS, base));
+        
+    /*
+     * 2. Set the cursor color composition 
+     */
+    pokeRegisterDWord(
+        (dispControl == PRIMARY_CTRL) ? PRIMARY_HWC_COLOR_12 : SECONDARY_HWC_COLOR_12, 
+        FIELD_VALUE(0, PRIMARY_HWC_COLOR_12, 1_RGB565, color1) |
+        FIELD_VALUE(0, PRIMARY_HWC_COLOR_12, 2_RGB565, color2) );
+
+    pokeRegisterDWord(
+        (dispControl == PRIMARY_CTRL) ? PRIMARY_HWC_COLOR_3 : SECONDARY_HWC_COLOR_3,
+        FIELD_VALUE(0, PRIMARY_HWC_COLOR_3, RGB565, color3));
+}
+
+/*
+ * This function sets the cursor position.
+ */
+void ddk750_setCursorPosition(
+    disp_control_t dispControl,     /* Display control (PRIMARY_CTRL or SECONDARY_CTRL) */
+    unsigned long dx,               /* X Coordinate of the cursor */
+    unsigned long dy,               /* Y Coordinate of the cursor */
+    unsigned char topOutside,       /* Top Boundary Select: either partially outside (= 1) 
+                                       or within the screen top boundary (= 0) */
+    unsigned char leftOutside       /* Left Boundary Select: either partially outside (= 1) 
+                                       or within the screen left boundary (= 0) */
+)
+{  
+    unsigned long value;
+
+    /* Set the XY coordinate */
+    value = FIELD_VALUE(0, PRIMARY_HWC_LOCATION, X, dx) |
+            FIELD_VALUE(0, PRIMARY_HWC_LOCATION, Y, dy);
+    
+    /* Set the top boundary select either partially outside the top boundary
+       screen or inside */
+    if (topOutside)
+        value = FIELD_SET(value, PRIMARY_HWC_LOCATION, TOP, OUTSIDE);
+    else         
+        value = FIELD_SET(value, PRIMARY_HWC_LOCATION, TOP, INSIDE);
+
+    /* Set the left boundary select either partially outside the left boundary
+       screen or inside */
+    if (leftOutside)
+        value = FIELD_SET(value, PRIMARY_HWC_LOCATION, LEFT, OUTSIDE);
+    else        
+        value = FIELD_SET(value, PRIMARY_HWC_LOCATION, LEFT, INSIDE);
+
+    /* Set the register accordingly, either Panel cursor or CRT cursor */
+    pokeRegisterDWord((dispControl == PRIMARY_CTRL) ? PRIMARY_HWC_LOCATION : SECONDARY_HWC_LOCATION, value);
+}
+
+/*
+ * This function enables/disables the cursor.
+ */
+void ddk750_enableCursor(
+    disp_control_t dispControl,     /* Display control (PRIMARY_CTRL or SECONDARY_CTRL) */
+    unsigned long enable
+)
+{
+    unsigned long cursorRegister, value;
+
+    cursorRegister = (dispControl == PRIMARY_CTRL) ? PRIMARY_HWC_ADDRESS : SECONDARY_HWC_ADDRESS;
+    
+	value = peekRegisterDWord(cursorRegister);
+    if (enable) 
+        value = FIELD_SET(value, PRIMARY_HWC_ADDRESS, ENABLE, ENABLE);
+    else
+        value = FIELD_SET(value, PRIMARY_HWC_ADDRESS, ENABLE, DISABLE);
+    
+    pokeRegisterDWord(cursorRegister, value);
+}
diff --git a/drivers/gpu/drm/smi/ddk750/ddk750_cursor.h b/drivers/gpu/drm/smi/ddk750/ddk750_cursor.h
new file mode 100644
index 000000000000..c2adebaca9c8
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk750/ddk750_cursor.h
@@ -0,0 +1,48 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2007 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  cursor.h --- SMI DDK 
+*  This file contains the definitions for the cursor functions.
+* 
+*******************************************************************/
+#ifndef _CURSOR_H_
+#define _CURSOR_H_
+
+#include "ddk750_mode.h"
+/*
+ * This function initializes the cursor attributes.
+ */
+void ddk750_initCursor(
+    disp_control_t dispControl,     /* Display control (PRIMARY_CTRL or SECONDARY_CTRL) */
+    unsigned long base,             /* Base Address */ 
+    unsigned long color1,           /* Cursor color 1 in RGB 5:6:5 format */
+    unsigned long color2,           /* Cursor color 2 in RGB 5:6:5 format */
+    unsigned long color3            /* Cursor color 3 in RGB 5:6:5 format */
+);
+
+/*
+ * This function sets the cursor position.
+ */
+void ddk750_setCursorPosition(
+    disp_control_t dispControl,     /* Display control (PRIMARY_CTRL or SECONDARY_CTRL) */
+    unsigned long dx,               /* X Coordinate of the cursor */
+    unsigned long dy,               /* Y Coordinate of the cursor */
+    unsigned char topOutside,       /* Top Boundary Select: either partially outside (= 1) 
+                                       or within the screen top boundary (= 0) */
+    unsigned char leftOutside       /* Left Boundary Select: either partially outside (= 1) 
+                                       or within the screen left boundary (= 0) */
+);
+
+/*
+ * This function enables/disables the cursor.
+ */
+void ddk750_enableCursor(
+    disp_control_t dispControl,     /* Display control (PRIMARY_CTRL or SECONDARY_CTRL) */
+    unsigned long enable
+);
+
+#endif /* _CURSOR_H_ */
diff --git a/drivers/gpu/drm/smi/ddk750/ddk750_defs.h b/drivers/gpu/drm/smi/ddk750/ddk750_defs.h
new file mode 100644
index 000000000000..78a12f069cec
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk750/ddk750_defs.h
@@ -0,0 +1,83 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2008 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  DEFS.H (The name of this file is defs.h in 718 DDK)
+*  This file contains register and common macro definitions.
+* 
+*******************************************************************/
+#ifndef _DEFS_H_
+#define _DEFS_H_
+
+/* For validation purpose only */
+/*#define SM750_AA*/
+//#include "ddk750_help.h"
+#include "ddk750_regsc.h"
+#include "ddk750_reggpio.h"
+//#include "ddk750_regpwm.h"
+//#include "ddk750_regssp.h"
+#include "ddk750_regdc.h"
+//#include "ddk750_regdma.h"
+//#include "ddk750_regde.h"
+//#include "ddk750_regzv.h"
+#include "ddk750_regi2c.h"
+
+/* Internal macros */
+#define _F_START(f)             (0 ? f)
+#define _F_END(f)               (1 ? f)
+#define _F_SIZE(f)              (1 + _F_END(f) - _F_START(f))
+#define _F_MASK(f)              (((1 << _F_SIZE(f)) - 1) << _F_START(f))
+#define _F_NORMALIZE(v, f)      (((v) & _F_MASK(f)) >> _F_START(f))
+#define _F_DENORMALIZE(v, f)    (((v) << _F_START(f)) & _F_MASK(f))
+
+/* Global macros */
+#define FIELD_GET(x, reg, field) \
+( \
+    _F_NORMALIZE((x), reg ## _ ## field) \
+)
+
+#define FIELD_SET(x, reg, field, value) \
+( \
+    (x & ~_F_MASK(reg ## _ ## field)) \
+    | _F_DENORMALIZE(reg ## _ ## field ## _ ## value, reg ## _ ## field) \
+)
+
+#define FIELD_VALUE(x, reg, field, value) \
+( \
+    (x & ~_F_MASK(reg ## _ ## field)) \
+    | _F_DENORMALIZE(value, reg ## _ ## field) \
+)
+
+#define FIELD_CLEAR(reg, field) \
+( \
+    ~ _F_MASK(reg ## _ ## field) \
+)
+
+/* FIELD MACROS */
+#define FIELD_START(field)              (0 ? field)
+#define FIELD_END(field)                (1 ? field)
+#define FIELD_SIZE(field)               (1 + FIELD_END(field) - FIELD_START(field))
+#define FIELD_MASK(field)               (((1 << (FIELD_SIZE(field)-1)) | ((1 << (FIELD_SIZE(field)-1)) - 1)) << FIELD_START(field))
+#define FIELD_NORMALIZE(reg, field)     (((reg) & FIELD_MASK(field)) >> FIELD_START(field))
+#define FIELD_DENORMALIZE(field, value) (((value) << FIELD_START(field)) & FIELD_MASK(field))
+#define FIELD_INIT(reg, field, value)   FIELD_DENORMALIZE(reg ## _ ## field, \
+                                                          reg ## _ ## field ## _ ## value)
+#define FIELD_INIT_VAL(reg, field, value) \
+                                        (FIELD_DENORMALIZE(reg ## _ ## field, value))
+#define FIELD_VAL_SET(x, r, f, v)       x = x & ~FIELD_MASK(r ## _ ## f) \
+                                              | FIELD_DENORMALIZE(r ## _ ## f, r ## _ ## f ## _ ## v)
+
+#define RGB(r, g, b) \
+( \
+    (unsigned long) (((r) << 16) | ((g) << 8) | (b)) \
+)
+
+#define RGB16(r, g, b) \
+( \
+    (unsigned short) ((((r) & 0xF8) << 8) | (((g) & 0xFC) << 3) | (((b) & 0xF8) >> 3)) \
+)
+
+#endif /* _DEFS_H_ */
diff --git a/drivers/gpu/drm/smi/ddk750/ddk750_display.c b/drivers/gpu/drm/smi/ddk750/ddk750_display.c
new file mode 100644
index 000000000000..92c7a1256bee
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk750/ddk750_display.c
@@ -0,0 +1,1707 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2007 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  DISPLAY.C --- Voyager GX SDK 
+*  This file contains the source code for the panel and CRT functions.
+* 
+*******************************************************************/
+#include "ddk750_defs.h"
+#include "ddk750_hardware.h"
+#include "ddk750_chip.h"
+//#include "ddk750/ddk750_swi2c.h"
+#include "ddk750_display.h"
+//#include "ddk750/ddk750_dvi.h"
+#include "ddk750_power.h"
+#include "ddk750_help.h"
+
+#define Validate_718_AA     1
+
+/* When use actual Panel, then do not need to turn on the DAC. */
+#define ENABLE_PANEL_DAC 
+
+/* Monitor Detection RGB Default Threshold values */
+#define DEFAULT_MON_DETECTION_THRESHOLD         0x64
+
+
+/*
+ * This function checks whether dual panel is enabled or not
+ *
+ * Output:
+ *      0   - Not Enable
+ *      1   - Enable  
+ */
+unsigned char isDualPanelEnable(void)
+{
+    unsigned long value;
+
+    value = FIELD_GET(peekRegisterDWord(PRIMARY_DISPLAY_CTRL), PRIMARY_DISPLAY_CTRL, DUAL_DISPLAY);
+    
+    return ((value == PRIMARY_DISPLAY_CTRL_DUAL_DISPLAY_ENABLE) ? 1 : 0);
+}
+
+/*
+ * This function gets the panel type
+ *
+ * Output:
+ *      panelType   - The type of the panel to be set  
+ */
+panel_type_t getPanelType(void)
+{
+    if (FIELD_GET(peekRegisterDWord(PRIMARY_DISPLAY_CTRL), PRIMARY_DISPLAY_CTRL, DOUBLE_PIXEL) == 
+        PRIMARY_DISPLAY_CTRL_DOUBLE_PIXEL_ENABLE)
+    {
+        return TFT_36BIT;
+    }
+    else if (isDualPanelEnable() == 1)
+        return TFT_18BIT;
+    else
+        return TFT_24BIT;
+}
+
+/*
+ * This function sets the panel type
+ *
+ * Input:
+ *      panelType   - The type of the panel to be set  
+ */
+long setPanelType(
+    panel_type_t panelType
+)
+{
+    unsigned long value;
+            
+    /* Set the panel type. */
+    value = peekRegisterDWord(PRIMARY_DISPLAY_CTRL);
+    switch (panelType)
+    {
+        case TFT_18BIT:
+            value = FIELD_SET(value, PRIMARY_DISPLAY_CTRL, DUAL_DISPLAY, ENABLE);
+            value = FIELD_SET(value, PRIMARY_DISPLAY_CTRL, DOUBLE_PIXEL, DISABLE);
+            break;
+        case TFT_24BIT:
+            value = FIELD_SET(value, PRIMARY_DISPLAY_CTRL, DUAL_DISPLAY, DISABLE);
+            value = FIELD_SET(value, PRIMARY_DISPLAY_CTRL, DOUBLE_PIXEL, DISABLE);
+            break;
+        case TFT_36BIT:
+            value = FIELD_SET(value, PRIMARY_DISPLAY_CTRL, DUAL_DISPLAY, DISABLE);
+            value = FIELD_SET(value, PRIMARY_DISPLAY_CTRL, DOUBLE_PIXEL, ENABLE);
+            break;
+        default:
+            return (-1);
+    }
+    pokeRegisterDWord(PRIMARY_DISPLAY_CTRL, value);
+    
+    //DDKDEBUGPRINT((DISPLAY_LEVEL, "(setPanelType)PRIMARY_DISPLAY_CTRL: %x\n", peekRegisterDWord(PRIMARY_DISPLAY_CTRL)));
+    
+    return 0;
+}
+
+/*
+ * Use vertical sync as time delay function.
+ *
+ * Input:
+ *          dispControl - Display Control (either panel or crt) 
+ *          vsync_count - Number of vertical sync to wait.
+ *
+ * Note:
+ *      This function is waiting for the next vertical sync.         
+ */
+void waitNextVerticalSync(disp_control_t dispControl, unsigned long vsync_count)
+{
+    unsigned long status;
+    unsigned long ulLoopCount = 0;
+    static unsigned long ulDeadLoopCount = 10000;
+    
+    if (dispControl == PRIMARY_CTRL)
+    {
+        /* Do not wait when the Primary PLL is off or display control is already off. 
+           This will prevent the software to wait forever. */
+        if ((FIELD_GET(peekRegisterDWord(PRIMARY_PLL_CTRL), PRIMARY_PLL_CTRL, POWER) ==
+             PRIMARY_PLL_CTRL_POWER_OFF) ||
+            (FIELD_GET(peekRegisterDWord(PRIMARY_DISPLAY_CTRL), PRIMARY_DISPLAY_CTRL, TIMING) ==
+             PRIMARY_DISPLAY_CTRL_TIMING_DISABLE))
+        {
+            return;
+        }
+
+        while (vsync_count-- > 0)
+        {
+            ulLoopCount = 0;
+            /* Wait for end of vsync. */
+            do
+            {
+                status = FIELD_GET(peekRegisterDWord(SYSTEM_CTRL),
+                                   SYSTEM_CTRL,
+                                   PRIMARY_VSYNC);
+                if(ulLoopCount++ > ulDeadLoopCount)
+                    break;
+            }
+            while (status == SYSTEM_CTRL_PRIMARY_VSYNC_ACTIVE);
+
+            ulLoopCount = 0;
+            /* Wait for start of vsync. */
+            do
+            {
+                status = FIELD_GET(peekRegisterDWord(SYSTEM_CTRL),
+                                   SYSTEM_CTRL, 
+                                   PRIMARY_VSYNC);
+                if(ulLoopCount++ > ulDeadLoopCount)
+                    break;
+            }
+            while (status == SYSTEM_CTRL_PRIMARY_VSYNC_INACTIVE);
+        }
+    }
+    else
+    {
+        /* Do not wait when the display control is already off. This will prevent
+           the software to wait forever. */
+        if ((FIELD_GET(peekRegisterDWord(SECONDARY_PLL_CTRL), SECONDARY_PLL_CTRL, POWER) ==
+             SECONDARY_PLL_CTRL_POWER_OFF) ||
+            (FIELD_GET(peekRegisterDWord(SECONDARY_DISPLAY_CTRL), SECONDARY_DISPLAY_CTRL, TIMING) ==
+             SECONDARY_DISPLAY_CTRL_TIMING_DISABLE))
+        {
+            return;
+        }
+
+        while (vsync_count-- > 0)
+        {
+            ulLoopCount = 0;
+            /* Wait for end of vsync. */
+            do
+            {
+                status = FIELD_GET(peekRegisterDWord(SYSTEM_CTRL),
+                                   SYSTEM_CTRL,
+                                   SECONDARY_VSYNC);
+                if(ulLoopCount++ > ulDeadLoopCount)
+                    break;                
+            }
+            while (status == SYSTEM_CTRL_SECONDARY_VSYNC_ACTIVE);
+
+            ulLoopCount = 0;
+            /* Wait for start of vsync. */
+            do
+            {
+                status = FIELD_GET(peekRegisterDWord(SYSTEM_CTRL),
+                                   SYSTEM_CTRL, 
+                                   SECONDARY_VSYNC);
+                if(ulLoopCount++ > ulDeadLoopCount)
+                    break;                
+            }
+            while (status == SYSTEM_CTRL_SECONDARY_VSYNC_INACTIVE);
+        }
+    }
+}
+
+/*
+ * Use Primary vertical sync as time delay function.
+ * Input: Number of vertical sync to wait.
+ */
+void primaryWaitVerticalSync(unsigned long vsync_count)
+{
+    waitNextVerticalSync(PRIMARY_CTRL, vsync_count);
+}
+
+/*
+ * Use crt vertical sync as time delay function.
+ * Input: Number of vertical sync to wait.
+ */
+void secondaryWaitVerticalSync(unsigned long vsync_count)
+{
+    waitNextVerticalSync(SECONDARY_CTRL, vsync_count);
+}
+
+/*
+ * Use panel vertical sync line as time delay function.
+ * This function does not wait for the next VSync. Instead, it will wait
+ * until the current line reaches the Vertical Sync line.
+ * This function is really useful when flipping display to prevent tearing.
+ *
+ * Input: display control (PRIMARY_CTRL or SECONDARY_CTRL)
+ */
+void waitVSyncLine(disp_control_t dispControl)
+{
+    unsigned long value;
+    mode_parameter_t modeParam;
+    
+    /* Get the current mode parameter of the specific display control */
+    modeParam = getCurrentModeParam(dispControl);
+    
+    do
+    {
+        if (dispControl == PRIMARY_CTRL)
+            value = FIELD_GET(peekRegisterDWord(PRIMARY_CURRENT_LINE), PRIMARY_CURRENT_LINE, LINE);
+        else
+            value = FIELD_GET(peekRegisterDWord(SECONDARY_CURRENT_LINE), SECONDARY_CURRENT_LINE, LINE);
+    }
+    while (value < modeParam.vertical_sync_start);
+}
+
+
+void swPanelPowerSequence_SM750LE(disp_state_t dispState, unsigned long vsync_delay)
+{
+    unsigned long ulDispControl, ulMask;
+
+    ulDispControl = peekRegisterDWord(DISPLAY_CONTROL_750LE);
+
+    if (dispState == DISP_ON)
+    {
+        ulMask = FIELD_SET(0, DISPLAY_CONTROL_750LE, EN,   HIGH) |
+                 FIELD_SET(0, DISPLAY_CONTROL_750LE, BIAS, HIGH) |
+                 FIELD_SET(0, DISPLAY_CONTROL_750LE, DATA, ENABLE) |
+                 FIELD_SET(0, DISPLAY_CONTROL_750LE, VDD,  HIGH);
+        
+        pokeRegisterDWord(DISPLAY_CONTROL_750LE, (ulDispControl | ulMask));
+    }
+    else
+    {
+        ulMask = FIELD_SET(0, DISPLAY_CONTROL_750LE, EN,   LOW) |
+                 FIELD_SET(0, DISPLAY_CONTROL_750LE, BIAS, LOW) |
+                 FIELD_SET(0, DISPLAY_CONTROL_750LE, DATA, DISABLE) |
+                 FIELD_SET(0, DISPLAY_CONTROL_750LE, VDD,  LOW);
+        
+        pokeRegisterDWord(DISPLAY_CONTROL_750LE, (ulDispControl & ulMask));
+    }
+}
+
+/*
+ * This functions uses software sequence to turn on/off the panel.
+ */
+void swPanelPowerSequence(disp_state_t dispState, unsigned long vsync_delay)
+{
+    unsigned long primaryControl = peekRegisterDWord(PRIMARY_DISPLAY_CTRL);
+
+    //DDKDEBUGPRINT((DISPLAY_LEVEL, "swPanelPowerSequence +\n"));
+
+    if (dispState == DISP_ON)
+    {
+        /* Turn on FPVDDEN. */
+        primaryControl = FIELD_SET(primaryControl, PRIMARY_DISPLAY_CTRL, FPVDDEN, HIGH);
+        pokeRegisterDWord(PRIMARY_DISPLAY_CTRL, primaryControl);
+        primaryWaitVerticalSync(vsync_delay);
+
+        /* Turn on FPDATA. */
+        primaryControl = FIELD_SET(primaryControl, PRIMARY_DISPLAY_CTRL, DATA, ENABLE);
+        pokeRegisterDWord(PRIMARY_DISPLAY_CTRL, primaryControl);
+        primaryWaitVerticalSync(vsync_delay);
+
+        /* Turn on FPVBIAS. */
+        primaryControl = FIELD_SET(primaryControl, PRIMARY_DISPLAY_CTRL, VBIASEN, HIGH);
+        pokeRegisterDWord(PRIMARY_DISPLAY_CTRL, primaryControl);
+        primaryWaitVerticalSync(vsync_delay);
+
+        /* Turn on FPEN. */
+        primaryControl = FIELD_SET(primaryControl, PRIMARY_DISPLAY_CTRL, FPEN, HIGH);
+        pokeRegisterDWord(PRIMARY_DISPLAY_CTRL, primaryControl);
+    }
+
+    else
+    {
+        /* Turn off FPEN. */
+        primaryControl = FIELD_SET(primaryControl, PRIMARY_DISPLAY_CTRL, FPEN, LOW);
+        pokeRegisterDWord(PRIMARY_DISPLAY_CTRL, primaryControl);
+        primaryWaitVerticalSync(vsync_delay);
+
+        /* Turn off FPVBIASEN. */
+        primaryControl = FIELD_SET(primaryControl, PRIMARY_DISPLAY_CTRL, VBIASEN, LOW);
+        pokeRegisterDWord(PRIMARY_DISPLAY_CTRL, primaryControl);
+        primaryWaitVerticalSync(vsync_delay);
+
+        /* Turn off FPDATA. */
+        primaryControl = FIELD_SET(primaryControl, PRIMARY_DISPLAY_CTRL, DATA, DISABLE);
+        pokeRegisterDWord(PRIMARY_DISPLAY_CTRL, primaryControl);
+        primaryWaitVerticalSync(vsync_delay);
+
+        /* Turn off FPVDDEN. */
+        primaryControl = FIELD_SET(primaryControl, PRIMARY_DISPLAY_CTRL, FPVDDEN, LOW);
+        pokeRegisterDWord(PRIMARY_DISPLAY_CTRL, primaryControl);
+    }
+    
+    //DDKDEBUGPRINT((DISPLAY_LEVEL, "swPanelPowerSequence -\n"));
+}
+
+/* 
+ * This function turns on/off the DAC for CRT display control.
+ * Input: On or off
+ */
+void setDAC(disp_state_t state)
+{
+    //DDKDEBUGPRINT((DISPLAY_LEVEL, "setDAC: %s\n", (state == DISP_ON) ? "on" : "off"));
+
+    if (state == DISP_ON)
+    {
+        pokeRegisterDWord(MISC_CTRL, FIELD_SET(peekRegisterDWord(MISC_CTRL),
+                                               MISC_CTRL,
+                                               DAC_POWER,
+                                               ON));
+    }
+    else
+    {
+        pokeRegisterDWord(MISC_CTRL, FIELD_SET(peekRegisterDWord(MISC_CTRL),
+                                               MISC_CTRL,
+                                               DAC_POWER,
+                                               OFF));
+    }
+}
+
+/*
+ * This function turns on/off the display control.
+ * Currently, it for CRT and Panel controls only.
+ * Input: Panel or CRT, or ...
+ *        On or Off.
+ *
+ * This function manipulate the physical display channels 
+ * and devices.
+ *
+ * Note:
+ *      Turning on/off the timing and the plane requires programming sequence.
+ *      The plane can not be changed without turning on the timing. However,
+ *      changing the plane has no effect when the timing (clock) is off. Below,
+ *      is the description of the timing and plane combination setting.
+ *
+ *      +-----------+-----------+-----------------------------------------------+
+ *      |  Timing   |   Plane   |                    Description                |
+ *      +-----------+-----------+-----------------------------------------------+
+ *      |    ON     |    OFF    | no Display but clock is on (consume power)    |
+ *      |    ON     |    ON     | normal display                                |
+ *      |    OFF    |    OFF    | no display and no clock (power down)          |
+ *      |    OFF    |    ON     | no display and no clock (same as power down)  |
+ *      +-----------+-----------+-----------------------------------------------+
+ */
+void setDisplayControl(disp_control_t dispControl, disp_state_t dispState)
+{
+    unsigned long ulDisplayCtrlReg, ulReservedBits;
+    unsigned long ulCount = 0;
+
+    /* Set the primary display control */
+    if (dispControl == PRIMARY_CTRL)
+    {
+        ulDisplayCtrlReg = peekRegisterDWord(PRIMARY_DISPLAY_CTRL);
+
+        //DDKDEBUGPRINT((DISPLAY_LEVEL, "(setDispCtrl) PRIMARY_DISPLAY_CTRL before set: %x\n", peekRegisterDWord(PRIMARY_DISPLAY_CTRL)));
+
+        /* Turn on/off the Panel display control */
+        if (dispState == DISP_ON)
+        {
+            /* Timing should be enabled first before enabling the plane because changing at the
+               same time does not guarantee that the plane will also enabled or disabled. 
+             */
+            ulDisplayCtrlReg = FIELD_SET(ulDisplayCtrlReg, PRIMARY_DISPLAY_CTRL, TIMING, ENABLE);
+            pokeRegisterDWord(PRIMARY_DISPLAY_CTRL, ulDisplayCtrlReg);
+            
+            ulDisplayCtrlReg = FIELD_SET(ulDisplayCtrlReg, PRIMARY_DISPLAY_CTRL, PLANE, ENABLE);
+            
+            /* Added some masks to mask out the reserved bits. 
+             * Sometimes, the reserved bits are set/reset randomly when 
+             * writing to the PRIMARY_DISPLAY_CTRL, therefore, the register
+             * reserved bits are needed to be masked out.
+             */
+            ulReservedBits = FIELD_SET(0, PRIMARY_DISPLAY_CTRL, RESERVED_1_MASK, ENABLE) |
+                             FIELD_SET(0, PRIMARY_DISPLAY_CTRL, RESERVED_2_MASK, ENABLE) |
+                             FIELD_SET(0, PRIMARY_DISPLAY_CTRL, RESERVED_3_MASK, ENABLE);
+                             
+            /* Somehow the register value on the plane is not set until a few delay. Need to write
+               and read it a couple times*/
+            pokeRegisterDWord(PRIMARY_DISPLAY_CTRL, ulDisplayCtrlReg);
+            primaryWaitVerticalSync(2);
+        }
+        else
+        {
+            /* When turning off, there is no rule on the programming sequence since whenever the
+               clock is off, then it does not matter whether the plane is enabled or disabled.
+               Note: Modifying the plane bit will take effect on the next vertical sync. Need to
+                     find out if it is necessary to wait for 1 vsync before modifying the timing
+                     enable bit. 
+             */
+            ulDisplayCtrlReg = FIELD_SET(ulDisplayCtrlReg, PRIMARY_DISPLAY_CTRL, PLANE, DISABLE);
+            pokeRegisterDWord(PRIMARY_DISPLAY_CTRL, ulDisplayCtrlReg);
+
+            ulDisplayCtrlReg = FIELD_SET(ulDisplayCtrlReg, PRIMARY_DISPLAY_CTRL, TIMING, DISABLE);
+            pokeRegisterDWord(PRIMARY_DISPLAY_CTRL, ulDisplayCtrlReg);
+        }
+
+        //DDKDEBUGPRINT((DISPLAY_LEVEL, "(setDispCtrl) PRIMARY_DISPLAY_CTRL after set: %x\n", peekRegisterDWord(PRIMARY_DISPLAY_CTRL)));
+    }
+    /* Set the secondary display control */
+    else
+    {
+        ulDisplayCtrlReg = peekRegisterDWord(SECONDARY_DISPLAY_CTRL);
+
+        //DDKDEBUGPRINT((DISPLAY_LEVEL, "(setDispCtrl) SECONDARY_DISPLAY_CTRL before set: %x\n", peekRegisterDWord(SECONDARY_DISPLAY_CTRL)));
+
+        if (dispState == DISP_ON)
+        {
+            /* Timing should be enabled first before enabling the plane because changing at the
+               same time does not guarantee that the plane will also enabled or disabled. 
+             */
+            ulDisplayCtrlReg = FIELD_SET(ulDisplayCtrlReg, SECONDARY_DISPLAY_CTRL, TIMING, ENABLE);
+            pokeRegisterDWord(SECONDARY_DISPLAY_CTRL, ulDisplayCtrlReg);
+                        
+            ulDisplayCtrlReg = FIELD_SET(ulDisplayCtrlReg, SECONDARY_DISPLAY_CTRL, PLANE, ENABLE);
+            
+            /* Added some masks to mask out the reserved bits. 
+             * Sometimes, the reserved bits are set/reset randomly when 
+             * writing to the PRIMARY_DISPLAY_CTRL, therefore, the register
+             * reserved bits are needed to be masked out.
+             */
+            ulReservedBits = FIELD_SET(0, SECONDARY_DISPLAY_CTRL, RESERVED_1_MASK, ENABLE) |
+                             FIELD_SET(0, SECONDARY_DISPLAY_CTRL, RESERVED_2_MASK, ENABLE) |
+                             FIELD_SET(0, SECONDARY_DISPLAY_CTRL, RESERVED_3_MASK, ENABLE) |
+                             FIELD_SET(0, SECONDARY_DISPLAY_CTRL, RESERVED_4_MASK, ENABLE);
+            
+            
+            pokeRegisterDWord(SECONDARY_DISPLAY_CTRL, ulDisplayCtrlReg);
+            secondaryWaitVerticalSync(2);
+        }
+        else
+        {
+            /* When turning off, there is no rule on the programming sequence since whenever the
+               clock is off, then it does not matter whether the plane is enabled or disabled.
+               Note: Modifying the plane bit will take effect on the next vertical sync. Need to
+                     find out if it is necessary to wait for 1 vsync before modifying the timing
+                     enable bit.
+             */
+            ulDisplayCtrlReg = FIELD_SET(ulDisplayCtrlReg, SECONDARY_DISPLAY_CTRL, PLANE, DISABLE);
+            pokeRegisterDWord(SECONDARY_DISPLAY_CTRL, ulDisplayCtrlReg);
+
+            ulDisplayCtrlReg = FIELD_SET(ulDisplayCtrlReg, SECONDARY_DISPLAY_CTRL, TIMING, DISABLE);
+            pokeRegisterDWord(SECONDARY_DISPLAY_CTRL, ulDisplayCtrlReg);
+        }
+
+        //DDKDEBUGPRINT((DISPLAY_LEVEL, "(setDispCtrl) SECONDARY_DISPLAY_CTRL after set: %x\n", peekRegisterDWord(SECONDARY_DISPLAY_CTRL)));
+    }
+}
+
+/*
+ * This function set the display path together with the HSync and VSync.
+ *
+ * Note:
+ *     This function has to be called last after setting all the display Control
+ *     and display output. 
+ */
+void setPath(
+    disp_path_t dispPath, 
+    disp_control_t dispControl, 
+    disp_state_t dispState
+)
+{
+    unsigned long control;
+    mode_parameter_t modeParam;
+    unsigned long clock0, clock1, MiscControl;    
+
+    /* Get the current mode parameter of the specific display control */
+    modeParam = getCurrentModeParam(dispControl);
+    
+    if (dispPath == PANEL_PATH)
+    {
+        control = peekRegisterDWord(PRIMARY_DISPLAY_CTRL);
+        if (dispState == DISP_ON)
+        {
+            /* Adjust the Clock polarity */
+            if (modeParam.clock_phase_polarity == POS)
+                control = FIELD_SET(control, PRIMARY_DISPLAY_CTRL, CLOCK_PHASE, ACTIVE_HIGH);
+            else
+                control = FIELD_SET(control, PRIMARY_DISPLAY_CTRL, CLOCK_PHASE, ACTIVE_LOW);
+                        
+            /* Adjust the VSync polarity */
+            if (modeParam.vertical_sync_polarity == POS)
+                control = FIELD_SET(control, PRIMARY_DISPLAY_CTRL, VSYNC_PHASE, ACTIVE_HIGH);
+            else
+                control = FIELD_SET(control, PRIMARY_DISPLAY_CTRL, VSYNC_PHASE, ACTIVE_LOW);
+
+            /* Adjust the HSync polarity */
+            if (modeParam.horizontal_sync_polarity == POS)
+                control = FIELD_SET(control, PRIMARY_DISPLAY_CTRL, HSYNC_PHASE, ACTIVE_HIGH);
+            else
+                control = FIELD_SET(control, PRIMARY_DISPLAY_CTRL, HSYNC_PHASE, ACTIVE_LOW);
+
+            /* Display control is not swapped, so use the normal display data flow */
+            if (dispControl == PRIMARY_CTRL)
+                control = FIELD_SET(control, PRIMARY_DISPLAY_CTRL, SELECT, PRIMARY);                    
+            else    /* Secondary Control */
+                control = FIELD_SET(control, PRIMARY_DISPLAY_CTRL, SELECT, SECONDARY);
+        }
+
+#if Validate_718_AA
+        //if (hwDeviceExtension1[0]->ChipID==0x718 ||
+        //    hwDeviceExtension1[1]->ChipID==0x718)
+        {
+            //patch for sm718aa, when set 80028[28] from 0 to 1, failed some time. needs to set the master
+            //clock to 56mhz.
+            clock0 = peekRegisterDWord(MODE0_GATE);
+            pokeRegisterDWord(MODE0_GATE, FIELD_SET(clock0, MODE0_GATE, MCLK, 42MHZ)); 
+            clock1 = peekRegisterDWord(MODE1_GATE);
+            pokeRegisterDWord(MODE1_GATE, FIELD_SET(clock1, MODE1_GATE, MCLK, 42MHZ));                 
+        }
+#endif
+        pokeRegisterDWord(PRIMARY_DISPLAY_CTRL, control);
+#if Validate_718_AA
+        //if (hwDeviceExtension1[0]->ChipID==0x718 ||
+        //    hwDeviceExtension1[1]->ChipID==0x718)
+        {
+             //patch for sm718aa, restore mclk.
+            pokeRegisterDWord(MODE0_GATE, clock0); 
+            pokeRegisterDWord(MODE1_GATE, clock1); 
+
+            //Reset video memory, otherwise, screen would show garbage.
+            MiscControl= peekRegisterDWord(MISC_CTRL);
+            MiscControl= FIELD_SET(MiscControl, MISC_CTRL, LOCALMEM_RESET, RESET);
+            pokeRegisterDWord(MISC_CTRL, MiscControl);
+            MiscControl= FIELD_SET(MiscControl, MISC_CTRL, LOCALMEM_RESET, NORMAL);
+            pokeRegisterDWord(MISC_CTRL, MiscControl);            
+        }
+#endif
+
+       // DDKDEBUGPRINT((DISPLAY_LEVEL, "(setPath) PRIMARY_DISPLAY_CTRL: %x\n", peekRegisterDWord(PRIMARY_DISPLAY_CTRL)));
+    }
+    else    /* CRT Path */
+    {
+        control = peekRegisterDWord(SECONDARY_DISPLAY_CTRL);
+    
+        if (dispState == DISP_ON)
+        {
+            /* Adjust the Clock polarity */
+            if (modeParam.clock_phase_polarity == POS)
+                control = FIELD_SET(control, SECONDARY_DISPLAY_CTRL, CLOCK_PHASE, ACTIVE_HIGH);
+            else
+                control = FIELD_SET(control, SECONDARY_DISPLAY_CTRL, CLOCK_PHASE, ACTIVE_LOW);
+                
+            /* Adjust the VSync polarity */
+            if (modeParam.vertical_sync_polarity == POS)
+                control = FIELD_SET(control, SECONDARY_DISPLAY_CTRL, VSYNC_PHASE, ACTIVE_HIGH);
+            else
+                control = FIELD_SET(control, SECONDARY_DISPLAY_CTRL, VSYNC_PHASE, ACTIVE_LOW);
+    
+            /* Adjust the HSync polarity */
+            if (modeParam.horizontal_sync_polarity == POS)
+                control = FIELD_SET(control, SECONDARY_DISPLAY_CTRL, HSYNC_PHASE, ACTIVE_HIGH);
+            else
+                control = FIELD_SET(control, SECONDARY_DISPLAY_CTRL, HSYNC_PHASE, ACTIVE_LOW);
+
+            /* Display control is not swapped, so use the normal display data flow */
+            if (dispControl == PRIMARY_CTRL)
+                control = FIELD_SET(control, SECONDARY_DISPLAY_CTRL, SELECT, PRIMARY);
+            else
+                control = FIELD_SET(control, SECONDARY_DISPLAY_CTRL, SELECT, SECONDARY);
+            
+            /* Enable the CRT Pixel */
+            control = FIELD_SET(control, SECONDARY_DISPLAY_CTRL, BLANK, OFF);
+        }
+        else
+        {
+            /* Disable the CRT Pixel */
+            control = FIELD_SET(control, SECONDARY_DISPLAY_CTRL, BLANK, ON);
+        }    
+
+        pokeRegisterDWord(SECONDARY_DISPLAY_CTRL, control);
+
+        //DDKDEBUGPRINT((DISPLAY_LEVEL, "(setPath) SECONDARY_DISPLAY_CTRL: %x\n", peekRegisterDWord(SECONDARY_DISPLAY_CTRL)));
+    }
+}
+
+/*
+ * This function gets the CRT2 Monitor Detection Threshold value.
+ *
+ * Input:
+ *      pRedValue   - Pointer to a variable to store the Red color threshold
+ *                    value.
+ *      pGreenValue - Pointer to a variable to store the Green color threshold
+ *                    value.
+ *      pBlueValue  - Pointer to a variable to store the Blue color threshold
+ *                    value. 
+ */
+void getCRTDetectThreshold(
+    unsigned char *pRedValue,
+    unsigned char *pGreenValue,
+    unsigned char *pBlueValue
+)
+{
+    unsigned long value;
+    
+    value = peekRegisterDWord(SECONDARY_MONITOR_DETECT);
+
+    if (pRedValue != (unsigned char *)0)
+        *pRedValue = (unsigned char)FIELD_GET(value, SECONDARY_MONITOR_DETECT, RED);
+        
+    if (pGreenValue != (unsigned char *)0)
+        *pGreenValue = (unsigned char)FIELD_GET(value, SECONDARY_MONITOR_DETECT, GREEN);
+        
+    if (pBlueValue != (unsigned char *)0)
+        *pBlueValue = (unsigned char)FIELD_GET(value, SECONDARY_MONITOR_DETECT, BLUE);
+}
+
+/*
+ * This function detects if the CRT monitor is attached.
+ *
+ * Input:
+ *      redValue    - Threshold value to be detected on the red color.
+ *      greenValue  - Threshold value to be detected on the green color.
+ *      blueValue   - Threshold value to be detected on the blue color.
+ *
+ * Output:
+ *      0   - Success
+ *     -1   - Fail 
+ */
+long ddk750_detectCRTMonitor(
+    unsigned char redValue,
+    unsigned char greenValue,
+    unsigned char blueValue
+)
+{
+    unsigned long value, red, green, blue;
+    long result = (-1);
+    
+    /* Use the given red, green, and blue threshold value to detect the monitor or
+       default. */
+    if (redValue != 0)
+        red = redValue;
+    else
+        red = DEFAULT_MON_DETECTION_THRESHOLD;
+        
+    if (greenValue != 0)
+        green = greenValue;
+    else
+        green = DEFAULT_MON_DETECTION_THRESHOLD;
+        
+    if (blueValue != 0)
+        blue = blueValue;
+    else
+        blue = DEFAULT_MON_DETECTION_THRESHOLD;
+        
+    /* Set the RGB Threshold value and enable the monitor detection. */
+    value = ((unsigned long)red << 16) |
+            ((unsigned long)green << 8) |
+            ((unsigned long)blue);
+    value = FIELD_SET(value, SECONDARY_MONITOR_DETECT, ENABLE, ENABLE);
+    pokeRegisterDWord(SECONDARY_MONITOR_DETECT, value);
+    
+    /* Add some delay here. Otherwise, the detection is not stable. */
+    value = 0xFFFF;
+    while (value--);
+    
+    /* Check if the monitor is detected. */
+    if (FIELD_GET(peekRegisterDWord(SECONDARY_MONITOR_DETECT), SECONDARY_MONITOR_DETECT, VALUE) ==
+        SECONDARY_MONITOR_DETECT_VALUE_ENABLE)
+    {
+        result = 0;
+    }
+    
+    /* Disable the Monitor Detect Enable bit. Somehow, enabling this bit will 
+       cause the CRT to lose display. */
+    value = peekRegisterDWord(SECONDARY_MONITOR_DETECT);
+    value = FIELD_SET(value, SECONDARY_MONITOR_DETECT, ENABLE, DISABLE);
+    pokeRegisterDWord(SECONDARY_MONITOR_DETECT, value);
+
+    return result;
+}
+
+/*
+ * This function set the logical display output.
+ *
+ * The output is called logical because it is independent of physical implementation.
+ * For example, CRT2 only mode is not using the internal secondary control. It uses the
+ * Primary Control with its output directed to CRT DAC.
+ *
+ * Input:
+ *      output          - Logical Display output
+ *      dispCtrlUsage   - Display Control Flag Usage:
+ *                          0 : Use primary display control (PRIMARY_CTRL) to control 
+ *                              primary output (LCD1 & CRT1) and use secondary display 
+ *                              control (SECONDARY_CTRL) to control secondary output 
+ *                              (CRT2 & LCD2)
+ *                          1 : Use primary display control (PRIMARY_CTRL) to control 
+ *                              secondary output (LCD2 & CRT2) and use secondary display 
+ *                              control (SECONDARY_CTRL) to control primary output 
+ *                              (LCD1 & CRT1)
+ *
+ * Output:
+ *      0   - Success
+ *     -1   - Fail 
+ */
+long setLogicalDispOutput(
+
+    disp_output_t output,
+    unsigned char dispCtrlUsage
+)
+{
+    unsigned long ulReg;
+
+    //DDKDEBUGPRINT((DISPLAY_LEVEL, "setLogicalDispOutput\n"));
+
+    switch (output)
+    {
+        case NO_DISPLAY:
+        {
+            //DDKDEBUGPRINT((DISPLAY_LEVEL, "NO_DISPLAY\n"));
+        
+            /* In here, all the display device has to be turned off first before the
+               the display control. */
+            swPanelPowerSequence(DISP_OFF, 4);                  /* Turn off Panel */
+            setDAC(DISP_OFF);                                   /* Turn off DAC */
+            setDPMS(DPMS_OFF);                                  /* Turn off DPMS */
+    
+            setDisplayControl(PRIMARY_CTRL, DISP_OFF);          /* Turn off Panel control */
+            setDisplayControl(SECONDARY_CTRL, DISP_OFF);        /* Turn off CRT control */
+
+            setPath(PANEL_PATH, PRIMARY_CTRL, DISP_OFF);        /* Turn off Panel path */
+            setPath(CRT_PATH, PRIMARY_CTRL, DISP_OFF);          /* Turn off CRT path */
+            break;
+        }    
+        case LCD1_ONLY:
+        {
+            //DDKDEBUGPRINT((DISPLAY_LEVEL, "LCD1_ONLY\n"));
+
+            /* 
+             * 1. Set all the display control and the display path 
+             */
+            if (dispCtrlUsage == 0)
+            {
+                /* Turn on Primary control */
+                setDisplayControl(PRIMARY_CTRL, DISP_ON);
+                if (isScalingEnabled(PRIMARY_CTRL) == 1)
+                {
+                    setDisplayControl(SECONDARY_CTRL, DISP_ON);     /* Turn on CRT control */
+                    setPath(PANEL_PATH, SECONDARY_CTRL, DISP_ON);   /* Turn on Panel Path and use Secondary data */
+                }
+                else
+                {
+                    setDisplayControl(SECONDARY_CTRL, DISP_OFF);    /* Turn off CRT control */
+                    setPath(PANEL_PATH, PRIMARY_CTRL, DISP_ON);     /* Turn on Panel Path and use panel data */
+                }
+                setPath(CRT_PATH, PRIMARY_CTRL, DISP_OFF);          /* Turn off CRT Path */
+            }
+            else
+            {
+                setDisplayControl(PRIMARY_CTRL, DISP_OFF);          /* Turn off Primary control */
+                setDisplayControl(SECONDARY_CTRL, DISP_ON);         /* Turn on Secondary control */
+                setPath(PANEL_PATH, SECONDARY_CTRL, DISP_ON);       /* Turn on Panel Path and use Secondary data */
+                setPath(CRT_PATH, SECONDARY_CTRL, DISP_OFF);        /* Turn off CRT Path */
+            }
+            
+            /* 
+             * 2. Enable/disable the display devices. 
+             */
+            swPanelPowerSequence(DISP_ON, 4);                   /* Turn on Panel */
+#ifdef ENABLE_PANEL_DAC
+            /* When using Analog CRT connected to the DVI channel, the DAC needs
+               to be turned on. The power is using the same power as CRT DAC. */
+            setDAC(DISP_ON);                                    /* Turn on DAC */
+#else
+            setDAC(DISP_OFF);                                   /* Turn off DAC */
+#endif
+            setDPMS(DPMS_OFF);                                  /* Turn off DPMS */
+            break;
+        }    
+        case LCD2_ONLY:
+        {
+            //DDKDEBUGPRINT((DISPLAY_LEVEL, "LCD2_ONLY\n"));
+
+            /* 
+             * 1. Check the conditions 
+             */
+            /* Can not enable LCD22 when the panel type is not 18-bit panel. */            
+            if (getPanelType() != TFT_18BIT)
+                return (-1);
+            
+            /* 
+             * 2. Set all the display control and the display path 
+             */
+            if (dispCtrlUsage == 0)
+            {
+                setDisplayControl(PRIMARY_CTRL, DISP_ON);           /* Turn on Primary control */                
+                if (isScalingEnabled(PRIMARY_CTRL) == 1)
+                {
+                    setDisplayControl(SECONDARY_CTRL, DISP_ON);     /* Turn on Secondary control */
+                    setPath(CRT_PATH, SECONDARY_CTRL, DISP_ON);     /* Turn on CRT Path and use Secondary data */
+                }
+                else
+                {
+                    setDisplayControl(SECONDARY_CTRL, DISP_OFF);    /* Turn off Secondary control */
+                    setPath(CRT_PATH, PRIMARY_CTRL, DISP_ON);       /* Turn on CRT Path and use primary data */
+                }
+                setPath(PANEL_PATH, PRIMARY_CTRL, DISP_OFF);        /* Turn off Panel Path */
+            }
+            else
+            {
+                setDisplayControl(PRIMARY_CTRL, DISP_OFF);          /* Turn off Primary control */                
+                setDisplayControl(SECONDARY_CTRL, DISP_ON);         /* Turn on Secondary control */
+                setPath(CRT_PATH, SECONDARY_CTRL, DISP_ON);         /* Turn off CRT Path and use secondary data */
+                setPath(PANEL_PATH, SECONDARY_CTRL, DISP_OFF);      /* Turn off Panel Path */
+            }
+            
+            /* 
+             * 3. Enable/disable the display devices. 
+             */
+            swPanelPowerSequence(DISP_OFF, 4);                  /* Turn off Panel 1 */
+            setDAC(DISP_OFF);                                   /* Turn off DAC */
+            setDPMS(DPMS_OFF);                                  /* Turn off DPMS */
+            break;
+        }
+        case CRT2_ONLY:
+        {
+            //DDKDEBUGPRINT((DISPLAY_LEVEL, "CRT2_ONLY\n"));
+
+            /* 
+             * 1. Set all the display control and the display path 
+             */
+            if (dispCtrlUsage == 0)
+            {
+                setDisplayControl(PRIMARY_CTRL, DISP_ON);           /* Turn on Primary Control */
+                setDisplayControl(SECONDARY_CTRL, DISP_OFF);        /* Turn off Secondary control */
+                setPath(PANEL_PATH, SECONDARY_CTRL, DISP_OFF);      /* Turn off Panel Path */
+                setPath(CRT_PATH, PRIMARY_CTRL, DISP_ON);           /* Turn off CRT Path and use Primary data */
+            }
+            else
+            {
+                setDisplayControl(PRIMARY_CTRL, DISP_OFF);          /* Turn off Primary Control */
+                setDisplayControl(SECONDARY_CTRL, DISP_ON);         /* Turn on Secondary control */
+                setPath(PANEL_PATH, SECONDARY_CTRL, DISP_OFF);      /* Turn off Panel Path */
+                setPath(CRT_PATH, SECONDARY_CTRL, DISP_ON);         /* Turn off CRT Path and use Primary data */
+            }
+            
+            /* 
+             * 2. Enable/disable the display devices. 
+             */
+            swPanelPowerSequence(DISP_OFF, 4);                  /* Turn off Panel */
+            setDAC(DISP_ON);                                    /* Turn on DAC */
+            setDPMS(DPMS_ON);                                   /* Turn on DPMS to drive CRT */
+            break;
+        }
+        case LCD1_CRT2_SIMUL: /* Panel and CRT same content */
+        {
+            //DDKDEBUGPRINT((DISPLAY_LEVEL, "LCD1_CRT2_SIMUL\n"));
+            
+            /* 
+             * 1. Set all the display control and the display path 
+             */
+            if (dispCtrlUsage == 0)
+            {
+                setDisplayControl(PRIMARY_CTRL, DISP_ON);           /* Turn on Primary Control */
+                if (isScalingEnabled(PRIMARY_CTRL) == 1)
+                {
+                    setDisplayControl(SECONDARY_CTRL, DISP_ON);     /* Turn on Secondary control */
+                    setPath(PANEL_PATH, SECONDARY_CTRL, DISP_ON);   /* Turn on Panel Path and use Secondary data */
+                }
+                else
+                {
+                    setDisplayControl(SECONDARY_CTRL, DISP_OFF);    /* Turn off Secondary control */
+                    setPath(PANEL_PATH, PRIMARY_CTRL, DISP_ON);     /* Turn on Panel Path and use Primary data */
+                } 
+                setPath(CRT_PATH, PRIMARY_CTRL, DISP_ON);           /* Turn on CRT Path and use Primary data */
+            }
+            else
+            {
+                setDisplayControl(PRIMARY_CTRL, DISP_OFF);          /* Turn off Primary Control */
+                setDisplayControl(SECONDARY_CTRL, DISP_ON);         /* Turn on Secondary control */
+                setPath(PANEL_PATH, SECONDARY_CTRL, DISP_ON);       /* Turn on Panel Path and use Secondary data */
+                setPath(CRT_PATH, SECONDARY_CTRL, DISP_ON);         /* Turn on CRT Path and use Primary data */
+            }
+            
+            /* 
+             * 2. Enable/disable the display devices. 
+             */
+            swPanelPowerSequence(DISP_ON, 4);                   /* Turn on Panel */
+            setDAC(DISP_ON);                                    /* Turn on DAC */
+            setDPMS(DPMS_ON);                                   /* Turn on DPMS to drive CRT */
+            break;
+        }    
+        case LCD1_LCD2_SIMUL:
+        {
+            //DDKDEBUGPRINT((DISPLAY_LEVEL, "LCD1_LCD2_SIMUL\n"));
+            
+            /* 
+             * 1. Check the conditions 
+             */
+            /* Can not enable PANEL2 when the panel type is not 18-bit panel. */            
+            if (getPanelType() != TFT_18BIT)
+                return (-1);
+            
+            /* 
+             * 2. Set all the display control and the display path 
+             */
+            if (dispCtrlUsage == 0)
+            {    
+                setDisplayControl(PRIMARY_CTRL, DISP_ON);           /* Turn on Primary Control */
+                if (isScalingEnabled(PRIMARY_CTRL) == 1)
+                {
+                    setDisplayControl(SECONDARY_CTRL, DISP_ON);     /* Turn on Secondary control */
+                    setPath(PANEL_PATH, SECONDARY_CTRL, DISP_ON);   /* Turn on Panel Path and use Secondary data */
+                    setPath(CRT_PATH, SECONDARY_CTRL, DISP_ON);     /* Turn on CRT Path and use Secondary data */
+                }
+                else
+                {
+                    setDisplayControl(SECONDARY_CTRL, DISP_OFF);    /* Turn off Secondary control */
+                    setPath(PANEL_PATH, PRIMARY_CTRL, DISP_ON);     /* Turn on Panel Path and use Primary data */
+                    setPath(CRT_PATH, PRIMARY_CTRL, DISP_ON);       /* Turn on CRT Path and use Primary data */
+                }
+            }
+            else
+            {
+                setDisplayControl(PRIMARY_CTRL, DISP_OFF);          /* Turn off Primary Control */
+                setDisplayControl(SECONDARY_CTRL, DISP_ON);         /* Turn on Secondary control */
+                setPath(PANEL_PATH, SECONDARY_CTRL, DISP_ON);       /* Turn on Panel Path and use Secondary data */
+                setPath(CRT_PATH, SECONDARY_CTRL, DISP_ON);         /* Turn on CRT Path and use Secondary data */
+            }
+            
+            /* 
+             * 3. Enable/disable the display devices. 
+             */
+            swPanelPowerSequence(DISP_ON, 4);                   /* Turn on Panel */
+#ifdef ENABLE_PANEL_DAC
+            /* When using Analog CRT connected to the DVI channel, the DAC needs
+               to be turned on. The power is using the same power as CRT DAC. */
+            setDAC(DISP_ON);                                    /* Turn on DAC */
+#else
+            setDAC(DISP_OFF);                                   /* Turn off DAC */
+#endif
+            setDPMS(DPMS_OFF);                                  /* Turn off DPMS */
+            break;
+        }    
+        case CRT2_LCD2_SIMUL:
+        {
+            //DDKDEBUGPRINT((DISPLAY_LEVEL, "CRT2_LCD2_SIMUL\n"));
+            
+            /* 
+             * 1. Check the conditions 
+             */
+            /* Can not enable PANEL2 when the panel type is not 18-bit panel. */            
+            if (getPanelType() != TFT_18BIT)
+                return (-1);
+            
+            /* 
+             * 2. Set all the display control and the display path 
+             */
+            if (dispCtrlUsage == 0)
+            {
+                setDisplayControl(PRIMARY_CTRL, DISP_ON);           /* Turn on Primary Control */
+                if (isScalingEnabled(PRIMARY_CTRL) == 1)
+                {
+                    setDisplayControl(SECONDARY_CTRL, DISP_ON);     /* Turn on Secondary control */
+                    setPath(CRT_PATH, SECONDARY_CTRL, DISP_ON);     /* Turn on CRT Path and use Secondary data */
+                }
+                else
+                {
+                    setDisplayControl(SECONDARY_CTRL, DISP_OFF);    /* Turn off Secondary control */
+                    setPath(CRT_PATH, PRIMARY_CTRL, DISP_ON);       /* Turn on CRT Path and use Primary data */
+                }
+                setPath(PANEL_PATH, PRIMARY_CTRL, DISP_OFF);        /* Turn on Panel Path and use Primary data */
+            }
+            else
+            {
+                setDisplayControl(PRIMARY_CTRL, DISP_OFF);          /* Turn off Primary Control */
+                setDisplayControl(SECONDARY_CTRL, DISP_ON);         /* Turn on Secondary control */
+                setPath(CRT_PATH, SECONDARY_CTRL, DISP_ON);         /* Turn on CRT Path and use Secondary data */
+                setPath(PANEL_PATH, SECONDARY_CTRL, DISP_OFF);      /* Turn on Panel Path and use Primary data */
+            }
+            
+            /* 
+             * 3. Enable/disable the display devices. 
+             */
+            swPanelPowerSequence(DISP_ON, 4);                   /* Turn on Panel */
+            setDAC(DISP_ON);                                    /* Turn on DAC */
+            setDPMS(DPMS_ON);                                   /* Turn on DPMS to drive CRT */
+            break;
+        }    
+        case LCD1_LCD2_CRT2_SIMUL:
+        {
+            //DDKDEBUGPRINT((DISPLAY_LEVEL, "LCD1_LCD2_CRT2_SIMUL\n"));
+            
+            /* 
+             * 1. Check the conditions
+             */
+            /* Can not enable PANEL2 when the panel type is not 18-bit panel. */            
+            if (getPanelType() != TFT_18BIT)
+                return (-1);
+            
+            /* 
+             * 2. Set all the display control and the display path 
+             */
+            if (dispCtrlUsage == 0)
+            {            
+                setDisplayControl(PRIMARY_CTRL, DISP_ON);           /* Turn on Primary Control */
+                if (isScalingEnabled(PRIMARY_CTRL) == 1)
+                {
+                    setDisplayControl(SECONDARY_CTRL, DISP_ON);     /* Turn on Secondary control */
+                    setPath(PANEL_PATH, SECONDARY_CTRL, DISP_ON);   /* Turn on Panel Path and use Secondary data */
+                    setPath(CRT_PATH, SECONDARY_CTRL, DISP_ON);     /* Turn on CRT Path and use Secondary data */
+                }
+                else
+                {
+                    setDisplayControl(SECONDARY_CTRL, DISP_OFF);    /* Turn off Secondary control */
+                    setPath(PANEL_PATH, PRIMARY_CTRL, DISP_ON);     /* Turn on Panel Path and use Primary data */
+                    setPath(CRT_PATH, PRIMARY_CTRL, DISP_ON);       /* Turn on CRT Path and use Primary data */
+                }
+            }
+            else
+            {
+                setDisplayControl(PRIMARY_CTRL, DISP_OFF);          /* Turn off Primary Control */
+                setDisplayControl(SECONDARY_CTRL, DISP_ON);         /* Turn on Secondary control */
+                setPath(PANEL_PATH, SECONDARY_CTRL, DISP_ON);       /* Turn on Panel Path and use Secondary data */
+                setPath(CRT_PATH, SECONDARY_CTRL, DISP_ON);         /* Turn on CRT Path and use Secondary data */
+            }
+            
+            /* 
+             * 3. Enable/disable the display devices. 
+             */
+            swPanelPowerSequence(DISP_ON, 4);                   /* Turn on Panel */
+            setDAC(DISP_ON);                                    /* Turn on DAC */
+            setDPMS(DPMS_ON);                                   /* Turn on DPMS to drive CRT */
+            break;
+        }
+        case LCD1_CRT2_DUAL: /* Panel and CRT different content */
+        {
+            //DDKDEBUGPRINT((DISPLAY_LEVEL, "LCD1_CRT2_DUAL\n"));
+            
+            /* 
+             * 1. Check the conditions
+             */
+            /* This combination is not valid if panel 1 requires scaling and display
+               control is not swapped. */
+          //  if (isScalingEnabled(PRIMARY_CTRL) == 1)
+          //      return (-1);
+
+            /* 
+             * 2. Set all the display control and the display path 
+             */
+            setDisplayControl(PRIMARY_CTRL, DISP_ON);           /* Turn on Primary Control */
+            setDisplayControl(SECONDARY_CTRL, DISP_ON);         /* Turn on Secondary control */
+
+
+            if (dispCtrlUsage == 0)
+            {
+                setPath(PANEL_PATH, PRIMARY_CTRL, DISP_ON);     /* Turn on Panel Path and use Primary data */
+                setPath(CRT_PATH, SECONDARY_CTRL, DISP_ON);     /* Turn on CRT Path and use Secondary data */
+
+
+            }
+            else
+            {
+                setPath(PANEL_PATH, SECONDARY_CTRL, DISP_ON);   /* Turn on Panel Path and use Secondary data */
+                setPath(CRT_PATH, PRIMARY_CTRL, DISP_ON);       /* Turn on CRT Path and use Primary data */
+
+
+            }
+            
+            /* 
+             * 3. Enable/disable the display devices. 
+             */
+            swPanelPowerSequence(DISP_ON, 4);                   /* Turn on Panel */
+            setDAC(DISP_ON);                                    /* Turn on DAC */
+            setDPMS(DPMS_ON);                                   /* Turn on DPMS to drive CRT */
+            break;
+        }    
+        case LCD1_LCD2_DUAL:
+        {
+            //DDKDEBUGPRINT((DISPLAY_LEVEL, "LCD1_LCD2_DUAL\n"));
+            
+            /* 
+             * 1. Check the conditions
+             */    
+            /* This combination is not valid if panel requires scaling and display
+               control is not swapped. */
+           // if (isScalingEnabled(PRIMARY_CTRL) == 1)
+           //     return (-1);
+                
+            /* Can not enable PANEL2 when the panel type is not 18-bit panel. */            
+            if (getPanelType() != TFT_18BIT)
+                return (-1);
+            
+            /* 
+             * 2. Set all the display control and the display path 
+             */
+            setDisplayControl(PRIMARY_CTRL, DISP_ON);           /* Turn on Primary Control */
+            setDisplayControl(SECONDARY_CTRL, DISP_ON);         /* Turn on Secondary control */
+            if (dispCtrlUsage == 0)
+            {
+                setPath(PANEL_PATH, PRIMARY_CTRL, DISP_ON);     /* Turn on Panel Path and use Primary data */
+                setPath(CRT_PATH, SECONDARY_CTRL, DISP_ON);     /* Turn on CRT Path and use Secondary data */
+            }
+            else
+            {
+                setPath(PANEL_PATH, SECONDARY_CTRL, DISP_ON);   /* Turn on Panel Path and use Secondary data */
+                setPath(CRT_PATH, PRIMARY_CTRL, DISP_ON);       /* Turn on CRT Path and use Primary data */
+            }
+            
+            /* 
+             * 3. Enable/disable the display devices. 
+             */
+            swPanelPowerSequence(DISP_ON, 4);                   /* Turn on Panel */
+#ifdef ENABLE_PANEL_DAC
+            /* When using Analog CRT connected to the DVI channel, the DAC needs
+               to be turned on. The power is using the same power as CRT DAC. */
+            setDAC(DISP_ON);                                    /* Turn on DAC */
+#else
+            setDAC(DISP_OFF);                                   /* Turn off DAC */
+#endif
+            setDPMS(DPMS_OFF);                                  /* Turn off DPMS to drive CRT */
+            break;
+        }
+        case LCD1_LCD2_CRT2_DUAL:
+        {
+            //DDKDEBUGPRINT((DISPLAY_LEVEL, "LCD1_LCD2_CRT2_DUAL\n"));
+            
+            /* 
+             * 1. Check the conditions
+             */    
+            /* This combination is not valid if panel requires scaling and display
+               control is not swapped. */
+            //if (isScalingEnabled(PRIMARY_CTRL) == 1)
+              //  return (-1);
+                
+            /* Can not enable PANEL2 when the panel type is not 18-bit panel. */            
+            if (getPanelType() != TFT_18BIT)
+                return (-1);
+            
+            /* 
+             * 2. Set all the display control and the display path 
+             */
+            setDisplayControl(PRIMARY_CTRL, DISP_ON);           /* Turn on Primary Control */
+            setDisplayControl(SECONDARY_CTRL, DISP_ON);         /* Turn on Secondary control */            
+            if (dispCtrlUsage == 0)
+            {
+                setPath(PANEL_PATH, PRIMARY_CTRL, DISP_ON);     /* Turn on Panel Path and use Primary data */
+                setPath(CRT_PATH, SECONDARY_CTRL, DISP_ON);     /* Turn on CRT Path and use Secondary data */
+            }
+            else
+            {
+                setPath(PANEL_PATH, SECONDARY_CTRL, DISP_ON);   /* Turn on Panel Path and use Secondary data */
+                setPath(CRT_PATH, PRIMARY_CTRL, DISP_ON);       /* Turn on CRT Path and use Primary data */
+            }
+            
+            /* 
+             * 3. Enable/disable the display devices. 
+             */
+            swPanelPowerSequence(DISP_ON, 4);                   /* Turn on Panel */
+            setDAC(DISP_ON);                                    /* Turn on DAC */
+            setDPMS(DPMS_ON);                                   /* Turn on DPMS to drive CRT */
+            break;
+        }
+    }
+    
+    return 0;
+}
+
+/*
+ * This function set the logical display output.
+ *
+ * The output is called logical because it is independent of physical implementation.
+ * For example, CRT2 only mode is not using the internal secondary control. It uses the
+ * Primary Control with its output directed to CRT DAC.
+ *
+ * Input:
+ *		isSnd	   		- is or not the second view
+ *      output          - Logical Display output
+ *      dispCtrlUsage   - Display Control Flag Usage:
+ *                          0 : Use primary display control (PRIMARY_CTRL) to control 
+ *                              primary output (LCD1 & CRT1) and use secondary display 
+ *                              control (SECONDARY_CTRL) to control secondary output 
+ *                              (CRT2 & LCD2)
+ *                          1 : Use primary display control (PRIMARY_CTRL) to control 
+ *                              secondary output (LCD2 & CRT2) and use secondary display 
+ *                              control (SECONDARY_CTRL) to control primary output 
+ *                              (LCD1 & CRT1)
+ *
+ * Output:
+ *      0   - Success
+ *     -1   - Fail 
+ */
+long setLogicalDispOutputExt(
+    long isSecondDisplay, 
+    disp_output_t output,
+    unsigned char dispCtrlUsage
+)
+{
+    unsigned long ulReg;
+
+    //DDKDEBUGPRINT((DISPLAY_LEVEL, "setLogicalDispOutputExt\n"));
+
+    switch (output)
+    {
+        case NO_DISPLAY:
+        {
+            //DDKDEBUGPRINT((DISPLAY_LEVEL, "NO_DISPLAY\n"));
+        
+            /* In here, all the display device has to be turned off first before the
+               the display control. */
+            swPanelPowerSequence(DISP_OFF, 4);                  /* Turn off Panel */
+            setDAC(DISP_OFF);                                   /* Turn off DAC */
+            setDPMS(DPMS_OFF);                                  /* Turn off DPMS */
+    
+            setDisplayControl(PRIMARY_CTRL, DISP_OFF);          /* Turn off Panel control */
+            setDisplayControl(SECONDARY_CTRL, DISP_OFF);        /* Turn off CRT control */
+
+            setPath(PANEL_PATH, PRIMARY_CTRL, DISP_OFF);        /* Turn off Panel path */
+            setPath(CRT_PATH, PRIMARY_CTRL, DISP_OFF);          /* Turn off CRT path */
+            break;
+        }    
+        case LCD1_ONLY:
+        {
+            //DDKDEBUGPRINT((DISPLAY_LEVEL, "LCD1_ONLY\n"));
+
+            /* 
+             * 1. Set all the display control and the display path 
+             */
+            if (dispCtrlUsage == 0)
+            {
+                /* Turn on Primary control */
+                setDisplayControl(PRIMARY_CTRL, DISP_ON);
+                if (isScalingEnabled(PRIMARY_CTRL) == 1)
+                {
+                    setDisplayControl(SECONDARY_CTRL, DISP_ON);     /* Turn on CRT control */
+                    setPath(PANEL_PATH, SECONDARY_CTRL, DISP_ON);   /* Turn on Panel Path and use Secondary data */
+                }
+                else
+                {
+                    setDisplayControl(SECONDARY_CTRL, DISP_OFF);    /* Turn off CRT control */
+                    setPath(PANEL_PATH, PRIMARY_CTRL, DISP_ON);     /* Turn on Panel Path and use panel data */
+                }
+                setPath(CRT_PATH, PRIMARY_CTRL, DISP_OFF);          /* Turn off CRT Path */
+            }
+            else
+            {
+                setDisplayControl(PRIMARY_CTRL, DISP_OFF);          /* Turn off Primary control */
+                setDisplayControl(SECONDARY_CTRL, DISP_ON);         /* Turn on Secondary control */
+                setPath(PANEL_PATH, SECONDARY_CTRL, DISP_ON);       /* Turn on Panel Path and use Secondary data */
+                setPath(CRT_PATH, SECONDARY_CTRL, DISP_OFF);        /* Turn off CRT Path */
+            }
+            
+            /* 
+             * 2. Enable/disable the display devices. 
+             */
+            swPanelPowerSequence(DISP_ON, 4);                   /* Turn on Panel */
+#ifdef ENABLE_PANEL_DAC
+            /* When using Analog CRT connected to the DVI channel, the DAC needs
+               to be turned on. The power is using the same power as CRT DAC. */
+            setDAC(DISP_ON);                                    /* Turn on DAC */
+#else
+            setDAC(DISP_OFF);                                   /* Turn off DAC */
+#endif
+            setDPMS(DPMS_OFF);                                  /* Turn off DPMS */
+            break;
+        }    
+        case LCD2_ONLY:
+        {
+            //DDKDEBUGPRINT((DISPLAY_LEVEL, "LCD2_ONLY\n"));
+
+            /* 
+             * 1. Check the conditions 
+             */
+            /* Can not enable LCD22 when the panel type is not 18-bit panel. */            
+            if (getPanelType() != TFT_18BIT)
+                return (-1);
+            
+            /* 
+             * 2. Set all the display control and the display path 
+             */
+            if (dispCtrlUsage == 0)
+            {
+                setDisplayControl(PRIMARY_CTRL, DISP_ON);           /* Turn on Primary control */                
+                if (isScalingEnabled(PRIMARY_CTRL) == 1)
+                {
+                    setDisplayControl(SECONDARY_CTRL, DISP_ON);     /* Turn on Secondary control */
+                    setPath(CRT_PATH, SECONDARY_CTRL, DISP_ON);     /* Turn on CRT Path and use Secondary data */
+                }
+                else
+                {
+                    setDisplayControl(SECONDARY_CTRL, DISP_OFF);    /* Turn off Secondary control */
+                    setPath(CRT_PATH, PRIMARY_CTRL, DISP_ON);       /* Turn on CRT Path and use primary data */
+                }
+                setPath(PANEL_PATH, PRIMARY_CTRL, DISP_OFF);        /* Turn off Panel Path */
+            }
+            else
+            {
+                setDisplayControl(PRIMARY_CTRL, DISP_OFF);          /* Turn off Primary control */                
+                setDisplayControl(SECONDARY_CTRL, DISP_ON);         /* Turn on Secondary control */
+                setPath(CRT_PATH, SECONDARY_CTRL, DISP_ON);         /* Turn off CRT Path and use secondary data */
+                setPath(PANEL_PATH, SECONDARY_CTRL, DISP_OFF);      /* Turn off Panel Path */
+            }
+            
+            /* 
+             * 3. Enable/disable the display devices. 
+             */
+            swPanelPowerSequence(DISP_OFF, 4);                  /* Turn off Panel 1 */
+            setDAC(DISP_OFF);                                   /* Turn off DAC */
+            setDPMS(DPMS_OFF);                                  /* Turn off DPMS */
+            break;
+        }
+        case CRT2_ONLY:
+        {
+            //DDKDEBUGPRINT((DISPLAY_LEVEL, "CRT2_ONLY\n"));
+
+            /* 
+             * 1. Set all the display control and the display path 
+             */
+            if (dispCtrlUsage == 0)
+            {
+                setDisplayControl(PRIMARY_CTRL, DISP_ON);           /* Turn on Primary Control */
+                setDisplayControl(SECONDARY_CTRL, DISP_OFF);        /* Turn off Secondary control */
+                setPath(PANEL_PATH, SECONDARY_CTRL, DISP_OFF);      /* Turn off Panel Path */
+                setPath(CRT_PATH, PRIMARY_CTRL, DISP_ON);           /* Turn off CRT Path and use Primary data */
+            }
+            else
+            {
+                setDisplayControl(PRIMARY_CTRL, DISP_OFF);          /* Turn off Primary Control */
+                setDisplayControl(SECONDARY_CTRL, DISP_ON);         /* Turn on Secondary control */
+                setPath(PANEL_PATH, SECONDARY_CTRL, DISP_OFF);      /* Turn off Panel Path */
+                setPath(CRT_PATH, SECONDARY_CTRL, DISP_ON);         /* Turn off CRT Path and use Primary data */
+            }
+            
+            /* 
+             * 2. Enable/disable the display devices. 
+             */
+            swPanelPowerSequence(DISP_OFF, 4);                  /* Turn off Panel */
+            setDAC(DISP_ON);                                    /* Turn on DAC */
+            setDPMS(DPMS_ON);                                   /* Turn on DPMS to drive CRT */
+            break;
+        }
+        case LCD1_CRT2_SIMUL: /* Panel and CRT same content */
+        {
+            //DDKDEBUGPRINT((DISPLAY_LEVEL, "LCD1_CRT2_SIMUL\n"));
+            
+            /* 
+             * 1. Set all the display control and the display path 
+             */
+            if (dispCtrlUsage == 0)
+            {
+                setDisplayControl(PRIMARY_CTRL, DISP_ON);           /* Turn on Primary Control */
+                if (isScalingEnabled(PRIMARY_CTRL) == 1)
+                {
+                    setDisplayControl(SECONDARY_CTRL, DISP_ON);     /* Turn on Secondary control */
+                    setPath(PANEL_PATH, SECONDARY_CTRL, DISP_ON);   /* Turn on Panel Path and use Secondary data */
+                }
+                else
+                {
+                    setDisplayControl(SECONDARY_CTRL, DISP_OFF);    /* Turn off Secondary control */
+                    setPath(PANEL_PATH, PRIMARY_CTRL, DISP_ON);     /* Turn on Panel Path and use Primary data */
+                }            
+                setPath(CRT_PATH, PRIMARY_CTRL, DISP_ON);           /* Turn on CRT Path and use Primary data */
+            }
+            else
+            {
+                setDisplayControl(PRIMARY_CTRL, DISP_OFF);          /* Turn off Primary Control */
+                setDisplayControl(SECONDARY_CTRL, DISP_ON);         /* Turn on Secondary control */
+                setPath(PANEL_PATH, SECONDARY_CTRL, DISP_ON);       /* Turn on Panel Path and use Secondary data */
+                setPath(CRT_PATH, SECONDARY_CTRL, DISP_ON);         /* Turn on CRT Path and use Primary data */
+            }
+            
+            /* 
+             * 2. Enable/disable the display devices. 
+             */
+            swPanelPowerSequence(DISP_ON, 4);                   /* Turn on Panel */
+            setDAC(DISP_ON);                                    /* Turn on DAC */
+            setDPMS(DPMS_ON);                                   /* Turn on DPMS to drive CRT */
+            break;
+        }    
+        case LCD1_LCD2_SIMUL:
+        {
+            //DDKDEBUGPRINT((DISPLAY_LEVEL, "LCD1_LCD2_SIMUL\n"));
+            
+            /* 
+             * 1. Check the conditions 
+             */
+            /* Can not enable PANEL2 when the panel type is not 18-bit panel. */            
+            if (getPanelType() != TFT_18BIT)
+                return (-1);
+            
+            /* 
+             * 2. Set all the display control and the display path 
+             */
+            if (dispCtrlUsage == 0)
+            {    
+                setDisplayControl(PRIMARY_CTRL, DISP_ON);           /* Turn on Primary Control */
+                if (isScalingEnabled(PRIMARY_CTRL) == 1)
+                {
+                    setDisplayControl(SECONDARY_CTRL, DISP_ON);     /* Turn on Secondary control */
+                    setPath(PANEL_PATH, SECONDARY_CTRL, DISP_ON);   /* Turn on Panel Path and use Secondary data */
+                    setPath(CRT_PATH, SECONDARY_CTRL, DISP_ON);     /* Turn on CRT Path and use Secondary data */
+                }
+                else
+                {
+                    setDisplayControl(SECONDARY_CTRL, DISP_OFF);    /* Turn off Secondary control */
+                    setPath(PANEL_PATH, PRIMARY_CTRL, DISP_ON);     /* Turn on Panel Path and use Primary data */
+                    setPath(CRT_PATH, PRIMARY_CTRL, DISP_ON);       /* Turn on CRT Path and use Primary data */
+                }
+            }
+            else
+            {
+                setDisplayControl(PRIMARY_CTRL, DISP_OFF);          /* Turn off Primary Control */
+                setDisplayControl(SECONDARY_CTRL, DISP_ON);         /* Turn on Secondary control */
+                setPath(PANEL_PATH, SECONDARY_CTRL, DISP_ON);       /* Turn on Panel Path and use Secondary data */
+                setPath(CRT_PATH, SECONDARY_CTRL, DISP_ON);         /* Turn on CRT Path and use Secondary data */
+            }
+            
+            /* 
+             * 3. Enable/disable the display devices. 
+             */
+            swPanelPowerSequence(DISP_ON, 4);                   /* Turn on Panel */
+#ifdef ENABLE_PANEL_DAC
+            /* When using Analog CRT connected to the DVI channel, the DAC needs
+               to be turned on. The power is using the same power as CRT DAC. */
+            setDAC(DISP_ON);                                    /* Turn on DAC */
+#else
+            setDAC(DISP_OFF);                                   /* Turn off DAC */
+#endif
+            setDPMS(DPMS_OFF);                                  /* Turn off DPMS */
+            break;
+        }    
+        case CRT2_LCD2_SIMUL:
+        {
+            //DDKDEBUGPRINT((DISPLAY_LEVEL, "CRT2_LCD2_SIMUL\n"));
+            
+            /* 
+             * 1. Check the conditions 
+             */
+            /* Can not enable PANEL2 when the panel type is not 18-bit panel. */            
+            if (getPanelType() != TFT_18BIT)
+                return (-1);
+            
+            /* 
+             * 2. Set all the display control and the display path 
+             */
+            if (dispCtrlUsage == 0)
+            {
+                setDisplayControl(PRIMARY_CTRL, DISP_ON);           /* Turn on Primary Control */
+                if (isScalingEnabled(PRIMARY_CTRL) == 1)
+                {
+                    setDisplayControl(SECONDARY_CTRL, DISP_ON);     /* Turn on Secondary control */
+                    setPath(CRT_PATH, SECONDARY_CTRL, DISP_ON);     /* Turn on CRT Path and use Secondary data */
+                }
+                else
+                {
+                    setDisplayControl(SECONDARY_CTRL, DISP_OFF);    /* Turn off Secondary control */
+                    setPath(CRT_PATH, PRIMARY_CTRL, DISP_ON);       /* Turn on CRT Path and use Primary data */
+                }
+                setPath(PANEL_PATH, PRIMARY_CTRL, DISP_OFF);        /* Turn on Panel Path and use Primary data */
+            }
+            else
+            {
+                setDisplayControl(PRIMARY_CTRL, DISP_OFF);          /* Turn off Primary Control */
+                setDisplayControl(SECONDARY_CTRL, DISP_ON);         /* Turn on Secondary control */
+                setPath(CRT_PATH, SECONDARY_CTRL, DISP_ON);         /* Turn on CRT Path and use Secondary data */
+                setPath(PANEL_PATH, SECONDARY_CTRL, DISP_OFF);      /* Turn on Panel Path and use Primary data */
+            }
+            
+            /* 
+             * 3. Enable/disable the display devices. 
+             */
+            swPanelPowerSequence(DISP_ON, 4);                   /* Turn on Panel */
+            setDAC(DISP_ON);                                    /* Turn on DAC */
+            setDPMS(DPMS_ON);                                   /* Turn on DPMS to drive CRT */
+            break;
+        }    
+        case LCD1_LCD2_CRT2_SIMUL:
+        {
+            //DDKDEBUGPRINT((DISPLAY_LEVEL, "LCD1_LCD2_CRT2_SIMUL\n"));
+            
+            /* 
+             * 1. Check the conditions
+             */
+            /* Can not enable PANEL2 when the panel type is not 18-bit panel. */            
+            if (getPanelType() != TFT_18BIT)
+                return (-1);
+            
+            /* 
+             * 2. Set all the display control and the display path 
+             */
+            if (dispCtrlUsage == 0)
+            {            
+                setDisplayControl(PRIMARY_CTRL, DISP_ON);           /* Turn on Primary Control */
+                if (isScalingEnabled(PRIMARY_CTRL) == 1)
+                {
+                    setDisplayControl(SECONDARY_CTRL, DISP_ON);     /* Turn on Secondary control */
+                    setPath(PANEL_PATH, SECONDARY_CTRL, DISP_ON);   /* Turn on Panel Path and use Secondary data */
+                    setPath(CRT_PATH, SECONDARY_CTRL, DISP_ON);     /* Turn on CRT Path and use Secondary data */
+                }
+                else
+                {
+                    setDisplayControl(SECONDARY_CTRL, DISP_OFF);    /* Turn off Secondary control */
+                    setPath(PANEL_PATH, PRIMARY_CTRL, DISP_ON);     /* Turn on Panel Path and use Primary data */
+                    setPath(CRT_PATH, PRIMARY_CTRL, DISP_ON);       /* Turn on CRT Path and use Primary data */
+                }
+            }
+            else
+            {
+                setDisplayControl(PRIMARY_CTRL, DISP_OFF);          /* Turn off Primary Control */
+                setDisplayControl(SECONDARY_CTRL, DISP_ON);         /* Turn on Secondary control */
+                setPath(PANEL_PATH, SECONDARY_CTRL, DISP_ON);       /* Turn on Panel Path and use Secondary data */
+                setPath(CRT_PATH, SECONDARY_CTRL, DISP_ON);         /* Turn on CRT Path and use Secondary data */
+            }
+            
+            /* 
+             * 3. Enable/disable the display devices. 
+             */
+            swPanelPowerSequence(DISP_ON, 4);                   /* Turn on Panel */
+            setDAC(DISP_ON);                                    /* Turn on DAC */
+            setDPMS(DPMS_ON);                                   /* Turn on DPMS to drive CRT */
+            break;
+        }
+        case LCD1_CRT2_DUAL: /* Panel and CRT different content */
+        {
+            //DDKDEBUGPRINT((DISPLAY_LEVEL, "LCD1_CRT2_DUAL\n"));
+            
+            /* 
+             * 1. Check the conditions
+             */
+            /* This combination is not valid if panel 1 requires scaling and display
+               control is not swapped. */
+            if (isScalingEnabled(PRIMARY_CTRL) == 1)
+                return (-1);
+
+            /* 
+             * 2. Set all the display control and the display path 
+             */
+            if(!isSecondDisplay) 
+                setDisplayControl(PRIMARY_CTRL, DISP_ON);           /* Turn on Primary Control */
+            else
+                setDisplayControl(SECONDARY_CTRL, DISP_ON);         /* Turn on Secondary control */
+            if (dispCtrlUsage == 0)
+            {
+                if(!isSecondDisplay) 
+                    setPath(PANEL_PATH, PRIMARY_CTRL, DISP_ON);     /* Turn on Panel Path and use Primary data */
+                else
+                    setPath(CRT_PATH, SECONDARY_CTRL, DISP_ON);     /* Turn on CRT Path and use Secondary data */
+            }
+            else
+            {
+                if(isSecondDisplay)             
+                    setPath(PANEL_PATH, SECONDARY_CTRL, DISP_ON);   /* Turn on Panel Path and use Secondary data */
+                else
+                    setPath(CRT_PATH, PRIMARY_CTRL, DISP_ON);       /* Turn on CRT Path and use Primary data */
+            }
+            /* 
+             * 3. Enable/disable the display devices. 
+             */
+            swPanelPowerSequence(DISP_ON, 4);                   /* Turn on Panel */
+            setDAC(DISP_ON);                                    /* Turn on DAC */
+            setDPMS(DPMS_ON);                                   /* Turn on DPMS to drive CRT */
+            break;
+        }    
+        case LCD1_LCD2_DUAL:
+        {
+            //DDKDEBUGPRINT((DISPLAY_LEVEL, "LCD1_LCD2_DUAL\n"));
+            
+            /* 
+             * 1. Check the conditions
+             */    
+            /* This combination is not valid if panel requires scaling and display
+               control is not swapped. */
+            if (isScalingEnabled(PRIMARY_CTRL) == 1)
+                return (-1);
+                
+            /* Can not enable PANEL2 when the panel type is not 18-bit panel. */            
+            if (getPanelType() != TFT_18BIT)
+                return (-1);
+            
+            /* 
+             * 2. Set all the display control and the display path 
+             */
+            setDisplayControl(PRIMARY_CTRL, DISP_ON);           /* Turn on Primary Control */
+            setDisplayControl(SECONDARY_CTRL, DISP_ON);         /* Turn on Secondary control */
+            if (dispCtrlUsage == 0)
+            {
+                setPath(PANEL_PATH, PRIMARY_CTRL, DISP_ON);     /* Turn on Panel Path and use Primary data */
+                setPath(CRT_PATH, SECONDARY_CTRL, DISP_ON);     /* Turn on CRT Path and use Secondary data */
+            }
+            else
+            {
+                setPath(PANEL_PATH, SECONDARY_CTRL, DISP_ON);   /* Turn on Panel Path and use Secondary data */
+                setPath(CRT_PATH, PRIMARY_CTRL, DISP_ON);       /* Turn on CRT Path and use Primary data */
+            }
+            
+            /* 
+             * 3. Enable/disable the display devices. 
+             */
+            swPanelPowerSequence(DISP_ON, 4);                   /* Turn on Panel */
+#ifdef ENABLE_PANEL_DAC
+            /* When using Analog CRT connected to the DVI channel, the DAC needs
+               to be turned on. The power is using the same power as CRT DAC. */
+            setDAC(DISP_ON);                                    /* Turn on DAC */
+#else
+            setDAC(DISP_OFF);                                   /* Turn off DAC */
+#endif
+            setDPMS(DPMS_OFF);                                  /* Turn off DPMS to drive CRT */
+            break;
+        }
+        case LCD1_LCD2_CRT2_DUAL:
+        {
+            //DDKDEBUGPRINT((DISPLAY_LEVEL, "LCD1_LCD2_CRT2_DUAL\n"));
+            
+            /* 
+             * 1. Check the conditions
+             */    
+            /* This combination is not valid if panel requires scaling and display
+               control is not swapped. */
+            if (isScalingEnabled(PRIMARY_CTRL) == 1)
+                return (-1);
+                
+            /* Can not enable PANEL2 when the panel type is not 18-bit panel. */            
+            if (getPanelType() != TFT_18BIT)
+                return (-1);
+            
+            /* 
+             * 2. Set all the display control and the display path 
+             */
+            setDisplayControl(PRIMARY_CTRL, DISP_ON);           /* Turn on Primary Control */
+            setDisplayControl(SECONDARY_CTRL, DISP_ON);         /* Turn on Secondary control */            
+            if (dispCtrlUsage == 0)
+            {
+                setPath(PANEL_PATH, PRIMARY_CTRL, DISP_ON);     /* Turn on Panel Path and use Primary data */
+                setPath(CRT_PATH, SECONDARY_CTRL, DISP_ON);     /* Turn on CRT Path and use Secondary data */
+            }
+            else
+            {
+                setPath(PANEL_PATH, SECONDARY_CTRL, DISP_ON);   /* Turn on Panel Path and use Secondary data */
+                setPath(CRT_PATH, PRIMARY_CTRL, DISP_ON);       /* Turn on CRT Path and use Primary data */
+            }
+            
+            /* 
+             * 3. Enable/disable the display devices. 
+             */
+            swPanelPowerSequence(DISP_ON, 4);                   /* Turn on Panel */
+            setDAC(DISP_ON);                                    /* Turn on DAC */
+            setDPMS(DPMS_ON);                                   /* Turn on DPMS to drive CRT */
+            break;
+        }
+    }
+    
+    return 0;
+}
+
+/*
+ * This function checks whether the scaling is enabled.
+ *
+ * Input:
+ *      dispCtrl    - Display control to be checked.
+ *
+ * Output:
+ *      0   - Scaling is not enabled
+ *      1   - Scaling is enabled
+ */
+unsigned char isScalingEnabled(
+    disp_control_t dispCtrl
+)
+{
+    unsigned long value;
+    
+    /* If display control is not swapped, then check the expansion bit for PRIMARY_CTRL 
+       and SECONDARY_SCALE register for SECONDARY_CTRL. */
+    if (dispCtrl == PRIMARY_CTRL)
+    {
+        value = peekRegisterDWord(SECONDARY_DISPLAY_CTRL);
+        if (FIELD_GET(value, SECONDARY_DISPLAY_CTRL, EXPANSION) == SECONDARY_DISPLAY_CTRL_EXPANSION_ENABLE)
+            return 1;
+    }
+    else
+    {
+        value = peekRegisterDWord(SECONDARY_SCALE);
+        if ((FIELD_GET(value, SECONDARY_SCALE, VERTICAL_SCALE) != 0) ||
+            (FIELD_GET(value, SECONDARY_SCALE, HORIZONTAL_SCALE) != 0))
+            return 1;
+    }
+    
+    return 0;
+}
+
diff --git a/drivers/gpu/drm/smi/ddk750/ddk750_display.h b/drivers/gpu/drm/smi/ddk750/ddk750_display.h
new file mode 100644
index 000000000000..d06d3ec43293
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk750/ddk750_display.h
@@ -0,0 +1,226 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2007 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  display.h --- SM750/SM718 DDK
+*  This file contains the function prototypes for the display.
+* 
+*******************************************************************/
+#ifndef _DISPLAY_H_
+#define _DISPLAY_H_
+
+#include "ddk750_mode.h"
+
+typedef enum _disp_path_t
+{
+    PANEL_PATH = 0,
+    CRT_PATH   = 1,
+}
+disp_path_t;
+
+typedef enum _disp_state_t
+{
+    DISP_OFF = 0,
+    DISP_ON  = 1,
+}
+disp_state_t;
+
+typedef enum _disp_output_t
+{
+    NO_DISPLAY,             /* All display off. */
+    LCD1_ONLY,              /* LCD1 only */
+    LCD2_ONLY,              /* LCD2 only */
+    CRT2_ONLY,              /* CRT2 only */
+    LCD1_CRT2_SIMUL,        /* Both LCD1 and CRT2 displaying the same content. */
+    LCD1_LCD2_SIMUL,        /* Both LCD1 and LCD2 displaying the same content. */
+    CRT2_LCD2_SIMUL,        /* CRT2 and LCD2 displaying the same content. */
+    LCD1_LCD2_CRT2_SIMUL,   /* LCD1, LCD2, and CRT2 displaying the same content. */
+    LCD1_CRT2_DUAL,         /* LCD1 and CRT2 displaying different contents. */
+    LCD1_LCD2_DUAL,         /* LCD1 and LCD2 displaying different contents. */
+    LCD1_LCD2_CRT2_DUAL     /* LCD2 and CRT2 displaying the same content while
+                               the Panel displaying different content. */
+}
+disp_output_t;
+
+typedef enum _panel_type_t
+{
+    TFT_18BIT = 0,
+    TFT_24BIT,
+    TFT_36BIT
+}
+panel_type_t;
+
+void setPath(
+    disp_path_t dispPath, 
+    disp_control_t dispControl, 
+    disp_state_t dispState
+);
+/*
+ * This functions sets the CRT Path.
+ */
+void setCRTPath(disp_control_t dispControl);
+
+/*
+ * This functions uses software sequence to turn on/off the panel.
+ */
+void swPanelPowerSequence(disp_state_t dispState, unsigned long vsync_delay);
+
+/* 
+ * This function turns on/off the DAC for CRT display control.
+ * Input: On or off
+ */
+void setDAC(disp_state_t state);
+
+/*
+ * This function turns on/off the display control.
+ * Currently, it for CRT and Panel controls only.
+ * Input: Panel or CRT, or ...
+ *        On or Off.
+ */
+void setDisplayControl(disp_control_t dispControl, disp_state_t dispState);
+
+/*
+ * This function set the logical display output.
+ *
+ * The output is called logical because it is independent of physical implementation.
+ * For example, CRT2 only mode is not using the internal secondary control. It uses the
+ * Primary Control with its output directed to CRT DAC.
+ *
+ * Input:
+ *      output          - Logical Display output
+ *      dispCtrlUsage   - Display Control Flag Usage:
+ *                          0 : Use primary display control (PRIMARY_CTRL) to control 
+ *                              primary output (LCD1 & CRT1) and use secondary display 
+ *                              control (SECONDARY_CTRL) to control secondary output 
+ *                              (CRT2 & LCD2)
+ *                          1 : Use primary display control (PRIMARY_CTRL) to control 
+ *                              secondary output (LCD2 & CRT2) and use secondary display 
+ *                              control (SECONDARY_CTRL) to control primary output 
+ *                              (LCD1 & CRT1)
+ *
+ * Output:
+ *      0   - Success
+ *     -1   - Fail 
+ */
+long setLogicalDispOutput(
+    disp_output_t output,
+    unsigned char dispCtrlUsage
+);
+
+/*
+ * This function set the logical display output.
+ *
+ * The output is called logical because it is independent of physical implementation.
+ * For example, CRT2 only mode is not using the internal secondary control. It uses the
+ * Primary Control with its output directed to CRT DAC.
+ *
+ * Input:
+ *		isSecondDispay  - Enable primary or secondary control
+ *							0 : Enable primary display control
+ *							1 : Enable secondary display control
+ *      output          - Logical Display output
+ *      dispCtrlUsage   - Display Control Flag Usage:
+ *                          0 : Use primary display control (PRIMARY_CTRL) to control 
+ *                              primary output (LCD1 & CRT1) and use secondary display 
+ *                              control (SECONDARY_CTRL) to control secondary output 
+ *                              (CRT2 & LCD2)
+ *                          1 : Use primary display control (PRIMARY_CTRL) to control 
+ *                              secondary output (LCD2 & CRT2) and use secondary display 
+ *                              control (SECONDARY_CTRL) to control primary output 
+ *                              (LCD1 & CRT1)
+ *
+ * Output:
+ *      0   - Success
+ *     -1   - Fail 
+ */
+long setLogicalDispOutputExt(
+    long isSecondDisplay,
+    disp_output_t output,
+    unsigned char dispCtrlUsage
+);
+/*
+ * Use vertical sync as time delay function.
+ * Input:
+ *          dispControl - Display Control (PRIMARY_CTRL or SECONDARY_CTRL) 
+ *          vsync_count - Number of vertical sync to wait.
+ *
+ * Note:
+ *      This function is waiting for the next vertical sync.
+ */
+void waitNextVerticalSync(disp_control_t dispControl, unsigned long vsync_count);
+
+/*
+ * Use panel vertical sync line as time delay function.
+ * This function does not wait for the next VSync. Instead, it will wait
+ * until the current line reaches the Vertical Sync line.
+ * This function is really useful when flipping display to prevent tearing.
+ *
+ * Input: display control (PRIMARY_CTRL or SECONDARY_CTRL)
+ */
+void waitVSyncLine(disp_control_t dispControl);
+
+/*
+ * This function gets the panel type
+ *
+ * Output:
+ *      panelType   - The type of the panel to be set  
+ */
+panel_type_t getPanelType(void);
+
+long setPanelType(panel_type_t panelType);
+
+
+/*
+ * This function gets the CRT Monitor Detection Threshold value.
+ *
+ * Input:
+ *      pRedValue   - Pointer to a variable to store the Red color threshold
+ *                    value.
+ *      pGreenValue - Pointer to a variable to store the Green color threshold
+ *                    value.
+ *      pBlueValue  - Pointer to a variable to store the Blue color threshold
+ *                    value. 
+ */
+void getCRTDetectThreshold(
+    unsigned char *pRedValue,
+    unsigned char *pGreenValue,
+    unsigned char *pBlueValue
+);
+
+/*
+ * This function detects if the CRT monitor is attached.
+ *
+ * Input:
+ *      redValue    - Threshold value to be detected on the red color.
+ *      greenValue  - Threshold value to be detected on the green color.
+ *      blueValue   - Threshold value to be detected on the blue color.
+ *
+ * Output:
+ *      0   - Success
+ *     -1   - Fail 
+ */
+long ddk750_detectCRTMonitor(
+    unsigned char redValue,
+    unsigned char greenValue,
+    unsigned char blueValue
+);
+
+/*
+ * This function checks whether the scaling is enabled.
+ *
+ * Input:
+ *      dispCtrl    - Display control to be checked.
+ *
+ * Output:
+ *      0   - Scaling is not enabled
+ *      1   - Scaling is enabled
+ */
+unsigned char isScalingEnabled(
+    disp_control_t dispCtrl
+);
+
+
+#endif /* _DISPLAY_H_ */
diff --git a/drivers/gpu/drm/smi/ddk750/ddk750_edid.c b/drivers/gpu/drm/smi/ddk750/ddk750_edid.c
new file mode 100644
index 000000000000..4ff902f82109
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk750/ddk750_edid.c
@@ -0,0 +1,2223 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2009 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  edid.c --- SM750/SM718 DDK 
+*  This file contains functions to interpret the EDID structure.
+* 
+*******************************************************************/
+//#include <linux/math.h>
+#include "ddk750_defs.h"
+#include "ddk750_hardware.h"
+#include "ddk750_helper.h"
+#include "ddk750_hwi2c.h"
+#include "ddk750_swi2c.h"
+#include "ddk750_edid.h"
+
+#include "ddkdebug.h"
+
+/* Enable this one to print the VDIF timing when debug is enabled. */
+//#define ENABLE_DEBUG_PRINT_VDIF
+
+/****************************************************************
+ * Configuration setting
+ ****************************************************************/
+/* I2C Address of each Monitor. Currently, there is only one i2c bus and
+   both display devices will responds to 0xA0 address with analog CRT as the first priority
+   The second version of evaluation board will separate the i2c bus, so that each i2c bus
+   corresponds to one display devices.
+   The new monitor devices (at least the tested DVI monitor) also corresponds to 0xA2, 
+   which is temporarily used in this DDK. */
+#define EDID_DEVICE_I2C_ADDRESS             0xA0
+
+/* GPIO used for the I2C on the PANEL_PATH size  */
+#define EDID_PANEL_I2C_SCL                  DEFAULT_I2C_SCL
+#define EDID_PANEL_I2C_SDA                  DEFAULT_I2C_SDA
+
+/* GPIO used for the I2C on the CRT_PATH size.
+   These GPIO pins only available in the Evaluation Board version 2.2.
+   Need to find out which pins are used for the CRT_PATH i2c. */
+#define EDID_CRT_I2C_SCL                    17
+#define EDID_CRT_I2C_SDA                    18
+
+#define TOTAL_EDID_REGISTERS                128
+
+#define TOTAL_EDID_REGISTERS_128                128
+#define TOTAL_EDID_REGISTERS_256                256
+#define EDID_EXTEND_BLOCK         126
+
+
+typedef struct _est_timing_mode_t
+{
+    unsigned long x;        /* Mode Width */
+    unsigned long y;        /* Mode Height */
+    unsigned long hz;       /* Refresh Rate */
+    unsigned char source;   /* Source:  0 - VESA
+                                        1 - IBM
+                                        2 - Apple
+                             */
+}
+est_timing_mode_t;
+
+/* These values only applies to EDID Version 1 */
+static est_timing_mode_t establishTiming[3][8] =
+{
+    /* Established Timing 1 */
+    {   
+        { 800,  600, 60, 0},
+        { 800,  600, 56, 0},
+        { 640,  480, 75, 0},
+        { 640,  480, 72, 0},
+        { 640,  480, 67, 2},
+        { 640,  480, 60, 1},
+        { 720,  400, 88, 1},
+        { 720,  400, 70, 1},
+    },
+    {
+        {1280, 1024, 75, 0},
+        {1024,  768, 75, 0},
+        {1024,  768, 70, 0},
+        {1024,  768, 60, 0},
+        {1024,  768, 87, 1},
+        { 832,  624, 75, 0},
+        { 800,  600, 75, 0},
+        { 800,  600, 72, 0},
+    },
+    {
+        {   0,    0,  0, 0},
+        {   0,    0,  0, 0},
+        {   0,    0,  0, 0},
+        {   0,    0,  0, 0},
+        {   0,    0,  0, 0},
+        {   0,    0,  0, 0},
+        {   0,    0,  0, 0},
+        {1152,  870, 75, 2},
+    }
+};
+
+static void printVdif(
+    vdif_t *pVDIF
+)
+{
+#ifdef DDKDEBUG
+
+#ifndef ENABLE_DEBUG_PRINT_VDIF
+    DDKDEBUGENABLE(0);
+#endif
+    
+    DDKDEBUGPRINT((DISPLAY_LEVEL, "pixelClock = %d\n", pVDIF->pixelClock));
+    DDKDEBUGPRINT((DISPLAY_LEVEL, "characterWidth = %d\n", pVDIF->characterWidth));
+    DDKDEBUGPRINT((DISPLAY_LEVEL, "scanType = %s\n", (pVDIF->scanType == VDIF_INTERLACED) ? "Interlaced" : "Progressive"));
+    
+    DDKDEBUGPRINT((DISPLAY_LEVEL, "horizontalFrequency = %d\n", pVDIF->horizontalFrequency));
+    DDKDEBUGPRINT((DISPLAY_LEVEL, "horizontalTotal = %d\n", pVDIF->horizontalTotal));
+    DDKDEBUGPRINT((DISPLAY_LEVEL, "horizontalActive = %d\n", pVDIF->horizontalActive));
+    DDKDEBUGPRINT((DISPLAY_LEVEL, "horizontalBlankStart = %d\n", pVDIF->horizontalBlankStart));
+    DDKDEBUGPRINT((DISPLAY_LEVEL, "horizontalBlankTime = %d\n", pVDIF->horizontalBlankTime));
+    DDKDEBUGPRINT((DISPLAY_LEVEL, "horizontalSyncStart = %d\n", pVDIF->horizontalSyncStart));
+    DDKDEBUGPRINT((DISPLAY_LEVEL, "horizontalRightBorder = %d\n", pVDIF->horizontalRightBorder));
+    DDKDEBUGPRINT((DISPLAY_LEVEL, "horizontalFrontPorch = %d\n", pVDIF->horizontalFrontPorch));
+    DDKDEBUGPRINT((DISPLAY_LEVEL, "horizontalSyncWidth = %d\n", pVDIF->horizontalSyncWidth));
+    DDKDEBUGPRINT((DISPLAY_LEVEL, "horizontalBackPorch = %d\n", pVDIF->horizontalBackPorch));
+    DDKDEBUGPRINT((DISPLAY_LEVEL, "horizontalLeftBorder = %d\n", pVDIF->horizontalLeftBorder));
+    DDKDEBUGPRINT((DISPLAY_LEVEL, "horizontalSyncPolarity = %s\n", 
+        (pVDIF->horizontalSyncPolarity == VDIF_SYNC_NEGATIVE) ? "Negative" : "Positive"));
+    
+    DDKDEBUGPRINT((DISPLAY_LEVEL, "verticalFrequency = %d\n", pVDIF->verticalFrequency));
+    DDKDEBUGPRINT((DISPLAY_LEVEL, "verticalTotal = %d\n", pVDIF->verticalTotal));
+    DDKDEBUGPRINT((DISPLAY_LEVEL, "verticalActive = %d\n", pVDIF->verticalActive));
+    DDKDEBUGPRINT((DISPLAY_LEVEL, "verticalBlankStart = %d\n", pVDIF->verticalBlankStart));
+    DDKDEBUGPRINT((DISPLAY_LEVEL, "verticalBlankTime = %d\n", pVDIF->verticalBlankTime));
+    DDKDEBUGPRINT((DISPLAY_LEVEL, "verticalSyncStart = %d\n", pVDIF->verticalSyncStart));
+    DDKDEBUGPRINT((DISPLAY_LEVEL, "verticalBottomBorder = %d\n", pVDIF->verticalBottomBorder));
+    DDKDEBUGPRINT((DISPLAY_LEVEL, "verticalFrontPorch = %d\n", pVDIF->verticalFrontPorch));
+    DDKDEBUGPRINT((DISPLAY_LEVEL, "verticalSyncHeight = %d\n", pVDIF->verticalSyncHeight));
+    DDKDEBUGPRINT((DISPLAY_LEVEL, "verticalBackPorch = %d\n", pVDIF->verticalBackPorch));
+    DDKDEBUGPRINT((DISPLAY_LEVEL, "verticalTopBorder = %d\n", pVDIF->verticalTopBorder));
+    DDKDEBUGPRINT((DISPLAY_LEVEL, "verticalSyncPolarity = %s\n", 
+        (pVDIF->verticalSyncPolarity == VDIF_SYNC_NEGATIVE) ? "Negative" : "Positive"));
+
+#ifndef ENABLE_DEBUG_PRINT_VDIF
+    DDKDEBUGENABLE(1);
+#endif
+#endif
+}
+
+/*
+ *  edidGetVersion
+ *      This function gets the EDID version
+ *
+ *  Input:
+ *      pEDIDBuffer - Buffer that contains the EDID structure of the monitor
+ *      pRevision   - Revision of the EDIE (if exist)
+ *
+ *  Output:
+ *      Revision number of the given EDID buffer.
+ */
+unsigned char edidGetVersion(
+    unsigned char *pEDIDBuffer,
+    unsigned char *pRevision
+)
+{
+    unsigned char version;
+    
+    if (pEDIDBuffer != (unsigned char *)0)
+    {
+        /* Check the header */
+        if ((pEDIDBuffer[0] == 0x00) && (pEDIDBuffer[1] == 0xFF) && (pEDIDBuffer[2] == 0xFF) &&
+            (pEDIDBuffer[3] == 0xFF) && (pEDIDBuffer[4] == 0xFF) && (pEDIDBuffer[5] == 0xFF) &&
+            (pEDIDBuffer[6] == 0xFF) && (pEDIDBuffer[7] == 0x00))
+        {
+            /* 
+             * EDID Structure Version 1.
+             */
+        
+            /* Read the version field from the buffer. It should be 1 */
+            version  = pEDIDBuffer[18];
+        
+            if (version == 1)
+            {
+                /* Copy the revision first */
+                if (pRevision != (unsigned char *)0)
+                    *pRevision = pEDIDBuffer[19];
+                    
+                return version;
+            }
+        }
+        else
+        {
+            /* 
+             * EDID Structure Version 2 
+             */
+             
+            /* Read the version and revision field from the buffer. */
+            version = pEDIDBuffer[0];
+        
+            if ((version >> 4) == 2)
+            {
+                /* Copy the revision */
+                if (pRevision != (unsigned char *)0)
+                    *pRevision = version & 0x0F;
+                
+                return (version >> 4);
+            }
+        }
+    }
+    
+    DDKDEBUGPRINT((DISPLAY_LEVEL, "Invalid EDID Structure\n"));    
+    return 0;    
+}
+
+/*
+ *  edidGetProductInfo
+ *      This function gets the vendor and product information.
+ *
+ *  Input:
+ *      pEDIDBuffer         - Buffer that contains the EDID structure of the monitor [in]
+ *      pManufacturerName   - Pointer to a 3 byte length variable to store the manufacturer name [out]
+ *      pProductCode        - Pointer to a variable to store the product code [out]
+ *      pSerialNumber       - Pointer to a variable to store the serial number [out]
+ *      pWeekOfManufacture  - Pointer to a variable to store the week of manufacture [out]
+ *      pYearOfManufacture  - Pointer to a variable to store the year of manufacture 
+ *                            or model year (if WeekOfManufacture is 0xff) [out]
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long edidGetProductInfo(
+    unsigned char *pEDIDBuffer,
+    char *pManufacturerName,
+    unsigned short *pProductCode,
+    unsigned long *pSerialNumber,
+    unsigned char *pWeekOfManufacture,
+    unsigned short *pYearOfManufacture
+)
+{
+    unsigned char version, revision;
+    unsigned short manufactureID;
+    
+    /* Get EDID Version and revision */
+    version = edidGetVersion(pEDIDBuffer, &revision);
+    
+    if (version == 1)
+    {
+        edid_version_1_t *pEDIDStructure;
+        
+        /* EDID Structure Version 1. */
+        pEDIDStructure = (edid_version_1_t *)pEDIDBuffer;
+        
+        if (pManufacturerName != (char *)0)
+        {
+            /* Swap the byte */
+            manufactureID = (pEDIDStructure->manufacturerID >> 8) + (pEDIDStructure->manufacturerID << 8);
+            pManufacturerName[0] = ((manufactureID >> 10) & 0x001F) + 'A' - 1;
+            pManufacturerName[1] = ((manufactureID >> 5) & 0x001F) + 'A' - 1;
+            pManufacturerName[2] = (manufactureID & 0x001F) + 'A' - 1;
+            pManufacturerName[3] = '\0';
+        }
+        
+        if (pProductCode != (unsigned short *)0)
+            *pProductCode = pEDIDStructure->productCode;
+            
+        /* Only EDID structure version 1.1 and 1.2 supports this. EDID 1.3 uses
+           detail timing descriptor to store the serial number in ASCII. */
+        if (pSerialNumber != (unsigned long *)0)
+            *pSerialNumber = pEDIDStructure->serialNumber;
+        
+        /*
+         * Rev 1.3: - A value of 0 means that week of manufacture is not specified
+         *          - A value in the range of 1 to 54 (0x01 - 0x36) means the week of manufacture
+         *          - Any values greater than 54 is invalid.
+         *
+         * Rev 1.4: - A value of 0 means that week of manufacture is not specified
+         *          - A value in the range of 1 to 54 (0x01 - 0x36) means the week of manufacture
+         *          - A value of 0xFF means that Year of Manufacture contains the model year
+         *            instead of year of Manufacture.
+         *          - Other values means invalid
+         */
+        if (pWeekOfManufacture != (unsigned char *)0)
+            *pWeekOfManufacture = pEDIDStructure->weekOfManufacture;
+            
+        /* The value must be greater than 3 and less than or equal to the current
+           year minus 1990.
+           A value of 3 or less would indicated that the display was manufactured 
+           before the EDID standard was defined.
+           A value greater than (current year - 1990) would indicate that the display
+           has not yet been manufactured.
+         */
+        if (pYearOfManufacture != (unsigned short *)0)
+            *pYearOfManufacture = (unsigned short) pEDIDStructure->yearOfManufacture + 1990;
+        
+        return 0;
+    }
+
+    return (-1);
+}
+
+/*
+ *  edidCheckMonitorInputSignal
+ *      This function checks whether the monitor is expected analog/digital 
+ *      input signal.
+ *
+ *  Input:
+ *      pEDIDBuffer     - Buffer that contains the EDID structure of the monitor
+ *
+ *  Output:
+ *      0   - Analog
+ *      1   - Digital
+ */
+unsigned char edidCheckMonitorInputSignal(
+    unsigned char *pEDIDBuffer
+)
+{
+    unsigned char version;
+    unsigned short index;
+    
+    /* Get EDID Version and revision */
+    version = edidGetVersion(pEDIDBuffer, (unsigned char *)0);
+    
+    if (version == 1)
+        return (unsigned char)((edid_version_1_t *)pEDIDBuffer)->videoInputDefinition.analogSignal.inputSignal;
+    
+    return 0;
+}
+
+/*
+ *  edidGetAnalogSignalInfo
+ *      This function gets the analog video input signal information
+ *
+ *  Input:
+ *      pEDIDBuffer             - Buffer that contains the EDID structure of the monitor
+ *      pRefWhiteAboveBlank     - Pointer to a variable to store the reference white above blank
+ *                                value. The value is in milliVolt.
+ *      pSyncLevelBelowBlank    - Pointer to a variable to store the Sync tip level below blank
+ *                                The value is also in milliVolt
+ *      pBlank2BlackSetup       - Pointer to a variable to store the Blank to black setup or
+ *                                pedestal per appropriate Signal Level Standard flag. 
+ *                                1 means that the display expect the setup.
+ *      pSeparateSyncSupport    - Pointer to a variable to store the flag to indicate that the
+ *                                monitor supports separate sync.
+ *      pCompositeSyncSupport   - Pointer to a variable to store a flag to indicate that the
+ *                                monitor supports composite sync.
+ *      pSyncOnGreenSupport     - Pointer to a variable to store a flag to indicate that
+ *                                the monitor supports sync on green video.
+ *      pVSyncSerrationRequired - Pointer to a variable to store a flag to indicate that serration
+ *                                of the VSync pulse is required when composite sync or
+ *                                sync-on-green video is used.
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long edidGetAnalogSignalInfo(
+    unsigned char *pEDIDBuffer,
+    unsigned short *pRefWhiteAboveBlank,
+    unsigned short *pSyncLevelBelowBlank,
+    unsigned char *pBlank2BlackSetup,
+    unsigned char *pSeparateSyncSupport,
+    unsigned char *pCompositeSyncSupport,
+    unsigned char *pSyncOnGreenSupport,
+    unsigned char *pVSyncSerrationRequired
+)
+{
+    unsigned char version, revision;
+    unsigned short whiteReference, syncLevel;
+    
+    /* Get EDID Version and revision */
+    version = edidGetVersion(pEDIDBuffer, &revision);
+    
+    if (version == 1)
+    {
+        edid_version_1_t *pEDIDStructure;
+        
+        /* EDID Structure Version 1. */
+        pEDIDStructure = (edid_version_1_t *)pEDIDBuffer;
+        
+        /* Check if the input signal is analog */
+        if (pEDIDStructure->videoInputDefinition.analogSignal.inputSignal != 0)
+            return (-1);
+        
+        switch (pEDIDStructure->videoInputDefinition.analogSignal.signalLevelStd)
+        {
+            case 0:
+                whiteReference = 700;
+                syncLevel = 300;
+                break;
+            case 1:
+                whiteReference = 714;
+                syncLevel = 286;
+                break;
+            case 2:
+                whiteReference = 1000;
+                syncLevel = 400;
+                break;
+            case 3:
+                whiteReference = 700;
+                syncLevel = 0;
+                break;
+        }
+        
+        if (pRefWhiteAboveBlank != (unsigned short *)0)
+            *pRefWhiteAboveBlank = whiteReference; 
+        
+        if (pSyncLevelBelowBlank != (unsigned short *)0)
+            *pSyncLevelBelowBlank = syncLevel;
+        
+        if (pBlank2BlackSetup != (unsigned char *)0)
+            *pBlank2BlackSetup = (unsigned char)
+                                  pEDIDStructure->videoInputDefinition.analogSignal.blank2Black;
+        
+        if (pSeparateSyncSupport != (unsigned char *)0)
+            *pSeparateSyncSupport = (unsigned char)
+                                     pEDIDStructure->videoInputDefinition.analogSignal.separateSyncSupport;
+        
+        if (pCompositeSyncSupport != (unsigned char *)0)
+            *pCompositeSyncSupport = (unsigned char)
+                                      pEDIDStructure->videoInputDefinition.analogSignal.compositeSyncSupport;
+        
+        if (pSyncOnGreenSupport != (unsigned char *)0)
+            *pSyncOnGreenSupport = (unsigned char)
+                                    pEDIDStructure->videoInputDefinition.analogSignal.syncOnGreenSupport;
+        
+        if (pVSyncSerrationRequired != (unsigned char *)0)
+            *pVSyncSerrationRequired = (unsigned char)
+                                        pEDIDStructure->videoInputDefinition.analogSignal.vsyncSerration;
+                                        
+        return 0;
+    }
+    else
+    {
+        /* EDID Structure 2 */
+    }
+    
+    return (-1);
+}
+
+/*
+ *  edidGetDigitalSignalInfo
+ *      This function gets the digital video input signal information.
+ *      Only applies to EDID 1.3 and above.
+ *
+ *  Input:
+ *      pEDIDBuffer     - Buffer that contains the EDID structure of the monitor
+ *      pDFP1xSupport   - Pointer to a variable to store the flag to indicate that
+ *                        the mointor interface is signal compatible with VESA
+ *                        DFP 1.x TMDS CRGB, 1 pixel/clock, up to 8 bits / color
+ *                        MSB aligned, DE active high
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long edidGetDigitalSignalInfo(
+    unsigned char *pEDIDBuffer,
+    unsigned char *pDFP1xSupport
+)
+{
+    unsigned char version, revision;
+    
+    /* Get EDID Version and revision */
+    version = edidGetVersion(pEDIDBuffer, &revision);
+    
+    if ((version == 1) && (revision == 3))
+    {
+        edid_version_1_t *pEDIDStructure;
+        
+        /* EDID Structure Version 1. */
+        pEDIDStructure = (edid_version_1_t *)pEDIDBuffer;
+        
+        /* Check if the input signal is digital */
+        if (pEDIDStructure->videoInputDefinition.digitalSignal.inputSignal != 1)
+            return (-1);
+            
+        if (pDFP1xSupport != (unsigned char *)0)
+            *pDFP1xSupport = pEDIDStructure->videoInputDefinition.digitalSignal.dfp1Support;
+        
+        return 0;
+    }
+    
+    return (-1);
+}
+
+/*
+ *  edidGetDisplaySize
+ *      This function gets the display sizes in cm.
+ *
+ *  Input:
+ *      pEDIDBuffer         - Buffer that contains the EDID structure of the monitor
+ *      pMaxHorzImageSize   - Pointer to a variable to store the maximum horizontal 
+ *                            image size to the nearest centimeter. A value of 0
+ *                            indicates that the size is indeterminate size.
+ *      pMaxVertImageSize   - Pointer to a variable to store the maximum vertical
+ *                            image size to the nearest centimeter. A value of 0
+ *                            indicates that the size is indeterminate size.
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long edidGetDisplaySize(
+    unsigned char *pEDIDBuffer,
+    unsigned char *pMaxHorzImageSize,
+    unsigned char *pMaxVertImageSize
+)
+{
+    unsigned char version, revision;
+    
+    /* Get EDID Version and revision */
+    version = edidGetVersion(pEDIDBuffer, &revision);
+    
+    if (version == 1)
+    {
+        edid_version_1_t *pEDIDStructure;
+        
+        /* EDID Structure Version 1. */
+        pEDIDStructure = (edid_version_1_t *)pEDIDBuffer;
+        
+        if (pMaxHorzImageSize != (unsigned char *)0)
+            *pMaxHorzImageSize = pEDIDStructure->maxHorzImageSize;
+        
+        if (pMaxVertImageSize != (unsigned char *)0)
+            *pMaxVertImageSize = pEDIDStructure->maxVertImageSize;
+        
+        return 0;
+    }
+    
+    return (-1);
+}
+
+#if 0   /* Use the edidGetWhitePoint to get the Gamma */
+/*
+ *  edidGetGamma
+ *      This function gets the Display Transfer Characteristic (Gamma).
+ *
+ *  Input:
+ *      pEDIDBuffer         - Buffer that contains the EDID structure of the monitor
+ *
+ *  Output:
+ *      Gamma value multiplied by 100. A value of 0xFFFF (-1) indicates that
+ *      the gamma value is not defined.
+ */
+unsigned short edidGetGamma(
+    unsigned char *pEDIDBuffer
+)
+{
+    unsigned char version;
+    
+    /* Get EDID Version and revision */
+    version = edidGetVersion(pEDIDBuffer, (unsigned char *)0);
+    
+    if (version == 1)
+        return (unsigned short)(((edid_version_1_t *)pEDIDBuffer)->displayTransferChar + 100);
+    
+    return (-1);
+}
+#endif
+
+/*
+ *  edidGetPowerManagementSupport
+ *      This function gets the monitor's power management support.
+ *
+ *  Input:
+ *      pEDIDBuffer     - Buffer that contains the EDID structure of the monitor
+ *      pStandBy        - Pointer to a variable to store the flag to indicate that
+ *                        standby power mode is supported.
+ *      pSuspend        - Pointer to a variable to store the flag to indicate that
+ *                        suspend power mode is supported.
+ *      pLowPower       - Pointer to a variable to store the flag to indicate that
+ *                        the display consumes low power when it receives a timing
+ *                        signal that is outside its declared active operating range.
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long edidGetPowerManagementSupport(
+    unsigned char *pEDIDBuffer,
+    unsigned char *pStandBy,
+    unsigned char *pSuspend,
+    unsigned char *pLowPower
+)
+{
+    unsigned char version;
+    
+    /* Get EDID Version and revision */
+    version = edidGetVersion(pEDIDBuffer, (unsigned char *)0);
+    
+    if (version == 1)
+    {
+        edid_version_1_t *pEDIDStructure;
+        
+        /* EDID Structure Version 1. */
+        pEDIDStructure = (edid_version_1_t *)pEDIDBuffer;
+        
+        if (pStandBy != (unsigned char *)0)
+            *pStandBy = (unsigned char) pEDIDStructure->featureSupport.standbySupport;
+            
+        if (pSuspend != (unsigned char *)0)
+            *pSuspend = (unsigned char) pEDIDStructure->featureSupport.suspendSupport;
+            
+        if (pLowPower != (unsigned char *)0)
+            *pLowPower = (unsigned char) pEDIDStructure->featureSupport.lowPowerSupport;
+        
+        return 0;
+    }
+    
+    return (-1);
+}
+
+/*
+ *  edidGetDisplayType
+ *      This function gets the display type.
+ *
+ *  Input:
+ *      pEDIDBuffer     - Buffer that contains the EDID structure of the monitor
+ *
+ *  Output:
+ *      0   - Monochrome / grayscale display
+ *      1   - RGB Color Display
+ *      2   - Non-RGB multicolor display, e.g. R/G/Y
+ *      3   - Undefined
+ */
+unsigned char edidGetDisplayType(
+    unsigned char *pEDIDBuffer
+)
+{
+    unsigned char version;
+    
+    /* Get EDID Version and revision */
+    version = edidGetVersion(pEDIDBuffer, (unsigned char *)0);
+    
+    if (version == 1)
+        return (unsigned char)((edid_version_1_t *)pEDIDBuffer)->featureSupport.displayType;
+    
+    return (3);
+}
+
+/*
+ *  edidChecksRGBUsage
+ *      This function checks if the display is using the sRGB standard default
+ *      color space as its primary color space. 
+ *
+ *  Input:
+ *      pEDIDBuffer     - Buffer that contains the EDID structure of the monitor
+ *
+ *  Output:
+ *      0   - Does not use sRGB as its primary color space
+ *      1   - Use sRGB as its primary color space
+ */
+unsigned char edidChecksRGBUsage(
+    unsigned char *pEDIDBuffer
+)
+{
+    unsigned char version;
+    
+    /* Get EDID Version and revision */
+    version = edidGetVersion(pEDIDBuffer, (unsigned char *)0);
+    
+    if (version == 1)
+        return (unsigned char)((edid_version_1_t *)pEDIDBuffer)->featureSupport.sRGBSupport;
+    
+    return (0);
+}
+
+/*
+ *  edidIsPreferredTimingAvailable
+ *      This function checks whether the preffered timing mode is available.
+ *      Use of preferred timing mode is required by EDID structure version 1
+ *      Revision 3 and higher. 
+ *
+ *  Input:
+ *      pEDIDBuffer     - Buffer that contains the EDID structure of the monitor
+ *
+ *  Output:
+ *      0   - Preferred Timing is not available
+ *      1   - Preferred Timing is available
+ */
+unsigned char edidIsPreferredTimingAvailable(
+    unsigned char *pEDIDBuffer
+)
+{
+    unsigned char version;
+    
+    if (pEDIDBuffer != (unsigned char *)0)
+    {
+        /* Get EDID Version and revision */
+        version = edidGetVersion(pEDIDBuffer, (unsigned char *)0);
+    
+        if (version == 1)
+            return (unsigned char)((edid_version_1_t *)pEDIDBuffer)->featureSupport.preferredTiming;
+    }
+        
+    return (0);
+}
+
+/*
+ *  edidIsDefaultGTFSupported
+ *      This function checks whether the display supports timings based on the
+ *      GTF standard using default GTF parameter values. 
+ *
+ *  Input:
+ *      pEDIDBuffer     - Buffer that contains the EDID structure of the monitor
+ *
+ *  Output:
+ *      0   - Default GTF is not supported
+ *      1   - Default GTF is supported
+ */
+unsigned char edidIsDefaultGTFSupported(
+    unsigned char *pEDIDBuffer
+)
+{
+    unsigned char version, revision;
+    
+    /* Get EDID Version and revision */
+    version = edidGetVersion(pEDIDBuffer, (unsigned char *)0);
+    
+    if (version == 1)
+        return (unsigned char)((edid_version_1_t *)pEDIDBuffer)->featureSupport.defaultGTFSupport;
+    
+    return (0);
+}
+
+/*
+ *  edidCalculateChromaticValue
+ *      This function calculates the chromatic value. 
+ *
+ *  Input:
+ *      colorBinaryValue    - Color Characteristic Binary Representation Value 
+ *                            to be computed
+ *
+ *  Output:
+ *      The chromatic value times a 1000.
+ */
+static unsigned short edidCalculateChromaticValue(
+    unsigned short colorBinaryValue
+)
+{
+    unsigned long index;
+    unsigned long result;
+    
+    result = 0;
+    for (index = 10; index > 0; index--)
+    {
+        /* Times 1000000 to make it accurate to the micro value. */
+        result += roundedDiv((colorBinaryValue & 0x0001) * 1000000, twoToPowerOfx(index));
+        colorBinaryValue >>= 1;
+    }
+    
+    /* Make it accurate to 1000 place */
+    return ((unsigned short)roundedDiv(result, 1000));
+}
+
+/*
+ *  edidGetColorCharacteristic
+ *      This function gets the chromaticity and white point values expressed as
+ *      an integer value which represents the actual value times 1000.
+ *
+ *  Input:
+ *      pEDIDBuffer - Buffer that contains the EDID structure of the monitor
+ *      pRedX   - Pointer to a variable to store the Red X values
+ *      pRedY   - Pointer to a variable to store the Red Y values
+ *      pGreenX - Pointer to a variable to store the Green X values
+ *      pGreenY - Pointer to a variable to store the Green Y values
+ *      pBlueX  - Pointer to a variable to store the Blue X values
+ *      pBlueY  - Pointer to a variable to store the Blue Y values
+ *
+ *  Note:
+ *      To get the White color characteristic, use the edidGetWhitePoint
+ */
+void edidGetColorCharacteristic(
+    unsigned char *pEDIDBuffer,
+    unsigned short *pRedX,
+    unsigned short *pRedY,
+    unsigned short *pGreenX,
+    unsigned short *pGreenY,
+    unsigned short *pBlueX,
+    unsigned short *pBlueY
+)
+{
+    unsigned char version, revision;
+    
+    /* Get EDID Version and revision */
+    version = edidGetVersion(pEDIDBuffer, (unsigned char *)0);
+    
+    if (version == 1)
+    {
+        edid_version_1_t *pEDIDStructure;
+        
+        /* EDID Structure Version 1. */
+        pEDIDStructure = (edid_version_1_t *)pEDIDBuffer;
+        
+        if (pRedX != (unsigned short *)0)
+        {
+            *pRedX = edidCalculateChromaticValue(((unsigned short)pEDIDStructure->redX << 2) + 
+                                                  (unsigned short)pEDIDStructure->redGreenLowBits.redXLowBits);
+        }
+            
+        if (pRedY != (unsigned short *)0)
+        {
+            *pRedY = edidCalculateChromaticValue(((unsigned short)pEDIDStructure->redY << 2) + 
+                                                  (unsigned short)pEDIDStructure->redGreenLowBits.redYLowBits);
+        }
+            
+        if (pGreenX != (unsigned short *)0)
+        {
+            *pGreenX = edidCalculateChromaticValue(((unsigned short)pEDIDStructure->greenX << 2) + 
+                                                    (unsigned short)pEDIDStructure->redGreenLowBits.greenXLowBits);
+        }
+            
+        if (pGreenY != (unsigned short *)0)
+        {
+            *pGreenY = edidCalculateChromaticValue(((unsigned short)pEDIDStructure->greenY << 2) + 
+                                                    (unsigned short)pEDIDStructure->redGreenLowBits.greenYLowBits);
+        }
+            
+        if (pBlueX != (unsigned short *)0)
+        {
+            *pBlueX = edidCalculateChromaticValue(((unsigned short)pEDIDStructure->blueX << 2) +
+                                                   (unsigned short)pEDIDStructure->blueWhiteLowBits.blueXLowBits);
+        }
+            
+        if (pBlueY != (unsigned short *)0)
+        {
+            *pBlueY = edidCalculateChromaticValue(((unsigned short)pEDIDStructure->blueY << 2) +
+                                                   (unsigned short)pEDIDStructure->blueWhiteLowBits.blueYLowBits);
+        }
+    }
+}
+
+/*
+ *  edidGetWhitePoint
+ *      This function gets the white point.
+ *      To get the default white point, set the index to 0. For multiple white point,
+ *      call this function multiple times to check if more than 1 white point is supported.
+ *
+ *  Input:
+ *      pEDIDBuffer - Buffer that contains the EDID structure of the monitor
+ *      pWhitePointIndex    - Pointer to a variable that contains the white point index 
+ *                            to be retrieved.
+ *      pWhiteX             - Pointer to a variable to store the White X value
+ *      pWhiteY             - Pointer to a variable to store the White Y value
+ *      pWhiteGamma         - Pointer to a variable to store the White Gamma value
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long edidGetWhitePoint(
+    unsigned char *pEDIDBuffer,
+    unsigned char *pWhitePointIndex,
+    unsigned short *pWhiteX,
+    unsigned short *pWhiteY,
+    unsigned short *pWhiteGamma
+)
+{
+    unsigned char version, revision, index, tableIndex;
+    
+    if (pWhitePointIndex == (unsigned char *)0)
+        return (-1);
+    
+    /* Get EDID Version and revision */
+    version = edidGetVersion(pEDIDBuffer, (unsigned char *)0);
+    
+    if (version == 1)
+    {
+        edid_version_1_t *pEDIDStructure;
+        monitor_desc_t *pMonitorDescriptor;
+        
+        /* EDID Structure Version 1. */
+        pEDIDStructure = (edid_version_1_t *)pEDIDBuffer;
+        
+        /* Get the index to a temporary variable and increment the index for the
+           next loop. */
+        index = *pWhitePointIndex;
+        (*pWhitePointIndex)++;
+        
+        if (index == 0)
+        {
+            if (pWhiteX != (unsigned short *)0)
+            {
+                *pWhiteX = edidCalculateChromaticValue(((unsigned short)pEDIDStructure->whiteX << 2) +
+                                                        (unsigned short)pEDIDStructure->blueWhiteLowBits.whiteXLowBits);
+            }
+            
+            if (pWhiteY != (unsigned short *)0)
+            {
+                *pWhiteY = edidCalculateChromaticValue(((unsigned short)pEDIDStructure->whiteY << 2) +
+                                                        (unsigned short)pEDIDStructure->blueWhiteLowBits.whiteYLowBits);
+            }
+            
+            if (pWhiteGamma != (unsigned short *)0)
+                *pWhiteGamma = pEDIDStructure->displayTransferChar + 100;
+                
+            return 0;
+        }
+        else
+        {
+            for (tableIndex = 0; tableIndex < 4; tableIndex++)
+            {
+                pMonitorDescriptor = &pEDIDStructure->miscInformation.monitorDesc[tableIndex];
+                if ((pMonitorDescriptor->flag1 == 0) && (pMonitorDescriptor->flag2 == 0) &&
+                    (pMonitorDescriptor->dataTypeTag == 0xFB) && 
+                    (pMonitorDescriptor->descriptor.colorPoint.white[index-1].whitePointIndex != 0))
+                {
+                    if (pWhiteX != (unsigned short *)0)
+                    {
+                        *pWhiteX = edidCalculateChromaticValue(((unsigned short)pMonitorDescriptor->descriptor.colorPoint.white[index-1].whiteX << 2) +
+                                                                (unsigned short)pMonitorDescriptor->descriptor.colorPoint.white[index-1].whiteLowBits.whiteXLowBits);
+                    }
+                    
+                    if (pWhiteY != (unsigned short *)0)
+                    {
+                        *pWhiteY = edidCalculateChromaticValue(((unsigned short)pMonitorDescriptor->descriptor.colorPoint.white[index-1].whiteY << 2) +
+                                                                (unsigned short)pMonitorDescriptor->descriptor.colorPoint.white[index-1].whiteLowBits.whiteYLowBits);
+                    }
+                    
+                    if (pWhiteGamma != (unsigned short *)0)
+                        *pWhiteGamma = pMonitorDescriptor->descriptor.colorPoint.white[index-1].gamma + 100;
+                    
+                    return 0;
+                }
+            }
+        }
+    }
+    
+    return (-1);
+}
+
+/*
+ *  edidCalculateChecksum
+ *      This function adds all one-byte value of the EDID buffer. 
+ *      The total should be equal to 0x00
+ *
+ *  Input:
+ *      pEDIDBuffer     - Buffer that contains the EDID structure of the monitor
+ *
+ *  Output:
+ *      Total of one-byte values. It should equal to 0x00. A value other than
+ *      0x00 indicates the EDID buffer is not valid.
+ */
+static unsigned char edidCalculateChecksum(
+    unsigned char *pEDIDBuffer
+)
+{
+    unsigned char version, revision, checksum;
+    unsigned short index;
+    
+    /* Get EDID Version and revision */
+    version = edidGetVersion(pEDIDBuffer, &revision);
+    
+    checksum = 0;
+    if (version == 1)
+    {
+        for (index = 0; index < 128; index++)
+            checksum += pEDIDBuffer[index];
+    }
+    
+    return checksum;
+}
+
+/*
+ *  edidGetExtension
+ *      This function gets the number of (optional) EDID extension blocks to follow
+ *      the given EDID buffer.
+ *
+ *  Input:
+ *      pEDIDBuffer     - Buffer that contains the EDID structure of the monitor
+ *
+ *  Output:
+ *      Total number of EDID Extension to follow the given EDID buffer.
+ */
+unsigned char edidGetExtension(
+    unsigned char *pEDIDBuffer
+)
+{
+    unsigned char version, revision;
+    
+    /* Get EDID Version and revision */
+    version = edidGetVersion(pEDIDBuffer, &revision);
+    
+    if (version == 1)
+        return ((edid_version_1_t *)pEDIDBuffer)->extFlag;
+    
+    return 0;
+}
+
+#define EDID_TOTAL_RETRY_COUNTER            4
+
+#if 0
+
+/*
+ *  edidReadMonitor
+ *      This function reads the EDID structure from the attached monitor
+ *
+ *  Input:
+ *      displayPath - Display device which EDID to be read from.
+ *      pEDIDBuffer - Buffer that contains the EDID structure of the monitor
+ *      bufferSize  - The EDID Buffer size index (usually 128-bytes)
+ *      edidExtNo   - Extension Index of the EDID Structure to be read
+ *      sclGpio     - GPIO pin used as the I2C Clock (SCL)
+ *      sdaGpio     - GPIO pin used as the I2C Data (SDA)
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long ddk750_edidReadMonitorEx(
+    disp_path_t displayPath,
+    unsigned char *pEDIDBuffer,
+    unsigned long bufferSize,
+    unsigned char edidExtNo,
+    unsigned char sclGpio,
+    unsigned char sdaGpio
+)
+{
+    unsigned char value, retry, edidVersion, edidRevision;
+    unsigned char edidBuffer[256];
+    unsigned long offset;
+    
+    /* Initialize the i2c bus */
+    swI2CInit(sclGpio, sdaGpio);
+
+    for (retry = 0; retry < EDID_TOTAL_RETRY_COUNTER; retry++)
+    {
+        DDKDEBUGPRINT((DISPLAY_LEVEL, "retry: %d\n", retry));
+            
+        /* Read the EDID from the monitor. */
+        for (offset = 0; offset < TOTAL_EDID_REGISTERS; offset++)
+            edidBuffer[offset] = swI2CReadReg(EDID_DEVICE_I2C_ADDRESS, (unsigned char)offset);
+            
+        /* Check if the EDID is valid. */
+        edidVersion = edidGetVersion((unsigned char *)&edidBuffer, (unsigned char *)&edidRevision);
+        DDKDEBUGPRINT((DISPLAY_LEVEL, "EDID Structure Version: %d.%d\n", edidVersion, edidRevision)); 
+        if (edidVersion != 0)
+            break;
+    }
+    
+    /* 
+     *  The monitor might not be DDC2B compliance. Therefore, need to use DDC1 protocol,
+     *  which uses the Vertical Sync to clock in the EDID data.
+     *  Currently this function return error. DDC1 protocol can be added later.  
+     */
+    if (retry == EDID_TOTAL_RETRY_COUNTER)
+    {
+        /* DDC1 uses the SDA line to transmit 9 bit data per byte. The last bit is
+         * only an acknowledge flag, which could be high or low. However, SCL line
+         * is not used. Instead the data is clock-in using vertical sync.
+         */
+        return (-1);
+    }
+    
+    /* Copy the data to the given buffer */
+    if (pEDIDBuffer != (unsigned char *)0)
+    {
+        for (offset = 0; offset < bufferSize; offset++)
+            pEDIDBuffer[offset] = edidBuffer[offset];
+    }
+    
+#if 0 /*def DDKDEBUG*/
+    for (offset = 0; offset < TOTAL_EDID_REGISTERS; offset++)
+    {
+        if ((offset % 16) == 0)
+        {
+            if (offset != 0)
+                DDKDEBUGPRINT((0/*DISPLAY_LEVEL*/, "\n"));
+            DDKDEBUGPRINT((0/*DISPLAY_LEVEL*/, "%02x:\t", offset));
+        }
+        DDKDEBUGPRINT((0/*DISPLAY_LEVEL*/, "%02x  ", pEDIDBuffer[offset]));
+    }
+    DDKDEBUGPRINT((0/*DISPLAY_LEVEL*/, "\n"));
+#endif
+
+    return 0;
+}
+
+#else
+/*
+ *  ddk750_edidReadMonitor
+ *      This function reads the EDID structure from the attached monitor
+ *
+ *  Input:
+ *      displayPath - Display device which EDID to be read from.
+ *      pEDIDBuffer - Buffer that contains the EDID structure of the monitor
+ *      bufferSize  - The EDID Buffer size index (usually 128-bytes)
+ *      edidExtNo   - Extension Index of the EDID Structure to be read
+ *      sclGpio     - GPIO pin used as the I2C Clock (SCL)
+ *      sdaGpio     - GPIO pin used as the I2C Data (SDA)
+ *
+ *  Output:
+ *      0   - Fail
+ *      edidSize   - Success and return the edid's size
+ */
+long ddk750_edidReadMonitorEx(
+	disp_path_t displayPath,
+    unsigned char *pEDIDBuffer,
+    unsigned long bufferSize,
+    unsigned char edidExtNo,
+    unsigned char sclGpio,
+    unsigned char sdaGpio
+)
+{
+    unsigned char value, retry, edidVersion, edidRevision;
+    unsigned char edidBuffer[TOTAL_EDID_REGISTERS_256];
+    unsigned long offset;
+    long edidSize = TOTAL_EDID_REGISTERS_128;
+
+    /* Initialize the i2c bus */
+    swI2CInit(sclGpio, sdaGpio);
+
+    for (retry = 0; retry < EDID_TOTAL_RETRY_COUNTER; retry++)
+    {
+       // DDKDEBUGPRINT((DISPLAY_LEVEL, "retry: %d\n", retry));
+
+        /* Read the EDID from the monitor. */
+        for (offset = 0; offset < TOTAL_EDID_REGISTERS_128; offset++)
+            edidBuffer[offset] = swI2CReadReg(EDID_DEVICE_I2C_ADDRESS, (unsigned char)offset);
+		if(edidBuffer[EDID_EXTEND_BLOCK])
+		{
+			for (offset = TOTAL_EDID_REGISTERS_128; offset < TOTAL_EDID_REGISTERS_256; offset++)
+				edidBuffer[offset] = swI2CReadReg(EDID_DEVICE_I2C_ADDRESS, (unsigned char)offset);
+			edidSize = TOTAL_EDID_REGISTERS_256;
+		}
+
+        /* Check if the EDID is valid. */
+        edidVersion = edidGetVersion((unsigned char *)&edidBuffer, (unsigned char *)&edidRevision);
+        //DDKDEBUGPRINT((DISPLAY_LEVEL, "EDID Structure Version: %d.%d\n", edidVersion, edidRevision));
+        if (edidVersion != 0)
+            break;
+    }
+
+    /*
+     *  The monitor might not be DDC2B compliance. Therefore, need to use DDC1 protocol,
+     *  which uses the Vertical Sync to clock in the EDID data.
+     *  Currently this function return error. DDC1 protocol can be added later.
+     */
+    if (retry == EDID_TOTAL_RETRY_COUNTER)
+    {
+        /* DDC1 uses the SDA line to transmit 9 bit data per byte. The last bit is
+         * only an acknowledge flag, which could be high or low. However, SCL line
+         * is not used. Instead the data is clock-in using vertical sync.
+         */
+        return 0;
+    }
+
+    /* Copy the data to the given buffer */
+    if (pEDIDBuffer != (unsigned char *)0)
+    {
+        for (offset = 0; offset < edidSize; offset++)
+            pEDIDBuffer[offset] = edidBuffer[offset];
+    }
+
+    return edidSize;
+}
+#endif
+
+long ddk750_edidReadMonitorEx_HW(
+    disp_path_t displayPath,
+    unsigned char *pEDIDBuffer,
+    unsigned long bufferSize,
+    unsigned char edidExtNo
+)
+{
+    unsigned char value, retry, edidVersion, edidRevision;
+    unsigned char edidBuffer[256];
+    unsigned long offset;
+	long edidSize = 0;
+    
+    /* Initialize the i2c bus */
+    ddk750_hwI2CInit(1);
+
+#if 0
+    for (retry = 0; retry < EDID_TOTAL_RETRY_COUNTER; retry++)
+    {
+                
+        /* Read the EDID from the monitor. */
+        for (offset = 0; offset < TOTAL_EDID_REGISTERS; offset++)
+            edidBuffer[offset] = ddk750_hwI2CReadReg(EDID_DEVICE_I2C_ADDRESS, (unsigned char)offset);
+            
+        /* Check if the EDID is valid. */
+        edidVersion = edidGetVersion((unsigned char *)&edidBuffer, (unsigned char *)&edidRevision);
+        if (edidVersion != 0)
+            break;
+    }
+#else
+
+	for (retry = 0; retry < EDID_TOTAL_RETRY_COUNTER; retry++)
+    {
+        //DDKDEBUGPRINT((DISPLAY_LEVEL, "retry: %d\n", retry));
+		edidSize = 0;
+        /* Read the EDID from the monitor. */
+        for (offset = 0; offset < TOTAL_EDID_REGISTERS_128; offset++)
+        {
+            value = ddk750_hwI2CReadReg(EDID_DEVICE_I2C_ADDRESS, (unsigned char)offset);
+            if(0xFFFFFFFF == value)
+                break;
+            edidBuffer[offset] = (0xFF & value);
+        }
+        if(0xFFFFFFFF != value)
+        {
+          	edidSize = TOTAL_EDID_REGISTERS_128;
+            if(edidBuffer[EDID_EXTEND_BLOCK])
+            {
+                for (offset = TOTAL_EDID_REGISTERS_128; offset < TOTAL_EDID_REGISTERS_256; offset++)
+                {
+                    value = ddk750_hwI2CReadReg(EDID_DEVICE_I2C_ADDRESS, (unsigned char)offset);
+
+                    if(0xFFFFFFFF == value)
+                        break;
+                    edidBuffer[offset] = (0xFF & value);
+                }
+
+                if(0xFFFFFFFF != value)
+                	edidSize = TOTAL_EDID_REGISTERS_256;
+            }
+            if(0xFFFFFFFF != value)
+            {
+                /* Check if the EDID is valid. */
+                edidVersion = edidGetVersion((unsigned char *)&edidBuffer, (unsigned char *)&edidRevision);
+           //     DDKDEBUGPRINT((DISPLAY_LEVEL, "EDID Structure Version: %d.%d\n", edidVersion, edidRevision));
+                if (edidVersion != 0)
+                    break;
+            }
+        }
+    }
+
+#endif
+    /* Finish using HW I2C, we can close the device. */
+    ddk750_hwI2CClose();
+
+    /* 
+     *  The monitor might not be DDC2B compliance. Therefore, need to use DDC1 protocol,
+     *  which uses the Vertical Sync to clock in the EDID data.
+     *  Currently this function return error. DDC1 protocol can be added later.  
+     */
+    if (retry == EDID_TOTAL_RETRY_COUNTER)
+    {
+        /* DDC1 uses the SDA line to transmit 9 bit data per byte. The last bit is
+         * only an acknowledge flag, which could be high or low. However, SCL line
+         * is not used. Instead the data is clock-in using vertical sync.
+         */
+        return (-1);
+    }
+    
+    /* Copy the data to the given buffer */
+    if (pEDIDBuffer != (unsigned char *)0)
+    {
+        for (offset = 0; offset < edidSize; offset++)
+            pEDIDBuffer[offset] = edidBuffer[offset];
+    }
+    
+#if 0 /*def DDKDEBUG*/
+    for (offset = 0; offset < TOTAL_EDID_REGISTERS; offset++)
+    {
+        if ((offset % 16) == 0)
+        {
+            if (offset != 0)
+                DDKDEBUGPRINT((0/*DISPLAY_LEVEL*/, "\n"));
+            DDKDEBUGPRINT((0/*DISPLAY_LEVEL*/, "%02x:\t", offset));
+        }
+        DDKDEBUGPRINT((0/*DISPLAY_LEVEL*/, "%02x  ", pEDIDBuffer[offset]));
+    }
+    DDKDEBUGPRINT((0/*DISPLAY_LEVEL*/, "\n"));
+#endif
+
+    return edidSize;
+}
+
+
+
+/*
+ *  edidReadMonitor
+ *      This function reads the EDID structure from the attached monitor
+ *
+ *  Input:
+ *      displayPath - Display device which EDID to be read from.
+ *      pEDIDBuffer - Buffer that contains the EDID structure of the monitor
+ *      bufferSize  - The EDID Buffer size index (usually 128-bytes)
+ *      edidExtNo   - Extension Index of the EDID Structure to be read
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long ddk750_edidReadMonitor(
+    disp_path_t displayPath,
+    unsigned char *pEDIDBuffer,
+    unsigned long bufferSize,
+    unsigned char edidExtNo
+)
+{
+    return ddk750_edidReadMonitorEx(displayPath, pEDIDBuffer, bufferSize, edidExtNo, DEFAULT_I2C_SCL, DEFAULT_I2C_SDA);
+}
+
+#define HEADER_EDID_REGISTERS               8
+
+/*
+ *  edidGetHeader
+ *      This function gets the EDID Header
+ *
+ *  Input:
+ *      pEDIDBuffer - Buffer that contains the EDID structure of the monitor
+ *
+ *  Output:
+ *      0 get header success; -1 fail.
+ */
+unsigned char ddk750_edidGetHeader(
+    unsigned char *pEDIDBuffer
+)
+{
+    if (pEDIDBuffer != (unsigned char *)0)
+    {
+        /* Check the header */
+        if ((pEDIDBuffer[0] == 0x00) && (pEDIDBuffer[1] == 0xFF) && (pEDIDBuffer[2] == 0xFF) &&
+            (pEDIDBuffer[3] == 0xFF) && (pEDIDBuffer[4] == 0xFF) && (pEDIDBuffer[5] == 0xFF) &&
+            (pEDIDBuffer[6] == 0xFF) && (pEDIDBuffer[7] == 0x00))
+        {
+            return 0;
+        }
+        else
+            return -1;
+    }
+
+   // DDKDEBUGPRINT((DISPLAY_LEVEL, "Invalid EDID bufffer\n"));
+    return -1;
+}
+
+
+
+/*
+ *  edidHeaderReadMonitor
+ *      This function reads the EDID header from the attached monitor
+ *
+ *  Input:
+ *      sclGpio     - GPIO pin used as the I2C Clock (SCL)
+ *      sdaGpio     - GPIO pin used as the I2C Data (SDA)
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long ddk750_edidHeaderReadMonitorEx(
+    unsigned char sclGpio,
+    unsigned char sdaGpio
+)
+{
+    unsigned char retry;//value,
+    unsigned char edidBuffer[10];
+    unsigned long offset;
+
+    /* Initialize the i2c bus */
+    swI2CInit(sclGpio, sdaGpio);
+
+    for (retry = 0; retry < EDID_TOTAL_RETRY_COUNTER; retry++)
+    {
+     //   DDKDEBUGPRINT((DISPLAY_LEVEL, "retry: %d\n", retry));
+
+        /* Read the EDID from the monitor. */
+        for (offset = 0; offset < HEADER_EDID_REGISTERS; offset++)
+            edidBuffer[offset] = swI2CReadReg(EDID_DEVICE_I2C_ADDRESS, (unsigned char)offset);
+
+        /* Check if the EDID header is valid. */
+        if (!ddk750_edidGetHeader((unsigned char *)&edidBuffer))
+            break;
+    }
+
+    /*
+     *  The monitor might not be DDC2B compliance. Therefore, need to use DDC1 protocol,
+     *  which uses the Vertical Sync to clock in the EDID data.
+     *  Currently this function return error. DDC1 protocol can be added later.
+     */
+    if (retry == EDID_TOTAL_RETRY_COUNTER)
+    {
+        /* DDC1 uses the SDA line to transmit 9 bit data per byte. The last bit is
+         * only an acknowledge flag, which could be high or low. However, SCL line
+         * is not used. Instead the data is clock-in using vertical sync.
+         */
+        return (-1);
+    }
+
+    return 0;
+}
+
+long ddk750_edidHeaderReadMonitorExHwI2C(void)
+{
+    unsigned char retry;//value,
+    unsigned char edidBuffer[10];
+    unsigned long offset;
+
+    /* Initialize the i2c bus */
+    ddk750_hwI2CInit(1);
+
+    for (retry = 0; retry < EDID_TOTAL_RETRY_COUNTER; retry++)
+    {
+        DDKDEBUGPRINT((DISPLAY_LEVEL, "retry: %d\n", retry));
+
+        /* Read the EDID from the monitor. */
+        for (offset = 0; offset < HEADER_EDID_REGISTERS; offset++)
+            edidBuffer[offset] = ddk750_hwI2CReadReg(EDID_DEVICE_I2C_ADDRESS, (unsigned char)offset);
+
+        /* Check if the EDID header is valid. */
+        if (!ddk750_edidGetHeader((unsigned char *)&edidBuffer))
+            break;
+    }
+
+	/* Finish using HW I2C, we can close the device. */
+    ddk750_hwI2CClose();
+
+    /*
+     *  The monitor might not be DDC2B compliance. Therefore, need to use DDC1 protocol,
+     *  which uses the Vertical Sync to clock in the EDID data.
+     *  Currently this function return error. DDC1 protocol can be added later.
+     */
+    if (retry == EDID_TOTAL_RETRY_COUNTER)
+    {
+        /* DDC1 uses the SDA line to transmit 9 bit data per byte. The last bit is
+         * only an acknowledge flag, which could be high or low. However, SCL line
+         * is not used. Instead the data is clock-in using vertical sync.
+         */
+        return (-1);
+    }
+
+    return 0;
+}
+
+
+
+
+/*
+ *  edidGetEstablishedTiming
+ *      This function gets the established timing list from the given EDID buffer,
+ *      table, and timing index.
+ *
+ *  Input:
+ *      pEDIDBuffer     - Buffer that contains the EDID structure of the monitor (In)
+ *      pEstTableIndex  - Pointer to the Established Timing Table index  (In/Out)
+ *      pIndex          - Pointer to the Establihsed Timing Index (In/Out)
+ *      pWidth          - Pointer to a variable that to store the horizontal active / width
+ *                        value of the retrieved timing (Out)
+ *      pHeight         - Pointer to a variable to store the vertical active / height
+ *                        value of the retrieved timing (Out)
+ *      pRefreshRate    - Pointer to a variable to store the vertical frequency value
+ *                        of the retrieved timing (out)
+ *      pSource         - Pointer to a variable to store the standard timing source:
+ *                          0 - VESA
+ *                          1 - IBM
+ *                          2 - Apple
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long edidGetEstablishedTiming(
+    unsigned char *pEDIDBuffer,
+    /*unsigned char *pEstTableIndex,*/
+    unsigned char *pIndex,
+    unsigned long *pWidth,
+    unsigned long *pHeight,
+    unsigned long *pRefreshRate,
+    unsigned char *pSource
+)
+{
+    unsigned char version, revision;
+    unsigned char tableIndex, index;
+    
+    /* Get EDID Version and revision */
+    version = edidGetVersion(pEDIDBuffer, &revision);
+    
+    if (version == 1)
+    {
+        edid_version_1_t *pEDIDStructure;
+        
+        /* EDID Structure Version 1. */
+        pEDIDStructure = (edid_version_1_t *)pEDIDBuffer;
+        
+        while (1)
+        {
+            /* Get index */
+            index = *pIndex;
+            
+            if (index > 16)
+                break;
+            
+            /* Search Established Table index 0 when the index is less than 8 */
+            tableIndex = index / 8;
+            
+            /* Exit the function when it has reached the last table. */
+            if (tableIndex > 2)
+                break;
+            
+            /* Increment the index value and update the index accordingly */
+            (*pIndex)++;
+            index %= 8;
+            
+            /* Check */
+            if ((pEDIDStructure->estTiming[tableIndex] & (1 << index)) != 0)
+            {
+                if (pWidth != (unsigned long *)0)
+                    *pWidth = establishTiming[tableIndex][index].x;
+        
+                if (pHeight != (unsigned long *)0)
+                    *pHeight = establishTiming[tableIndex][index].y;
+    
+                if (pRefreshRate != (unsigned long *)0)
+                    *pRefreshRate = establishTiming[tableIndex][index].hz;
+    
+                if (pSource != (unsigned char *)0)
+                    *pSource = establishTiming[tableIndex][index].source;
+                    
+                /* Return success */
+                return 0;
+            }
+        }
+    }
+    else
+    {
+        /* EDID Structure Version 2.0. */
+    }
+    
+    return (-1);
+}
+
+/*
+ *  edidCalculateStdTiming
+ *      This function calculates the width, height, and vertical frequency values
+ *      from the given Standard Timing structure. This function only applies to
+ *      EDID structure version 1. It will give the wrong result when used with
+ *      EDID version 2.
+ *
+ *  Input:
+ *      pStdTiming      - Pointer to a standard timing structure that contains the
+ *                        standard timing value to be calculated (In)
+ *      edid1Revision   - Revision of the EDID 1 (In)
+ *      pWidth          - Pointer to a variable that to store the horizontal active / width
+ *                        value of the retrieved timing (Out)
+ *      pHeight         - Pointer to a variable to store the vertical active / height
+ *                        value of the retrieved timing (Out)
+ *      pRefreshRate    - Pointer to a variable to store the vertical frequency value
+ *                        of the retrieved timing (out)
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+static long edidCalculateStdTiming(
+    standard_timing_t *pStdTiming,
+    unsigned char edid1Revision,
+    unsigned long *pWidth,
+    unsigned long *pHeight,
+    unsigned long *pRefreshRate
+)
+{
+    unsigned long x, y;
+     
+    /* Calculate the standard timing into x and y mode dimension */
+    if (pStdTiming->horzActive != 0x01)
+    {
+        /* Calculate the X and Y */
+        x = (pStdTiming->horzActive + 31) * 8;
+        switch (pStdTiming->stdTimingInfo.aspectRatio)
+        {
+            case 0:
+                if (edid1Revision != 3)
+                    y = x;                  /* 1:1 aspect ratio (prior revision 1.3) */
+                else
+                    y = x * 10 / 16;        /* 16:10 aspect ratio (revision 1.3) */
+                break;
+            case 1:
+                y = x * 3 / 4;              /* 4:3 aspect ratio */
+                break;
+            case 2:
+                y = x * 4 / 5;              /* 5:4 aspect ratio */
+                break;
+            case 3:
+                y = x * 9 / 16;             /* 16:9 aspect ratio */
+                break;
+        }
+
+        if (pWidth != (unsigned long *)0)
+            *pWidth = x;
+
+        if (pHeight != (unsigned long *)0)
+            *pHeight = y;
+
+        if (pRefreshRate != (unsigned long *)0)
+            *pRefreshRate = pStdTiming->stdTimingInfo.refreshRate + 60;
+    
+        return 0;
+    }
+    
+    return (-1);
+}
+
+/*
+ *  edidGetStandardTiming
+ *      This function gets the standard timing from the given EDID buffer and
+ *      calculates the width, height, and vertical frequency from that timing.
+ *
+ *  Input:
+ *      pEDIDBuffer     - Buffer that contains the EDID structure of the monitor
+ *      pStdTimingIndex - Pointer to a standard timing index to be retrieved
+ *      pWidth          - Pointer to a variable that to store the horizontal active / width
+ *                        value of the retrieved timing (Out)
+ *      pHeight         - Pointer to a variable to store the vertical active / height
+ *                        value of the retrieved timing (Out)
+ *      pRefreshRate    - Pointer to a variable to store the vertical frequency value
+ *                        of the retrieved timing (out)
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long edidGetStandardTiming(
+    unsigned char *pEDIDBuffer,
+    unsigned char *pStdTimingIndex,
+    unsigned long *pWidth,
+    unsigned long *pHeight,
+    unsigned long *pRefreshRate
+)
+{
+    unsigned char version, revision, timingIndex, tableIndex;
+    unsigned long x, y, aspectRatio;
+    
+    /* Get EDID Version and revision */
+    version = edidGetVersion(pEDIDBuffer, &revision);
+    
+    if (version == 1)
+    {
+        edid_version_1_t *pEDIDStructure;
+        monitor_desc_t *pMonitorDescriptor;
+        
+        /* EDID Structure Version 1. */
+        pEDIDStructure = (edid_version_1_t *)pEDIDBuffer;
+        
+        while (1)
+        {
+            /* There are only 8 standard timing entries */
+            if (*pStdTimingIndex > 7)
+                break;
+            
+            /* Get the table index first before incrementing the index. */
+            timingIndex = *pStdTimingIndex;
+            
+            /* Increment the standard timing index */
+            (*pStdTimingIndex)++;
+            
+            if (timingIndex < 8)
+            {
+                /*
+                 *  Search the first Standard Timing Identifier table
+                 */
+                 
+                /* Calculate the standard timing into x and y mode dimension */
+                if (edidCalculateStdTiming(&pEDIDStructure->stdTiming[timingIndex], 
+                                       revision, pWidth, pHeight, pRefreshRate) == 0)
+                {
+                    return 0;
+                }
+            }
+            else
+            {
+                /*
+                 *  Search Standard Timing Identifier Table in the detailed Timing block. 
+                 */
+                
+                /* 
+                 * Each Detailed Timing Identifier can contains 6 entries of Standard Timing
+                 * Identifier. Based on this value, we can get the Detailed Timing Table Index
+                 * that contains the requested standard timing.
+                 */
+                timingIndex = timingIndex - 8;
+                for (tableIndex = 0; tableIndex < 4; tableIndex++)
+                {
+                    /* Get detailed info */
+                    pMonitorDescriptor = &pEDIDStructure->miscInformation.monitorDesc[tableIndex];
+                    if ((pMonitorDescriptor->flag1 == 0) && (pMonitorDescriptor->flag2 == 0) &&
+                        (pMonitorDescriptor->dataTypeTag == 0xFA))
+                    {
+                        if (timingIndex >= 6)
+                        {
+                            timingIndex-=6;
+                            continue;
+                        }
+                        else
+                        {
+                            if (edidCalculateStdTiming(&pMonitorDescriptor->descriptor.stdTimingExt.stdTiming[timingIndex], 
+                                                   revision, pWidth, pHeight, pRefreshRate) == 0)
+                            {
+                                return 0;
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+    else
+    {
+        /* EDID Structure version 2 */
+    }
+    
+    return (-1);
+}
+
+/*
+ *  edidGetDetailedTiming
+ *      This function gets the detailed timing from the given EDID buffer.
+ *
+ *  Input:
+ *      pEDIDBuffer             - Buffer that contains the EDID structure of the monitor
+ *      pDetailedTimingIndex    - Pointer to a detailed timing index to be retrieved
+ *      pModeParameter          - Pointer to a mode_parameter_t structure that will be
+ *                                filled with the detailed timing.
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long edidGetDetailedTiming(
+    unsigned char *pEDIDBuffer,
+    unsigned char *pDetailedTimingIndex,
+    vdif_t *pVDIF
+)
+{
+    unsigned char version, revision, tableIndex;
+    unsigned long x, y, aspectRatio;
+    
+    /* Get EDID Version and revision */
+    version = edidGetVersion(pEDIDBuffer, &revision);
+    
+    if (version == 1)
+    {
+        edid_version_1_t *pEDIDStructure;
+        detailed_timing_t *pDetailedTiming;
+        
+        /* EDID Structure Version 1. */
+        pEDIDStructure = (edid_version_1_t *)pEDIDBuffer;
+        
+        while (1)
+        {
+            if (*pDetailedTimingIndex > 3)
+                break;
+            
+            /* Get the Detail Timing entry index */
+            tableIndex = *pDetailedTimingIndex;
+            
+            /* Increment the index */
+            (*pDetailedTimingIndex)++;
+                
+            /* Get detailed info */
+            pDetailedTiming = &pEDIDStructure->miscInformation.detailTiming[tableIndex];
+            if ((pDetailedTiming->pixelClock != 0) && (pVDIF != (vdif_t *)0))
+            {
+                /* Translate the Detail timing to VDIF format. */
+                pVDIF->pixelClock = (unsigned long)pDetailedTiming->pixelClock * 10000;
+                pVDIF->characterWidth = 8;
+                pVDIF->scanType = (pDetailedTiming->flags.interlaced == 0) ? VDIF_NONINTERLACED : VDIF_INTERLACED;
+
+                pVDIF->horizontalActive = 
+                    ((unsigned long)pDetailedTiming->horzActiveBlanking.horzActiveMSB << 8) +
+                     (unsigned long)pDetailedTiming->horzActive;
+                pVDIF->horizontalBlankStart = pVDIF->horizontalActive;
+                pVDIF->horizontalBlankTime = 
+                    ((unsigned long)pDetailedTiming->horzActiveBlanking.horzBlankingMSB << 8) +
+                     (unsigned long)pDetailedTiming->horzBlanking;
+                pVDIF->horizontalTotal = pVDIF->horizontalActive + pVDIF->horizontalBlankTime;
+                pVDIF->horizontalFrontPorch = 
+                    ((unsigned long)pDetailedTiming->syncAuxInfo.horzSyncOffset << 8) + 
+                     (unsigned long)pDetailedTiming->horzSyncOffset;
+                pVDIF->horizontalSyncStart = pVDIF->horizontalBlankStart + pVDIF->horizontalFrontPorch;
+                pVDIF->horizontalSyncWidth = 
+                    ((unsigned long)pDetailedTiming->syncAuxInfo.horzSyncWidth << 8) +
+                     (unsigned long)pDetailedTiming->horzSyncPulseWidth;                     
+                pVDIF->horizontalBackPorch = 
+                    pVDIF->horizontalBlankTime - (pVDIF->horizontalFrontPorch + pVDIF->horizontalSyncWidth);
+                pVDIF->horizontalFrequency = roundedDiv(pVDIF->pixelClock, pVDIF->horizontalTotal);
+                pVDIF->horizontalLeftBorder = 0;
+                pVDIF->horizontalRightBorder = 0;
+        
+                pVDIF->verticalActive = 
+                    ((unsigned long)pDetailedTiming->vertActiveBlanking.vertActiveMSB << 8) +
+                     (unsigned long)pDetailedTiming->vertActive;
+                pVDIF->verticalBlankStart = pVDIF->verticalActive;
+                pVDIF->verticalBlankTime =
+                    ((unsigned long)pDetailedTiming->vertActiveBlanking.vertBlankingMSB << 8) +
+                     (unsigned long)pDetailedTiming->vertBlanking;
+                pVDIF->verticalTotal = pVDIF->verticalActive + pVDIF->verticalBlankTime;
+                pVDIF->verticalFrontPorch = 
+                    ((unsigned long)pDetailedTiming->syncAuxInfo.vertSyncOffset << 8) +
+                     (unsigned long)pDetailedTiming->verticalSyncInfo.syncOffset;
+                pVDIF->verticalSyncStart = pVDIF->verticalBlankStart + pVDIF->verticalFrontPorch;
+                pVDIF->verticalSyncHeight =
+                    ((unsigned long)pDetailedTiming->syncAuxInfo.vertSyncWidth  << 8) +
+                     (unsigned long)pDetailedTiming->verticalSyncInfo.syncWidth;
+                pVDIF->verticalBackPorch =
+                    pVDIF->verticalBlankTime - (pVDIF->verticalFrontPorch + pVDIF->verticalSyncHeight);
+                pVDIF->verticalFrequency =
+                    roundedDiv(pVDIF->pixelClock, (pVDIF->horizontalTotal * pVDIF->verticalTotal));
+                pVDIF->verticalTopBorder = 0;
+                pVDIF->verticalBottomBorder = 0;
+                
+                if (pDetailedTiming->flags.connectionType == 3)
+                {
+                    pVDIF->verticalSyncPolarity = 
+                        (pDetailedTiming->flags.vertSyncFlag == 1) ? VDIF_SYNC_POSITIVE : VDIF_SYNC_NEGATIVE;
+                    pVDIF->horizontalSyncPolarity = 
+                        (pDetailedTiming->flags.horzSyncFlag == 1) ? VDIF_SYNC_POSITIVE : VDIF_SYNC_NEGATIVE;
+                }
+                else
+                {
+                    pVDIF->verticalSyncPolarity = VDIF_SYNC_NEGATIVE;
+                    pVDIF->horizontalSyncPolarity = VDIF_SYNC_NEGATIVE;
+                }
+                
+                /* For debugging purpose. */
+                printVdif(pVDIF);
+                
+                return 0;
+            }
+        }
+    }
+    
+    return (-1);
+}
+
+/*
+ *  edidGetMonitorSerialNumber
+ *      This function gets the monitor serial number from the EDID structure.
+ *      Only EDID version 1 and revision 1 or above supports this feature.
+ *
+ *  Input:
+ *      pEDIDBuffer             - Buffer that contains the EDID structure of the monitor
+ *      pMonitorSerialNumber    - Pointer to a buffer to store the serial number 
+ *                                retrieved from the EDID
+ *      bufferSize              - The size of the buffer to store the serial number.
+ *                                The maximum size required is 13 bytes.
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long edidGetMonitorSerialNumber(
+    unsigned char *pEDIDBuffer,
+    char *pMonitorSerialNumber,
+    unsigned char bufferSize
+)
+{
+    unsigned char version, revision, tableIndex, charIndex;
+    
+    /* If no pointer is given or the buffer size is set to 0, then return fail. */
+    if ((pMonitorSerialNumber == (char *)0) || (bufferSize == 0))
+        return (-1);
+    
+    /* Get EDID Version and revision */
+    version = edidGetVersion(pEDIDBuffer, &revision);
+    
+    if ((version == 1) && (revision > 0))
+    {
+        edid_version_1_t *pEDIDStructure;
+        monitor_desc_t *pMonitorDescriptor;
+        
+        /* EDID Structure Version 1. */
+        pEDIDStructure = (edid_version_1_t *)pEDIDBuffer;
+        for (tableIndex = 0; tableIndex < 4; tableIndex++)
+        {
+            pMonitorDescriptor = &pEDIDStructure->miscInformation.monitorDesc[tableIndex];
+            if ((pMonitorDescriptor->flag1 == 0) && (pMonitorDescriptor->flag2 == 0) &&
+                (pMonitorDescriptor->dataTypeTag == 0xFF))
+            {
+                bufferSize = (bufferSize > 13) ? 13 : bufferSize;
+                for (charIndex = 0; charIndex < 13; charIndex++)
+                {
+                    if (pMonitorDescriptor->descriptor.serialNo[charIndex] == 0x0A)
+                    {
+                        pMonitorSerialNumber[charIndex] = '\0';
+                        break;
+                    }
+                        
+                    pMonitorSerialNumber[charIndex] = pMonitorDescriptor->descriptor.serialNo[charIndex];
+                }
+                
+                return 0;
+            }
+        }
+    }
+    
+    /* Serial Number is not found. */
+    return (-1);
+}
+
+/*
+ *  edidGetDataString
+ *      This function gets the data string from the EDID 
+ *      Only EDID version 1 and revision 1 or above supports this feature.
+ *
+ *  Input:
+ *      pEDIDBuffer             - Buffer that contains the EDID structure of the monitor
+ *      pMonitorSerialNumber    - Pointer to a buffer to store the data string 
+ *                                retrieved from the EDID
+ *      bufferSize              - The size of the buffer to store the data string
+ *                                The maximum size required is 13 bytes.
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long edidGetDataString(
+    unsigned char *pEDIDBuffer,
+    char *pDataString,
+    unsigned char bufferSize
+)
+{
+    unsigned char version, revision, tableIndex, charIndex;
+    
+    /* If no pointer is given or the buffer size is set to 0, then return fail. */
+    if ((pDataString == (char *)0) || (bufferSize == 0))
+        return (-1);
+    
+    /* Get EDID Version and revision */
+    version = edidGetVersion(pEDIDBuffer, &revision);
+    
+    if ((version == 1) && (revision > 0))
+    {
+        edid_version_1_t *pEDIDStructure;
+        monitor_desc_t *pMonitorDescriptor;
+        
+        /* EDID Structure Version 1. */
+        pEDIDStructure = (edid_version_1_t *)pEDIDBuffer;
+        for (tableIndex = 0; tableIndex < 4; tableIndex++)
+        {
+            pMonitorDescriptor = &pEDIDStructure->miscInformation.monitorDesc[tableIndex];
+            if ((pMonitorDescriptor->flag1 == 0) && (pMonitorDescriptor->flag2 == 0) &&
+                (pMonitorDescriptor->dataTypeTag == 0xFE))
+            {
+                bufferSize = (bufferSize > 13) ? 13 : bufferSize;
+                for (charIndex = 0; charIndex < 13; charIndex++)
+                {
+                    if (pMonitorDescriptor->descriptor.dataString[charIndex] == 0x0A)
+                    {
+                        pDataString[charIndex] = '\0';
+                        break;
+                    }
+                        
+                    pDataString[charIndex] = pMonitorDescriptor->descriptor.dataString[charIndex];
+                }
+                
+                return 0;
+            }
+        }
+    }
+    
+    /* Data String is not found. */
+    return (-1);
+}
+
+/*
+ *  edidGetMonitorRangeLimit
+ *      This function gets the monitor range limits from the EDID structure.
+ *      Only EDID version 1 revision 1 or above supports this feature.
+ *      This is a required field in EDID Version 1.3
+ *
+ *  Input:
+ *      pEDIDBuffer         - Buffer that contains the EDID structure of the monitor
+ *      pMinVerticalRate    - Pointer to a variable to store the Minimum Vertical Rate (Hz)
+ *      pMaxVerticalRate    - Pointer to a variable to store the Maximum Vertical Rate (Hz)
+ *      pMinHorzFreq        - Pointer to a variable to store the Minimum Horz. Freq (kHz)
+ *      pMaxHorzFreq        - Pointer to a variable to store the Maximum Horz. Freq (kHz)
+ *      pMaxPixelClock      - Pointer to a variable to store the Maximum Pixel Clock (Hz)
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long edidGetMonitorRangeLimit(
+    unsigned char *pEDIDBuffer,
+    unsigned char *pMinVerticalRate,
+    unsigned char *pMaxVerticalRate,
+    unsigned char *pMinHorzFreq,
+    unsigned char *pMaxHorzFreq,
+    unsigned long *pMaxPixelClock
+)
+{
+    unsigned char version, revision, tableIndex, charIndex;
+    
+    if (pEDIDBuffer == (unsigned char *)0)
+        return (-1);
+            
+    /* Get EDID Version and revision */
+    version = edidGetVersion(pEDIDBuffer, &revision);
+    
+    if ((version == 1) && (revision > 0))
+    {
+        edid_version_1_t *pEDIDStructure;
+        monitor_desc_t *pMonitorDescriptor;
+        
+        /* EDID Structure Version 1. */
+        pEDIDStructure = (edid_version_1_t *)pEDIDBuffer;
+        
+        for (tableIndex = 0; tableIndex < 4; tableIndex++)
+        {
+            pMonitorDescriptor = &pEDIDStructure->miscInformation.monitorDesc[tableIndex];
+            if ((pMonitorDescriptor->flag1 == 0) && (pMonitorDescriptor->flag2 == 0) &&
+                (pMonitorDescriptor->dataTypeTag == 0xFD) && (pMonitorDescriptor->flag3 == 0))
+            {
+                if (pMinVerticalRate != (unsigned char *)0)
+                    *pMinVerticalRate = pMonitorDescriptor->descriptor.monitorRange.minVertRate;
+
+                if (pMaxVerticalRate != (unsigned char *)0)
+                    *pMaxVerticalRate = pMonitorDescriptor->descriptor.monitorRange.maxVertRate;
+                    
+                if (pMinHorzFreq != (unsigned char *)0)
+                    *pMinHorzFreq = pMonitorDescriptor->descriptor.monitorRange.minHorzFrequency;
+                    
+                if (pMaxHorzFreq != (unsigned char *)0)
+                    *pMaxHorzFreq = pMonitorDescriptor->descriptor.monitorRange.maxHorzFrequency;
+                    
+                if (pMaxPixelClock != (unsigned long *)0)
+                    *pMaxPixelClock = (unsigned long) pMonitorDescriptor->descriptor.monitorRange.maxPixelClock * 10 * 1000000;
+                    
+                return 0;
+            }
+        }
+    }
+    
+    /* Data String is not found. */
+    return (-1);
+}
+
+/*
+ *  edidGetSecondaryTimingSupport
+ *      This function gets the secondary GTF timing support.
+ *      Only EDID version 1 and revision 1 or above supports this feature.
+ *
+ *  Input:
+ *      pEDIDBuffer             - Buffer that contains the EDID structure of the monitor
+ *      pStartFrequency         - Pointer to a variable to store the start frequency of 
+ *                                the secondary GTF
+ *      pOffset                 - Pointer to a variable to store the Offset (C) value of
+ *                                the secondary GTF
+ *      pGradient               - Pointer to a variable to store the Gradient (M) value of
+ *                                the secondary GTF
+ *      pScalingFactor          - Pointer to a variable to store the Scaling Factor (K)
+ *                                value of the secondary GTF
+ *      pScalingFactorWeight    - Pointer to a variable to store the Scaling Factore Weight (J)
+ *                                value of the secondary GTF
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long edidGetSecondaryTimingSupport(
+    unsigned char *pEDIDBuffer,
+    unsigned short *pStartFrequency,
+    unsigned char *pOffset,
+    unsigned short *pGradient,
+    unsigned char *pScalingFactor,
+    unsigned char *pScalingFactorWeight
+)
+{
+    unsigned char version, revision, tableIndex, charIndex;
+            
+    /* Get EDID Version and revision */
+    version = edidGetVersion(pEDIDBuffer, &revision);
+    
+    if ((version == 1) && (revision > 0) && (pEDIDBuffer != (unsigned char *)0))
+    {
+        edid_version_1_t *pEDIDStructure;
+        monitor_desc_t *pMonitorDescriptor;
+        
+        /* EDID Structure Version 1. */
+        pEDIDStructure = (edid_version_1_t *)pEDIDBuffer;
+        for (tableIndex = 0; tableIndex < 4; tableIndex++)
+        {
+            pMonitorDescriptor = &pEDIDStructure->miscInformation.monitorDesc[tableIndex];
+            if ((pMonitorDescriptor->flag1 == 0) && (pMonitorDescriptor->flag2 == 0) &&
+                (pMonitorDescriptor->dataTypeTag == 0xFD) && 
+                (pMonitorDescriptor->descriptor.monitorRange.secondaryTimingFlag == 0x02))
+            {
+                if (pStartFrequency != (unsigned short *)0)
+                    *pStartFrequency = (unsigned short)
+                        pMonitorDescriptor->descriptor.monitorRange.secondaryTimingInfo.cmkjParam.startFrequency * 2 * 1000;
+
+                if (pOffset != (unsigned char *)0)
+                    *pOffset = pMonitorDescriptor->descriptor.monitorRange.secondaryTimingInfo.cmkjParam.cParam/2;
+                    
+                if (pGradient != (unsigned short *)0)
+                    *pGradient = pMonitorDescriptor->descriptor.monitorRange.secondaryTimingInfo.cmkjParam.mParam;
+                    
+                if (pScalingFactor != (unsigned char *)0)
+                    *pScalingFactor = pMonitorDescriptor->descriptor.monitorRange.secondaryTimingInfo.cmkjParam.kParam;
+                    
+                if (pScalingFactorWeight != (unsigned char *)0)
+                    *pScalingFactorWeight = pMonitorDescriptor->descriptor.monitorRange.secondaryTimingInfo.cmkjParam.jParam / 2;
+                    
+                return 0;
+            }
+        }
+    }
+    
+    /* Data String is not found. */
+    return (-1);
+}
+
+/*
+ *  edidGetMonitorName
+ *      This function gets the monitor name from the EDID structure.
+ *      This is a required field in EDID Version 1.3
+ *
+ *  Input:
+ *      pEDIDBuffer             - Buffer that contains the EDID structure of the monitor
+ *      pMonitorName            - Pointer to a buffer to store the monitor name 
+ *                                retrieved from the EDID
+ *      bufferSize              - The size of the buffer to store the monitor name
+ *                                The maximum size required is 13 bytes.
+ * 
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long edidGetMonitorName(
+    unsigned char *pEDIDBuffer,
+    char *pMonitorName,
+    unsigned char bufferSize
+)
+{
+    unsigned char version, revision, tableIndex, charIndex;
+    
+    /* If no pointer is given or the buffer size is set to 0, then return fail. */
+    if ((pMonitorName == (char *)0) || (bufferSize == 0))
+        return (-1);
+        
+    /* Get EDID Version and revision */
+    version = edidGetVersion(pEDIDBuffer, &revision);
+    
+    if (version == 1)
+    {
+        edid_version_1_t *pEDIDStructure;
+        monitor_desc_t *pMonitorDescriptor;
+        
+        /* EDID Structure Version 1. */
+        pEDIDStructure = (edid_version_1_t *)pEDIDBuffer;
+        for (tableIndex = 0; tableIndex < 4; tableIndex++)
+        {
+            pMonitorDescriptor = &pEDIDStructure->miscInformation.monitorDesc[tableIndex];
+            if ((pMonitorDescriptor->flag1 == 0) && (pMonitorDescriptor->flag2 == 0) &&
+                (pMonitorDescriptor->dataTypeTag == 0xFC) && (pMonitorDescriptor->flag3 == 0))
+            {
+                bufferSize = (bufferSize > 13) ? 13 : bufferSize;
+                for (charIndex = 0; charIndex < 13; charIndex++)
+                {
+                    if (pMonitorDescriptor->descriptor.monitorName[charIndex] == 0x0A)
+                    {
+                        pMonitorName[charIndex] = '\0';
+                        break;
+                    }
+                        
+                    pMonitorName[charIndex] = pMonitorDescriptor->descriptor.monitorName[charIndex];
+                }
+                
+                return 0;
+            }
+        }
+    }
+    
+    /* Data String is not found. */
+    return (-1);
+}
+
+/*
+ *  edidGetPreferredTiming
+ *      This function gets the preferred/native timing of the monitor
+ *
+ *  Input:
+ *      pEDIDBuffer         - Buffer that contains the EDID structure of the monitor
+ *      pWidth              - Pointer to an unsigned long buffer to store the width 
+ *                            of the preferred (native) timing.
+ *      pHeight             - Pointer to an unsigned long buffer to store the height
+ *                            of the preferred (native) timing.
+ *      pVerticalFrequency  - Pointer to an unsigned long buffer to store the refresh
+ *                            rate of the preferred (native) timing.
+ * 
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long edidGetPreferredTiming(
+    unsigned char *pEDIDBuffer,
+    unsigned long *pWidth,
+    unsigned long *pHeight,
+    unsigned long *pVerticalFrequency
+)
+{
+    unsigned char index = 0;
+    vdif_t vdifBuffer;
+
+/* Disable this checking since some old monitor does have the Detailed Timing although the preferred timing flag is 0. */
+#if 0
+    /* Check if preferred timing is available */
+    if (edidIsPreferredTimingAvailable(pEDIDBuffer) == 1)
+#endif
+    {
+        /* The preferred (native) timing is available, so get the timing. It is located
+           at the first index of detailed timing.
+         */
+        if (edidGetDetailedTiming(pEDIDBuffer, &index, &vdifBuffer) == 0)
+        {
+            if (pWidth != (unsigned long *)0)
+                *pWidth = vdifBuffer.horizontalActive;
+                
+            if (pHeight != (unsigned long *)0)
+                *pHeight = vdifBuffer.verticalActive;
+                
+            if (pVerticalFrequency != (unsigned long *)0)
+                *pVerticalFrequency = vdifBuffer.verticalFrequency;
+                
+            return 0;
+        }
+    }
+    
+    return (-1);
+}
diff --git a/drivers/gpu/drm/smi/ddk750/ddk750_edid.h b/drivers/gpu/drm/smi/ddk750/ddk750_edid.h
new file mode 100644
index 000000000000..0f58f4a47c1b
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk750/ddk750_edid.h
@@ -0,0 +1,1024 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2009 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  edid.h --- SMI DDK 
+*  This file contains the EDID structure and function API to
+*  interpret the EDID
+* 
+*******************************************************************/
+#ifndef _EDID_H_
+#define _EDID_H_
+
+#include "ddk750_display.h"
+#include "vdif.h"
+
+/* Set the alignment to 1-bit aligned. Otherwise, it can't get the EDID correctly. */
+#pragma pack(1)
+
+/* Standard Timing Structure */
+typedef struct _standard_timing_t
+{
+    unsigned char horzActive;       /* (Horizontal active pixels / 8 ) - 31 */
+    struct
+    {
+        unsigned char refreshRate:6;    /* Refresh Rate (Hz) - 60; Range 60 --> 123 */
+        unsigned char aspectRatio:2;    /* Aspect Ratio:
+                                            Bit 7   Bit 6   Operation
+                                              0       0        1:1      (prior Version 1.3)
+                                              0       0       16:10     (Version 1.3)
+                                              0       1        4:3
+                                              1       0        5:4
+                                              1       1       16:9
+                                         */
+    } stdTimingInfo;
+} standard_timing_t;
+
+/* Detailed Timing Description Structure */
+typedef struct _detailed_timing_t
+{
+    unsigned short pixelClock;
+    unsigned char horzActive;
+    unsigned char horzBlanking;
+    struct 
+    {
+        unsigned char horzBlankingMSB:4;
+        unsigned char horzActiveMSB:4;
+    } horzActiveBlanking;
+    unsigned char vertActive;
+    unsigned char vertBlanking;
+    struct 
+    {
+        unsigned char vertBlankingMSB:4;
+        unsigned char vertActiveMSB:4;
+    } vertActiveBlanking;
+    unsigned char horzSyncOffset;
+    unsigned char horzSyncPulseWidth;
+    struct
+    {
+        unsigned char syncWidth:4;
+        unsigned char syncOffset:4;
+    } verticalSyncInfo;
+    struct
+    {
+        unsigned char vertSyncWidth:2;
+        unsigned char vertSyncOffset:2;
+        unsigned char horzSyncWidth:2;
+        unsigned char horzSyncOffset:2;
+    } syncAuxInfo;
+    unsigned char horzImageSize;
+    unsigned char vertImageSize;
+    struct
+    {
+        unsigned char vertImageSizeMSB:4;
+        unsigned char horzImageSizeMSB:4;
+    } horzVertImageSize;
+    unsigned char horzBorder;
+    unsigned char vertBorder;
+    struct
+    {
+        unsigned char interleaved:1;
+        unsigned char horzSyncFlag:1;
+        unsigned char vertSyncFlag:1;
+        unsigned char connectionType:2;
+        unsigned char stereo:2;
+        unsigned char interlaced:1;
+    } flags;
+} detailed_timing_t;
+
+typedef struct _color_point_t
+{
+    unsigned char whitePointIndex;
+    struct
+    {
+        unsigned char whiteYLowBits:2;
+        unsigned char whiteXLowBits:2;
+        unsigned char reserved:4;
+    } whiteLowBits;
+    unsigned char whiteX;
+    unsigned char whiteY;
+    unsigned char gamma;
+} color_point_t;
+
+typedef struct _monitor_desc_t
+{
+    unsigned short flag1;               /* Flag = 0000h when block used as descriptor */
+    unsigned char flag2;                /* Flag = 00h when block used as descriptor */
+    unsigned char dataTypeTag;          /* Data type tag:
+                                                FFh: Monitor Serial Number - Stored as ASCII, 
+                                                     code page #437, <= 13bytes
+                                                FEh: ASCII String - Stored as ASCII, code 
+                                                     page #437, <= 13 bytes
+                                                FDh: Monitor range limits, binary coded
+                                                FCh: Monitor name, stored as ASCII, code page #437
+                                                FBh: Descriptor contains additional color point data
+                                                FAh: Descriptor contains additional Standard Timing
+                                                     Identifications
+                                                F9h-11h: Currently undefined
+                                                10h: Dummy descriptor, used to indicate 
+                                                     that the descriptor space is unused
+                                                0Fh-00h: Descriptor defined by manufacturer.
+                                         */
+    unsigned char flag3;                /* Flag = 00h when block used as descriptor */
+    union
+    {
+        unsigned char serialNo[13];
+        unsigned char dataString[13];
+        struct
+        {
+            unsigned char minVertRate;
+            unsigned char maxVertRate;
+            unsigned char minHorzFrequency;
+            unsigned char maxHorzFrequency;
+            unsigned char maxPixelClock;        /* Binary coded clock rate in MHz / 10 
+                                                   Max Pixel Clock those are not a multiple of 10MHz
+                                                   is rounded up to a multiple of 10MHz
+                                                 */
+            unsigned char secondaryTimingFlag;  /* 00h = No secondary timing formula supported
+                                                   (Support for default GTF indicated in feature byte)
+                                                   02h = Secondary GTF curve supported
+                                                   All other = Reserved for future timing formula
+                                                               definitions.
+                                                 */
+            union
+            {
+                unsigned char constantStr[7];
+                struct
+                {
+                    unsigned char reserved;
+                    unsigned char startFrequency;
+                    unsigned char cParam;
+                    unsigned short mParam;
+                    unsigned char kParam;
+                    unsigned char jParam;
+                } cmkjParam;
+            } secondaryTimingInfo;
+        } monitorRange;
+        
+        unsigned char monitorName[13];
+        struct
+        {
+            color_point_t white[2];
+            unsigned char reserved[3];          /* Set to (0Ah, 20h, 20h)*/
+        } colorPoint;
+        
+        struct
+        {
+            standard_timing_t stdTiming[6];
+            unsigned char reserved;             /* Set to 0Ah */
+        } stdTimingExt;
+        
+        unsigned char manufactureSpecifics[13];
+    } descriptor; 
+}
+monitor_desc_t;
+
+/* EDID Structuve Version 1. Within version 1 itself, there are 4 revisions mentioned
+   below: 
+    - EDID 1.0: The original 128-byte data format
+    - EDID 1.1: Added definitions for monitor descriptors as an alternate use of the space 
+                originally reserved for detailed timings, as well as definitions for 
+                previously unused fields.
+    - EDID 1.2: Added definitions to existing data fields.
+    - EDID 1.3: Added definitions for secondary GTF curve coefficients. This is the new
+                baseline for EDID data structures, which is recommended for all new monitor
+                designs.
+ */
+typedef struct _edid_version_1_t
+{
+    /* Header (8 bytes) */
+    unsigned char header[8];            /* Header */
+    
+    /* Vendor / Product ID (10 bytes) */
+    unsigned short manufacturerID;      /* Manufacture Identification */
+    unsigned short productCode;         /* Product code Identification */ 
+    unsigned long serialNumber;         /* Serial Number */
+    unsigned char weekOfManufacture;    /* Week of Manufacture */
+    unsigned char yearOfManufacture;    /* Year of Manufacture */
+    
+    /* EDID Structure version / revision (2 bytes) */
+    unsigned char version;              /* EDID Structure Version no. */
+    unsigned char revision;             /* Revision Version no. */
+    
+    /* Basic Display Parameters / Features (5 bytes) */
+    union
+    {
+        struct
+        {
+            unsigned char vsyncSerration:1;
+            unsigned char syncOnGreenSupport:1;
+            unsigned char compositeSyncSupport:1;
+            unsigned char separateSyncSupport:1;
+            unsigned char blank2Black:1;
+            unsigned char signalLevelStd:2;
+            unsigned char inputSignal:1;    /* Input Signal: Analog = 0, Digital = 1 */
+        } analogSignal;
+        struct
+        {
+            unsigned char dfp1Support:1;
+            unsigned char reserved:6;
+            unsigned char inputSignal:1;    /* Input Signal: Analog = 0, Digital = 1 */
+        } digitalSignal;
+    } videoInputDefinition;             /* Video Input Definition */
+
+    unsigned char maxHorzImageSize;     /* Maximum Horizontal Image Size */
+    unsigned char maxVertImageSize;     /* Maximum Vertical Image Size */
+    unsigned char displayTransferChar;  /* Display Transfer Characteristic (Gamma) */
+    struct
+    {
+        unsigned char defaultGTFSupport:1;  /* Support timings based on the GTF standard using
+                                               default GTF parameters 
+                                             */ 
+        unsigned char preferredTiming:1;    /* If set, the display's preferred timing mode is
+                                               indicated in the first detailed timing block.
+                                             */
+        unsigned char sRGBSupport:1;        /* If set, the display uses the sRGB standard
+                                               default color space as its primary color space
+                                             */
+        unsigned char displayType:2;        /* Display Type:
+                                                    00  - Monochrome / Grayscale display
+                                                    01  - RGB Color Display
+                                                    10  - Non-RGB multicolor display, e.g. R/G/Y
+                                                    11  - Undefined
+                                             */
+        unsigned char lowPowerSupport:1;    /* If set, the display consumes much less power when
+                                               it receives a timing signal outside its active
+                                               operating range. It will revert to normal if the
+                                               timing returns to the normal operating range.
+                                             */
+        unsigned char suspendSupport:1;     /* Support Suspend as defined in VESA DPMS spec. */
+        unsigned char standbySupport:1;     /* Support Standby as defined in VESA DPMS spec. */
+    } featureSupport;                   /* Feature Support */
+    
+    /* Color Characteristics (10 bytes) */
+    struct
+    {
+        unsigned char greenYLowBits:2;
+        unsigned char greenXLowBits:2;
+        unsigned char redYLowBits:2;
+        unsigned char redXLowBits:2;
+    } redGreenLowBits;                  /* Red/Green Low Bits */
+    struct
+    {
+        unsigned char whiteYLowBits:2;
+        unsigned char whiteXLowBits:2;
+        unsigned char blueYLowBits:2;
+        unsigned char blueXLowBits:2;
+    } blueWhiteLowBits;                 /* Blue/White Low Bits */
+    unsigned char redX;                 /* Red-x bits 9-2 */
+    unsigned char redY;                 /* Red-y bits 9-2 */
+    unsigned char greenX;               /* Green-x bits 9-2 */
+    unsigned char greenY;               /* Green-y bits 9-2 */
+    unsigned char blueX;                /* Blue-x bits 9-2 */
+    unsigned char blueY;                /* Blue-y bits 9-2 */
+    unsigned char whiteX;               /* White-x bits 9-2 */
+    unsigned char whiteY;               /* White-y bits 9-2 */
+    
+    /* Established Timings (3 bytes) */
+    unsigned char estTiming[3];         /* Established Timings */
+    
+    /* Standard Timing Identification (16 bytes) */
+    standard_timing_t stdTiming[8];     /* Standard Timings Identification */
+
+    /* Detailed Timing Descriptions (72 bytes) */
+    union
+    {
+        detailed_timing_t detailTiming[4];  /* Detailed Timing Descriptor */
+        monitor_desc_t monitorDesc[4];  /* Monitor descriptor */
+    } miscInformation;
+    
+    /* Extension Flag (1 byte) */
+    unsigned char extFlag;              /* Number of (optional) 1280byte EDID
+                                           extension blocks to follow. 
+                                         */
+                                         
+    /* Checksum (1 byte) */
+    unsigned char checksum;             /* The 1-byte sum of all 128 bytes in 
+                                           this EDID block shall equal zero. 
+                                         */
+}
+edid_version_1_t;
+
+#if 0   /* Temporary on hold. To be completed later. */
+
+/* EDID Version 2.0. Not widely used. Usually defined for displays that follow 
+   the original VESA Plug & Display (P&D) and Flat Panel Display Interface-2 (FPDI-2)
+   Standards
+ */
+typedef struct _edid_version_2_t
+{
+    /* 
+     * EDID Structure Version/Revision (1 byte) 
+     */
+    unsigned char version:4;
+    unsigned char revision:4;
+    
+    /* 
+     * Vendor / Product ID (7 bytes) 
+     */
+    unsigned short manufacturerID;              /* ID Manufacturer Name */
+    unsigned short productID;                   /* ID Product Code */
+    unsigned char manufactureWeek;              /* Week of Manufacture */
+    unsigned short manufactureYear;             /* Year of Manufacture */
+    
+    /* 
+     * Manufacturer/Product ID string (32 bytes) 
+     */
+    unsigned char productName;                  /* This string is compiresed of both manufacture name 
+                                                   and model name, which are separated using ASCII code 09h.
+                                                   If the entire string is <32 bytes, then it is terminated
+                                                   with ASCII code 0Ah and the field is padded with ASCII 
+                                                   code 20h 
+                                                 */
+                                             
+    /* 
+     * Serial number string (16 bytes) 
+     */
+    unsigned char serianNumber[16];             /* Serial number string. If <16 bytes then the string is
+                                                   terminated with ASCII code 0Ah and the field padded
+                                                   with ASCII code 20h
+                                                 */
+                                             
+    /* 
+     * Unused/Reserved (8 bytes) 
+     */
+    unsigned char reserved[8];
+    
+    /* 
+     * Display Interface Parameters (15 bytes) 
+     */
+    unsigned char secondaryPhysicalIF:4;        /* Look at defaultPhysicalIF description above. */
+    unsigned char defaultPhysicalIF:4;          /* Physical Connector Types. Consists of 2 fields. Bit 7-4
+                                                   indicates the connector for the default interface. If
+                                                   a secondary interface is available, its connector is
+                                                   indicated using bit 3-0. Both fields value description
+                                                   is listed below:
+                                                        0 = None (Not valid for default connector)
+                                                        1 = BNC
+                                                        2 = 15 pin VGA
+                                                        3 = 13w3
+                                                        4 = VESA EVC
+                                                        5 = VESA P&D-D
+                                                        6 = Micro-ribbon Connector (per the VESA P&D standard)
+                                                        7 = IEEE-1394 connector
+                                                        8 = VESA FPDI-2
+                                                        9-E = Reserved
+                                                        F = Non-standard connector
+                                                 */
+    unsigned char secondaryVideoIF:4;           /* Look at the defaultVideoIF description above. */
+    unsigned char defaultVideoIF:4;             /* Video Interface Types. Consists of 2 fields. Bit 7-4
+                                                   defines the default video interface. Bit 3-0 defines
+                                                   the secondary interface. Descriptions of the field is
+                                                   listed below:
+                                                        0 = None (Not valid for default interface)
+                                                        1 = Analog
+                                                        2 = Analog w/ sampled pixel clock
+                                                        3 = TMDS (Transition Minimized Differential Signaling)
+                                                        4 = IEEE-1394-1995
+                                                        5 = LVDS
+                                                        6 = Parallel
+                                                        7-F = Reserved
+                                                 */
+    unsigned char analogIFDataFormat[4];        /* Analog Interface Data Format */
+    unsigned char digitalIFDataFormat[4];       /* Digital Interface Data Format */
+    unsigned char secondaryColorEncodingIF:4;   /* Secondary Color Encoding Interface */
+    unsigned char defaultColorEncodingIF:4;     /* Color Encoding default Interface */
+    unsigned char primarySubChannel1:4;         /* Supported bit-depth of sub-channel 1 ("Green") 
+                                                   of the Primary interface. */
+    unsigned char primarySubChannel0:4;         /* Supported bit-depth of sub-channel 0 ("Red") 
+                                                   of the Primary interface. */
+    unsigned char primarySubChannel3:4;         /* Supported bit-depth of sub-channel 3 of the 
+                                                   Primary interface. */
+    unsigned char primarySubChannel2:4;         /* Supported bit-depth of sub-channel 2 ("Blue") 
+                                                   of the Primary interface. */
+    unsigned char secondarySubChannel1:4;       /* Supported bit-depth of sub-channel 1 ("Green") 
+                                                   of the Secondary interface. */
+    unsigned char secondarySubChannel0:4;       /* Supported bit-depth of sub-channel 0 ("Red") 
+                                                   of the Secondary interface. */
+    unsigned char secondarySubChannel3:4;       /* Supported bit-depth of sub-channel 3 of the 
+                                                   Secondary interface. */
+    unsigned char secondarySubChannel2:4;       /* Supported bit-depth of sub-channel 2 ("Blue") 
+                                                   of the Secondary interface. */
+                                                   
+    /* 
+     * Display Device Description (5 bytes) 
+     */
+    unsigned char displayType;                  /* Display technology type/subtype*/
+    unsigned char displayCharacteristic;        /* Major display characteristics. */
+    unsigned char featureSupport[3];            /* Feature Support */
+    
+    /* 
+     * Display Response Time (2 bytes) 
+     */
+    unsigned char riseTimeResponse:4;           /* Rise time response in seconds */
+    unsigned char riseTimeExponent:4;           /* Rise time exponent */
+    unsigned char fallTimeResponse:4;           /* Fall time response in seconds */
+    unsigned char fallTimeExponent:4;           /* Fall time exponent */
+    
+    /* 
+     * Color / Luminance Description (28 bytes) 
+     */
+    unsigned char whiteGamme;                   /* (Gamma x 100) - 100, [range 1.00 --> 3.55] */
+    unsigned char redGamma;                     /* Color 0 ("red") Gamma (optional). Set to ffh if unused. */
+    unsigned char greenGamma;                   /* Color 1 ("green") Gamma (optional). Set to ffh if unused. */
+    unsigned char blueGamma;                    /* Color 2 ("blue") Gamma (optional). Set to ffh if unused. */
+    unsigned short maxLuminance;                /* Maximum LUminance (white) in units of cd/m^2*10 */
+    unsigned char colorConfig;                  /* Standard RGB Model, adjustable Gamma and its offset */
+    unsigned char offsetValue;                  /* Color Offset value */
+    
+    /* Calorimetry and White Point(s) */
+    unsigned char redGreenLowBits;              /* Red / Green Low Bits */
+}
+edid_version_2_t;
+
+#endif
+
+/* Restore alignment */
+#pragma pack()
+
+/**************************************************************
+ *  Function Prototypes
+ **************************************************************/
+
+/*
+ *  edidGetVersion
+ *      This function gets the EDID version
+ *
+ *  Input:
+ *      pEDIDBuffer - Buffer that contains the EDID structure of the monitor
+ *      pRevision   - Revision of the EDIE (if exist)
+ *
+ *  Output:
+ *      Revision number of the given EDID buffer.
+ */
+unsigned char edidGetVersion(
+    unsigned char *pEDIDBuffer,
+    unsigned char *pRevision
+);
+
+/*
+ *  edidGetProductInfo
+ *      This function gets the vendor and product information.
+ *
+ *  Input:
+ *      pEDIDBuffer         - Buffer that contains the EDID structure of the monitor [in]
+ *      pManufacturerName   - Pointer to a 3 byte length variable to store the manufacturer name [out]
+ *      pProductCode        - Pointer to a variable to store the product code [out]
+ *      pSerialNumber       - Pointer to a variable to store the serial number [out]
+ *      pWeekOfManufacture  - Pointer to a variable to store the week of manufacture [out]
+ *      pYearOfManufacture  - Pointer to a variable to store the year of manufacture 
+ *                            or model year (if WeekOfManufacture is 0xff) [out]
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long edidGetProductInfo(
+    unsigned char *pEDIDBuffer,
+    char *pManufacturerName,
+    unsigned short *pProductCode,
+    unsigned long *pSerialNumber,
+    unsigned char *pWeekOfManufacture,
+    unsigned short *pYearOfManufacture
+);
+
+/*
+ *  edidCheckMonitorInputSignal
+ *      This function checks whether the monitor is expected analog/digital 
+ *      input signal.
+ *
+ *  Input:
+ *      pEDIDBuffer     - Buffer that contains the EDID structure of the monitor
+ *
+ *  Output:
+ *      0   - Analog
+ *      1   - Digital
+ */
+unsigned char edidCheckMonitorInputSignal(
+    unsigned char *pEDIDBuffer
+);
+
+/*
+ *  edidGetAnalogSignalInfo
+ *      This function gets the analog video input signal information
+ *
+ *  Input:
+ *      pEDIDBuffer             - Buffer that contains the EDID structure of the monitor
+ *      pRefWhiteAboveBlank     - Pointer to a variable to store the reference white above blank
+ *                                value. The value is in milliVolt.
+ *      pSyncLevelBelowBlank    - Pointer to a variable to store the Sync tip level below blank
+ *                                The value is also in milliVolt
+ *      pBlank2BlackSetup       - Pointer to a variable to store the Blank to black setup or
+ *                                pedestal per appropriate Signal Level Standard flag. 
+ *                                1 means that the display expect the setup.
+ *      pSeparateSyncSupport    - Pointer to a variable to store the flag to indicate that the
+ *                                monitor supports separate sync.
+ *      pCompositeSyncSupport   - Pointer to a variable to store a flag to indicate that the
+ *                                monitor supports composite sync.
+ *      pSyncOnGreenSupport     - Pointer to a variable to store a flag to indicate that
+ *                                the monitor supports sync on green video.
+ *      pVSyncSerrationRequired - Pointer to a variable to store a flag to indicate that serration
+ *                                of the VSync pulse is required when composite sync or
+ *                                sync-on-green video is used.
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long edidGetAnalogSignalInfo(
+    unsigned char *pEDIDBuffer,
+    unsigned short *pRefWhiteAboveBlank,
+    unsigned short *pSyncLevelBelowBlank,
+    unsigned char *pBlank2BlackSetup,
+    unsigned char *pSeparateSyncSupport,
+    unsigned char *pCompositeSyncSupport,
+    unsigned char *pSyncOnGreenSupport,
+    unsigned char *pVSyncSerrationRequired
+);
+
+/*
+ *  edidGetDigitalSignalInfo
+ *      This function gets the digital video input signal information
+ *
+ *  Input:
+ *      pEDIDBuffer     - Buffer that contains the EDID structure of the monitor
+ *      pDFP1xSupport   - Pointer to a variable to store the flag to indicate that
+ *                        the mointor interface is signal compatible with VESA
+ *                        DFP 1.x TMDS CRGB, 1 pixel/clock, up to 8 bits / color
+ *                        MSB aligned, DE active high
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long edidGetDigitalSignalInfo(
+    unsigned char *pEDIDBuffer,
+    unsigned char *pDFP1xSupport
+);
+
+/*
+ *  edidGetDisplaySize
+ *      This function gets the display sizes in cm.
+ *
+ *  Input:
+ *      pEDIDBuffer         - Buffer that contains the EDID structure of the monitor
+ *      pMaxHorzImageSize   - Pointer to a variable to store the maximum horizontal 
+ *                            image size to the nearest centimeter. A value of 0
+ *                            indicates that the size is indeterminate size.
+ *      pMaxVertImageSize   - Pointer to a variable to store the maximum vertical
+ *                            image size to the nearest centimeter. A value of 0
+ *                            indicates that the size is indeterminate size.
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long edidGetDisplaySize(
+    unsigned char *pEDIDBuffer,
+    unsigned char *pMaxHorzImageSize,
+    unsigned char *pMaxVertImageSize
+);
+
+/*
+ *  edidGetPowerManagementSupport
+ *      This function gets the monitor's power management support.
+ *
+ *  Input:
+ *      pEDIDBuffer     - Buffer that contains the EDID structure of the monitor
+ *      pStandBy        - Pointer to a variable to store the flag to indicate that
+ *                        standby power mode is supported.
+ *      pSuspend        - Pointer to a variable to store the flag to indicate that
+ *                        suspend power mode is supported.
+ *      pLowPower       - Pointer to a variable to store the flag to indicate that
+ *                        the display consumes low power when it receives a timing
+ *                        signal that is outside its declared active operating range.
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long edidGetPowerManagementSupport(
+    unsigned char *pEDIDBuffer,
+    unsigned char *pStandBy,
+    unsigned char *pSuspend,
+    unsigned char *pLowPower
+);
+
+/*
+ *  edidGetDisplayType
+ *      This function gets the display type.
+ *
+ *  Input:
+ *      pEDIDBuffer     - Buffer that contains the EDID structure of the monitor
+ *
+ *  Output:
+ *      0   - Monochrome / grayscale display
+ *      1   - RGB Color Display
+ *      2   - Non-RGB multicolor display, e.g. R/G/Y
+ *      3   - Undefined
+ */
+unsigned char edidGetDisplayType(
+    unsigned char *pEDIDBuffer
+);
+
+/*
+ *  edidChecksRGBUsage
+ *      This function checks if the display is using the sRGB standard default
+ *      color space as its primary color space. 
+ *
+ *  Input:
+ *      pEDIDBuffer     - Buffer that contains the EDID structure of the monitor
+ *
+ *  Output:
+ *      0   - Does not use sRGB as its primary color space
+ *      1   - Use sRGB as its primary color space
+ */
+unsigned char edidChecksRGBUsage(
+    unsigned char *pEDIDBuffer
+);
+
+/*
+ *  edidIsPreferredTimingAvailable
+ *      This function checks whether the preffered timing mode is available.
+ *      Use of preferred timing mode is required by EDID structure version 1
+ *      Revision 3 and higher. 
+ *
+ *  Input:
+ *      pEDIDBuffer     - Buffer that contains the EDID structure of the monitor
+ *
+ *  Output:
+ *      0   - Preferred Timing is not available
+ *      1   - Preferred Timing is available
+ */
+unsigned char edidIsPreferredTimingAvailable(
+    unsigned char *pEDIDBuffer
+);
+
+/*
+ *  edidIsDefaultGTFSupported
+ *      This function checks whether the display supports timings based on the
+ *      GTF standard using default GTF parameter values. 
+ *
+ *  Input:
+ *      pEDIDBuffer     - Buffer that contains the EDID structure of the monitor
+ *
+ *  Output:
+ *      0   - Default GTF is not supported
+ *      1   - Default GTF is supported
+ */
+unsigned char edidIsDefaultGTFSupported(
+    unsigned char *pEDIDBuffer
+);
+
+/*
+ *  edidGetColorCharacteristic
+ *      This function gets the chromaticity and white point values expressed as
+ *      an integer value which represents the actual value times 1000.
+ *
+ *  Input:
+ *      pEDIDBuffer - Buffer that contains the EDID structure of the monitor
+ *      pRedX   - Pointer to a variable to store the Red X values
+ *      pRedY   - Pointer to a variable to store the Red Y values
+ *      pGreenX - Pointer to a variable to store the Green X values
+ *      pGreenY - Pointer to a variable to store the Green Y values
+ *      pBlueX  - Pointer to a variable to store the Blue X values
+ *      pBlueY  - Pointer to a variable to store the Blue Y values
+ *
+ *  Note:
+ *      To get the White color characteristic, use the edidGetWhitePoint
+ */
+void edidGetColorCharacteristic(
+    unsigned char *pEDIDBuffer,
+    unsigned short *pRedX,
+    unsigned short *pRedY,
+    unsigned short *pGreenX,
+    unsigned short *pGreenY,
+    unsigned short *pBlueX,
+    unsigned short *pBlueY
+);
+
+/*
+ *  edidGetWhitePoint
+ *      This function gets the white point.
+ *      To get the default white point, set the index to 0. For multiple white point,
+ *      call this function multiple times to check if more than 1 white point is supported.
+ *
+ *  Input:
+ *      pEDIDBuffer         - Buffer that contains the EDID structure of the monitor
+ *      pWhitePointIndex    - Pointer to a variable that contains the white point index 
+ *                            to be retrieved.
+ *      pWhiteX             - Pointer to a variable to store the White X value
+ *      pWhiteY             - Pointer to a variable to store the White Y value
+ *      pWhiteGamma         - Pointer to a variable to store the White Gamma value
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long edidGetWhitePoint(
+    unsigned char *pEDIDBuffer,
+    unsigned char *pWhitePointIndex,
+    unsigned short *pWhiteX,
+    unsigned short *pWhiteY,
+    unsigned short *pWhiteGamma
+);
+
+/*
+ *  edidGetExtension
+ *      This function gets the number of (optional) EDID extension blocks to follow
+ *      the given EDID buffer.
+ *
+ *  Input:
+ *      pEDIDBuffer     - Buffer that contains the EDID structure of the monitor
+ *
+ *  Output:
+ *      Total number of EDID Extension to follow the given EDID buffer.
+ */
+unsigned char edidGetExtension(
+    unsigned char *pEDIDBuffer
+);
+
+/*
+ *  edidReadMonitor
+ *      This function reads the EDID structure from the attached monitor
+ *
+ *  Input:
+ *      displayPath - Display device which EDID to be read from.
+ *      pEDIDBuffer - Buffer that contains the EDID structure of the monitor
+ *      bufferSize  - The EDID Buffer size index (usually 128-bytes)
+ *      edidExtNo   - Extension Index of the EDID Structure to be read
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long edidReadMonitor(
+    disp_path_t displayPath,
+    unsigned char *pEDIDBuffer,
+    unsigned long bufferSize,
+    unsigned char edidExtNo
+);
+
+/*
+ *  edidReadMonitor
+ *      This function reads the EDID structure from the attached monitor
+ *
+ *  Input:
+ *      displayPath - Display device which EDID to be read from.
+ *      pEDIDBuffer - Buffer that contains the EDID structure of the monitor
+ *      bufferSize  - The EDID Buffer size index (usually 128-bytes)
+ *      edidExtNo   - Extension Index of the EDID Structure to be read
+ *      sclGpio     - GPIO pin used as the I2C Clock (SCL)
+ *      sdaGpio     - GPIO pin used as the I2C Data (SDA)
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long ddk750_edidReadMonitorEx(
+    disp_path_t displayPath,
+    unsigned char *pEDIDBuffer,
+    unsigned long bufferSize,
+    unsigned char edidExtNo,
+    unsigned char sclGpio,
+    unsigned char sdaGpio
+);
+
+long ddk750_edidReadMonitorEx_HW(
+    disp_path_t displayPath,
+    unsigned char *pEDIDBuffer,
+    unsigned long bufferSize,
+    unsigned char edidExtNo
+);
+
+
+/*
+ *  edidGetEstablishedTiming
+ *      This function gets the established timing list from the given EDID buffer,
+ *      table, and timing index.
+ *
+ *  Input:
+ *      pEDIDBuffer     - Buffer that contains the EDID structure of the monitor (In)
+ *      pEstTableIndex  - Pointer to the Established Timing Table index  (In/Out)
+ *      pIndex          - Pointer to the Establihsed Timing Index (In/Out)
+ *      pWidth          - Pointer to a variable that to store the horizontal active / width
+ *                        value of the retrieved timing (Out)
+ *      pHeight         - Pointer to a variable to store the vertical active / height
+ *                        value of the retrieved timing (Out)
+ *      pRefreshRate    - Pointer to a variable to store the vertical frequency value
+ *                        of the retrieved timing (out)
+ *      pSource         - Pointer to a variable to store the standard timing source:
+ *                          0 - VESA
+ *                          1 - IBM
+ *                          2 - Apple
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long edidGetEstablishedTiming(
+    unsigned char *pEDIDBuffer,
+    /*unsigned char *pEstTableIndex,*/
+    unsigned char *pIndex,
+    unsigned long *pWidth,
+    unsigned long *pHeight,
+    unsigned long *pRefreshRate,
+    unsigned char *pSource
+);
+
+/*
+ *  edidGetStandardTiming
+ *      This function gets the standard timing from the given EDID buffer and
+ *      calculates the width, height, and vertical frequency from that timing.
+ *
+ *  Input:
+ *      pEDIDBuffer     - Buffer that contains the EDID structure of the monitor
+ *      pStdTimingIndex - Pointer to a standard timing index to be retrieved
+ *      pWidth          - Pointer to a variable that to store the horizontal active / width
+ *                        value of the retrieved timing (Out)
+ *      pHeight         - Pointer to a variable to store the vertical active / height
+ *                        value of the retrieved timing (Out)
+ *      pRefreshRate    - Pointer to a variable to store the vertical frequency value
+ *                        of the retrieved timing (out)
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long edidGetStandardTiming(
+    unsigned char *pEDIDBuffer,
+    unsigned char *pStdTimingIndex,
+    unsigned long *pWidth,
+    unsigned long *pHeight,
+    unsigned long *pRefreshRate
+);
+
+/*
+ *  edidGetDetailedTiming
+ *      This function gets the detailed timing from the given EDID buffer.
+ *
+ *  Input:
+ *      pEDIDBuffer             - Buffer that contains the EDID structure of the monitor
+ *      pDetailedTimingIndex    - Pointer to a detailed timing index to be retrieved
+ *      pModeParameter          - Pointer to a mode_parameter_t structure that will be
+ *                                filled with the detailed timing.
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long edidGetDetailedTiming(
+    unsigned char *pEDIDBuffer,
+    unsigned char *pDetailedTimingIndex,
+    vdif_t *pVDIF
+);
+
+/*
+ *  edidGetMonitorSerialNumber
+ *      This function gets the monitor serial number from the EDID structure.
+ *
+ *  Input:
+ *      pEDIDBuffer             - Buffer that contains the EDID structure of the monitor
+ *      pMonitorSerialNumber    - Pointer to a buffer to store the serial number 
+ *                                retrieved from the EDID
+ *      bufferSize              - The size of the buffer to store the serial number.
+ *                                The maximum size required is 13 bytes.
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long edidGetMonitorSerialNumber(
+    unsigned char *pEDIDBuffer,
+    char *pMonitorSerialNumber,
+    unsigned char bufferSize
+);
+
+/*
+ *  edidGetDataString
+ *      This function gets the data string from the EDID structure.
+ *
+ *  Input:
+ *      pEDIDBuffer             - Buffer that contains the EDID structure of the monitor
+ *      pMonitorSerialNumber    - Pointer to a buffer to store the data string 
+ *                                retrieved from the EDID
+ *      bufferSize              - The size of the buffer to store the data string
+ *                                The maximum size required is 13 bytes.
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long edidGetDataString(
+    unsigned char *pEDIDBuffer,
+    char *pDataString,
+    unsigned char bufferSize
+);
+
+/*
+ *  edidGetMonitorRangeLimit
+ *      This function gets the monitor range limits from the EDID structure.
+ *      Only EDID version 1 and revision 1 or above supports this feature.
+ *
+ *  Input:
+ *      pEDIDBuffer         - Buffer that contains the EDID structure of the monitor
+ *      pMinVerticalRate    - Pointer to a variable to store the Minimum Vertical Rate (Hz)
+ *      pMaxVerticalRate    - Pointer to a variable to store the Maximum Vertical Rate (Hz)
+ *      pMinHorzFreq        - Pointer to a variable to store the Minimum Horz. Freq (kHz)
+ *      pMaxHorzFreq        - Pointer to a variable to store the Maximum Horz. Freq (kHz)
+ *      pMaxPixelClock      - Pointer to a variable to store the Maximum Pixel Clock (Hz)
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long edidGetMonitorRangeLimit(
+    unsigned char *pEDIDBuffer,
+    unsigned char *pMinVerticalRate,
+    unsigned char *pMaxVerticalRate,
+    unsigned char *pMinHorzFreq,
+    unsigned char *pMaxHorzFreq,
+    unsigned long *pMaxPixelClock
+);
+
+/*
+ *  edidGetSecondaryTimingSupport
+ *      This function gets the secondary GTF timing support.
+ *
+ *  Input:
+ *      pEDIDBuffer             - Buffer that contains the EDID structure of the monitor
+ *      pStartFrequency         - Pointer to a variable to store the start frequency of 
+ *                                the secondary GTF
+ *      pOffset                 - Pointer to a variable to store the Offset (C) value of
+ *                                the secondary GTF
+ *      pGradient               - Pointer to a variable to store the Gradient (M) value of
+ *                                the secondary GTF
+ *      pScalingFactor          - Pointer to a variable to store the Scaling Factor (K)
+ *                                value of the secondary GTF
+ *      pScalingFactorWeight    - Pointer to a variable to store the Scaling Factore Weight (J)
+ *                                value of the secondary GTF
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long edidGetSecondaryTimingSupport(
+    unsigned char *pEDIDBuffer,
+    unsigned short *pStartFrequency,
+    unsigned char *pOffset,
+    unsigned short *pGradient,
+    unsigned char *pScalingFactor,
+    unsigned char *pScalingFactorWeight
+);
+
+/*
+ *  edidGetMonitorName
+ *      This function gets the monitor name from the EDID structure.
+ *
+ *  Input:
+ *      pEDIDBuffer             - Buffer that contains the EDID structure of the monitor
+ *      pMonitorName            - Pointer to a buffer to store the monitor name 
+ *                                retrieved from the EDID
+ *      bufferSize              - The size of the buffer to store the monitor name
+ *                                The maximum size required is 13 bytes. 
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long edidGetMonitorName(
+    unsigned char *pEDIDBuffer,
+    char *pMonitorName,
+    unsigned char bufferSize
+);
+
+/*
+ *  edidGetPreferredTiming
+ *      This function gets the preferred/native timing of the monitor
+ *
+ *  Input:
+ *      pEDIDBuffer         - Buffer that contains the EDID structure of the monitor
+ *      pWidth              - Pointer to an unsigned long buffer to store the width 
+ *                            of the preferred (native) timing.
+ *      pHeight             - Pointer to an unsigned long buffer to store the height
+ *                            of the preferred (native) timing.
+ *      pVerticalFrequency  - Pointer to an unsigned long buffer to store the refresh
+ *                            rate of the preferred (native) timing.
+ * 
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long edidGetPreferredTiming(
+    unsigned char *pEDIDBuffer,
+    unsigned long *pWidth,
+    unsigned long *pHeight,
+    unsigned long *pVerticalFrequency
+);
+
+#endif  /* _EDID_H_ */
+
+
+
diff --git a/drivers/gpu/drm/smi/ddk750/ddk750_hardware.h b/drivers/gpu/drm/smi/ddk750/ddk750_hardware.h
new file mode 100644
index 000000000000..86b84b4497d9
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk750/ddk750_hardware.h
@@ -0,0 +1,191 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2007 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  HARDWARE.h --- Voyager GX SDK 
+*  This file contains the definitions for the physical hardware.
+* 
+*******************************************************************/
+#ifndef _HARDWARE_H_
+#define _HARDWARE_H_
+
+/* Use IO Port to access the MMIO 
+   NOTE:
+        The easiest way to run the application in MS-DOS when using the SM750 as 
+        secondary adapter is using the following steps:
+        1. Disable the VGA enable bit in the primary card's PCI to PCI bridge.
+           This bit is location at offset 0x3E bit 3. --> This can be implemented
+           in the application or run the PCI Tools to modify the PCI to PCI bridge manually.
+        2. Enable the VGA enable bit in the secondary (SM750) card's PCI to PCI bridge.
+           --> This can be implemented
+           in the application or run the PCI Tools to modify the PCI to PCI bridge manually.
+        3. Enable "USE_IO_PORT" definition and compile it. --> It will automatically 
+           enable the IO Port Access in the PCI Configuration Register offset 4, bit 1.
+        4. Configure the DOS system to use Serial port. Hints: Use "mode" command
+           and "ctty com1". It requires NULL model serial cable and another system to
+           operate the DOS from the other serial port. --> This step can be done in 
+           any sequence prior running the application. 
+        5. Run the application from the serial port.
+ */
+//#define USE_IO_PORT
+
+/* Use 0xA0000 as the frame buffer access. */
+//#define USE_A0000
+
+/* Silicon Motion PCI vendor ID */
+#define SMI_PCI_VENDOR_ID               0x126F
+#define HIS_PCI_VENDOR_ID               0x19E5
+
+/* Maximum number of devices with the same ID supported by this library. */
+#define MAX_SMI_DEVICE                  4
+
+/* List of Silicon Motion PCI Device ID that is supported by this library. */
+#define SMI_DEVICE_ID_SM750             0x0750
+#define SMI_DEVICE_ID_SM718             0x0718
+#define HIS_DEVICE_ID_SM750             0x1711
+
+/* Size of the SM750 MMIO and memory */
+#define SM750_PCI_ALLOC_MMIO_SIZE       (2*1024*1024)
+#define SM750_PCI_ALLOC_MEMORY_SIZE     (64*1024*1024)
+
+/* Register types */
+typedef enum _reg_type_t
+{
+    MISCELLANEOUS_REGISTER,
+    SEQUENCER_REGISTER,
+    CRT_REGISTER,
+    GRAPHICS_REGISTER,
+    OTHER_REGISTER
+}
+reg_type_t;
+
+#ifdef USE_A0000
+/*
+ * Set the bank size when using A0000h memory addressing .
+ */
+void setBankSize(
+    unsigned long bankSize
+);
+#endif
+
+/*
+ * Get the physical address of an offset location in frame buffer.
+ * In DOS, the physical and the logical address most likely are the same.
+ * Return: A valid address if success.
+ *         NULL address if fail.
+ */
+void *getPhysicalAddress(unsigned long offset /* Offset from base of physical frame buffer */);
+
+/*
+ * Get the logical address of an offset location in frame buffer.
+ * Return: A valid address if success.
+ *         NULL address if fail.
+ */
+void *getAddress(unsigned long offset /*Offset from base of frame buffer*/);
+
+/*
+ * Get the IRQ number of the current device.
+ */
+unsigned char getIRQ(void);
+
+/*
+ * This function detects what SMI chips is in the system.
+ *
+ * Return: A non-zero device ID if SMI chip is detected.
+ *         Zero means NO SMI chip is detected.
+ */
+unsigned short detectDevices(void);
+
+/*
+ *  Function to return vendor ID, chip ID and revision of the current chip, if any.
+ */
+unsigned short getVendorId(void);
+unsigned short getDeviceId(void);
+unsigned char  getDeviceRev(void);
+
+/*
+ * How many devices of the same ID are there.
+ */
+unsigned short getNumOfDevices(void);
+
+/*
+ * This function sets up the current accessible device, if more
+ * than one of the same ID exist in the system.
+ *
+ * Note:
+ * Single device application don't need to call this function.
+ * This function is to control multiple devices.
+ */
+long setCurrentDevice(unsigned short dev);
+//unsigned short getCurrentDevice(void);
+#define getCurrentDevice(...) SM750
+
+/* Video Memory read/write functions */
+unsigned char peekByte(unsigned long offset);
+unsigned short peekWord(unsigned long offset);
+unsigned long peekDWord(unsigned long offset);
+void poke_4_Byte(unsigned long offset, unsigned char *buf);
+void pokeByte(unsigned long offset, unsigned char value);
+void pokeWord(unsigned long offset, unsigned short value);
+void pokeDWord(unsigned long offset, unsigned long value);
+#if 0 //by ilena
+/* MMIO read/write functions */
+unsigned char peekRegisterByte(unsigned long offset);
+unsigned short peekRegisterWord(unsigned long offset);
+unsigned long peekRegisterDWord(unsigned long offset);
+void pokeRegisterByte(unsigned long offset, unsigned char value);
+void pokeRegisterWord(unsigned long offset, unsigned short value);
+void pokeRegisterDWord(unsigned long offset, unsigned long value);
+#endif
+
+#if 0   /* For Testing Purpose */
+/*
+ * Read SM718 PCI byte value 
+ */
+unsigned char readDevicePCIByte(
+    unsigned short offset
+);
+
+/*
+ * Read SM718 PCI word value 
+ */
+unsigned short readDevicePCIWord(
+    unsigned short offset
+);
+
+/*
+ * Read SM718 PCI dword value 
+ */
+unsigned long readDevicePCIDWord(
+    unsigned short offset
+);
+
+/*
+ * Write SM718 PCI byte value 
+ */
+long writeDevicePCIByte(
+    unsigned short offset,
+    unsigned char value
+);
+
+/*
+ * Write SM718 PCI word value 
+ */
+long writeDevicePCIWord(
+    unsigned short offset,
+    unsigned short value
+);
+
+/*
+ * Write SM718 PCI dword value 
+ */
+long writeDevicePCIDWord(
+    unsigned short offset,
+    unsigned long value
+);
+#endif
+
+#endif /* _HARDWARE_H_ */
diff --git a/drivers/gpu/drm/smi/ddk750/ddk750_help.c b/drivers/gpu/drm/smi/ddk750/ddk750_help.c
new file mode 100644
index 000000000000..5e36214b95e4
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk750/ddk750_help.c
@@ -0,0 +1,18 @@
+#include "ddk750_help.h"
+
+volatile unsigned char __iomem * mmio750 = NULL;
+char revId750 = 0;
+unsigned short devId750 = 0;
+
+
+
+/* after driver mapped io registers, use this function first */
+void ddk750_set_mmio(volatile unsigned char * addr,unsigned short devId,char revId)
+{
+	mmio750 = addr;
+	devId750 = devId;
+	revId750 = revId;
+	if(revId == 0xfe)
+		printk("found sm750le\n");
+}
+
diff --git a/drivers/gpu/drm/smi/ddk750/ddk750_help.h b/drivers/gpu/drm/smi/ddk750/ddk750_help.h
new file mode 100644
index 000000000000..f2b76339726f
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk750/ddk750_help.h
@@ -0,0 +1,213 @@
+#ifndef DDK750_HELP_H__
+#define DDK750_HELP_H__
+#include "ddk750_chip.h"
+#ifndef USE_INTERNAL_REGISTER_ACCESS
+
+#include <linux/ioport.h>
+#include <linux/io.h>
+#include <linux/uaccess.h>
+#include "ddk750_mode.h"
+
+#define PEEK32(addr) readl((addr)+mmio750)
+#define POKE32(addr,data) writel((data),(addr)+mmio750)
+#define peekRegisterDWord PEEK32
+#define pokeRegisterDWord POKE32
+
+#define peekRegisterByte(addr) readb((addr)+mmio750)
+#define pokeRegisterByte(addr,data) writeb((data),(addr)+mmio750)
+
+extern volatile unsigned  char __iomem * mmio750;
+extern char revId750;
+extern unsigned short devId750;
+void ddk750_set_mmio(volatile unsigned char *,unsigned short,char);
+
+/*
+ *  Default Timing parameter for some popular modes.
+ *  Note that the most timings in this table is made according to standard VESA 
+ *  parameters for the popular modes.
+ */
+static mode_parameter_t gDefaultModeParamTable[] =
+{
+/*800x480*/
+ //{0, 	800, 	0,	0,	NEG, 0, 480,  0,  0,   POS, 	0,		0,		0, NEG},
+/* 320 x 240 [4:3] */
+ { 352, 320, 335,  8, NEG, 265, 240, 254, 2, NEG,  5600000, 15909, 60, NEG},
+
+/* 400 x 300 [4:3] -- Not a popular mode */
+ { 528, 400, 420, 64, NEG, 314, 300, 301, 2, NEG,  9960000, 18864, 60, NEG},
+ 
+/* 480 x 272 -- Not a popular mode --> only used for panel testing */
+/* { 525, 480, 482, 41, NEG, 286, 272, 274, 10, NEG, 9009000, 17160, 60, NEG}, */
+
+/* 640 x 480  [4:3] */
+/* The first 2 commented lines below are taken from SM502, the rest timing are
+   taken from the VESA Monitor Timing Standard */
+/* { 840, 640, 680, 64, NEG, 500, 480, 481, 3, NEG, 31500000, 37500, 75, NEG}, */
+/* { 832, 640, 700, 56, NEG, 509, 480, 481, 3, NEG, 36000000, 43269, 85, NEG}, */
+ { 800, 640, 656, 96, NEG, 525, 480, 490, 2, NEG, 25175000, 31469, 60, NEG},
+ { 840, 640, 656, 64, NEG, 500, 480, 481, 3, NEG, 31500000, 37500, 75, NEG},
+ { 832, 640, 696, 56, NEG, 509, 480, 481, 3, NEG, 36000000, 43269, 85, NEG},
+
+/* 720 x 480  [3:2] */
+ { 889, 720, 738,108, POS, 525, 480, 490, 2, NEG, 28000000, 31496, 60, NEG},
+
+/* 720 x 540  [4:3] -- Not a popular mode */
+ { 886, 720, 740, 96, POS, 576, 540, 545, 2, POS, 30600000, 34537, 60, NEG},
+
+/* 800 x 480  [5:3] -- Not a popular mode */
+ { 973, 800, 822, 56, POS, 524, 480, 490, 2, NEG, 30600000, 31449, 60, NEG},
+
+/* 800 x 600  [4:3] */
+/* The first 2 commented lines below are taken from SM502, the rest timing are
+   taken from the VESA Monitor Timing Standard */
+/* {1062, 800, 840,128, POS, 628, 600, 601, 4, POS, 40000000, 37665, 60, NEG}, */
+/* {1054, 800, 842, 64, POS, 625, 600, 601, 3, POS, 56000000, 53131, 85, NEG}, */
+ {1056, 800, 840,128, POS, 628, 600, 601, 4, POS, 40000000, 37879, 60, NEG},
+ {1056, 800, 816, 80, POS, 625, 600, 601, 3, POS, 49500000, 46875, 75, NEG},
+ {1048, 800, 832, 64, POS, 631, 600, 601, 3, POS, 56250000, 53674, 85, NEG},
+
+/* 960 x 720  [4:3] -- Not a popular mode */
+ {1245, 960, 992, 64, POS, 750, 720, 721, 3, POS, 56000000, 44980, 60, NEG},
+      
+/* 1024 x 600  [16:9] 1.7 */
+ {1313,1024,1064,104, POS, 622, 600, 601, 3, POS, 49000000, 37319, 60, NEG},
+     
+/* 1024 x 768  [4:3] */
+/* The first 2 commented lines below are taken from SM502, the rest timing are
+   taken from the VESA Monitor Timing Standard */
+/* {1340,1024,1060,136, NEG, 809, 768, 772, 6, NEG, 65000000, 48507, 60, NEG}, */
+/* {1337,1024,1072, 96, NEG, 808, 768, 780, 3, NEG, 81000000, 60583, 75, NEG}, */
+ {1344,1024,1048,136, NEG, 806, 768, 771, 6, NEG, 65000000, 48363, 60, NEG},
+ {1312,1024,1040, 96, POS, 800, 768, 769, 3, POS, 78750000, 60023, 75, NEG},
+ {1376,1024,1072, 96, POS, 808, 768, 769, 3, POS, 94500000, 68677, 85, NEG},
+  
+/* 1152 x 864  [4:3] -- Widescreen eXtended Graphics Array */
+/* {1475,1152,1208, 96, NEG, 888, 864, 866, 3, NEG, 78600000, 53288, 60, NEG},*/
+ {1475,1152,1208, 96, POS, 888, 864, 866, 3, POS, 78600000, 53288, 60, NEG},
+ {1600,1152,1216,128, POS, 900, 864, 865, 3, POS,108000000, 67500, 75, NEG},
+ 
+/* 1280 x 720  [16:9] -- HDTV (WXGA) */
+ {1664,1280,1336,136, POS, 746, 720, 721, 3, POS, 74481000, 44760, 60, NEG},
+
+/* 1280 x 768  [5:3] -- Not a popular mode */
+ {1678,1280,1350,136, POS, 795, 768, 769, 3, POS, 80000000, 47676, 60, NEG},
+
+/* 1280 x 800  [8:5] -- Not a popular mode */
+ {1650,1280,1344,136, NEG, 824, 800, 800, 3, NEG, 81600000, 49455, 60, NEG},
+
+/* 1280 x 960  [4:3] */
+/* The first commented line below are taken from SM502, the rest timing are
+   taken from the VESA Monitor Timing Standard */
+/* {1618,1280,1330, 96, NEG, 977, 960, 960, 2, NEG, 94500000, 59259, 60, NEG},*/
+ {1800,1280,1376,112, POS,1000, 960, 961, 3, POS,108000000, 60000, 60, NEG},
+ {1728,1280,1344,160, POS,1011, 960, 961, 3, POS,148500000, 85938, 85, NEG},
+    
+/* 1280 x 1024 [5:4] */
+#if 1
+ /* GTF with C = 40, M = 600, J = 20, K = 128 */
+ {1712,1280,1360,136, NEG,1060,1024,1025, 3, POS,108883200, 63600, 60, NEG},
+ {1728,1280,1368,136, NEG,1069,1024,1025, 3, POS,138542400, 80175, 75, NEG},
+ {1744,1280,1376,136, NEG,1075,1024,1025, 3, POS,159358000, 91375, 85, NEG},
+#else
+ /* VESA Standard */
+ {1688,1280,1328,112, POS,1066,1024,1025, 3, POS,108000000, 63981, 60, NEG},
+ {1688,1280,1296,144, POS,1066,1024,1025, 3, POS,135000000, 79976, 75, NEG},
+ {1728,1280,1344,160, POS,1072,1024,1025, 3, POS,157500000, 91146, 85, NEG},
+#endif
+
+/* 1360 x 768 [16:9] */
+#if 1
+ /* GTF with C = 40, M = 600, J = 20, K = 128 */
+ //{1776,1360,1432,136, NEG, 795, 768, 769, 3, POS, 84715200, 47700, 60, NEG},
+ 
+ /* GTF with C = 30, M = 600, J = 20, K = 128 */
+ {1664,1360,1384,128, NEG, 795, 768, 769, 3, POS, 79372800, 47700, 60, NEG},
+#else
+ /* Previous Calculation */
+ {1776,1360,1424,144, POS, 795, 768, 769, 3, POS, 84715000, 47700, 60, NEG},
+#endif
+ 
+/* 1366 x 768  [16:9] */
+ /* Previous Calculation  */
+ {1722,1366,1424,112, NEG, 784, 768, 769, 3, NEG, 81000000, 47038, 60, NEG},
+ 
+/* 1400 x 1050 [4:3] -- Hitachi TX38D95VC1CAH -- It is not verified yet, therefore
+   temporarily disabled. */
+ //{1688,1400,1448,112, NEG,1068,1050,1051, 3, NEG,108000000, 64000, 60, NEG},
+ //{1688,1400,1464,112, NEG,1068,1050,1051, 3, NEG,108167040, 64080, 60, NEG},
+ 
+ /* Taken from the www.tinyvga.com */
+ {1880,1400,1488,152, NEG,1087,1050,1051, 3, POS,122610000, 65218, 60, NEG},
+ 
+/* 1440 x 900  [8:5] -- Widescreen Super eXtended Graphics Array (WSXGA) */
+ {1904,1440,1520,152, NEG, 932, 900, 901, 3, POS,106470000, 55919, 60, NEG},
+
+/* 1440 x 960 [3:2] -- Not a popular mode */
+ {1920,1440,1528,152, POS, 994, 960, 961, 3, POS,114509000, 59640, 60, NEG},
+
+ /* 1600 x 900 */
+ {2128,1600,1664,192, POS,932,900,901, 3, POS,119000000, 56000, 60, NEG},
+
+
+/* 1600 x 1200 [4:3]. -- Ultra eXtended Graphics Array */
+ /* VESA */
+ {2160,1600,1664,192, POS,1250,1200,1201, 3, POS,162000000, 75000, 60, NEG},
+ {2160,1600,1664,192, POS,1250,1200,1201, 3, POS,202500000, 93750, 75, NEG},
+ {2160,1600,1664,192, POS,1250,1200,1201, 3, POS,229500000,106250, 85, NEG},
+
+/* 
+ * The timing below is taken from the www.tinyvga.com/vga-timing.
+ * With the exception of 1920x1080.
+ */
+ 
+/* 1680 x 1050 [8:5]. -- Widescreen Super eXtended Graphics Array Plus (WSXGA+) */ 
+/* The first commented timing might be used for DVI LCD Monitor timing. */
+/* {1840,1680,1728, 32, NEG,1080,1050,1053, 6, POS,119232000, 64800, 60, NEG}, */
+ /* GTF with C = 30, M = 600, J = 20, K = 128 */
+ {2256,1680,1784,184, NEG,1087,1050,1051, 3, POS,147140000, 65222, 60, NEG},
+/*
+ {2272,1680,1792,184, NEG,1093,1050,1051, 3, POS,173831000, 76510, 70, NEG},
+ {2288,1680,1800,184, NEG,1096,1050,1051, 3, POS,188074000, 82200, 75, NEG},
+*/
+ 
+/* 1792 x 1344 [4:3]. -- Not a popular mode */ 
+ {2448,1792,1920,200, NEG,1394,1344,1345, 3, POS,204800000, 83660, 60, NEG},
+ {2456,1792,1888,216, NEG,1417,1344,1345, 3, POS,261000000,106270, 75, NEG},
+ 
+/* 1856 x 1392 [4:3]. -- Not a popular mode 
+   The 1856 x 1392 @ 75Hz has not been tested due to high Horizontal Frequency
+   where not all monitor can support it (including the developer monitor)
+ */
+ {2528,1856,1952,224, NEG,1439,1392,1393, 3, POS,218300000, 86353, 60, NEG},
+/* {2560,1856,1984,224, NEG,1500,1392,1393, 3, POS,288000000,112500, 75, NEG},*/
+
+/* 1920 x 1080 [16:9]. This is a make-up value, need to be proven. 
+   The Pixel clock is calculated based on the maximum resolution of
+   "Single Link" DVI, which support a maximum 165MHz pixel clock.
+   The second values are taken from:
+   http://www.tek.com/Measurement/App_Notes/25_14700/eng/25W_14700_3.pdf
+ */
+/* {2560,1920,2048,208, NEG,1125,1080,1081, 3, POS,172800000, 67500, 60, NEG}, */
+ {2200,1920,2008, 44, NEG,1125,1080,1081, 3, POS,148500000, 67500, 60, NEG},
+
+/* 1920 x 1200 [8:5]. -- Widescreen Ultra eXtended Graphics Array (WUXGA) */
+ {2592,1920,2048,208, NEG,1242,1200,1201, 3, POS,193160000, 74522, 60, NEG},
+
+/* 1920 x 1440 [4:3]. */
+/* In the databook, it mentioned only support up to 1920x1440 @ 60Hz. 
+   The timing for 75 Hz is provided here if necessary to do testing. - Some underflow
+   has been noticed. */
+ {2600,1920,2048,208, NEG,1500,1440,1441, 3, POS,234000000, 90000, 60, NEG},
+/* {2640,1920,2064,224, NEG,1500,1440,1441, 3, POS,297000000,112500, 75, NEG}, */
+
+/* End of table. */
+ { 0, 0, 0, 0, NEG, 0, 0, 0, 0, NEG, 0, 0, 0, NEG},
+};
+
+
+#else
+/* implement if you want use it*/
+#endif
+
+#endif
+
diff --git a/drivers/gpu/drm/smi/ddk750/ddk750_helper.c b/drivers/gpu/drm/smi/ddk750/ddk750_helper.c
new file mode 100644
index 000000000000..41004100fa6c
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk750/ddk750_helper.c
@@ -0,0 +1,47 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2009 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  helper.c --- SM750 DDK 
+*  This file contains helper functions those are used throughout
+*  the DDK library.
+* 
+*******************************************************************/
+#include "ddk750_helper.h"
+
+/* Perform a rounded division. 
+ * For example, if the result is 4.5, this function returns 5.
+ * If the result is 4.4, this function returns 4.
+ */
+unsigned long roundedDiv(unsigned long num, unsigned long denom)
+{
+    /* n / d + 1 / 2 = (2n + d) / 2d */
+    return (2 * num + denom) / (2 * denom);
+}
+
+
+/* Absolute differece between two numbers */
+unsigned long absDiff(unsigned long a, unsigned long b)
+{
+    if ( a >= b )
+        return(a - b);
+    else
+        return(b - a);
+}
+
+/* This function calculates 2 to the power of x 
+   Input is the power number.
+ */
+unsigned long twoToPowerOfx(unsigned long x)
+{
+    unsigned long i;
+    unsigned long result = 1;
+
+    for (i=1; i<=x; i++)
+        result *= 2;
+
+    return result;
+}
diff --git a/drivers/gpu/drm/smi/ddk750/ddk750_helper.h b/drivers/gpu/drm/smi/ddk750/ddk750_helper.h
new file mode 100644
index 000000000000..30b9fb8d1a10
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk750/ddk750_helper.h
@@ -0,0 +1,30 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2009 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  helper.h --- SMI DDK 
+*  This file contains the helper functions those are used throughout
+*  the library
+* 
+*******************************************************************/
+#ifndef _HELPER_H_
+#define _HELPER_H_
+
+/* Perform a rounded division. 
+ * For example, if the result is 4.5, this function returns 5.
+ * If the result is 4.4, this function returns 4.
+ */
+unsigned long roundedDiv(unsigned long num, unsigned long denom);
+
+/* Absolute differece between two numbers */
+unsigned long absDiff(unsigned long a, unsigned long b);
+
+/* This function calculates 2 to the power of x 
+   Input is the power number.
+ */
+unsigned long twoToPowerOfx(unsigned long x);
+
+#endif  /* _HELPER_H_ */
diff --git a/drivers/gpu/drm/smi/ddk750/ddk750_hwi2c.c b/drivers/gpu/drm/smi/ddk750/ddk750_hwi2c.c
new file mode 100644
index 000000000000..7478c61da00c
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk750/ddk750_hwi2c.c
@@ -0,0 +1,378 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2007 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  hwi2c.c --- SMI DDK 
+*  This file contains the source code for hardware i2c.
+* 
+*******************************************************************/
+
+#include "ddk750_defs.h"
+#include "ddk750_hardware.h"
+#include "ddk750_power.h"
+#include "ddk750_help.h"
+#include "ddk750_hwi2c.h"
+
+#define MAX_HWI2C_FIFO                  16
+
+/*
+ *  This function initializes the hardware i2c
+ *
+ *  Parameters:
+ *      busSpeedMode    - I2C Bus Speed Mode
+ *                          0 = Standard Mode (100kbps)
+ *                          1 = Fast Mode (400kbps)
+ *
+ *  Return Value:
+ *       0   - Success
+ *      -1   - Fail to initialize i2c
+ */
+long ddk750_hwI2CInit(
+    unsigned char busSpeedMode
+)
+{
+    unsigned long value;
+    
+    /* Enable GPIO 30 & 31 as IIC clock & data */
+	value = peekRegisterDWord(GPIO_MUX);
+    value = FIELD_SET(value, GPIO_MUX, 30, I2C) |
+			FIELD_SET(0, GPIO_MUX, 31, I2C);
+	pokeRegisterDWord(GPIO_MUX, value);
+              
+    /* Enable Hardware I2C power.
+       TODO: Check if we need to enable GPIO power?
+     */
+    enableI2C(1);
+    
+    /* Enable the I2C Controller and set the bus speed mode */
+    value = peekRegisterByte(I2C_CTRL);
+    if (busSpeedMode == 0)
+        value = FIELD_SET(value, I2C_CTRL, MODE, STANDARD);
+    else
+        value = FIELD_SET(value, I2C_CTRL, MODE, FAST);        
+    value = FIELD_SET(value, I2C_CTRL, EN, ENABLE);
+    pokeRegisterByte(I2C_CTRL, value);
+    
+    return 0;
+}
+
+/*
+ *  This function closes the hardware i2c.
+ */
+void ddk750_hwI2CClose()
+{
+    unsigned long value;
+    
+    /* Disable I2C controller */
+    value = peekRegisterByte(I2C_CTRL);
+    value = FIELD_SET(value, I2C_CTRL, EN, DISABLE);
+    pokeRegisterByte(I2C_CTRL, value);
+
+    /* Disable I2C Power */
+    enableI2C(0);
+
+    /* Set GPIO 30 & 31 back as GPIO pins */
+    value = peekRegisterDWord(GPIO_MUX);
+    value = FIELD_SET(value, GPIO_MUX, 30, GPIO);
+    value = FIELD_SET(value, GPIO_MUX, 31, GPIO);
+    pokeRegisterDWord(GPIO_MUX, value);
+}
+
+/*
+ *  This function waits until the transfer is completed within the timeout value.
+ *
+ *  Return Value:
+ *       0   - Transfer is completed
+ *      -1   - Tranfer is not successful (timeout)
+ */
+#define HWI2C_WAIT_TIMEOUT              0xF0000
+static long hwI2CWaitTXDone(void)
+{
+    unsigned long timeout;
+
+    /* Wait until the transfer is completed. */
+    timeout = HWI2C_WAIT_TIMEOUT;
+	while ((FIELD_GET(peekRegisterByte(I2C_STATUS), I2C_STATUS, TX) != I2C_STATUS_TX_COMPLETED) &&
+           (timeout != 0))
+		timeout--;
+    
+	if (timeout == 0)
+	    return (-1);
+
+    return 0;
+}
+
+/*
+ *  This function writes data to the i2c slave device registers.
+ *
+ *  Parameters:
+ *      deviceAddress   - i2c Slave device address
+ *      length          - Total number of bytes to be written to the device
+ *      pBuffer         - The buffer that contains the data to be written to the
+ *                     i2c device.   
+ *
+ *  Return Value:
+ *      Total number of bytes those are actually written.
+ */
+static unsigned long hwI2CWriteData(
+    unsigned char deviceAddress,
+    unsigned long length,
+    unsigned char *pBuffer
+)
+{
+    unsigned char value, count, i;
+    unsigned long timeout, totalBytes = 0;
+    
+    /* Set the Device Address */
+    pokeRegisterByte(I2C_SLAVE_ADDRESS, deviceAddress & ~0x01);
+    
+    /* Write data.
+     * Note:
+     *      Only 16 byte can be accessed per i2c start instruction.
+     */
+    do
+    {
+        /* Reset I2C by writing 0 to I2C_RESET register to clear the previous status. */
+        pokeRegisterByte(I2C_RESET, 0);
+        
+        /* Set the number of bytes to be written */
+        if (length < MAX_HWI2C_FIFO)
+            count = length - 1;
+        else
+            count = MAX_HWI2C_FIFO - 1;
+        pokeRegisterByte(I2C_BYTE_COUNT, count);
+        
+        /* Move the data to the I2C data register */
+	    for (i = 0; i <= count; i++)
+            pokeRegisterByte(I2C_DATA0 + i, *pBuffer++);
+
+        /* Start the I2C */
+        pokeRegisterByte(I2C_CTRL, FIELD_SET(peekRegisterByte(I2C_CTRL), I2C_CTRL, CTRL, START));
+        
+        /* Wait until the transfer is completed. */
+        if (hwI2CWaitTXDone() != 0)
+            break;
+    
+        /* Substract length */
+        length -= (count + 1);
+        
+        /* Total byte written */
+        totalBytes += (count + 1);
+        
+    } while (length > 0);
+            
+    return totalBytes;
+}
+
+/*
+ *  This function reads data from the slave device and stores them
+ *  in the given buffer
+ *
+ *  Parameters:
+ *      deviceAddress   - i2c Slave device address
+ *      length          - Total number of bytes to be read
+ *      pBuffer         - Pointer to a buffer to be filled with the data read
+ *                     from the slave device. It has to be the same size as the
+ *                     length to make sure that it can keep all the data read.   
+ *
+ *  Return Value:
+ *      Total number of actual bytes read from the slave device
+ */
+static unsigned long hwI2CReadData(
+    unsigned char deviceAddress,
+    unsigned long length,
+    unsigned char *pBuffer
+)
+{
+    unsigned char value, count, i;
+    unsigned long totalBytes = 0; 
+    
+    /* Set the Device Address */
+    pokeRegisterByte(I2C_SLAVE_ADDRESS, deviceAddress | 0x01);
+    
+    /* Read data and save them to the buffer.
+     * Note:
+     *      Only 16 byte can be accessed per i2c start instruction.
+     */
+    do
+    {
+        /* Reset I2C by writing 0 to I2C_RESET register to clear all the status. */
+        pokeRegisterByte(I2C_RESET, 0);
+        
+        /* Set the number of bytes to be read */
+        if (length <= MAX_HWI2C_FIFO)
+            count = length - 1;
+        else
+            count = MAX_HWI2C_FIFO - 1;
+        pokeRegisterByte(I2C_BYTE_COUNT, count);
+
+        /* Start the I2C */
+        pokeRegisterByte(I2C_CTRL, FIELD_SET(peekRegisterByte(I2C_CTRL), I2C_CTRL, CTRL, START));
+        
+        /* Wait until transaction done. */
+        if (hwI2CWaitTXDone() != 0)
+            break;
+
+        /* Save the data to the given buffer */
+        for (i = 0; i <= count; i++)
+		    *pBuffer++ = peekRegisterByte(I2C_DATA0 + i);
+
+        /* Substract length by 16 */
+        length -= (count + 1);
+    
+        /* Number of bytes read. */
+        totalBytes += (count + 1); 
+        
+    } while (length > 0);
+    
+    return totalBytes;
+}
+
+/*
+ *  This function reads the slave device's register
+ *
+ *  Parameters:
+ *      deviceAddress   - i2c Slave device address which register
+ *                        to be read from
+ *      registerIndex   - Slave device's register to be read
+ *
+ *  Return Value:
+ *      Register value
+ */
+unsigned char ddk750_hwI2CReadReg(
+    unsigned char deviceAddress, 
+    unsigned char registerIndex
+)
+{
+    unsigned char value = (0xFF);
+
+    if (hwI2CWriteData(deviceAddress, 1, &registerIndex) == 1)
+        hwI2CReadData(deviceAddress, 1, &value);
+
+    return value;
+}
+
+/*
+ *  This function writes a value to the slave device's register
+ *
+ *  Parameters:
+ *      deviceAddress   - i2c Slave device address which register
+ *                        to be written
+ *      registerIndex   - Slave device's register to be written
+ *      data            - Data to be written to the register
+ *
+ *  Result:
+ *          0   - Success
+ *         -1   - Fail
+ */
+long ddk750_hwI2CWriteReg(
+    unsigned char deviceAddress, 
+    unsigned char registerIndex, 
+    unsigned char data
+)
+{
+    unsigned char value[2];
+    
+    value[0] = registerIndex;
+    value[1] = data;
+    if (hwI2CWriteData(deviceAddress, 2, value) == 2)
+        return 0;
+
+    return (-1);
+}
+
+#if 0
+/* 
+ * This function read the i2c device register value
+ *
+ * Input:   deviceAddress   - I2C Device Address
+ *          registerIndex   - Register index to be read
+ *
+ * Output:
+ *          The value of the register being read.
+ */
+unsigned long hwI2CReadRegMultiple(
+    unsigned char deviceAddress,
+    unsigned char registerIndex,
+    unsigned long length,
+    unsigned char *pBuffer
+)
+{
+    unsigned long totalData = 0;
+
+    /* The length is limited to 256 since register index is limited to unsigned char. */
+    if ((registerIndex + length) > 256)
+        length = 256 - registerIndex;
+
+    /* Read from the slave device */
+    if (hwI2CWriteData(deviceAddress, 1, &registerIndex) == 1)
+        totalData = hwI2CReadData(deviceAddress, length, pBuffer);
+    
+    /* Return the total number of read data */
+    return totalData;
+}
+
+/* 
+ * This function writes a value to the i2c device register.
+ *
+ * Input:   deviceAddress   - I2C Device Address
+ *          registerIndex   - Register index to be read
+ *
+ * Output:
+ *          The value of the register being read.
+ */
+long hwI2CWriteRegMultiple(
+    unsigned char deviceAddress,
+    unsigned char registerIndex,
+    unsigned long length,
+    unsigned char *pBuffer
+)
+{
+    unsigned char value[MAX_HWI2C_FIFO], index, count, start = 1;
+    unsigned long totalData = 0;
+    
+    /* The length is limited to 256 since register index is limited to unsigned char. */
+    if ((registerIndex + length) > 256)
+        length = 256 - registerIndex;
+
+#if 1
+    /* Temporary use this one */
+    for (index = 0; index < (unsigned char)length; index++)
+    {
+        if (hwI2CWriteReg(deviceAddress, registerIndex + index, *pBuffer++) != 0)
+            return (-1); 
+    }
+#else
+    /* Does not work here. Need to find out how to write multiple data at once. */
+    while (length > 0)
+    {
+        if (length < MAX_HWI2C_FIFO)
+            count = length + 1;         /* Add one for the register Index. */
+        else
+            count = MAX_HWI2C_FIFO;
+        
+        /* Write the starting register index */
+        value[0] = registerIndex;
+        
+        /* Write the data */
+        for (index = 1; index < count; index++)
+            value[index] = *pBuffer++;
+    
+        if (hwI2CWriteData(deviceAddress, count, &value[0]) != count)
+            return (-1);
+            
+        /* Update the length */
+        length -= (count - 1);
+        
+        /* Update the registerIndex */
+        registerIndex += (count - 1);
+    }
+#endif
+    
+    return 0;
+}
+#endif
+
diff --git a/drivers/gpu/drm/smi/ddk750/ddk750_hwi2c.h b/drivers/gpu/drm/smi/ddk750/ddk750_hwi2c.h
new file mode 100644
index 000000000000..ac425fc0fbe1
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk750/ddk750_hwi2c.h
@@ -0,0 +1,67 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2008 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  hwi2c.H --- SMI DDK 
+*  This file contains the definitions for Hardware I2C.
+* 
+*******************************************************************/
+#ifndef _HWI2C_H_
+#define _HWI2C_H_
+
+/*
+ *  This function initializes the hardware i2c
+ *
+ *  Parameters:
+ *      busSpeedMode    - I2C Bus Speed Mode
+ *                       0 = Standard Mode (100kbps)
+ *                       1 = Fast Mode (400kbps)
+ *
+ *  Return Value:
+ *       0   - Success
+ *      -1   - Fail to initialize i2c
+ */
+long ddk750_hwI2CInit(
+    unsigned char busSpeedMode
+);
+
+/* 
+ * This function close the hardware i2c 
+ */
+void ddk750_hwI2CClose(void);
+
+/* 
+ * This function read the i2c device register value
+ *
+ * Input:   deviceAddress   - I2C Device Address
+ *          registerIndex   - Register index to be read
+ *
+ * Output:
+ *          The value of the register being read.
+ */
+unsigned char ddk750_hwI2CReadReg(
+    unsigned char deviceAddress, 
+    unsigned char registerIndex
+);
+
+/* 
+ * This function writes a value to the i2c device register.
+ *
+ * Input:   deviceAddress   - I2C Device Address
+ *          registerIndex   - Register index to be written to
+ *          data            - Data to be written to
+ *
+ * Output:
+ *          0   - Success
+ *         -1   - Fail
+ */
+long ddk750_hwI2CWriteReg(
+    unsigned char deviceAddress, 
+    unsigned char registerIndex, 
+    unsigned char data
+);
+
+#endif  /* _HWI2C_H_ */
diff --git a/drivers/gpu/drm/smi/ddk750/ddk750_mode.c b/drivers/gpu/drm/smi/ddk750/ddk750_mode.c
new file mode 100644
index 000000000000..7484424c4925
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk750/ddk750_mode.c
@@ -0,0 +1,1001 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2007 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  MODE.C --- SMI DDK 
+*  This file contains the source code for the mode table.
+* 
+*******************************************************************/
+//#include <string.h>
+#include "ddk750_defs.h"
+#include "ddk750_chip.h"
+#include "ddk750_clock.h"
+#include "ddk750_hardware.h"
+#include "ddk750_helper.h"
+#include "ddk750_power.h"
+#include "ddk750_mode.h"
+#include "ddk750_help.h"
+
+//#include "ddk750_os.h"
+
+//#include "ddkdebug.h"
+
+#define SCALE_CONSTANT                      (1 << 12)
+
+/* Maximum panel size scaling */
+#define MAX_PANEL_SIZE_WIDTH                1920
+#define MAX_PANEL_SIZE_HEIGHT               1440
+
+/* The valid signature of the user data pointer  for the setmode function. 
+   The following definition is ASCII representation of the word 'USER'
+ */
+#define MODE_USER_DATA_SIGNATURE            0x55534552
+
+static mode_parameter_t gPrimaryModeParamTable[MAX_SMI_DEVICE][MAX_MODE_TABLE_ENTRIES] =
+{
+    {
+    /* End of table */
+     { 0, 0, 0, 0, NEG, 0, 0, 0, 0, NEG, 0, 0, 0, NEG},
+    },
+    {
+    /* End of table */
+     { 0, 0, 0, 0, NEG, 0, 0, 0, 0, NEG, 0, 0, 0, NEG},
+    },
+    {
+    /* End of table */
+     { 0, 0, 0, 0, NEG, 0, 0, 0, 0, NEG, 0, 0, 0, NEG},
+    },
+    {
+    /* End of table */
+     { 0, 0, 0, 0, NEG, 0, 0, 0, 0, NEG, 0, 0, 0, NEG},
+    }
+};
+
+static mode_parameter_t gSecondaryModeParamTable[MAX_SMI_DEVICE][MAX_MODE_TABLE_ENTRIES] =
+{
+    {
+    /* End of table */
+     { 0, 0, 0, 0, NEG, 0, 0, 0, 0, NEG, 0, 0, 0, NEG},
+    },
+    {
+    /* End of table */
+     { 0, 0, 0, 0, NEG, 0, 0, 0, 0, NEG, 0, 0, 0, NEG},
+    },
+    {
+    /* End of table */
+     { 0, 0, 0, 0, NEG, 0, 0, 0, 0, NEG, 0, 0, 0, NEG},
+    },
+    {
+    /* End of table */
+     { 0, 0, 0, 0, NEG, 0, 0, 0, 0, NEG, 0, 0, 0, NEG},
+    }
+};
+
+/* Static variable to store the mode information. */
+static mode_parameter_t gPrimaryCurrentModeParam[MAX_SMI_DEVICE];
+static mode_parameter_t gSecondaryCurrentModeParam[MAX_SMI_DEVICE];
+
+/*
+ *  getUserDataSignature
+ *      This function gets the user data mode signature
+ *
+ *  Output:
+ *      The signature to be filled in the user_data_mode_t structure to be considered
+ *      a valid structure.
+ */
+unsigned long getUserDataSignature(void)
+{
+    return MODE_USER_DATA_SIGNATURE;
+}
+
+/*
+ *  findModeParamFromTable
+ *      This function locates the requested mode in the given parameter table
+ *
+ *  Input:
+ *      width           - Mode width
+ *      height          - Mode height
+ *      refresh_rate    - Mode refresh rate
+ *      index           - Index that is used for multiple search of the same mode 
+ *                        that have the same width, height, and refresh rate, 
+ *                        but have different timing parameters.
+ *
+ *  Output:
+ *      Success: return a pointer to the mode_parameter_t entry.
+ *      Fail: a NULL pointer.
+ */
+mode_parameter_t *findModeParamFromTable(
+    unsigned long width, 
+    unsigned long height, 
+    unsigned long refresh_rate,
+    unsigned short index,
+    mode_parameter_t *pModeTable
+)
+{
+    unsigned short modeIndex = 0, tempIndex = 0;
+    
+    /* Walk the entire mode table. */    
+    while (pModeTable[modeIndex].pixel_clock != 0)
+    {
+        if (((width == (unsigned long)(-1)) || (pModeTable[modeIndex].horizontal_display_end == width)) &&
+            ((height == (unsigned long)(-1)) || (pModeTable[modeIndex].vertical_display_end == height)) &&
+            ((refresh_rate == (unsigned long)(-1)) || (pModeTable[modeIndex].vertical_frequency == refresh_rate)))
+        {
+            //if (tempIndex < index)
+            //    tempIndex++;
+           // else
+                return (&pModeTable[modeIndex]);
+        }
+        
+        /* Next entry */
+        modeIndex++;
+    }
+
+    /* No match, return NULL pointer */
+    return((mode_parameter_t *)0);
+}
+
+/*
+ *  Locate in-stock parameter table for the requested mode.
+ *  Success: return a pointer to the mode_parameter_t entry.
+ *  Fail: a NULL pointer.
+ */
+mode_parameter_t *findModeParam(
+    disp_control_t dispCtrl,
+    unsigned long width, 
+    unsigned long height, 
+    unsigned long refresh_rate,
+    unsigned short index
+)
+{
+    return findModeParamFromTable(width, height, refresh_rate, index, getStockModeParamTableEx(dispCtrl));
+}
+
+/*
+ *  Use the
+ *  Locate timing parameter for the requested mode from the default mode table.
+ *  Success: return a pointer to the mode_parameter_t entry.
+ *  Fail: a NULL pointer.
+ */
+mode_parameter_t *findVesaModeParam(
+    unsigned long width, 
+    unsigned long height, 
+    unsigned long refresh_rate
+)
+{
+	switch(ddk750_getChipType())
+	{
+		default: /* Normal SM750/SM718 */
+    		return findModeParamFromTable(width, height, refresh_rate, 0, gDefaultModeParamTable);
+	}
+}
+
+/*
+ * (Obsolete) 
+ * Return a point to the gDefaultModeParamTable.
+ * Function in other files used this to get the mode table pointer.
+ */
+mode_parameter_t *getStockModeParamTable(void)
+{
+	switch(ddk750_getChipType())
+	{
+		default:
+    		return (gDefaultModeParamTable);
+	}	
+}
+
+/*
+ * (Obsolete)
+ * Return the size of the Stock Mode Param Table
+ */
+unsigned long getStockModeParamTableSize(void)
+{
+
+    return (sizeof(gDefaultModeParamTable) / sizeof(mode_parameter_t) - 1);
+
+}
+
+/* 
+ *  getStockModeParamTableEx
+ *      This function gets the mode parameters table associated to the
+ *      display control (PRIMARY_CTRL or SECONDAR_CTRL).
+ *
+ *  Input:
+ *      dispCtrl    - Display Control of the mode table that is associated to.
+ *
+ *  Output:
+ *      Pointer to the mode table
+ */
+mode_parameter_t *getStockModeParamTableEx(
+    disp_control_t dispCtrl
+)
+{
+    mode_parameter_t *pModeTable;
+    pModeTable = getStockModeParamTable();
+#if 0 
+    if (dispCtrl == PRIMARY_CTRL)
+        pModeTable = (mode_parameter_t *)&gPrimaryModeParamTable[getCurrentDevice()];
+    else
+        pModeTable = (mode_parameter_t *)&gSecondaryModeParamTable[getCurrentDevice()];
+        
+    /* Check if the table exist by checking the first entry. 
+       If it doesn't, then use the default mode table. */
+    if (pModeTable->pixel_clock == 0)
+	{
+#if 1 /* Cheok_2013_0118 */
+		pModeTable = getStockModeParamTable();
+#else
+		if (ddk750_getChipType() == SM750LE)
+        	pModeTable = (mode_parameter_t *)&gSM750LEModeParamTable;
+		else
+        	pModeTable = (mode_parameter_t *)&gDefaultModeParamTable;
+#endif
+	}
+#endif   
+    return (pModeTable);
+}
+
+/*
+ *  getStockModeParamTableSizeEx
+ *      This function gets the size of the mode parameter table associated with
+ *      specific display control
+ *
+ *  Input:
+ *      dispCtrl    - Display control of the mode param table that is associated to.
+ *
+ *  Output:
+ *      Size of the requeted mode param table.
+ */
+unsigned long getStockModeParamTableSizeEx(
+    disp_control_t dispCtrl
+)
+{
+    unsigned long tableSize;
+    mode_parameter_t *pModeTable;
+    
+    /* Get the mode table */
+    pModeTable = getStockModeParamTableEx(dispCtrl);
+    
+    /* Calculate the table size by finding the end of table entry indicated by all zeroes. */    
+    tableSize = 0;
+    while (pModeTable[tableSize].pixel_clock != 0)
+        tableSize++;
+        
+    return tableSize;
+}
+
+
+/* 
+ * This function returns the current mode.
+ */
+mode_parameter_t getCurrentModeParam(
+    disp_control_t dispCtrl
+)
+{
+    if (dispCtrl == PRIMARY_CTRL)
+        return gPrimaryCurrentModeParam[getCurrentDevice()];
+    else
+        return gSecondaryCurrentModeParam[getCurrentDevice()];
+}
+
+/*
+ *  Convert the timing into possible SM750 timing.
+ *  If actual pixel clock is not equal to timing pixel clock.
+ *  other parameter like horizontal total and sync have to be changed.
+ *
+ *  Input: Pointer to a mode parameters.
+ *         Pointer to a an empty mode parameter structure to be filled.
+ *         Actual pixel clock generated by SMI hardware.
+ *
+ *  Output:
+ *      1) Fill up input structure mode_parameter_t with possible timing for SM750.
+ */
+long adjustModeParam(
+mode_parameter_t *pModeParam,/* Pointer to mode parameter */
+mode_parameter_t *pMode,     /* Pointer to mode parameter to be updated here */
+unsigned long ulPClk         /* real pixel clock feasible by SM750 */
+)
+{
+    unsigned long blank_width, sync_start, sync_width;
+
+    /* Sanity check */
+    if ( pModeParam == (mode_parameter_t *)0 ||
+         pMode      == (mode_parameter_t *)0 ||
+         ulPClk     == 0)
+    {
+        return -1;
+    }
+
+    /* Copy VESA mode into SM750 mode. */
+    *pMode = *pModeParam;
+
+    /* If it can generate the vesa required pixel clock, and there are a minimum of
+       24 pixel difference between the horizontal sync start and the horizontal display
+       end, then there is nothing to change */
+    if ((ulPClk == pModeParam->pixel_clock) && 
+        ((pModeParam->horizontal_sync_start - pModeParam->horizontal_display_end) > 24))
+        return 0;
+
+    pMode->pixel_clock = ulPClk; /* Update actual pixel clock into mode */
+
+    /* Calculate the sync percentages of the VESA mode. */
+    blank_width = pModeParam->horizontal_total - pModeParam->horizontal_display_end;
+    sync_start = roundedDiv((pModeParam->horizontal_sync_start -
+                       pModeParam->horizontal_display_end) * 100, blank_width);
+    sync_width = roundedDiv(pModeParam->horizontal_sync_width * 100, blank_width);
+
+     /* Calculate the horizontal total based on the actual pixel clock and VESA line frequency. */
+    pMode->horizontal_total = roundedDiv(pMode->pixel_clock,
+                                    pModeParam->horizontal_frequency);
+
+    /* Calculate the sync start and width based on the VESA percentages. */
+    blank_width = pMode->horizontal_total - pMode->horizontal_display_end;
+
+    if (ddk750_getChipType() == SM750)
+    {
+        unsigned long sync_adjustment;
+            
+        /* There is minimum delay of 22 pixels between the horizontal display end 
+           to the horizontal sync start. Therefore, the horizontal sync start value
+           needs to be adjusted if the value falls below 22 pixels.
+           The 22 pixels comes from the propagating delay from the CRT display to
+           all the 11 display pipes inside SM750. The factor of 2 is caused by the
+           double pixel support in SM750. The value used here is 24 to align to 
+           8 bit character width.
+         */
+        sync_adjustment = roundedDiv(blank_width * sync_start, 100);
+        if (sync_adjustment < 24)
+            sync_adjustment = 24;
+        pMode->horizontal_sync_start = pMode->horizontal_display_end + sync_adjustment;
+    
+        /* Check if the adjustment of the sync start will cause the sync width to go
+           over the horizontal total. If it is, then reduce the width instead of
+           changing the horizontal total.
+         */
+        /* Maximum value for sync width and back porch. */
+        sync_adjustment = blank_width - sync_adjustment;
+        pMode->horizontal_sync_width = roundedDiv(blank_width * sync_width, 100);
+        if (sync_adjustment <= pMode->horizontal_sync_width)
+            pMode->horizontal_sync_width = sync_adjustment/2;
+    }
+    else
+    {
+        /* SM718 does not have the above restriction. */
+        pMode->horizontal_sync_start = pMode->horizontal_display_end + roundedDiv(blank_width * sync_start, 100);
+        pMode->horizontal_sync_width = roundedDiv(blank_width * sync_width, 100);
+    }
+    
+    /* Calculate the line and screen frequencies. */
+    pMode->horizontal_frequency = roundedDiv(pMode->pixel_clock,
+                                        pMode->horizontal_total);
+    pMode->vertical_frequency = roundedDiv(pMode->horizontal_frequency,
+                                      pMode->vertical_total);
+    return 0;
+}
+
+
+/*
+ *	This function gets the display status
+ *
+ *	Input:
+ *		dispControl		- display control of which display status to be retrieved.
+ *
+ *  Output:
+ *      0   - Display is pending
+ *     -1   - Display is not pending
+ */
+long isCurrentDisplayPending(
+    disp_control_t dispControl
+)
+{
+    unsigned long value;
+
+    /* Get the display status */
+    if (dispControl == PRIMARY_CTRL)
+    {
+        if (FIELD_GET(peekRegisterDWord(PRIMARY_FB_ADDRESS), PRIMARY_FB_ADDRESS, STATUS) == PRIMARY_FB_ADDRESS_STATUS_PENDING)
+            return 0;
+    }
+	else if (dispControl == SECONDARY_CTRL)
+    {
+        if (FIELD_GET(peekRegisterDWord(SECONDARY_FB_ADDRESS), SECONDARY_FB_ADDRESS, STATUS) == SECONDARY_FB_ADDRESS_STATUS_PENDING)
+            return 0;
+    }
+
+    return (-1);
+}
+
+/*
+ *	This function sets the display base address
+ *
+ *	Input:
+ *		dispControl		- display control of which base address to be set.
+ *		ulBaseAddress	- Base Address value to be set.
+ */
+void setDisplayBaseAddress(
+	disp_control_t dispControl,
+	unsigned long ulBaseAddress
+)
+{
+	if (dispControl == PRIMARY_CTRL)
+	{
+		/* Frame buffer base for this mode */
+	    pokeRegisterDWord(PRIMARY_FB_ADDRESS,
+              FIELD_SET(0, PRIMARY_FB_ADDRESS, STATUS, PENDING)
+            | FIELD_SET(0, PRIMARY_FB_ADDRESS, EXT, LOCAL)
+            | FIELD_VALUE(0, PRIMARY_FB_ADDRESS, ADDRESS, ulBaseAddress));
+	}
+	else if (dispControl == SECONDARY_CTRL)
+	{
+        /* Frame buffer base for this mode */
+        pokeRegisterDWord(SECONDARY_FB_ADDRESS,
+              FIELD_SET(0, SECONDARY_FB_ADDRESS, STATUS, PENDING)
+            | FIELD_SET(0, SECONDARY_FB_ADDRESS, EXT, LOCAL)
+            | FIELD_VALUE(0, SECONDARY_FB_ADDRESS, ADDRESS, ulBaseAddress));
+	}
+}
+
+
+/* 
+ * Program the hardware for a specific video mode
+ */
+void programModeRegisters(
+mode_parameter_t *pModeParam,   /* mode information about pixel clock, horizontal total, etc. */
+unsigned long ulBpp,            /* Color depth for this mode */
+unsigned long ulBaseAddress,    /* Offset in frame buffer */
+unsigned long ulPitch,          /* Mode pitch value in byte: no of bytes between two lines. */
+pll_value_t *pPLL               /* Pre-calculated values for the PLL */
+)
+{
+    unsigned long ulTmpValue, ulReg, ulReservedBits;
+    unsigned long palette_ram;
+    unsigned long offset;
+	logical_chip_type_t chipType;
+
+    /* Enable display power gate */
+    ulTmpValue = peekRegisterDWord(CURRENT_GATE);
+    ulTmpValue = FIELD_SET(ulTmpValue, CURRENT_GATE, DISPLAY, ON);
+    setCurrentGate(ulTmpValue);
+
+    if (pPLL->clockType == SECONDARY_PLL)
+    {
+   // printk("func[%s], secondary reg, ulPitch=[%d]\n", __func__, ulPitch);
+        /* Secondary Display Control: SECONDARY_PLL */
+        pokeRegisterDWord(SECONDARY_PLL_CTRL, formatPllReg(pPLL)); 
+
+        /* Frame buffer base for this mode */
+        //setDisplayBaseAddress(SECONDARY_CTRL, ulBaseAddress);//move by ilena
+
+        /* Pitch value (Sometime, hardware people calls it Offset) */
+       // pokeRegisterDWord(SECONDARY_FB_WIDTH,
+         //     FIELD_VALUE(0, SECONDARY_FB_WIDTH, WIDTH, ulPitch)
+           // | FIELD_VALUE(0, SECONDARY_FB_WIDTH, OFFSET, ulPitch));
+
+        pokeRegisterDWord(SECONDARY_HORIZONTAL_TOTAL,
+              FIELD_VALUE(0, SECONDARY_HORIZONTAL_TOTAL, TOTAL, pModeParam->horizontal_total - 1)
+            | FIELD_VALUE(0, SECONDARY_HORIZONTAL_TOTAL, DISPLAY_END, pModeParam->horizontal_display_end - 1));
+
+        pokeRegisterDWord(SECONDARY_HORIZONTAL_SYNC,
+              FIELD_VALUE(0, SECONDARY_HORIZONTAL_SYNC, WIDTH, pModeParam->horizontal_sync_width)
+            | FIELD_VALUE(0, SECONDARY_HORIZONTAL_SYNC, START, pModeParam->horizontal_sync_start - 1));
+
+        pokeRegisterDWord(SECONDARY_VERTICAL_TOTAL,
+              FIELD_VALUE(0, SECONDARY_VERTICAL_TOTAL, TOTAL, pModeParam->vertical_total - 1)
+            | FIELD_VALUE(0, SECONDARY_VERTICAL_TOTAL, DISPLAY_END, pModeParam->vertical_display_end - 1));
+
+        pokeRegisterDWord(SECONDARY_VERTICAL_SYNC,
+              FIELD_VALUE(0, SECONDARY_VERTICAL_SYNC, HEIGHT, pModeParam->vertical_sync_height)
+            | FIELD_VALUE(0, SECONDARY_VERTICAL_SYNC, START, pModeParam->vertical_sync_start - 1));
+
+        /* Set control register value */
+        ulTmpValue =        
+            (pModeParam->vertical_sync_polarity == POS
+            ? FIELD_SET(0, SECONDARY_DISPLAY_CTRL, VSYNC_PHASE, ACTIVE_HIGH)
+            : FIELD_SET(0, SECONDARY_DISPLAY_CTRL, VSYNC_PHASE, ACTIVE_LOW))
+          | (pModeParam->horizontal_sync_polarity == POS
+            ? FIELD_SET(0, SECONDARY_DISPLAY_CTRL, HSYNC_PHASE, ACTIVE_HIGH)
+            : FIELD_SET(0, SECONDARY_DISPLAY_CTRL, HSYNC_PHASE, ACTIVE_LOW))
+          | FIELD_SET(0, SECONDARY_DISPLAY_CTRL, SELECT, SECONDARY)
+          | FIELD_SET(0, SECONDARY_DISPLAY_CTRL, TIMING, ENABLE)
+          | FIELD_SET(0, SECONDARY_DISPLAY_CTRL, PLANE, ENABLE) 
+          | (ulBpp == 8
+            ? FIELD_SET(0, SECONDARY_DISPLAY_CTRL, FORMAT, 8)
+            : (ulBpp == 16
+            ? FIELD_SET(0, SECONDARY_DISPLAY_CTRL, FORMAT, 16)
+            : FIELD_SET(0, SECONDARY_DISPLAY_CTRL, FORMAT, 32)));
+
+		chipType = ddk750_getChipType();
+
+		if (chipType == SM750 || chipType == SM718)
+        {
+            /* TODO: Check if the auto expansion bit can be cleared here */
+            ulReg = peekRegisterDWord(SECONDARY_DISPLAY_CTRL)
+              & FIELD_CLEAR(SECONDARY_DISPLAY_CTRL, VSYNC_PHASE)
+              & FIELD_CLEAR(SECONDARY_DISPLAY_CTRL, HSYNC_PHASE)
+              & FIELD_CLEAR(SECONDARY_DISPLAY_CTRL, SELECT)
+              & FIELD_CLEAR(SECONDARY_DISPLAY_CTRL, TIMING)
+              & FIELD_CLEAR(SECONDARY_DISPLAY_CTRL, PLANE)
+              & FIELD_CLEAR(SECONDARY_DISPLAY_CTRL, FORMAT)
+              & FIELD_CLEAR(SECONDARY_DISPLAY_CTRL, LOCK_TIMING)
+              & FIELD_CLEAR(SECONDARY_DISPLAY_CTRL, EXPANSION);
+
+            pokeRegisterDWord(SECONDARY_DISPLAY_CTRL, ulTmpValue | ulReg);
+        }
+		
+
+        /* Palette RAM. */
+        palette_ram = SECONDARY_PALETTE_RAM;
+        
+        /* Save the current mode param */
+        gSecondaryCurrentModeParam[getCurrentDevice()] = *pModeParam;
+    }
+    else 
+    {
+        /* Primary display control clock: PRIMARY_PLL */
+        pokeRegisterDWord(PRIMARY_PLL_CTRL, formatPllReg(pPLL));
+
+        /* Program primary PLL, if applicable */
+        if (pPLL->clockType == PRIMARY_PLL)
+        {
+            pokeRegisterDWord(PRIMARY_PLL_CTRL, formatPllReg(pPLL));
+
+            /* Program to Non-VGA mode when using primary PLL */
+            pokeRegisterDWord(VGA_CONFIGURATION, 
+                FIELD_SET(peekRegisterDWord(VGA_CONFIGURATION), VGA_CONFIGURATION, PLL, PRIMARY));
+        }
+        
+        /* Frame buffer base for this mode */
+		//setDisplayBaseAddress(PRIMARY_CTRL, ulBaseAddress);// move by iena
+		//printk("func[%s], primary reg, ulPitch=[%d]\n", __func__, ulPitch);
+        /* Pitch value (Sometime, hardware people calls it Offset) */
+        //pokeRegisterDWord(PRIMARY_FB_WIDTH,
+          //    FIELD_VALUE(0, PRIMARY_FB_WIDTH, WIDTH, ulPitch)
+            //| FIELD_VALUE(0, PRIMARY_FB_WIDTH, OFFSET, ulPitch));
+
+        pokeRegisterDWord(PRIMARY_WINDOW_WIDTH,
+              FIELD_VALUE(0, PRIMARY_WINDOW_WIDTH, WIDTH, pModeParam->horizontal_display_end - 1)
+            | FIELD_VALUE(0, PRIMARY_WINDOW_WIDTH, X, 0));
+
+        pokeRegisterDWord(PRIMARY_WINDOW_HEIGHT,
+              FIELD_VALUE(0, PRIMARY_WINDOW_HEIGHT, HEIGHT, pModeParam->vertical_display_end - 1)
+            | FIELD_VALUE(0, PRIMARY_WINDOW_HEIGHT, Y, 0));
+
+        pokeRegisterDWord(PRIMARY_PLANE_TL,
+              FIELD_VALUE(0, PRIMARY_PLANE_TL, TOP, 0)
+            | FIELD_VALUE(0, PRIMARY_PLANE_TL, LEFT, 0));
+
+        pokeRegisterDWord(PRIMARY_PLANE_BR, 
+              FIELD_VALUE(0, PRIMARY_PLANE_BR, BOTTOM, pModeParam->vertical_display_end - 1)
+            | FIELD_VALUE(0, PRIMARY_PLANE_BR, RIGHT, pModeParam->horizontal_display_end - 1));
+
+        pokeRegisterDWord(PRIMARY_HORIZONTAL_TOTAL,
+              FIELD_VALUE(0, PRIMARY_HORIZONTAL_TOTAL, TOTAL, pModeParam->horizontal_total - 1)
+            | FIELD_VALUE(0, PRIMARY_HORIZONTAL_TOTAL, DISPLAY_END, pModeParam->horizontal_display_end - 1));
+
+        pokeRegisterDWord(PRIMARY_HORIZONTAL_SYNC,
+              FIELD_VALUE(0, PRIMARY_HORIZONTAL_SYNC, WIDTH, pModeParam->horizontal_sync_width)
+            | FIELD_VALUE(0, PRIMARY_HORIZONTAL_SYNC, START, pModeParam->horizontal_sync_start - 1));
+
+        pokeRegisterDWord(PRIMARY_VERTICAL_TOTAL,
+              FIELD_VALUE(0, PRIMARY_VERTICAL_TOTAL, TOTAL, pModeParam->vertical_total - 1)
+            | FIELD_VALUE(0, PRIMARY_VERTICAL_TOTAL, DISPLAY_END, pModeParam->vertical_display_end - 1));
+
+        pokeRegisterDWord(PRIMARY_VERTICAL_SYNC,
+              FIELD_VALUE(0, PRIMARY_VERTICAL_SYNC, HEIGHT, pModeParam->vertical_sync_height)
+            | FIELD_VALUE(0, PRIMARY_VERTICAL_SYNC, START, pModeParam->vertical_sync_start - 1));
+
+        /* Set control register value */
+        ulTmpValue =
+            (pModeParam->clock_phase_polarity == POS
+            ? FIELD_SET(0, PRIMARY_DISPLAY_CTRL, CLOCK_PHASE, ACTIVE_HIGH)
+            : FIELD_SET(0, PRIMARY_DISPLAY_CTRL, CLOCK_PHASE, ACTIVE_LOW))
+          | (pModeParam->vertical_sync_polarity == POS
+            ? FIELD_SET(0, PRIMARY_DISPLAY_CTRL, VSYNC_PHASE, ACTIVE_HIGH)
+            : FIELD_SET(0, PRIMARY_DISPLAY_CTRL, VSYNC_PHASE, ACTIVE_LOW))
+          | (pModeParam->horizontal_sync_polarity == POS
+            ? FIELD_SET(0, PRIMARY_DISPLAY_CTRL, HSYNC_PHASE, ACTIVE_HIGH)
+            : FIELD_SET(0, PRIMARY_DISPLAY_CTRL, HSYNC_PHASE, ACTIVE_LOW))
+          | FIELD_SET(0, PRIMARY_DISPLAY_CTRL, TIMING, ENABLE)
+          | FIELD_SET(0, PRIMARY_DISPLAY_CTRL, PLANE, ENABLE)
+          | (ulBpp == 8
+            ? FIELD_SET(0, PRIMARY_DISPLAY_CTRL, FORMAT, 8)
+            : (ulBpp == 16
+            ? FIELD_SET(0, PRIMARY_DISPLAY_CTRL, FORMAT, 16)
+            : FIELD_SET(0, PRIMARY_DISPLAY_CTRL, FORMAT, 32)));
+
+        /* Added some masks to mask out the reserved bits. 
+         * Sometimes, the reserved bits are set/reset randomly when 
+         * writing to the PRIMARY_DISPLAY_CTRL, therefore, the register
+         * reserved bits are needed to be masked out.
+         */
+        ulReservedBits = FIELD_SET(0, PRIMARY_DISPLAY_CTRL, RESERVED_1_MASK, ENABLE) |
+                         FIELD_SET(0, PRIMARY_DISPLAY_CTRL, RESERVED_2_MASK, ENABLE) |
+                         FIELD_SET(0, PRIMARY_DISPLAY_CTRL, RESERVED_3_MASK, ENABLE);
+
+        ulReg = (peekRegisterDWord(PRIMARY_DISPLAY_CTRL) & ~ulReservedBits)
+              & FIELD_CLEAR(PRIMARY_DISPLAY_CTRL, CLOCK_PHASE)
+              & FIELD_CLEAR(PRIMARY_DISPLAY_CTRL, VSYNC_PHASE)
+              & FIELD_CLEAR(PRIMARY_DISPLAY_CTRL, HSYNC_PHASE)
+              & FIELD_CLEAR(PRIMARY_DISPLAY_CTRL, TIMING)
+              & FIELD_CLEAR(PRIMARY_DISPLAY_CTRL, VERTICAL_PAN)
+              & FIELD_CLEAR(PRIMARY_DISPLAY_CTRL, HORIZONTAL_PAN)
+              & FIELD_CLEAR(PRIMARY_DISPLAY_CTRL, PLANE)
+              & FIELD_CLEAR(PRIMARY_DISPLAY_CTRL, FORMAT);
+
+        pokeRegisterDWord(PRIMARY_DISPLAY_CTRL, ulTmpValue | ulReg);
+
+        /* 
+         * PRIMARY_DISPLAY_CTRL register seems requiring few writes
+         * before a value can be succesfully written in.
+         * Added some masks to mask out the reserved bits.
+         * Note: This problem happens by design. The hardware will wait for the
+         *       next vertical sync to turn on/off the plane.
+         */
+        while((peekRegisterDWord(PRIMARY_DISPLAY_CTRL) & ~ulReservedBits) != (ulTmpValue|ulReg))
+        {
+            pokeRegisterDWord(PRIMARY_DISPLAY_CTRL, ulTmpValue | ulReg);
+        }
+
+        /* Palette RAM */
+        palette_ram = PRIMARY_PALETTE_RAM;
+        
+        /* Save the current mode param */
+        gPrimaryCurrentModeParam[getCurrentDevice()] = *pModeParam;
+    }
+
+    /* In case of 8-bpp, fill palette */
+    if (ulBpp==8)
+    {
+        /* Start with RGB = 0,0,0. */
+        unsigned char red = 0, green = 0, blue = 0;
+        unsigned long gray = 0;
+        for (offset = 0; offset < 256 * 4; offset += 4)
+        {
+            /* Store current RGB value. */
+            pokeRegisterDWord(palette_ram + offset, gray
+                                ? RGB((gray + 50) / 100,
+                                      (gray + 50) / 100,
+                                      (gray + 50) / 100)
+                                : RGB(red, green, blue));
+
+            if (gray)
+            {
+                /* Walk through grays (40 in total). */
+                gray += 654;
+            }
+
+            else
+            {
+                /* Walk through colors (6 per base color). */
+                if (blue != 255)
+                {
+                    blue += 51;
+                }
+                else if (green != 255)
+                {
+                    blue = 0;
+                    green += 51;
+                }
+                else if (red != 255)
+                {
+                    green = blue = 0;
+                    red += 51;
+                }
+                else
+                {
+                    gray = 1;
+                }
+            }
+        }
+    }
+
+    /* For 16- and 32-bpp,  fill palette with gamma values. */
+    else
+    {
+        /* Start with RGB = 0,0,0. */
+        ulTmpValue = 0x000000;
+        for (offset = 0; offset < 256 * 4; offset += 4)
+        {
+            pokeRegisterDWord(palette_ram + offset, ulTmpValue);
+
+            /* Advance RGB by 1,1,1. */
+            ulTmpValue += 0x010101;
+        }
+    }
+}
+
+/* 
+ * This function gets the available clock type
+ *
+ */
+clock_type_t getClockType(disp_control_t dispCtrl)
+{
+    clock_type_t clockType;
+
+    switch (dispCtrl)
+    {
+        case PRIMARY_CTRL:
+            clockType = PRIMARY_PLL;
+            break;
+        default:
+        case SECONDARY_CTRL:
+            clockType = SECONDARY_PLL;
+            break;
+    }
+    return clockType;
+}
+
+/*
+ * Input:
+ *     1) pLogicalMode contains information such as x, y resolution and bpp.
+ *     2) A user defined parameter table for the mode.
+ *
+ * This function calculate and programs the hardware to set up the
+ * requested mode.
+ *
+ * This function allows the use of user defined parameter table if
+ * predefined Vesa parameter table (gDefaultModeParamTable) does not fit.
+ *
+ * Return: 0 (or NO_ERROR) if mode can be set successfully.
+ *         -1 if any set mode error.
+ */
+long setCustomMode(
+	logicalMode_t *pLogicalMode, 
+	mode_parameter_t *pUserModeParam
+)
+{
+    mode_parameter_t pModeParam; /* physical parameters for the mode */
+    pll_value_t pll;
+    unsigned long ulActualPixelClk, ulTemp, ulAddress;
+
+    /*
+     * Minimum check on mode base address.
+     * At least it shouldn't be bigger than the size of frame buffer.
+     */
+    if (ddk750_getFrameBufSize() <= pLogicalMode->baseAddress)
+    	{printk("in func [%s], line[%d], return error\n", __func__, __LINE__);
+        return -1;
+    	}
+
+    /*
+     * Set up PLL, a structure to hold the value to be set in clocks.
+     */
+    pll.inputFreq = DEFAULT_INPUT_CLOCK; /* Defined in CLOCK.H */
+
+    /* Get the Clock Type */
+    pll.clockType = getClockType(pLogicalMode->dispCtrl);
+
+    /* 
+     * Call calcPllValue() to fill up the other fields for PLL structure.
+     * Sometime, the chip cannot set up the exact clock required by User.
+     * Return value from calcPllValue() gives the actual possible pixel clock.
+     */
+    ulActualPixelClk = calcPllValue(pUserModeParam->pixel_clock, &pll);
+    //DDKDEBUGPRINT((DISPLAY_LEVEL, "Actual Pixel Clock: %d\n", ulActualPixelClk));
+
+    /* 
+     * Adjust Vesa mode parameter to feasible mode parameter for SMI hardware.
+     */
+    if (adjustModeParam(pUserModeParam, &pModeParam, ulActualPixelClk) != 0 )
+    {
+    //printk("in func [%s], line[%d], return error\n", __func__, __LINE__);
+        return -1;
+    }
+
+    /* If calling function don't have a preferred pitch value, 
+       work out a 16 byte aligned pitch value.
+    */	
+    //printk("func[%s], ulPitch=[%d]\n", __func__, pLogicalMode->pitch);
+    if (pLogicalMode->pitch <= 0)
+    {
+        /* 
+         * Pitch value calculation in Bytes.
+         * Usually, it is (screen width) * (byte per pixel).
+         * However, there are cases that screen width is not 16 pixel aligned, which is
+         * a requirement for some OS and the hardware itself.
+         * For standard 4:3 resolutions: 320, 640, 800, 1024 and 1280, they are all
+         * 16 pixel aligned and pitch is simply (screen width) * (byte per pixel).
+         *   
+         * However, 1366 resolution, for example, has to be adjusted for 16 pixel aligned.
+         */
+
+        ulTemp = (pLogicalMode->x + 15) & ~15; /* This calculation has no effect on 640, 800, 1024 and 1280. */
+        pLogicalMode->pitch = ulTemp * (pLogicalMode->bpp / 8);
+    }
+	//printk("func[%s], ulPitch=[%d]\n", __func__, pLogicalMode->pitch);
+
+    /* Program the hardware to set up the mode. */
+    programModeRegisters( 
+        &pModeParam,
+        pLogicalMode->bpp, 
+        pLogicalMode->baseAddress, 
+        pLogicalMode->pitch, 
+        &pll);
+        
+    return (0);
+}
+
+/*
+ * Input:
+ *     1) pLogicalMode contains information such as x, y resolution, bpp, xLCD, and yLCD.
+ *     2) A user defined parameter table for the mode.
+ *
+ * This function calculate and programs the hardware to set up the
+ * requested mode and scale the mode if necessary.
+ *
+ * This function allows the use of user defined parameter table if
+ * predefined parameter table does not fit.
+ *
+ * Return: 0 (or NO_ERROR) if mode can be set successfully.
+ *         -1 if any set mode error.
+ */
+long setCustomModeEx(
+	logicalMode_t *pLogicalMode, 
+	mode_parameter_t *pUserModeParam
+)
+{
+    long returnValue = 0;
+
+#if 0   /* userData field is used on DDK version 1.1 and above. Thereofre, this checking is
+           not needed anymore. */
+    /* For the current DDK version, the userData needs to be set to 0. If not, then return error. */
+    if (pLogicalMode->userData != (void *)0)
+        return (-1);
+#endif
+
+    /* Return error when the mode is bigger than the panel size. Might be temporary solution
+       depending whether we will support panning or not. */
+    if (((pLogicalMode->xLCD != 0) && 
+         (pLogicalMode->yLCD != 0)) &&
+        ((pLogicalMode->xLCD < pLogicalMode->x) ||
+         (pLogicalMode->yLCD < pLogicalMode->y)))
+    	{
+    	//printk("in func [%s], line[%d], return error\n", __func__, __LINE__);
+        return (-1);
+    	}
+    
+    /* Return error when the panel size exceed the maximum mode that we can support. */
+    if ((pLogicalMode->xLCD > MAX_PANEL_SIZE_WIDTH) ||
+        (pLogicalMode->yLCD > MAX_PANEL_SIZE_HEIGHT))
+    	{
+    	//printk("in func [%s], line[%d], return error\n", __func__, __LINE__);
+        return (-1);    /* Unsupported panel size. */
+    	}
+    
+    /* Set the mode first */
+    returnValue = setCustomMode(pLogicalMode, pUserModeParam);
+
+    
+    return (returnValue);
+}
+
+/*
+ * Input pLogicalMode contains information such as x, y resolution, bpp, 
+ * xLCD and yLCD. The main difference between setMode and setModeEx are
+ * these two parameters (xLCD and yLCD). Use this setModeEx API to set
+ * expansion while setMode API for regular setmode without any expansion.
+ * Refer to MODE.h for the details.
+ *
+ * This function calculate and programs the hardware to set up the
+ * requested mode.
+ *
+ * Return: 0 (or NO_ERROR) if mode can be set successfully.
+ *         -1 if any set mode error.
+ */
+long setModeEx(
+	logicalMode_t *pLogicalMode
+)
+{
+    mode_parameter_t *pModeParam;       /* physical parameters for the mode */
+    unsigned short index = 0;
+    unsigned long modeWidth, modeHeight;
+    userData_t *pUserData;
+    
+    /* Conditions to set the mode when scaling is needed (xLCD and yLCD is not zeroes)
+     *      1. PRIMARY_CTRL
+     *          a. Set the primary display control timing to the actual display mode.
+     *          b. Set the secondary display control timing to the mode that equals to
+     *             the panel size.
+     *      2. SECONDARY_CTRL
+     *          a. Set the secondary display control timing to the mode that equals to
+     *             the panel size.
+     */
+    if ((pLogicalMode->dispCtrl == SECONDARY_CTRL) &&
+        (pLogicalMode->xLCD != 0) && (pLogicalMode->yLCD != 0))
+    {
+        modeWidth = pLogicalMode->xLCD;
+        modeHeight = pLogicalMode->yLCD;
+    }
+    else
+    {
+        modeWidth = pLogicalMode->x;
+        modeHeight = pLogicalMode->y;
+    }
+    
+    /*
+     * Check the validity of the userData pointer and translate the information as necessary
+     */
+    pUserData = (userData_t *)pLogicalMode->userData;
+    if ((pUserData != (userData_t *)0) &&
+        (pUserData->signature == getUserDataSignature()) &&
+        (pUserData->size == sizeof(userData_t)))
+    {
+        /* Interpret the userData information */
+        if (pUserData->paramList.size == sizeof(userDataParam_t))
+        {
+            if (pUserData->paramList.modeInfoID == MODE_INFO_INDEX)
+                index = pUserData->paramList.paramInfo.index;
+        }
+    }
+    
+    /* 
+     * Check if we already have physical timing parameter for this mode.
+     */
+  //   printk("fine ctrl=[%d], width[%d](x=[%d]), height[%d], hz[%d], index[%d], disp=[%d]\n", pLogicalMode->dispCtrl, modeWidth,pLogicalMode->x,modeHeight, pLogicalMode->hz, index,pLogicalMode->dispCtrl);
+    pModeParam = findModeParam(pLogicalMode->dispCtrl, modeWidth, modeHeight, pLogicalMode->hz, index);
+    if (pModeParam == (mode_parameter_t *)0)
+    	{
+    	//printk("in func [%s], line[%d], return error\n", __func__, __LINE__);
+        return -1;
+    	}
+
+    return(setCustomModeEx(pLogicalMode, pModeParam));
+}
+
+/*
+ * Input pLogicalMode contains information such as x, y resolution and bpp.
+ * Refer to MODE.h for the details.
+ *
+ * This function calculate and programs the hardware to set up the
+ * requested mode.
+ *
+ * Return: 0 (or NO_ERROR) if mode can be set successfully.
+ *         -1 if any set mode error.
+ */
+long setMode(
+	logicalMode_t *pLogicalMode
+)
+{
+    /* Initialize the panel size to 0 */
+    pLogicalMode->xLCD = 0;
+    pLogicalMode->yLCD = 0;
+    pLogicalMode->userData = (void *)0;
+
+    /* Call the setModeEx to set the mode. */
+    return setModeEx(pLogicalMode);
+}
+
+/*
+ *  setInterpolation
+ *      This function enables/disables the horizontal and vertical interpolation
+ *      for the secondary display control. Primary display control does not have
+ *      this capability.
+ *
+ *  Input:
+ *      enableHorzInterpolation - Flag to enable/disable Horizontal interpolation
+ *      enableVertInterpolation - Flag to enable/disable Vertical interpolation
+ */
+void setInterpolation(
+    unsigned long enableHorzInterpolation,
+    unsigned long enableVertInterpolation
+)
+{
+    unsigned long value;
+
+    value = peekRegisterDWord(SECONDARY_DISPLAY_CTRL);
+    
+    if (enableHorzInterpolation)
+        value = FIELD_SET(value, SECONDARY_DISPLAY_CTRL, HORIZONTAL_MODE, INTERPOLATE);
+    else
+        value = FIELD_SET(value, SECONDARY_DISPLAY_CTRL, HORIZONTAL_MODE, REPLICATE);
+        
+    if (enableVertInterpolation)
+        value = FIELD_SET(value, SECONDARY_DISPLAY_CTRL, VERTICAL_MODE, INTERPOLATE);
+    else
+        value = FIELD_SET(value, SECONDARY_DISPLAY_CTRL, VERTICAL_MODE, REPLICATE);
+        
+    pokeRegisterDWord(SECONDARY_DISPLAY_CTRL, value);
+}
diff --git a/drivers/gpu/drm/smi/ddk750/ddk750_mode.h b/drivers/gpu/drm/smi/ddk750/ddk750_mode.h
new file mode 100644
index 000000000000..65edd8582e2d
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk750/ddk750_mode.h
@@ -0,0 +1,565 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2007 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  MODE.H --- SMI DDK 
+*  This file contains the definitions for the mode tables.
+* 
+*******************************************************************/
+#ifndef _MODE_H_
+#define _MODE_H_
+
+/* Maximum parameters those can be saved in the mode table. */
+#define MAX_MODE_TABLE_ENTRIES              60
+
+/* Set the alignment to 1-bit aligned. Otherwise, the memory compare used in the
+   modeext to compare timing will not work. */
+#pragma pack(1)
+
+typedef enum _spolarity_t
+{
+    POS, /* positive */
+    NEG, /* negative */
+}
+spolarity_t;
+
+typedef struct _mode_parameter_t
+{
+    /* Horizontal timing. */
+    unsigned long horizontal_total;
+    unsigned long horizontal_display_end;
+    unsigned long horizontal_sync_start;
+    unsigned long horizontal_sync_width;
+    spolarity_t horizontal_sync_polarity;
+
+    /* Vertical timing. */
+    unsigned long vertical_total;
+    unsigned long vertical_display_end;
+    unsigned long vertical_sync_start;
+    unsigned long vertical_sync_height;
+    spolarity_t vertical_sync_polarity;
+
+    /* Refresh timing. */
+    unsigned long pixel_clock;
+    unsigned long horizontal_frequency;
+    unsigned long vertical_frequency;
+    
+    /* Clock Phase. This clock phase only applies to Panel. */
+    spolarity_t clock_phase_polarity;
+}
+mode_parameter_t;
+
+typedef enum _disp_control_t
+{
+    PRIMARY_CTRL = 0,
+    SECONDARY_CTRL   = 1,
+#if 0    
+    VGA_CTRL   = 2
+#endif
+}
+disp_control_t;
+
+typedef struct _logicalMode_t
+{
+    unsigned long x;            /* X resolution */
+    unsigned long y;            /* Y resolution */
+    unsigned long bpp;          /* Bits per pixel */
+    unsigned long hz;           /* Refresh rate */
+
+    unsigned long baseAddress;  /* Offset from beginning of frame buffer.
+                                   It is used to control the starting location of a mode.
+                                   Calling function must initialize this field.
+                                 */
+
+    unsigned long pitch;        /* Mode pitch in byte.
+                                   If initialized to 0, setMode function will set
+                                   up this field.
+                                   If not zero, setMode function will use this value.
+                                 */
+
+    disp_control_t dispCtrl;    /* SECONDARY or PRIMARY display control channel */
+    
+    /* These two parameters are used in the setModeEx. */
+    unsigned long xLCD;         /* Panel width */
+    unsigned long yLCD;         /* Panel height */
+    
+    void *userData;             /* Not used now, set it to 0 (for future used only) */
+}
+logicalMode_t;
+
+/*
+ * ID of the modeInfoID used in the userDataParam_t
+ */
+#define MODE_INFO_INDEX         0x01
+
+typedef struct _userDataParam_t
+{
+    unsigned long size;         /* Size of this parameter */
+    unsigned char modeInfoID;   /* Mode information ID */
+    
+    /* As the modeInfoID might be expanded in the future to support more stuffs as necessary, 
+       the following parameter list might be expanded in the future. */
+    union
+    {
+        unsigned char index;    /* The index of the mode timing of the given resolution:
+                                        0   - The first mode timing found in the table
+                                        1   - The second mode timing found in the table
+                                        etc...
+                                 */
+        /* Add more user data information parameters here as necessary. */
+    } paramInfo;
+} userDataParam_t;
+
+/* 
+ * Structure that is used as userData pointer in the logicalMode_t 
+ */
+typedef struct _userData_t
+{
+    unsigned long signature;    /* Signature of the userData pointer. 
+                                   It has to be filled with user data Signature to be a valid
+                                   structure pointer. The signature can be obtained by
+                                   calling getUserDataSignature function.
+                                 */
+    unsigned long size;         /* Size of this data structure. */
+    userDataParam_t paramList;  /* List of parameters those are associated with this userData 
+                                   Currently, only one modeInfoID is supported. Later on, when
+                                   the ID is expanded, then the paramList might be expanded
+                                   as an array. */
+} 
+userData_t;
+
+/* Restore alignment */
+#pragma pack()
+
+/*
+ *  getUserDataSignature
+ *      This function gets the user data mode signature
+ *
+ *  Output:
+ *      The signature to be filled in the user_data_mode_t structure to be considered
+ *      a valid structure.
+ */
+unsigned long getUserDataSignature(void);
+
+/*
+ *  compareModeParam
+ *      This function compares two mode parameters
+ *
+ *  Input:
+ *      pModeParam1 - Pointer to the first mode parameter to be compared
+ *      pModeParam2 - Pointer to the second mode parameter to be compared
+ *
+ *  Output:
+ *      0   - Identical mode
+ *     -1   - Mode is not identical
+ */
+long compareModeParam(
+    mode_parameter_t *pModeParam1,
+    mode_parameter_t *pModeParam2
+);
+
+/*
+ *  getDuplicateModeIndex
+ *      This function retrieves the index of dupicate modes, but having different timing.
+ *
+ *  Input:
+ *      dispCtrl    - Display Control where the mode table belongs to.
+ *      pModeParam  - The mode parameters which index to be checked.
+ *
+ *  Output:
+ *      0xFFFF  - The mode parameter can not be found in the current mode table
+ *      Other   - The index of the given parameters among the duplicate modes.
+ *                0 means that the mode param is the first mode encountered in the table
+ *                1 means that the mode param is the second mode encountered in the table
+ *                etc...
+ */
+unsigned short getDuplicateModeIndex(
+    disp_control_t dispCtrl,
+    mode_parameter_t *pModeParam
+);
+
+/*
+ *  findModeParamFromTable
+ *      This function locates the requested mode in the given parameter table
+ *
+ *  Input:
+ *      width           - Mode width
+ *      height          - Mode height
+ *      refresh_rate    - Mode refresh rate
+ *      index           - Index that is used for multiple search of the same mode 
+ *                        that have the same width, height, and refresh rate, 
+ *                        but have different timing parameters.
+ *
+ *  Output:
+ *      Success: return a pointer to the mode_parameter_t entry.
+ *      Fail: a NULL pointer.
+ */
+mode_parameter_t *findModeParamFromTable(
+    unsigned long width, 
+    unsigned long height, 
+    unsigned long refresh_rate,
+    unsigned short index,
+    mode_parameter_t *pModeTable
+);
+
+/*
+ *  Locate in-stock parameter table for the requested mode.
+ *  Success: return a pointer to the mode_parameter_t entry.
+ *  Fail: a NULL pointer.
+ */
+mode_parameter_t *findModeParam(
+    disp_control_t dispCtrl,
+    unsigned long width, 
+    unsigned long height, 
+    unsigned long refresh_rate,
+    unsigned short index
+);
+
+/*
+ *  (Obsolete) --> replace by findModeParam
+ *  Locate in-stock parameter table for the requested mode.
+ *  Success: return a pointer to the mode_parameter_t entry.
+ *  Fail: a NULL pointer.
+ */
+mode_parameter_t *findVesaModeParam(
+    unsigned long width, 
+    unsigned long height, 
+    unsigned long refresh_rate
+);
+
+/* 
+ * Return a point to the gModeParamTable.
+ * Function in other files used this to get the mode table pointer.
+ */
+mode_parameter_t *getStockModeParamTable(void);
+
+/*
+ * Return the size of the Stock Mode Param Table
+ */
+unsigned long getStockModeParamTableSize(void);
+
+/* 
+ *  getStockModeParamTableEx
+ *      This function gets the mode parameters table associated to the
+ *      display control (PRIMARY_CTRL or SECONDAR_CTRL).
+ *
+ *  Input:
+ *      dispCtrl    - Display Control of the mode table that is associated to.
+ *
+ *  Output:
+ *      Pointer to the mode table
+ */
+mode_parameter_t *getStockModeParamTableEx(
+    disp_control_t dispCtrl
+);
+
+/*
+ *  getStockModeParamTableSizeEx
+ *      This function gets the size of the mode parameter table associated with
+ *      specific display control
+ *
+ *  Input:
+ *      dispCtrl    - Display control of the mode param table that is associated to.
+ *
+ *  Output:
+ *      Size of the requeted mode param table.
+ */
+unsigned long getStockModeParamTableSizeEx(
+    disp_control_t dispCtrl
+);
+
+/* 
+ * This function returns the current mode.
+ */
+mode_parameter_t getCurrentModeParam(
+    disp_control_t dispCtrl
+);
+
+/*
+ *  getMaximumModeEntries
+ *      This function gets the maximum entries that can be stored in the mode table.
+ *
+ *  Output:
+ *      Total number of maximum entries
+ */
+unsigned long getMaximumModeEntries(void);
+
+/*
+ * Input:
+ *     1) pLogicalMode contains information such as x, y resolution and bpp.
+ *     2) A user defined parameter table for the mode.
+ *
+ * This function calculate and programs the hardware to set up the
+ * requested mode.
+ *
+ * This function allows the use of user defined parameter table if
+ * predefined Vesa parameter table (gModeParamTable) does not fit.
+ *
+ * Return: 0 (or NO_ERROR) if mode can be set successfully.
+ *         -1 if any set mode error.
+ */
+long setCustomMode(
+    logicalMode_t *pLogicalMode, 
+    mode_parameter_t *pUserModeParam
+);
+
+/*
+ * Input:
+ *     1) pLogicalMode contains information such as x, y resolution, bpp, xLCD, and yLCD.
+ *     2) A user defined parameter table for the mode.
+ *
+ * Similar like setCustomMode, this function calculate and programs the hardware 
+ * to set up the requested mode and also scale the mode if necessary.
+ *
+ * This function allows the use of user defined parameter table if
+ * predefined Vesa parameter table (gModeParamTable) does not fit.
+ *
+ * Return: 0 (or NO_ERROR) if mode can be set successfully.
+ *         -1 if any set mode error.
+ */
+long setCustomModeEx(
+    logicalMode_t *pLogicalMode, 
+    mode_parameter_t *pUserModeParam
+);
+
+/*
+ * Input pLogicalMode contains information such as x, y resolution and bpp.
+ * Refer to MODE.h for the details.
+ *
+ * This function calculate and programs the hardware to set up the
+ * requested mode.
+ *
+ * Return: 0 (or NO_ERROR) if mode can be set successfully.
+ *         -1 if any set mode error.
+ */
+long setMode(
+    logicalMode_t *pLogicalMode
+);
+
+/*
+ * Input pLogicalMode contains information such as x, y resolution, bpp, 
+ * xLCD and yLCD. The main difference between setMode and setModeEx are
+ * the xLCD and yLCD parameters. Use this setModeEx API to set the mode
+ * and enable expansion. setMode API does not support expansion.
+ *
+ * This function calculate and programs the hardware to set up the
+ * requested mode.
+ *
+ * Return: 0 (or NO_ERROR) if mode can be set successfully.
+ *         -1 if any set mode error.
+ */
+long setModeEx(
+    logicalMode_t *pLogicalMode
+);
+
+
+/*
+ *  setInterpolation
+ *      This function enables/disables the horizontal and vertical interpolation
+ *      for the secondary display control. Primary display control does not have
+ *      this capability.
+ *
+ *  Input:
+ *      enableHorzInterpolation - Flag to enable/disable Horizontal interpolation
+ *      enableVertInterpolation - Flag to enable/disable Vertical interpolation
+ */
+void setInterpolation(
+    unsigned long enableHorzInterpolation,
+    unsigned long enableVertInterpolation
+);
+
+/***********************************************************************************
+ *
+ *  The following function prototypes are the extension of mode.c where it involves
+ *  EDID, GTF, and others calculation. Please include modeext.c to use these
+ *  functions.
+ *
+ ***********************************************************************************/
+
+/*
+ *  registerEdidTiming
+ *      This function registers timing from EDID, LCD Monitor Timing Extension,
+ *      Standard Timing Extension, etc...
+ *
+ *  Input:
+ *      dispCtrl            - Display control where the mode will be associated to
+ *      pEDIDBuffer         - Pointer to the display device's EDID Buffer
+ *      pLCDTimingExt       - Pointer to LCD Monitor Timing Extension (currently is not supported)
+ *      pStdTimingExt       - Pointer to Standard Timing extension (currently is not supported)
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long registerEdidTiming(
+    disp_control_t dispCtrl,
+    unsigned char *pEDIDBuffer,
+    unsigned char *pLCDTimingExt,
+    unsigned char *pStdTimingExt
+);
+
+/*
+ *  calculateGtfTiming
+ *      This function calculate the GTF Timing and produce the SM750 mode parameter
+ *      format
+ *
+ *  Input:
+ *      width               - Mode Width
+ *      height              - Mode Height
+ *      refreshRate         - Mode Refresh Rate
+ *      pModeParam          - Pointer to SM750 mode parameter format variable to store
+ *                            the calculated value of the GTF
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long calculateDefaultGtfTiming(
+    unsigned long width,
+    unsigned long height,
+    unsigned long refreshRate,
+    mode_parameter_t *pModeParam
+);
+
+/*
+ *  calculateGtfTiming
+ *      This function calculate the GTF Timing and produce the SM750 mode parameter
+ *      format
+ *
+ *  Input:
+ *      width               - Mode Width
+ *      height              - Mode Height
+ *      refreshRate         - Mode Refresh Rate
+ *      pModeParam          - Pointer to SM750 mode parameter format variable to store
+ *                            the calculated value of the GTF
+ *      offset              - The value of GTF Offset parameter
+ *      gradient            - The value of GTF Gradient parameter
+ *      scalingFactor       - The value of the GTF scaling factor parameter
+ *      scalingFactorWeight - The value of the GTF scaling Factor Weight parameter
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long calculateGtfTiming(
+    unsigned long width,
+    unsigned long height,
+    unsigned long refreshRate,
+    mode_parameter_t *pModeParam,
+    unsigned char offset,
+    unsigned short gradient,
+    unsigned char scalingFactor,
+    unsigned char scalingFactorWeight
+    
+);
+
+/*
+ *  isDefaultGtfTiming
+ *      Check if the given timing is default GTF timing. 
+ *      Default here means it uses the following configuration to calculate the timing:
+ *          Offset (C) = 40%
+ *          Gradient (M) = 600%/kHz
+ *          Scaling Factor (K) = 128
+ *          Weighted Scaling Factor (J) = 20%
+ *
+ *  Input:
+ *      pModeParam  - Mode Parameter that will be checked whether is default GTF or not
+ *
+ *  Output:
+ *      0       - Indicates that the given mode parameter is a NOT a default GTF Timing
+ *      Other   - Indicates that the given mode parameter is a default GTF Timing
+ */
+long isDefaultGtfTiming(
+    mode_parameter_t *pModeParam
+);
+
+/*
+ *  isSecondaryGtfTiming
+ *      Check if the given timing is the secondary GTF timing calculated based on the
+ *      given offset (C), gradient (M), scaling factor (K), and weighted scaling factor (J). 
+ *
+ *  Input:
+ *      pModeParam          - Mode Parameter that will be checked whether is secondary GTF or not
+ *      offset              - Blanking formula offset used to calculate the secondary GTF mode param.
+ *      gradient            - Blanking formula gradient used to calculate the secondary GTF 
+ *                            mode param.
+ *      scalingFactor       - Blanking formula scaling factor used to calculate the secondary 
+ *                            GTF mode param
+ *      scalingFactorWeight - Blanking formula scaling factor weighting used to calculate the
+ *                            secondary GTF mode param
+ *
+ *  Output:
+ *      0       - Indicates that the given mode parameter is NOT a default GTF Timing
+ *      Other   - Indicates that the given mode parameter is a default GTF Timing
+ */
+long isSecondaryGtfTiming(
+    mode_parameter_t *pModeParam,
+    unsigned char offset,
+    unsigned short gradient,
+    unsigned char scalingFactor,
+    unsigned char scalingFactorWeight
+);
+
+/*
+ *  isVesaTiming
+ *      Check if the given timing is the VESA Discrete Monitor Timing Standard. 
+ *
+ *  Input:
+ *      pModeParam  - Mode Parameter that will be checked whether is VESA Timing or not
+ *
+ *  Output:
+ *      0       - Indicates that the given mode parameter is NOT a VESA DMT Timing
+ *      Other   - Indicates that the given mode parameter is a VESA DMT Timing
+ */
+long isVesaTiming(
+    mode_parameter_t *pModeParam
+);
+
+/*
+ *  isEdidPreferredTiming
+ *      Check if the given timing is the EDID preferred timing. 
+ *
+ *  Input:
+ *      pEDIDBuffer - Pointer to an EDID Buffer. 
+ *      pModeParam  - Mode Parameter that will be checked whether is EDID
+ *                    preferred timing or not.
+ *
+ *  Output:
+ *     >0   - Indicates that the given mode parameter is a default GTF Timing
+ *      0   - Indicates that the given mode parameter is NOT a default GTF Timing
+ */
+long isEdidPreferredTiming(
+    unsigned char *pEDIDBuffer,
+    mode_parameter_t *pModeParam
+);
+
+/*
+ *	This function sets the display base address
+ *
+ *	Input:
+ *		dispControl		- display control of which base address to be set.
+ *		ulBaseAddress	- Base Address value to be set.
+ */
+void setDisplayBaseAddress(
+	disp_control_t dispControl,
+	unsigned long ulBaseAddress
+);
+
+/*
+ *	This function gets the display status
+ *
+ *	Input:
+ *		dispControl		- display control of which display status to be retrieved.
+ *
+ *  Output:
+ *      0   - Display is pending
+ *     -1   - Display is not pending
+ */
+long isCurrentDisplayPending(
+    disp_control_t dispControl
+);
+
+#endif /* _MODE_H_ */
diff --git a/drivers/gpu/drm/smi/ddk750/ddk750_power.c b/drivers/gpu/drm/smi/ddk750/ddk750_power.c
new file mode 100644
index 000000000000..552e32fdc78f
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk750/ddk750_power.c
@@ -0,0 +1,495 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2007 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  power.c --- Voyager GX SDK 
+*  This file contains the source code for the power functions.
+* 
+*******************************************************************/
+#include "ddk750_defs.h"
+#include "ddk750_chip.h"
+#include "ddk750_clock.h"
+#include "ddk750_hardware.h"
+#include "ddk750_power.h"
+#include "ddk750_help.h"
+
+//#include "ddkdebug.h"
+
+/* Semaphore Counter for Bus Master Enable Bit */
+unsigned long g_ulBusMasterSemaphoreCounter[MAX_SMI_DEVICE] = { 0, 0, 0, 0};
+unsigned long g_ulPCISlaveBurstWriteSemaphoreCounter[MAX_SMI_DEVICE] = { 0, 0, 0, 0};
+unsigned long g_ulPCISlaveBurstReadSemaphoreCounter[MAX_SMI_DEVICE] = { 0, 0, 0, 0};
+
+/* Set DPMS state */
+void setDPMS(DPMS_t state)
+{
+    unsigned long value;
+
+    //if(ddk750_getChipType() == SM750LE)
+    if(ddk750_getChipType() >= SM750LE)
+    {
+        value = peekRegisterDWord(SECONDARY_DISPLAY_CTRL);
+        switch (state)
+        {
+        case DPMS_ON:
+            value = FIELD_SET(value, SECONDARY_DISPLAY_CTRL, DPMS, 0);
+            break;
+
+        case DPMS_STANDBY:
+            value = FIELD_SET(value, SECONDARY_DISPLAY_CTRL, DPMS, 1);
+            break;
+
+        case DPMS_SUSPEND:
+            value = FIELD_SET(value, SECONDARY_DISPLAY_CTRL, DPMS, 2);
+            break;
+
+        case DPMS_OFF:
+            value = FIELD_SET(value, SECONDARY_DISPLAY_CTRL, DPMS, 3);
+            break;
+        }
+
+        pokeRegisterDWord(SECONDARY_DISPLAY_CTRL, value);
+        return;
+    }
+
+    value = peekRegisterDWord(SYSTEM_CTRL);
+    switch (state)
+    {
+       case DPMS_ON:
+        value = FIELD_SET(value, SYSTEM_CTRL, DPMS, VPHP);
+        break;
+
+       case DPMS_STANDBY:
+        value = FIELD_SET(value, SYSTEM_CTRL, DPMS, VPHN);
+        break;
+
+       case DPMS_SUSPEND:
+        value = FIELD_SET(value, SYSTEM_CTRL, DPMS, VNHP);
+        break;
+
+       case DPMS_OFF:
+        value = FIELD_SET(value, SYSTEM_CTRL, DPMS, VNHN);
+        break;
+    }
+
+    pokeRegisterDWord(SYSTEM_CTRL, value);
+}
+
+/*
+ * This function gets the power mode, one of three modes: 0, 1 or Sleep.
+ * On hardware reset, power mode 0 is default.
+ */
+unsigned long getPowerMode()
+{
+
+    return (FIELD_GET(peekRegisterDWord(POWER_MODE_CTRL), POWER_MODE_CTRL, MODE));
+}
+
+/*
+ * SM750/SM718 can operate in one of three modes: 0, 1 or Sleep.
+ * On hardware reset, power mode 0 is default.
+ */
+void setPowerMode(unsigned long powerMode)
+{
+    unsigned long control_value = 0, previousPowerState, timeout, value;
+
+    /* Get the current power mode ctrl register value and save it 
+       before switching the power mode. */
+    control_value = peekRegisterDWord(POWER_MODE_CTRL);
+    previousPowerState = FIELD_GET(control_value, POWER_MODE_CTRL, MODE);
+
+    /* Set the power mode to the requested power mode. */
+    switch (powerMode)
+    {
+        case 0:
+            control_value = FIELD_SET(control_value, POWER_MODE_CTRL, MODE, MODE0);
+            break;
+
+        case 1:
+            control_value = FIELD_SET(control_value, POWER_MODE_CTRL, MODE, MODE1);
+            break;
+
+        case 2:
+            control_value = FIELD_SET(control_value, POWER_MODE_CTRL, MODE, SLEEP);
+            break;
+
+        default:
+            break;
+    }
+
+#if 0   /* These routines are removed since turning off the oscillator during sleep
+           will require the software to reset the frame buffer memory. 
+         */
+    /* Set up other fields in Power Control Register */
+    if (powerMode == POWER_MODE_CTRL_MODE_SLEEP)
+        control_value = FIELD_SET(control_value, POWER_MODE_CTRL, OSC_INPUT, OFF);
+    else
+        control_value = FIELD_SET(control_value, POWER_MODE_CTRL, OSC_INPUT, ON);
+#endif
+
+    /* Program new power mode. */
+    pokeRegisterDWord(POWER_MODE_CTRL, control_value);
+    
+    /* In SM718, the chip needs to wait until wake up from the sleep mode and wait for
+       a few milliseconds before reseting the memory and resume the normal operation. */
+    if ((powerMode != 2) && (previousPowerState != FIELD_GET(control_value, POWER_MODE_CTRL, MODE)))
+    {
+        /* Switching power mode between power mode 0 and 1 */
+        
+        /* Need a minimum of 16ms between power mode switching */
+        waitMasterClock(16);
+        
+        /* Reset Memory. */
+        ddk750_resetFrameBufferMemory();
+    }
+}
+
+void setCurrentGate(unsigned long gate)
+{
+    unsigned long gate_reg;
+    unsigned long mode;
+
+    /* Get current power mode. */
+    mode = getPowerMode();
+
+    switch (mode)
+    {
+        case POWER_MODE_CTRL_MODE_MODE0:
+            gate_reg = MODE0_GATE;
+            break;
+
+        case POWER_MODE_CTRL_MODE_MODE1:
+            gate_reg = MODE1_GATE;
+            break;
+
+        default:
+            gate_reg = MODE0_GATE;
+            break;
+    }
+    pokeRegisterDWord(gate_reg, gate);
+}
+
+/*
+ * This function enable/disable Bus Master
+ */
+void enableBusMaster(unsigned long enable)
+{
+    unsigned long busMasterCounter, value;
+
+    /* Enable Bus Master as necessary.*/
+	busMasterCounter = g_ulBusMasterSemaphoreCounter[getCurrentDevice()];
+	value = peekRegisterDWord(SYSTEM_CTRL);
+
+    /* Currently, only SM718 needs to enable the Bus Master enable bit. 
+       The Bus Master in SM750 is enabled by default, without programming any bits. */
+    if (enable)
+    {
+        if ((ddk750_getChipType() == SM718) && (busMasterCounter == 0))        
+            pokeRegisterDWord(SYSTEM_CTRL, FIELD_SET(peekRegisterDWord(SYSTEM_CTRL), SYSTEM_CTRL, PCI_MASTER, ON));
+        
+        busMasterCounter++;
+    }
+    else
+    {
+        if (busMasterCounter > 0)
+            busMasterCounter--;
+        
+        if ((ddk750_getChipType() == SM718) && (busMasterCounter == 0))
+            pokeRegisterDWord(SYSTEM_CTRL, FIELD_SET(peekRegisterDWord(SYSTEM_CTRL), SYSTEM_CTRL, PCI_MASTER, OFF));
+    }
+
+    g_ulBusMasterSemaphoreCounter[getCurrentDevice()] = busMasterCounter;
+}
+
+/* 
+ *	setPCIMasterBaseAddress
+ *		This function set the PCI Master Base Address (used by bus master or DMA).
+ *
+ *	Input:	
+ *		physicalSystemMemAddress	- System physical memory address which PCI
+ *									  Master Base Address to be set to.
+ *
+ *	Output:
+ *		The memory address to be set in the register.  
+ */
+unsigned long setPCIMasterBaseAddress(
+	unsigned long physicalSystemMemAddress
+)
+{
+	unsigned long pciMasterBaseAddress, remainingAddress;
+
+    /* Set PCI Master Base Address */
+    if (ddk750_getChipType() == SM750)
+    {
+#ifdef SM750_AA
+        pciMasterBaseAddress = ((physicalSystemMemAddress & 0xFFF00000) >> 23) << 3;
+        pokeRegisterDWord(PCI_MASTER_BASE, FIELD_VALUE(0, PCI_MASTER_BASE, ADDRESS, pciMasterBaseAddress));
+        
+        /* This errata only applies to System Memory. For local to local, no correction is
+           needed. */
+        remainingAddress = ((physicalSystemMemAddress & 0x00700000) << 3) + (physicalSystemMemAddress & 0x000FFFFF);
+#else
+        pciMasterBaseAddress = physicalSystemMemAddress >> 23;
+        pciMasterBaseAddress = (pciMasterBaseAddress > 0xFF) ? 0xFF : pciMasterBaseAddress;
+        pokeRegisterDWord(PCI_MASTER_BASE, FIELD_VALUE(0, PCI_MASTER_BASE, ADDRESS, pciMasterBaseAddress));
+        remainingAddress = physicalSystemMemAddress - (pciMasterBaseAddress << 23);
+#endif
+    }
+    else
+    {
+        pciMasterBaseAddress = physicalSystemMemAddress & 0xFFF00000;
+        pokeRegisterDWord(SM718_PCI_MASTER_BASE, FIELD_VALUE(0, SM718_PCI_MASTER_BASE, ADDRESS, pciMasterBaseAddress));
+        remainingAddress = physicalSystemMemAddress - pciMasterBaseAddress;
+    }
+
+    //DDKDEBUGPRINT((DMA_LEVEL, "pciMasterBaseAddress: %x\n", pciMasterBaseAddress));
+
+	/* Send back the remaining address */
+    return remainingAddress;
+}
+
+/*
+ * 	This function enable/disable PCI Slave Burst Write provided the CPU supports Write Combine.
+ *
+ *	Input:
+ *			enable		- Enable/Disable the PCI Slave Burst Write (0 = disable, 1 = enable)
+ */
+void enablePCISlaveBurstWrite(
+	unsigned long enable
+)
+{
+	unsigned long pciSlaveBurstWriteCounter, value;
+
+    /* Enable PCI Slave Burst Write */
+	pciSlaveBurstWriteCounter = g_ulPCISlaveBurstWriteSemaphoreCounter[getCurrentDevice()];
+	value = peekRegisterDWord(SYSTEM_CTRL);
+
+    if (enable != 0)
+    {
+        if ((ddk750_getChipType() == SM718) && (pciSlaveBurstWriteCounter == 0))
+		{
+			/* Enable PCI Slave Burst Write. */
+			value = FIELD_SET(peekRegisterDWord(SYSTEM_CTRL), SYSTEM_CTRL, PCI_BURST, ON); 
+			pokeRegisterDWord(SYSTEM_CTRL, value);
+        }
+
+        pciSlaveBurstWriteCounter++;
+    }
+    else
+    {
+        if (pciSlaveBurstWriteCounter > 0)
+            pciSlaveBurstWriteCounter--;
+        
+        if ((ddk750_getChipType() == SM718) && (pciSlaveBurstWriteCounter == 0))
+		{
+			/* Disable PCI Slave Burst Write */
+			value = FIELD_SET(peekRegisterDWord(SYSTEM_CTRL), SYSTEM_CTRL, PCI_BURST, OFF); 
+			pokeRegisterDWord(SYSTEM_CTRL, value);
+		}
+    }
+
+	g_ulPCISlaveBurstWriteSemaphoreCounter[getCurrentDevice()] = pciSlaveBurstWriteCounter;
+}
+
+/*
+ * 	This function enable/disable PCI Slave Burst Read provided the CPU supports it.
+ *
+ *	Input:
+ *			enable			- Enable/Disable the PCI Slave Burst Read (0 = disable, 1 = enable)
+ *			burstReadSize	- Burst Read Size in 32-words (valid values are 1, 2, 4, and 8)
+ */
+void enablePCISlaveBurstRead(
+	unsigned long enable,
+	unsigned long burstReadSize
+)
+{
+	unsigned long pciSlaveBurstReadCounter, value;
+
+    /* Currently, only SM718 needs to enable the Bus Master enable bit. 
+       The Bus Master in SM750 is enabled by default, without programming any bits. */
+	pciSlaveBurstReadCounter = g_ulPCISlaveBurstReadSemaphoreCounter[getCurrentDevice()];
+	value = peekRegisterDWord(SYSTEM_CTRL);
+
+    if (enable != 0)
+    {
+        if ((ddk750_getChipType() == SM718) && (pciSlaveBurstReadCounter == 0))
+		{
+			value = peekRegisterDWord(SYSTEM_CTRL);
+
+			/* Enable PCI Slave Burst Read. */
+			value = FIELD_SET(value, SYSTEM_CTRL, PCI_BURST_READ, ON); 
+
+			/* Set the Read Size */
+			switch(burstReadSize)
+			{
+				case 1:
+					value = FIELD_SET(value, SYSTEM_CTRL, PCI_SLAVE_BURST_READ_SIZE, 1);
+					break;
+				case 2:
+					value = FIELD_SET(value, SYSTEM_CTRL, PCI_SLAVE_BURST_READ_SIZE, 2);
+					break;
+				case 4:
+					value = FIELD_SET(value, SYSTEM_CTRL, PCI_SLAVE_BURST_READ_SIZE, 4);
+					break;
+				default:
+				case 8:
+					value = FIELD_SET(value, SYSTEM_CTRL, PCI_SLAVE_BURST_READ_SIZE, 8);
+					break;
+			}
+			pokeRegisterDWord(SYSTEM_CTRL, value);
+        }
+
+        pciSlaveBurstReadCounter++;
+    }
+    else
+    {
+        if (pciSlaveBurstReadCounter > 0)
+            pciSlaveBurstReadCounter--;
+        
+        if ((ddk750_getChipType() == SM718) && (pciSlaveBurstReadCounter == 0))
+		{
+			/* Disable PCI Slave Burst */
+			value = FIELD_SET(peekRegisterDWord(SYSTEM_CTRL), SYSTEM_CTRL, PCI_BURST_READ, OFF); 
+			pokeRegisterDWord(SYSTEM_CTRL, value);
+		}
+    }
+
+	g_ulPCISlaveBurstReadSemaphoreCounter[getCurrentDevice()] = pciSlaveBurstReadCounter;
+}
+
+/* 
+ * This function enable/disable the 2D engine.
+ */
+void enable2DEngine(unsigned long enable)
+{
+    unsigned long gate;
+
+    gate = peekRegisterDWord(CURRENT_GATE);
+    if (enable)
+    {
+        gate = FIELD_SET(gate, CURRENT_GATE, DE,  ON);
+        gate = FIELD_SET(gate, CURRENT_GATE, CSC, ON);
+    }
+    else
+    {
+        gate = FIELD_SET(gate, CURRENT_GATE, DE,  OFF);
+        gate = FIELD_SET(gate, CURRENT_GATE, CSC, OFF);
+    }
+
+    setCurrentGate(gate);
+}
+
+/* 
+ * This function enable/disable the ZV Port.
+ */
+void enableZVPort(unsigned long enable)
+{
+    unsigned long gate;
+    
+    /* Enable ZV Port Gate */
+    gate = peekRegisterDWord(CURRENT_GATE);
+    if (enable)
+    {
+        gate = FIELD_SET(gate, CURRENT_GATE, ZVPORT, ON);
+#if 1
+        /* Using Software I2C */
+        gate = FIELD_SET(gate, CURRENT_GATE, GPIO, ON);
+#endif
+    }
+    else
+    {
+        /* Disable ZV Port Gate. There is no way to know whether the GPIO pins are being used
+           or not. Therefore, do not disable the GPIO gate. */
+        gate = FIELD_SET(gate, CURRENT_GATE, ZVPORT, OFF);
+    }
+    
+    setCurrentGate(gate);
+}
+
+/* 
+ * This function enable/disable the SSP.
+ */
+void enableSSP(unsigned long enable)
+{
+    unsigned long gate;
+    
+    /* Enable SSP Gate */
+    gate = peekRegisterDWord(CURRENT_GATE);
+    if (enable)
+        gate = FIELD_SET(gate, CURRENT_GATE, SSP, ON);        
+    else
+        gate = FIELD_SET(gate, CURRENT_GATE, SSP, OFF);
+    
+    setCurrentGate(gate);
+}
+
+/* 
+ * This function enable/disable the DMA Engine
+ */
+void enableDMA(unsigned long enable)
+{
+    unsigned long gate;
+    
+    /* Enable DMA Gate */
+    gate = peekRegisterDWord(CURRENT_GATE);
+    if (enable)
+        gate = FIELD_SET(gate, CURRENT_GATE, DMA, ON);
+    else
+        gate = FIELD_SET(gate, CURRENT_GATE, DMA, OFF);
+
+    setCurrentGate(gate);
+}
+
+/* 
+ * This function enable/disable the GPIO Engine
+ */
+void enableGPIO(unsigned long enable)
+{
+    unsigned long gate;
+    
+    /* Enable GPIO Gate */
+    gate = peekRegisterDWord(CURRENT_GATE);
+    if (enable)
+        gate = FIELD_SET(gate, CURRENT_GATE, GPIO, ON);        
+    else
+        gate = FIELD_SET(gate, CURRENT_GATE, GPIO, OFF);
+    
+    setCurrentGate(gate);
+}
+
+/* 
+ * This function enable/disable the PWM Engine
+ */
+void enablePWM(unsigned long enable)
+{
+    unsigned long gate;
+    
+    /* Enable PWM Gate */
+    gate = peekRegisterDWord(CURRENT_GATE);
+    if (enable)
+        gate = FIELD_SET(gate, CURRENT_GATE, PWM, ON);        
+    else
+        gate = FIELD_SET(gate, CURRENT_GATE, PWM, OFF);
+    
+    setCurrentGate(gate);
+}
+
+/* 
+ * This function enable/disable the I2C Engine
+ */
+void enableI2C(unsigned long enable)
+{
+    unsigned long gate;
+    
+    /* Enable I2C Gate */
+    gate = peekRegisterDWord(CURRENT_GATE);
+    if (enable)
+        gate = FIELD_SET(gate, CURRENT_GATE, I2C, ON);        
+    else
+        gate = FIELD_SET(gate, CURRENT_GATE, I2C, OFF);
+    
+    setCurrentGate(gate);
+}
diff --git a/drivers/gpu/drm/smi/ddk750/ddk750_power.h b/drivers/gpu/drm/smi/ddk750/ddk750_power.h
new file mode 100644
index 000000000000..4fc93b0e05dc
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk750/ddk750_power.h
@@ -0,0 +1,121 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2007 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  power.h --- Voyager GX SDK 
+*  This file contains the definitions for the power functions.
+* 
+*******************************************************************/
+#ifndef _POWER_H_
+#define _POWER_H_
+
+typedef enum _DPMS_t
+{
+    DPMS_ON,
+    DPMS_STANDBY,
+    DPMS_SUSPEND,
+    DPMS_OFF
+}
+DPMS_t;
+
+/*
+ * This function sets the DPMS state 
+ */
+void setDPMS(DPMS_t state);
+
+/* 
+ * This function gets the current power mode 
+ */
+unsigned long getPowerMode(void);
+
+/* 
+ * This function sets the current power mode
+ */
+void setPowerMode(unsigned long powerMode);
+
+/* 
+ * This function sets current gate 
+ */
+void setCurrentGate(unsigned long gate);
+
+/*
+ * This function enable/disable Bus Master
+ */
+void enableBusMaster(unsigned long enable);
+
+/* 
+ *	setPCIMasterBaseAddress
+ *		This function set the PCI Master Base Address (used by bus master or DMA).
+ *
+ *	Input:	
+ *		physicalSystemMemAddress	- System physical memory address which PCI
+ *									  Master Base Address to be set to.
+ *
+ *	Output:
+ *		The memory address to be set in the register.  
+ */
+unsigned long setPCIMasterBaseAddress(
+	unsigned long physicalSystemMemAddress
+);
+
+/*
+ * 	This function enable/disable PCI Slave Burst Write provided the CPU supports Write Combine.
+ *
+ *	Input:
+ *			enable		- Enable/Disable the PCI Slave Burst Write (0 = disable, 1 = enable)
+ */
+void enablePCISlaveBurstWrite(
+	unsigned long enable
+);
+
+/*
+ * 	This function enable/disable PCI Slave Burst Read provided the CPU supports it.
+ *
+ *	Input:
+ *			enable			- Enable/Disable the PCI Slave Burst Read (0 = disable, 1 = enable)
+ *			burstReadSize	- Burst Read Size in 32-words (valid values are 1, 2, 4, and 8)
+ */
+void enablePCISlaveBurstRead(
+	unsigned long enable,
+	unsigned long burstReadSize
+);
+
+/* 
+ * This function enable/disable the 2D engine.
+ */
+void enable2DEngine(unsigned long enable);
+
+/* 
+ * This function enable/disable the ZV Port 
+ */
+void enableZVPort(unsigned long enable);
+
+/* 
+ * This function enable/disable the DMA Engine
+ */
+void enableDMA(unsigned long enable);
+
+/* 
+ * This function enable/disable the GPIO Engine
+ */
+void enableGPIO(unsigned long enable);
+
+/* 
+ * This function enable/disable the PWM Engine
+ */
+void enablePWM(unsigned long enable);
+
+/* 
+ * This function enable/disable the I2C Engine
+ */
+void enableI2C(unsigned long enable);
+
+/* 
+ * This function enable/disable the SSP.
+ */
+void enableSSP(unsigned long enable);
+
+#endif /* _POWER_H_ */
diff --git a/drivers/gpu/drm/smi/ddk750/ddk750_regdc.h b/drivers/gpu/drm/smi/ddk750/ddk750_regdc.h
new file mode 100644
index 000000000000..07cc3e01a316
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk750/ddk750_regdc.h
@@ -0,0 +1,960 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2008 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  RegDC.h --- SMI DDK 
+*  This file contains the definitions for the Display Controller registers.
+* 
+*******************************************************************/
+
+/* Primary Graphics Control */
+
+#define PRIMARY_DISPLAY_CTRL                            0x080000
+#define PRIMARY_DISPLAY_CTRL_RESERVED_1_MASK            31:30
+#define PRIMARY_DISPLAY_CTRL_RESERVED_1_MASK_DISABLE    0
+#define PRIMARY_DISPLAY_CTRL_RESERVED_1_MASK_ENABLE     3
+#define PRIMARY_DISPLAY_CTRL_SELECT                     29:28
+#define PRIMARY_DISPLAY_CTRL_SELECT_PRIMARY             0
+#define PRIMARY_DISPLAY_CTRL_SELECT_VGA                 1
+#define PRIMARY_DISPLAY_CTRL_SELECT_SECONDARY           2
+#define PRIMARY_DISPLAY_CTRL_FPEN                       27:27
+#define PRIMARY_DISPLAY_CTRL_FPEN_LOW                   0
+#define PRIMARY_DISPLAY_CTRL_FPEN_HIGH                  1
+#define PRIMARY_DISPLAY_CTRL_VBIASEN                    26:26
+#define PRIMARY_DISPLAY_CTRL_VBIASEN_LOW                0
+#define PRIMARY_DISPLAY_CTRL_VBIASEN_HIGH               1
+#define PRIMARY_DISPLAY_CTRL_DATA                       25:25
+#define PRIMARY_DISPLAY_CTRL_DATA_DISABLE               0
+#define PRIMARY_DISPLAY_CTRL_DATA_ENABLE                1
+#define PRIMARY_DISPLAY_CTRL_FPVDDEN                    24:24
+#define PRIMARY_DISPLAY_CTRL_FPVDDEN_LOW                0
+#define PRIMARY_DISPLAY_CTRL_FPVDDEN_HIGH               1
+#define PRIMARY_DISPLAY_CTRL_RESERVED_2_MASK            23:20
+#define PRIMARY_DISPLAY_CTRL_RESERVED_2_MASK_DISABLE    0
+#define PRIMARY_DISPLAY_CTRL_RESERVED_2_MASK_ENABLE     15
+#define PRIMARY_DISPLAY_CTRL_DUAL_DISPLAY               19:19
+#define PRIMARY_DISPLAY_CTRL_DUAL_DISPLAY_DISABLE       0
+#define PRIMARY_DISPLAY_CTRL_DUAL_DISPLAY_ENABLE        1
+#define PRIMARY_DISPLAY_CTRL_DOUBLE_PIXEL               18:18
+#define PRIMARY_DISPLAY_CTRL_DOUBLE_PIXEL_DISABLE       0
+#define PRIMARY_DISPLAY_CTRL_DOUBLE_PIXEL_ENABLE        1
+#define PRIMARY_DISPLAY_CTRL_FIFO                       17:16
+#define PRIMARY_DISPLAY_CTRL_FIFO_1                     0
+#define PRIMARY_DISPLAY_CTRL_FIFO_3                     1
+#define PRIMARY_DISPLAY_CTRL_FIFO_7                     2
+#define PRIMARY_DISPLAY_CTRL_FIFO_11                    3
+#define PRIMARY_DISPLAY_CTRL_RESERVED_3_MASK            15:15
+#define PRIMARY_DISPLAY_CTRL_RESERVED_3_MASK_DISABLE    0
+#define PRIMARY_DISPLAY_CTRL_RESERVED_3_MASK_ENABLE     1
+#define PRIMARY_DISPLAY_CTRL_CLOCK_PHASE                14:14
+#define PRIMARY_DISPLAY_CTRL_CLOCK_PHASE_ACTIVE_HIGH    0
+#define PRIMARY_DISPLAY_CTRL_CLOCK_PHASE_ACTIVE_LOW     1
+#define PRIMARY_DISPLAY_CTRL_VSYNC_PHASE                13:13
+#define PRIMARY_DISPLAY_CTRL_VSYNC_PHASE_ACTIVE_HIGH    0
+#define PRIMARY_DISPLAY_CTRL_VSYNC_PHASE_ACTIVE_LOW     1
+#define PRIMARY_DISPLAY_CTRL_HSYNC_PHASE                12:12
+#define PRIMARY_DISPLAY_CTRL_HSYNC_PHASE_ACTIVE_HIGH    0
+#define PRIMARY_DISPLAY_CTRL_HSYNC_PHASE_ACTIVE_LOW     1
+#define PRIMARY_DISPLAY_CTRL_VSYNC                      11:11
+#define PRIMARY_DISPLAY_CTRL_VSYNC_ACTIVE_HIGH          0
+#define PRIMARY_DISPLAY_CTRL_VSYNC_ACTIVE_LOW           1
+#define PRIMARY_DISPLAY_CTRL_CAPTURE_TIMING             10:10
+#define PRIMARY_DISPLAY_CTRL_CAPTURE_TIMING_DISABLE     0
+#define PRIMARY_DISPLAY_CTRL_CAPTURE_TIMING_ENABLE      1
+#define PRIMARY_DISPLAY_CTRL_COLOR_KEY                  9:9
+#define PRIMARY_DISPLAY_CTRL_COLOR_KEY_DISABLE          0
+#define PRIMARY_DISPLAY_CTRL_COLOR_KEY_ENABLE           1
+#define PRIMARY_DISPLAY_CTRL_TIMING                     8:8
+#define PRIMARY_DISPLAY_CTRL_TIMING_DISABLE             0
+#define PRIMARY_DISPLAY_CTRL_TIMING_ENABLE              1
+#define PRIMARY_DISPLAY_CTRL_VERTICAL_PAN_DIR           7:7
+#define PRIMARY_DISPLAY_CTRL_VERTICAL_PAN_DIR_DOWN      0
+#define PRIMARY_DISPLAY_CTRL_VERTICAL_PAN_DIR_UP        1
+#define PRIMARY_DISPLAY_CTRL_VERTICAL_PAN               6:6
+#define PRIMARY_DISPLAY_CTRL_VERTICAL_PAN_DISABLE       0
+#define PRIMARY_DISPLAY_CTRL_VERTICAL_PAN_ENABLE        1
+#define PRIMARY_DISPLAY_CTRL_HORIZONTAL_PAN_DIR         5:5
+#define PRIMARY_DISPLAY_CTRL_HORIZONTAL_PAN_DIR_RIGHT   0
+#define PRIMARY_DISPLAY_CTRL_HORIZONTAL_PAN_DIR_LEFT    1
+#define PRIMARY_DISPLAY_CTRL_HORIZONTAL_PAN             4:4
+#define PRIMARY_DISPLAY_CTRL_HORIZONTAL_PAN_DISABLE     0
+#define PRIMARY_DISPLAY_CTRL_HORIZONTAL_PAN_ENABLE      1
+#define PRIMARY_DISPLAY_CTRL_GAMMA                      3:3
+#define PRIMARY_DISPLAY_CTRL_GAMMA_DISABLE              0
+#define PRIMARY_DISPLAY_CTRL_GAMMA_ENABLE               1
+#define PRIMARY_DISPLAY_CTRL_PLANE                      2:2
+#define PRIMARY_DISPLAY_CTRL_PLANE_DISABLE              0
+#define PRIMARY_DISPLAY_CTRL_PLANE_ENABLE               1
+#define PRIMARY_DISPLAY_CTRL_FORMAT                     1:0
+#define PRIMARY_DISPLAY_CTRL_FORMAT_8                   0
+#define PRIMARY_DISPLAY_CTRL_FORMAT_16                  1
+#define PRIMARY_DISPLAY_CTRL_FORMAT_32                  2
+
+#define PRIMARY_PAN_CTRL                                0x080004
+#define PRIMARY_PAN_CTRL_VERTICAL_PAN                   31:24
+#define PRIMARY_PAN_CTRL_VERTICAL_VSYNC                 21:16
+#define PRIMARY_PAN_CTRL_HORIZONTAL_PAN                 15:8
+#define PRIMARY_PAN_CTRL_HORIZONTAL_VSYNC               5:0
+
+#define PRIMARY_COLOR_KEY                               0x080008
+#define PRIMARY_COLOR_KEY_MASK                          31:16
+#define PRIMARY_COLOR_KEY_VALUE                         15:0
+
+#define PRIMARY_FB_ADDRESS                              0x08000C
+#define PRIMARY_FB_ADDRESS_STATUS                       31:31
+#define PRIMARY_FB_ADDRESS_STATUS_CURRENT               0
+#define PRIMARY_FB_ADDRESS_STATUS_PENDING               1
+#define PRIMARY_FB_ADDRESS_EXT                          27:27
+#define PRIMARY_FB_ADDRESS_EXT_LOCAL                    0
+#define PRIMARY_FB_ADDRESS_EXT_EXTERNAL                 1
+#define PRIMARY_FB_ADDRESS_ADDRESS                      25:0
+
+#define PRIMARY_FB_WIDTH                                0x080010
+#define PRIMARY_FB_WIDTH_WIDTH                          29:16
+#define PRIMARY_FB_WIDTH_OFFSET                         13:0
+
+#define PRIMARY_WINDOW_WIDTH                            0x080014
+#define PRIMARY_WINDOW_WIDTH_WIDTH                      27:16
+#define PRIMARY_WINDOW_WIDTH_X                          11:0
+
+#define PRIMARY_WINDOW_HEIGHT                           0x080018
+#define PRIMARY_WINDOW_HEIGHT_HEIGHT                    27:16
+#define PRIMARY_WINDOW_HEIGHT_Y                         11:0
+
+#define PRIMARY_PLANE_TL                                0x08001C
+#define PRIMARY_PLANE_TL_TOP                            26:16
+#define PRIMARY_PLANE_TL_LEFT                           10:0
+
+#define PRIMARY_PLANE_BR                                0x080020
+#define PRIMARY_PLANE_BR_BOTTOM                         26:16
+#define PRIMARY_PLANE_BR_RIGHT                          10:0
+
+#define PRIMARY_HORIZONTAL_TOTAL                        0x080024
+#define PRIMARY_HORIZONTAL_TOTAL_TOTAL                  27:16
+#define PRIMARY_HORIZONTAL_TOTAL_DISPLAY_END            11:0
+
+#define PRIMARY_HORIZONTAL_SYNC                         0x080028
+#define PRIMARY_HORIZONTAL_SYNC_WIDTH                   23:16
+#define PRIMARY_HORIZONTAL_SYNC_START                   11:0
+
+#define PRIMARY_VERTICAL_TOTAL                          0x08002C
+#define PRIMARY_VERTICAL_TOTAL_TOTAL                    26:16
+#define PRIMARY_VERTICAL_TOTAL_DISPLAY_END              10:0
+
+#define PRIMARY_VERTICAL_SYNC                           0x080030
+#define PRIMARY_VERTICAL_SYNC_HEIGHT                    21:16
+#define PRIMARY_VERTICAL_SYNC_START                     10:0
+
+#define PRIMARY_CURRENT_LINE                            0x080034
+#define PRIMARY_CURRENT_LINE_LINE                       10:0
+
+/* Video Control */
+
+#define VIDEO_DISPLAY_CTRL                              0x080040
+#define VIDEO_DISPLAY_CTRL_LINE_BUFFER                  18:18
+#define VIDEO_DISPLAY_CTRL_LINE_BUFFER_DISABLE          0
+#define VIDEO_DISPLAY_CTRL_LINE_BUFFER_ENABLE           1
+#define VIDEO_DISPLAY_CTRL_FIFO                         17:16
+#define VIDEO_DISPLAY_CTRL_FIFO_1                       0
+#define VIDEO_DISPLAY_CTRL_FIFO_3                       1
+#define VIDEO_DISPLAY_CTRL_FIFO_7                       2
+#define VIDEO_DISPLAY_CTRL_FIFO_11                      3
+#define VIDEO_DISPLAY_CTRL_BUFFER                       15:15
+#define VIDEO_DISPLAY_CTRL_BUFFER_0                     0
+#define VIDEO_DISPLAY_CTRL_BUFFER_1                     1
+#define VIDEO_DISPLAY_CTRL_CAPTURE                      14:14
+#define VIDEO_DISPLAY_CTRL_CAPTURE_DISABLE              0
+#define VIDEO_DISPLAY_CTRL_CAPTURE_ENABLE               1
+#define VIDEO_DISPLAY_CTRL_DOUBLE_BUFFER                13:13
+#define VIDEO_DISPLAY_CTRL_DOUBLE_BUFFER_DISABLE        0
+#define VIDEO_DISPLAY_CTRL_DOUBLE_BUFFER_ENABLE         1
+#define VIDEO_DISPLAY_CTRL_BYTE_SWAP                    12:12
+#define VIDEO_DISPLAY_CTRL_BYTE_SWAP_DISABLE            0
+#define VIDEO_DISPLAY_CTRL_BYTE_SWAP_ENABLE             1
+#define VIDEO_DISPLAY_CTRL_VERTICAL_SCALE               11:11
+#define VIDEO_DISPLAY_CTRL_VERTICAL_SCALE_NORMAL        0
+#define VIDEO_DISPLAY_CTRL_VERTICAL_SCALE_HALF          1
+#define VIDEO_DISPLAY_CTRL_HORIZONTAL_SCALE             10:10
+#define VIDEO_DISPLAY_CTRL_HORIZONTAL_SCALE_NORMAL      0
+#define VIDEO_DISPLAY_CTRL_HORIZONTAL_SCALE_HALF        1
+#define VIDEO_DISPLAY_CTRL_VERTICAL_MODE                9:9
+#define VIDEO_DISPLAY_CTRL_VERTICAL_MODE_REPLICATE      0
+#define VIDEO_DISPLAY_CTRL_VERTICAL_MODE_INTERPOLATE    1
+#define VIDEO_DISPLAY_CTRL_HORIZONTAL_MODE              8:8
+#define VIDEO_DISPLAY_CTRL_HORIZONTAL_MODE_REPLICATE    0
+#define VIDEO_DISPLAY_CTRL_HORIZONTAL_MODE_INTERPOLATE  1
+#define VIDEO_DISPLAY_CTRL_PIXEL                        7:4
+#define VIDEO_DISPLAY_CTRL_GAMMA                        3:3
+#define VIDEO_DISPLAY_CTRL_GAMMA_DISABLE                0
+#define VIDEO_DISPLAY_CTRL_GAMMA_ENABLE                 1
+#define VIDEO_DISPLAY_CTRL_PLANE                        2:2
+#define VIDEO_DISPLAY_CTRL_PLANE_DISABLE                0
+#define VIDEO_DISPLAY_CTRL_PLANE_ENABLE                 1
+#define VIDEO_DISPLAY_CTRL_FORMAT                       1:0
+#define VIDEO_DISPLAY_CTRL_FORMAT_8                     0
+#define VIDEO_DISPLAY_CTRL_FORMAT_16                    1
+#define VIDEO_DISPLAY_CTRL_FORMAT_32                    2
+#define VIDEO_DISPLAY_CTRL_FORMAT_YUV                   3
+
+#define VIDEO_FB_0_ADDRESS                              0x080044
+#define VIDEO_FB_0_ADDRESS_STATUS                       31:31
+#define VIDEO_FB_0_ADDRESS_STATUS_CURRENT               0
+#define VIDEO_FB_0_ADDRESS_STATUS_PENDING               1
+#define VIDEO_FB_0_ADDRESS_EXT                          27:27
+#define VIDEO_FB_0_ADDRESS_EXT_LOCAL                    0
+#define VIDEO_FB_0_ADDRESS_EXT_EXTERNAL                 1
+#define VIDEO_FB_0_ADDRESS_ADDRESS                      25:0
+
+#define VIDEO_FB_WIDTH                                  0x080048
+#define VIDEO_FB_WIDTH_WIDTH                            29:16
+#define VIDEO_FB_WIDTH_OFFSET                           13:0
+
+#define VIDEO_FB_0_LAST_ADDRESS                         0x08004C
+#define VIDEO_FB_0_LAST_ADDRESS_EXT                     27:27
+#define VIDEO_FB_0_LAST_ADDRESS_EXT_LOCAL               0
+#define VIDEO_FB_0_LAST_ADDRESS_EXT_EXTERNAL            1
+#define VIDEO_FB_0_LAST_ADDRESS_ADDRESS                 25:0
+
+#define VIDEO_PLANE_TL                                  0x080050
+#define VIDEO_PLANE_TL_TOP                              26:16
+#define VIDEO_PLANE_TL_LEFT                             10:0
+
+#define VIDEO_PLANE_BR                                  0x080054
+#define VIDEO_PLANE_BR_BOTTOM                           26:16
+#define VIDEO_PLANE_BR_RIGHT                            10:0
+
+#define VIDEO_SCALE                                     0x080058
+#define VIDEO_SCALE_VERTICAL_MODE                       31:31
+#define VIDEO_SCALE_VERTICAL_MODE_EXPAND                0
+#define VIDEO_SCALE_VERTICAL_MODE_SHRINK                1
+#define VIDEO_SCALE_VERTICAL_SCALE                      27:16
+#define VIDEO_SCALE_HORIZONTAL_MODE                     15:15
+#define VIDEO_SCALE_HORIZONTAL_MODE_EXPAND              0
+#define VIDEO_SCALE_HORIZONTAL_MODE_SHRINK              1
+#define VIDEO_SCALE_HORIZONTAL_SCALE                    11:0
+
+#define VIDEO_INITIAL_SCALE                             0x08005C
+#define VIDEO_INITIAL_SCALE_FB_1                        27:16
+#define VIDEO_INITIAL_SCALE_FB_0                        11:0
+
+#define VIDEO_YUV_CONSTANTS                             0x080060
+#define VIDEO_YUV_CONSTANTS_Y                           31:24
+#define VIDEO_YUV_CONSTANTS_R                           23:16
+#define VIDEO_YUV_CONSTANTS_G                           15:8
+#define VIDEO_YUV_CONSTANTS_B                           7:0
+
+#define VIDEO_FB_1_ADDRESS                              0x080064
+#define VIDEO_FB_1_ADDRESS_STATUS                       31:31
+#define VIDEO_FB_1_ADDRESS_STATUS_CURRENT               0
+#define VIDEO_FB_1_ADDRESS_STATUS_PENDING               1
+#define VIDEO_FB_1_ADDRESS_EXT                          27:27
+#define VIDEO_FB_1_ADDRESS_EXT_LOCAL                    0
+#define VIDEO_FB_1_ADDRESS_EXT_EXTERNAL                 1
+#define VIDEO_FB_1_ADDRESS_ADDRESS                      25:0
+
+#define VIDEO_FB_1_LAST_ADDRESS                         0x080068
+#define VIDEO_FB_1_LAST_ADDRESS_EXT                     27:27
+#define VIDEO_FB_1_LAST_ADDRESS_EXT_LOCAL               0
+#define VIDEO_FB_1_LAST_ADDRESS_EXT_EXTERNAL            1
+#define VIDEO_FB_1_LAST_ADDRESS_ADDRESS                 25:0
+
+#define VIDEO_EDGE_DETECTION                            0x080074
+#define VIDEO_EDGE_DETECTION_DETECT                     24:24
+#define VIDEO_EDGE_DETECTION_DETECT_DISABLE             0
+#define VIDEO_EDGE_DETECTION_DETECT_ENABLE              1
+#define VIDEO_EDGE_DETECTION_VALUE                      9:0
+
+/* Video Alpha Control */
+
+#define VIDEO_ALPHA_DISPLAY_CTRL                        0x080080
+#define VIDEO_ALPHA_DISPLAY_CTRL_SELECT                 28:28
+#define VIDEO_ALPHA_DISPLAY_CTRL_SELECT_PER_PIXEL       0
+#define VIDEO_ALPHA_DISPLAY_CTRL_SELECT_ALPHA           1
+#define VIDEO_ALPHA_DISPLAY_CTRL_ALPHA                  27:24
+#define VIDEO_ALPHA_DISPLAY_CTRL_FIFO                   17:16
+#define VIDEO_ALPHA_DISPLAY_CTRL_FIFO_1                 0
+#define VIDEO_ALPHA_DISPLAY_CTRL_FIFO_3                 1
+#define VIDEO_ALPHA_DISPLAY_CTRL_FIFO_7                 2
+#define VIDEO_ALPHA_DISPLAY_CTRL_FIFO_11                3
+#define VIDEO_ALPHA_DISPLAY_CTRL_VERT_SCALE             11:11
+#define VIDEO_ALPHA_DISPLAY_CTRL_VERT_SCALE_NORMAL      0
+#define VIDEO_ALPHA_DISPLAY_CTRL_VERT_SCALE_HALF        1
+#define VIDEO_ALPHA_DISPLAY_CTRL_HORZ_SCALE             10:10
+#define VIDEO_ALPHA_DISPLAY_CTRL_HORZ_SCALE_NORMAL      0
+#define VIDEO_ALPHA_DISPLAY_CTRL_HORZ_SCALE_HALF        1
+#define VIDEO_ALPHA_DISPLAY_CTRL_VERT_MODE              9:9
+#define VIDEO_ALPHA_DISPLAY_CTRL_VERT_MODE_REPLICATE    0
+#define VIDEO_ALPHA_DISPLAY_CTRL_VERT_MODE_INTERPOLATE  1
+#define VIDEO_ALPHA_DISPLAY_CTRL_HORZ_MODE              8:8
+#define VIDEO_ALPHA_DISPLAY_CTRL_HORZ_MODE_REPLICATE    0
+#define VIDEO_ALPHA_DISPLAY_CTRL_HORZ_MODE_INTERPOLATE  1
+#define VIDEO_ALPHA_DISPLAY_CTRL_PIXEL                  7:4
+#define VIDEO_ALPHA_DISPLAY_CTRL_CHROMA_KEY             3:3
+#define VIDEO_ALPHA_DISPLAY_CTRL_CHROMA_KEY_DISABLE     0
+#define VIDEO_ALPHA_DISPLAY_CTRL_CHROMA_KEY_ENABLE      1
+#define VIDEO_ALPHA_DISPLAY_CTRL_PLANE                  2:2
+#define VIDEO_ALPHA_DISPLAY_CTRL_PLANE_DISABLE          0
+#define VIDEO_ALPHA_DISPLAY_CTRL_PLANE_ENABLE           1
+#define VIDEO_ALPHA_DISPLAY_CTRL_FORMAT                 1:0
+#define VIDEO_ALPHA_DISPLAY_CTRL_FORMAT_8               0
+#define VIDEO_ALPHA_DISPLAY_CTRL_FORMAT_16              1
+#define VIDEO_ALPHA_DISPLAY_CTRL_FORMAT_ALPHA_4_4       2
+#define VIDEO_ALPHA_DISPLAY_CTRL_FORMAT_ALPHA_4_4_4_4   3
+
+#define VIDEO_ALPHA_FB_ADDRESS                          0x080084
+#define VIDEO_ALPHA_FB_ADDRESS_STATUS                   31:31
+#define VIDEO_ALPHA_FB_ADDRESS_STATUS_CURRENT           0
+#define VIDEO_ALPHA_FB_ADDRESS_STATUS_PENDING           1
+#define VIDEO_ALPHA_FB_ADDRESS_EXT                      27:27
+#define VIDEO_ALPHA_FB_ADDRESS_EXT_LOCAL                0
+#define VIDEO_ALPHA_FB_ADDRESS_EXT_EXTERNAL             1
+#define VIDEO_ALPHA_FB_ADDRESS_ADDRESS                  25:0
+
+#define VIDEO_ALPHA_FB_WIDTH                            0x080088
+#define VIDEO_ALPHA_FB_WIDTH_WIDTH                      29:16
+#define VIDEO_ALPHA_FB_WIDTH_OFFSET                     13:0
+
+#define VIDEO_ALPHA_FB_LAST_ADDRESS                     0x08008C
+#define VIDEO_ALPHA_FB_LAST_ADDRESS_EXT                 27:27
+#define VIDEO_ALPHA_FB_LAST_ADDRESS_EXT_LOCAL           0
+#define VIDEO_ALPHA_FB_LAST_ADDRESS_EXT_EXTERNAL        1
+#define VIDEO_ALPHA_FB_LAST_ADDRESS_ADDRESS             25:0
+
+#define VIDEO_ALPHA_PLANE_TL                            0x080090
+#define VIDEO_ALPHA_PLANE_TL_TOP                        26:16
+#define VIDEO_ALPHA_PLANE_TL_LEFT                       10:0
+
+#define VIDEO_ALPHA_PLANE_BR                            0x080094
+#define VIDEO_ALPHA_PLANE_BR_BOTTOM                     26:16
+#define VIDEO_ALPHA_PLANE_BR_RIGHT                      10:0
+
+#define VIDEO_ALPHA_SCALE                               0x080098
+#define VIDEO_ALPHA_SCALE_VERTICAL_MODE                 31:31
+#define VIDEO_ALPHA_SCALE_VERTICAL_MODE_EXPAND          0
+#define VIDEO_ALPHA_SCALE_VERTICAL_MODE_SHRINK          1
+#define VIDEO_ALPHA_SCALE_VERTICAL_SCALE                27:16
+#define VIDEO_ALPHA_SCALE_HORIZONTAL_MODE               15:15
+#define VIDEO_ALPHA_SCALE_HORIZONTAL_MODE_EXPAND        0
+#define VIDEO_ALPHA_SCALE_HORIZONTAL_MODE_SHRINK        1
+#define VIDEO_ALPHA_SCALE_HORIZONTAL_SCALE              11:0
+
+#define VIDEO_ALPHA_INITIAL_SCALE                       0x08009C
+#define VIDEO_ALPHA_INITIAL_SCALE_VERTICAL              27:16
+#define VIDEO_ALPHA_INITIAL_SCALE_HORIZONTAL            11:0
+
+#define VIDEO_ALPHA_CHROMA_KEY                          0x0800A0
+#define VIDEO_ALPHA_CHROMA_KEY_MASK                     31:16
+#define VIDEO_ALPHA_CHROMA_KEY_VALUE                    15:0
+
+#define VIDEO_ALPHA_COLOR_LOOKUP_01                     0x0800A4
+#define VIDEO_ALPHA_COLOR_LOOKUP_01_1                   31:16
+#define VIDEO_ALPHA_COLOR_LOOKUP_01_1_RED               31:27
+#define VIDEO_ALPHA_COLOR_LOOKUP_01_1_GREEN             26:21
+#define VIDEO_ALPHA_COLOR_LOOKUP_01_1_BLUE              20:16
+#define VIDEO_ALPHA_COLOR_LOOKUP_01_0                   15:0
+#define VIDEO_ALPHA_COLOR_LOOKUP_01_0_RED               15:11
+#define VIDEO_ALPHA_COLOR_LOOKUP_01_0_GREEN             10:5
+#define VIDEO_ALPHA_COLOR_LOOKUP_01_0_BLUE              4:0
+
+#define VIDEO_ALPHA_COLOR_LOOKUP_23                     0x0800A8
+#define VIDEO_ALPHA_COLOR_LOOKUP_23_3                   31:16
+#define VIDEO_ALPHA_COLOR_LOOKUP_23_3_RED               31:27
+#define VIDEO_ALPHA_COLOR_LOOKUP_23_3_GREEN             26:21
+#define VIDEO_ALPHA_COLOR_LOOKUP_23_3_BLUE              20:16
+#define VIDEO_ALPHA_COLOR_LOOKUP_23_2                   15:0
+#define VIDEO_ALPHA_COLOR_LOOKUP_23_2_RED               15:11
+#define VIDEO_ALPHA_COLOR_LOOKUP_23_2_GREEN             10:5
+#define VIDEO_ALPHA_COLOR_LOOKUP_23_2_BLUE              4:0
+
+#define VIDEO_ALPHA_COLOR_LOOKUP_45                     0x0800AC
+#define VIDEO_ALPHA_COLOR_LOOKUP_45_5                   31:16
+#define VIDEO_ALPHA_COLOR_LOOKUP_45_5_RED               31:27
+#define VIDEO_ALPHA_COLOR_LOOKUP_45_5_GREEN             26:21
+#define VIDEO_ALPHA_COLOR_LOOKUP_45_5_BLUE              20:16
+#define VIDEO_ALPHA_COLOR_LOOKUP_45_4                   15:0
+#define VIDEO_ALPHA_COLOR_LOOKUP_45_4_RED               15:11
+#define VIDEO_ALPHA_COLOR_LOOKUP_45_4_GREEN             10:5
+#define VIDEO_ALPHA_COLOR_LOOKUP_45_4_BLUE              4:0
+
+#define VIDEO_ALPHA_COLOR_LOOKUP_67                     0x0800B0
+#define VIDEO_ALPHA_COLOR_LOOKUP_67_7                   31:16
+#define VIDEO_ALPHA_COLOR_LOOKUP_67_7_RED               31:27
+#define VIDEO_ALPHA_COLOR_LOOKUP_67_7_GREEN             26:21
+#define VIDEO_ALPHA_COLOR_LOOKUP_67_7_BLUE              20:16
+#define VIDEO_ALPHA_COLOR_LOOKUP_67_6                   15:0
+#define VIDEO_ALPHA_COLOR_LOOKUP_67_6_RED               15:11
+#define VIDEO_ALPHA_COLOR_LOOKUP_67_6_GREEN             10:5
+#define VIDEO_ALPHA_COLOR_LOOKUP_67_6_BLUE              4:0
+
+#define VIDEO_ALPHA_COLOR_LOOKUP_89                     0x0800B4
+#define VIDEO_ALPHA_COLOR_LOOKUP_89_9                   31:16
+#define VIDEO_ALPHA_COLOR_LOOKUP_89_9_RED               31:27
+#define VIDEO_ALPHA_COLOR_LOOKUP_89_9_GREEN             26:21
+#define VIDEO_ALPHA_COLOR_LOOKUP_89_9_BLUE              20:16
+#define VIDEO_ALPHA_COLOR_LOOKUP_89_8                   15:0
+#define VIDEO_ALPHA_COLOR_LOOKUP_89_8_RED               15:11
+#define VIDEO_ALPHA_COLOR_LOOKUP_89_8_GREEN             10:5
+#define VIDEO_ALPHA_COLOR_LOOKUP_89_8_BLUE              4:0
+
+#define VIDEO_ALPHA_COLOR_LOOKUP_AB                     0x0800B8
+#define VIDEO_ALPHA_COLOR_LOOKUP_AB_B                   31:16
+#define VIDEO_ALPHA_COLOR_LOOKUP_AB_B_RED               31:27
+#define VIDEO_ALPHA_COLOR_LOOKUP_AB_B_GREEN             26:21
+#define VIDEO_ALPHA_COLOR_LOOKUP_AB_B_BLUE              20:16
+#define VIDEO_ALPHA_COLOR_LOOKUP_AB_A                   15:0
+#define VIDEO_ALPHA_COLOR_LOOKUP_AB_A_RED               15:11
+#define VIDEO_ALPHA_COLOR_LOOKUP_AB_A_GREEN             10:5
+#define VIDEO_ALPHA_COLOR_LOOKUP_AB_A_BLUE              4:0
+
+#define VIDEO_ALPHA_COLOR_LOOKUP_CD                     0x0800BC
+#define VIDEO_ALPHA_COLOR_LOOKUP_CD_D                   31:16
+#define VIDEO_ALPHA_COLOR_LOOKUP_CD_D_RED               31:27
+#define VIDEO_ALPHA_COLOR_LOOKUP_CD_D_GREEN             26:21
+#define VIDEO_ALPHA_COLOR_LOOKUP_CD_D_BLUE              20:16
+#define VIDEO_ALPHA_COLOR_LOOKUP_CD_C                   15:0
+#define VIDEO_ALPHA_COLOR_LOOKUP_CD_C_RED               15:11
+#define VIDEO_ALPHA_COLOR_LOOKUP_CD_C_GREEN             10:5
+#define VIDEO_ALPHA_COLOR_LOOKUP_CD_C_BLUE              4:0
+
+#define VIDEO_ALPHA_COLOR_LOOKUP_EF                     0x0800C0
+#define VIDEO_ALPHA_COLOR_LOOKUP_EF_F                   31:16
+#define VIDEO_ALPHA_COLOR_LOOKUP_EF_F_RED               31:27
+#define VIDEO_ALPHA_COLOR_LOOKUP_EF_F_GREEN             26:21
+#define VIDEO_ALPHA_COLOR_LOOKUP_EF_F_BLUE              20:16
+#define VIDEO_ALPHA_COLOR_LOOKUP_EF_E                   15:0
+#define VIDEO_ALPHA_COLOR_LOOKUP_EF_E_RED               15:11
+#define VIDEO_ALPHA_COLOR_LOOKUP_EF_E_GREEN             10:5
+#define VIDEO_ALPHA_COLOR_LOOKUP_EF_E_BLUE              4:0
+
+/* Primary Cursor Control */
+
+#define PRIMARY_HWC_ADDRESS                             0x0800F0
+#define PRIMARY_HWC_ADDRESS_ENABLE                      31:31
+#define PRIMARY_HWC_ADDRESS_ENABLE_DISABLE              0
+#define PRIMARY_HWC_ADDRESS_ENABLE_ENABLE               1
+#define PRIMARY_HWC_ADDRESS_MODE                        30:30
+#define PRIMARY_HWC_ADDRESS_MODE_MONO                   0
+#define PRIMARY_HWC_ADDRESS_MODE_COLOR                  1
+#define PRIMARY_HWC_ADDRESS_EXT                         27:27
+#define PRIMARY_HWC_ADDRESS_EXT_LOCAL                   0
+#define PRIMARY_HWC_ADDRESS_EXT_EXTERNAL                1
+#define PRIMARY_HWC_ADDRESS_ADDRESS                     25:0
+
+#define PRIMARY_HWC_LOCATION                            0x0800F4
+#define PRIMARY_HWC_LOCATION_TOP                        27:27
+#define PRIMARY_HWC_LOCATION_TOP_INSIDE                 0
+#define PRIMARY_HWC_LOCATION_TOP_OUTSIDE                1
+#define PRIMARY_HWC_LOCATION_Y                          26:16
+#define PRIMARY_HWC_LOCATION_LEFT                       11:11
+#define PRIMARY_HWC_LOCATION_LEFT_INSIDE                0
+#define PRIMARY_HWC_LOCATION_LEFT_OUTSIDE               1
+#define PRIMARY_HWC_LOCATION_X                          10:0
+
+#define PRIMARY_HWC_COLOR_12                            0x0800F8
+#define PRIMARY_HWC_COLOR_12_2_RGB565                   31:16
+#define PRIMARY_HWC_COLOR_12_1_RGB565                   15:0
+
+#define PRIMARY_HWC_COLOR_3                             0x0800FC
+#define PRIMARY_HWC_COLOR_3_RGB565                      15:0
+
+/* Alpha Control */
+
+#define ALPHA_DISPLAY_CTRL                              0x080100
+#define ALPHA_DISPLAY_CTRL_SELECT                       28:28
+#define ALPHA_DISPLAY_CTRL_SELECT_PER_PIXEL             0
+#define ALPHA_DISPLAY_CTRL_SELECT_ALPHA                 1
+#define ALPHA_DISPLAY_CTRL_ALPHA                        27:24
+#define ALPHA_DISPLAY_CTRL_FIFO                         17:16
+#define ALPHA_DISPLAY_CTRL_FIFO_1                       0
+#define ALPHA_DISPLAY_CTRL_FIFO_3                       1
+#define ALPHA_DISPLAY_CTRL_FIFO_7                       2
+#define ALPHA_DISPLAY_CTRL_FIFO_11                      3
+#define ALPHA_DISPLAY_CTRL_PIXEL                        7:4
+#define ALPHA_DISPLAY_CTRL_CHROMA_KEY                   3:3
+#define ALPHA_DISPLAY_CTRL_CHROMA_KEY_DISABLE           0
+#define ALPHA_DISPLAY_CTRL_CHROMA_KEY_ENABLE            1
+#define ALPHA_DISPLAY_CTRL_PLANE                        2:2
+#define ALPHA_DISPLAY_CTRL_PLANE_DISABLE                0
+#define ALPHA_DISPLAY_CTRL_PLANE_ENABLE                 1
+#define ALPHA_DISPLAY_CTRL_FORMAT                       1:0
+#define ALPHA_DISPLAY_CTRL_FORMAT_16                    1
+#define ALPHA_DISPLAY_CTRL_FORMAT_ALPHA_4_4             2
+#define ALPHA_DISPLAY_CTRL_FORMAT_ALPHA_4_4_4_4         3
+
+#define ALPHA_FB_ADDRESS                                0x080104
+#define ALPHA_FB_ADDRESS_STATUS                         31:31
+#define ALPHA_FB_ADDRESS_STATUS_CURRENT                 0
+#define ALPHA_FB_ADDRESS_STATUS_PENDING                 1
+#define ALPHA_FB_ADDRESS_EXT                            27:27
+#define ALPHA_FB_ADDRESS_EXT_LOCAL                      0
+#define ALPHA_FB_ADDRESS_EXT_EXTERNAL                   1
+#define ALPHA_FB_ADDRESS_ADDRESS                        25:0
+
+#define ALPHA_FB_WIDTH                                  0x080108
+#define ALPHA_FB_WIDTH_WIDTH                            29:16
+#define ALPHA_FB_WIDTH_OFFSET                           13:0
+
+#define ALPHA_PLANE_TL                                  0x08010C
+#define ALPHA_PLANE_TL_TOP                              26:16
+#define ALPHA_PLANE_TL_LEFT                             10:0
+
+#define ALPHA_PLANE_BR                                  0x080110
+#define ALPHA_PLANE_BR_BOTTOM                           26:16
+#define ALPHA_PLANE_BR_RIGHT                            10:0
+
+#define ALPHA_CHROMA_KEY                                0x080114
+#define ALPHA_CHROMA_KEY_MASK                           31:16
+#define ALPHA_CHROMA_KEY_VALUE                          15:0
+
+#define ALPHA_COLOR_LOOKUP_01                           0x080118
+#define ALPHA_COLOR_LOOKUP_01_1                         31:16
+#define ALPHA_COLOR_LOOKUP_01_1_RED                     31:27
+#define ALPHA_COLOR_LOOKUP_01_1_GREEN                   26:21
+#define ALPHA_COLOR_LOOKUP_01_1_BLUE                    20:16
+#define ALPHA_COLOR_LOOKUP_01_0                         15:0
+#define ALPHA_COLOR_LOOKUP_01_0_RED                     15:11
+#define ALPHA_COLOR_LOOKUP_01_0_GREEN                   10:5
+#define ALPHA_COLOR_LOOKUP_01_0_BLUE                    4:0
+
+#define ALPHA_COLOR_LOOKUP_23                           0x08011C
+#define ALPHA_COLOR_LOOKUP_23_3                         31:16
+#define ALPHA_COLOR_LOOKUP_23_3_RED                     31:27
+#define ALPHA_COLOR_LOOKUP_23_3_GREEN                   26:21
+#define ALPHA_COLOR_LOOKUP_23_3_BLUE                    20:16
+#define ALPHA_COLOR_LOOKUP_23_2                         15:0
+#define ALPHA_COLOR_LOOKUP_23_2_RED                     15:11
+#define ALPHA_COLOR_LOOKUP_23_2_GREEN                   10:5
+#define ALPHA_COLOR_LOOKUP_23_2_BLUE                    4:0
+
+#define ALPHA_COLOR_LOOKUP_45                           0x080120
+#define ALPHA_COLOR_LOOKUP_45_5                         31:16
+#define ALPHA_COLOR_LOOKUP_45_5_RED                     31:27
+#define ALPHA_COLOR_LOOKUP_45_5_GREEN                   26:21
+#define ALPHA_COLOR_LOOKUP_45_5_BLUE                    20:16
+#define ALPHA_COLOR_LOOKUP_45_4                         15:0
+#define ALPHA_COLOR_LOOKUP_45_4_RED                     15:11
+#define ALPHA_COLOR_LOOKUP_45_4_GREEN                   10:5
+#define ALPHA_COLOR_LOOKUP_45_4_BLUE                    4:0
+
+#define ALPHA_COLOR_LOOKUP_67                           0x080124
+#define ALPHA_COLOR_LOOKUP_67_7                         31:16
+#define ALPHA_COLOR_LOOKUP_67_7_RED                     31:27
+#define ALPHA_COLOR_LOOKUP_67_7_GREEN                   26:21
+#define ALPHA_COLOR_LOOKUP_67_7_BLUE                    20:16
+#define ALPHA_COLOR_LOOKUP_67_6                         15:0
+#define ALPHA_COLOR_LOOKUP_67_6_RED                     15:11
+#define ALPHA_COLOR_LOOKUP_67_6_GREEN                   10:5
+#define ALPHA_COLOR_LOOKUP_67_6_BLUE                    4:0
+
+#define ALPHA_COLOR_LOOKUP_89                           0x080128
+#define ALPHA_COLOR_LOOKUP_89_9                         31:16
+#define ALPHA_COLOR_LOOKUP_89_9_RED                     31:27
+#define ALPHA_COLOR_LOOKUP_89_9_GREEN                   26:21
+#define ALPHA_COLOR_LOOKUP_89_9_BLUE                    20:16
+#define ALPHA_COLOR_LOOKUP_89_8                         15:0
+#define ALPHA_COLOR_LOOKUP_89_8_RED                     15:11
+#define ALPHA_COLOR_LOOKUP_89_8_GREEN                   10:5
+#define ALPHA_COLOR_LOOKUP_89_8_BLUE                    4:0
+
+#define ALPHA_COLOR_LOOKUP_AB                           0x08012C
+#define ALPHA_COLOR_LOOKUP_AB_B                         31:16
+#define ALPHA_COLOR_LOOKUP_AB_B_RED                     31:27
+#define ALPHA_COLOR_LOOKUP_AB_B_GREEN                   26:21
+#define ALPHA_COLOR_LOOKUP_AB_B_BLUE                    20:16
+#define ALPHA_COLOR_LOOKUP_AB_A                         15:0
+#define ALPHA_COLOR_LOOKUP_AB_A_RED                     15:11
+#define ALPHA_COLOR_LOOKUP_AB_A_GREEN                   10:5
+#define ALPHA_COLOR_LOOKUP_AB_A_BLUE                    4:0
+
+#define ALPHA_COLOR_LOOKUP_CD                           0x080130
+#define ALPHA_COLOR_LOOKUP_CD_D                         31:16
+#define ALPHA_COLOR_LOOKUP_CD_D_RED                     31:27
+#define ALPHA_COLOR_LOOKUP_CD_D_GREEN                   26:21
+#define ALPHA_COLOR_LOOKUP_CD_D_BLUE                    20:16
+#define ALPHA_COLOR_LOOKUP_CD_C                         15:0
+#define ALPHA_COLOR_LOOKUP_CD_C_RED                     15:11
+#define ALPHA_COLOR_LOOKUP_CD_C_GREEN                   10:5
+#define ALPHA_COLOR_LOOKUP_CD_C_BLUE                    4:0
+
+#define ALPHA_COLOR_LOOKUP_EF                           0x080134
+#define ALPHA_COLOR_LOOKUP_EF_F                         31:16
+#define ALPHA_COLOR_LOOKUP_EF_F_RED                     31:27
+#define ALPHA_COLOR_LOOKUP_EF_F_GREEN                   26:21
+#define ALPHA_COLOR_LOOKUP_EF_F_BLUE                    20:16
+#define ALPHA_COLOR_LOOKUP_EF_E                         15:0
+#define ALPHA_COLOR_LOOKUP_EF_E_RED                     15:11
+#define ALPHA_COLOR_LOOKUP_EF_E_GREEN                   10:5
+#define ALPHA_COLOR_LOOKUP_EF_E_BLUE                    4:0
+
+/* Secondary Graphics Control */
+
+#define SECONDARY_DISPLAY_CTRL                              0x080200
+
+/* SM750 and SM718 definition */
+#define SECONDARY_DISPLAY_CTRL_RESERVED_1_MASK              31:27
+#define SECONDARY_DISPLAY_CTRL_RESERVED_1_MASK_DISABLE      0
+#define SECONDARY_DISPLAY_CTRL_RESERVED_1_MASK_ENABLE       0x1F
+/* SM750LE definition */
+#define SECONDARY_DISPLAY_CTRL_DPMS                         31:30
+#define SECONDARY_DISPLAY_CTRL_DPMS_0                       0
+#define SECONDARY_DISPLAY_CTRL_DPMS_1                       1
+#define SECONDARY_DISPLAY_CTRL_DPMS_2                       2
+#define SECONDARY_DISPLAY_CTRL_DPMS_3                       3
+#define SECONDARY_DISPLAY_CTRL_CLK                          29:27
+#define SECONDARY_DISPLAY_CTRL_CLK_PLL25                    0
+#define SECONDARY_DISPLAY_CTRL_CLK_PLL41                    1
+#define SECONDARY_DISPLAY_CTRL_CLK_PLL62                    2
+#define SECONDARY_DISPLAY_CTRL_CLK_PLL65                    3
+#define SECONDARY_DISPLAY_CTRL_CLK_PLL74                    4
+#define SECONDARY_DISPLAY_CTRL_CLK_PLL80                    5
+#define SECONDARY_DISPLAY_CTRL_CLK_PLL108                   6
+#define SECONDARY_DISPLAY_CTRL_CLK_RESERVED                 7
+#define SECONDARY_DISPLAY_CTRL_SHIFT_VGA_DAC                26:26
+#define SECONDARY_DISPLAY_CTRL_SHIFT_VGA_DAC_DISABLE        1
+#define SECONDARY_DISPLAY_CTRL_SHIFT_VGA_DAC_ENABLE         0
+
+/* SM750 and SM718 definition */
+#define SECONDARY_DISPLAY_CTRL_RESERVED_2_MASK              25:24
+#define SECONDARY_DISPLAY_CTRL_RESERVED_2_MASK_DISABLE      0
+#define SECONDARY_DISPLAY_CTRL_RESERVED_2_MASK_ENABLE       3
+
+/* SM750LE definition */
+#define SECONDARY_DISPLAY_CTRL_CRTSELECT                    25:25
+#define SECONDARY_DISPLAY_CTRL_CRTSELECT_VGA                0
+#define SECONDARY_DISPLAY_CTRL_CRTSELECT_CRT                1
+#define SECONDARY_DISPLAY_CTRL_RGBBIT                       24:24
+#define SECONDARY_DISPLAY_CTRL_RGBBIT_24BIT                 0
+#define SECONDARY_DISPLAY_CTRL_RGBBIT_12BIT                 1
+
+#define SECONDARY_DISPLAY_CTRL_LOCK_TIMING                  23:23
+#define SECONDARY_DISPLAY_CTRL_LOCK_TIMING_DISABLE          0
+#define SECONDARY_DISPLAY_CTRL_LOCK_TIMING_ENABLE           1
+#define SECONDARY_DISPLAY_CTRL_EXPANSION                    22:22
+#define SECONDARY_DISPLAY_CTRL_EXPANSION_DISABLE            0
+#define SECONDARY_DISPLAY_CTRL_EXPANSION_ENABLE             1
+#define SECONDARY_DISPLAY_CTRL_VERTICAL_MODE                21:21
+#define SECONDARY_DISPLAY_CTRL_VERTICAL_MODE_REPLICATE      0
+#define SECONDARY_DISPLAY_CTRL_VERTICAL_MODE_INTERPOLATE    1
+#define SECONDARY_DISPLAY_CTRL_HORIZONTAL_MODE              20:20
+#define SECONDARY_DISPLAY_CTRL_HORIZONTAL_MODE_REPLICATE    0
+#define SECONDARY_DISPLAY_CTRL_HORIZONTAL_MODE_INTERPOLATE  1
+#define SECONDARY_DISPLAY_CTRL_SELECT                       19:18
+#define SECONDARY_DISPLAY_CTRL_SELECT_PRIMARY               0
+#define SECONDARY_DISPLAY_CTRL_SELECT_VGA                   1
+#define SECONDARY_DISPLAY_CTRL_SELECT_SECONDARY             2
+#define SECONDARY_DISPLAY_CTRL_FIFO                         17:16
+#define SECONDARY_DISPLAY_CTRL_FIFO_1                       0
+#define SECONDARY_DISPLAY_CTRL_FIFO_3                       1
+#define SECONDARY_DISPLAY_CTRL_FIFO_7                       2
+#define SECONDARY_DISPLAY_CTRL_FIFO_11                      3
+#define SECONDARY_DISPLAY_CTRL_RESERVED_3_MASK              15:15
+#define SECONDARY_DISPLAY_CTRL_RESERVED_3_MASK_DISABLE      0
+#define SECONDARY_DISPLAY_CTRL_RESERVED_3_MASK_ENABLE       1
+#define SECONDARY_DISPLAY_CTRL_CLOCK_PHASE                  14:14
+#define SECONDARY_DISPLAY_CTRL_CLOCK_PHASE_ACTIVE_HIGH      0
+#define SECONDARY_DISPLAY_CTRL_CLOCK_PHASE_ACTIVE_LOW       1
+#define SECONDARY_DISPLAY_CTRL_VSYNC_PHASE                  13:13
+#define SECONDARY_DISPLAY_CTRL_VSYNC_PHASE_ACTIVE_HIGH      0
+#define SECONDARY_DISPLAY_CTRL_VSYNC_PHASE_ACTIVE_LOW       1
+#define SECONDARY_DISPLAY_CTRL_HSYNC_PHASE                  12:12
+#define SECONDARY_DISPLAY_CTRL_HSYNC_PHASE_ACTIVE_HIGH      0
+#define SECONDARY_DISPLAY_CTRL_HSYNC_PHASE_ACTIVE_LOW       1
+#define SECONDARY_DISPLAY_CTRL_BLANK                        10:10
+#define SECONDARY_DISPLAY_CTRL_BLANK_OFF                    0
+#define SECONDARY_DISPLAY_CTRL_BLANK_ON                     1
+#define SECONDARY_DISPLAY_CTRL_RESERVED_4_MASK              9:9
+#define SECONDARY_DISPLAY_CTRL_RESERVED_4_MASK_DISABLE      0
+#define SECONDARY_DISPLAY_CTRL_RESERVED_4_MASK_ENABLE       1
+#define SECONDARY_DISPLAY_CTRL_TIMING                       8:8
+#define SECONDARY_DISPLAY_CTRL_TIMING_DISABLE               0
+#define SECONDARY_DISPLAY_CTRL_TIMING_ENABLE                1
+#define SECONDARY_DISPLAY_CTRL_PIXEL                        7:4
+#define SECONDARY_DISPLAY_CTRL_GAMMA                        3:3
+#define SECONDARY_DISPLAY_CTRL_GAMMA_DISABLE                0
+#define SECONDARY_DISPLAY_CTRL_GAMMA_ENABLE                 1
+#define SECONDARY_DISPLAY_CTRL_PLANE                        2:2
+#define SECONDARY_DISPLAY_CTRL_PLANE_DISABLE                0
+#define SECONDARY_DISPLAY_CTRL_PLANE_ENABLE                 1
+#define SECONDARY_DISPLAY_CTRL_FORMAT                       1:0
+#define SECONDARY_DISPLAY_CTRL_FORMAT_8                     0
+#define SECONDARY_DISPLAY_CTRL_FORMAT_16                    1
+#define SECONDARY_DISPLAY_CTRL_FORMAT_32                    2
+#define SECONDARY_DISPLAY_CTRL_RESERVED_BITS_MASK           0xFF000200
+
+#define SECONDARY_FB_ADDRESS                            0x080204
+#define SECONDARY_FB_ADDRESS_STATUS                     31:31
+#define SECONDARY_FB_ADDRESS_STATUS_CURRENT             0
+#define SECONDARY_FB_ADDRESS_STATUS_PENDING             1
+#define SECONDARY_FB_ADDRESS_EXT                        27:27
+#define SECONDARY_FB_ADDRESS_EXT_LOCAL                  0
+#define SECONDARY_FB_ADDRESS_EXT_EXTERNAL               1
+#define SECONDARY_FB_ADDRESS_ADDRESS                    25:0
+
+#define SECONDARY_FB_WIDTH                              0x080208
+#define SECONDARY_FB_WIDTH_WIDTH                        29:16
+#define SECONDARY_FB_WIDTH_OFFSET                       13:0
+
+#define SECONDARY_HORIZONTAL_TOTAL                      0x08020C
+#define SECONDARY_HORIZONTAL_TOTAL_TOTAL                27:16
+#define SECONDARY_HORIZONTAL_TOTAL_DISPLAY_END          11:0
+
+#define SECONDARY_HORIZONTAL_SYNC                       0x080210
+#define SECONDARY_HORIZONTAL_SYNC_WIDTH                 23:16
+#define SECONDARY_HORIZONTAL_SYNC_START                 11:0
+
+#define SECONDARY_VERTICAL_TOTAL                        0x080214
+#define SECONDARY_VERTICAL_TOTAL_TOTAL                  26:16
+#define SECONDARY_VERTICAL_TOTAL_DISPLAY_END            10:0
+
+#define SECONDARY_VERTICAL_SYNC                         0x080218
+#define SECONDARY_VERTICAL_SYNC_HEIGHT                  21:16
+#define SECONDARY_VERTICAL_SYNC_START                   10:0
+
+#define SECONDARY_SIGNATURE_ANALYZER                    0x08021C
+#define SECONDARY_SIGNATURE_ANALYZER_STATUS             31:16
+#define SECONDARY_SIGNATURE_ANALYZER_ENABLE             3:3
+#define SECONDARY_SIGNATURE_ANALYZER_ENABLE_DISABLE     0
+#define SECONDARY_SIGNATURE_ANALYZER_ENABLE_ENABLE      1
+#define SECONDARY_SIGNATURE_ANALYZER_RESET              2:2
+#define SECONDARY_SIGNATURE_ANALYZER_RESET_NORMAL       0
+#define SECONDARY_SIGNATURE_ANALYZER_RESET_RESET        1
+#define SECONDARY_SIGNATURE_ANALYZER_SOURCE             1:0
+#define SECONDARY_SIGNATURE_ANALYZER_SOURCE_RED         0
+#define SECONDARY_SIGNATURE_ANALYZER_SOURCE_GREEN       1
+#define SECONDARY_SIGNATURE_ANALYZER_SOURCE_BLUE        2
+
+#define SECONDARY_CURRENT_LINE                          0x080220
+#define SECONDARY_CURRENT_LINE_LINE                     10:0
+
+#define SECONDARY_MONITOR_DETECT                        0x080224
+#define SECONDARY_MONITOR_DETECT_VALUE                  25:25
+#define SECONDARY_MONITOR_DETECT_VALUE_DISABLE          0
+#define SECONDARY_MONITOR_DETECT_VALUE_ENABLE           1
+#define SECONDARY_MONITOR_DETECT_ENABLE                 24:24
+#define SECONDARY_MONITOR_DETECT_ENABLE_DISABLE         0
+#define SECONDARY_MONITOR_DETECT_ENABLE_ENABLE          1
+#define SECONDARY_MONITOR_DETECT_RED                    23:16
+#define SECONDARY_MONITOR_DETECT_GREEN                  15:8
+#define SECONDARY_MONITOR_DETECT_BLUE                   7:0
+
+#define SECONDARY_SCALE                                 0x080228
+#define SECONDARY_SCALE_VERTICAL_MODE                   31:31
+#define SECONDARY_SCALE_VERTICAL_MODE_EXPAND            0
+#define SECONDARY_SCALE_VERTICAL_MODE_SHRINK            1
+#define SECONDARY_SCALE_VERTICAL_SCALE                  27:16
+#define SECONDARY_SCALE_HORIZONTAL_MODE                 15:15
+#define SECONDARY_SCALE_HORIZONTAL_MODE_EXPAND          0
+#define SECONDARY_SCALE_HORIZONTAL_MODE_SHRINK          1
+#define SECONDARY_SCALE_HORIZONTAL_SCALE                11:0
+
+/* Secondary Cursor Control */
+
+#define SECONDARY_HWC_ADDRESS                           0x080230
+#define SECONDARY_HWC_ADDRESS_ENABLE                    31:31
+#define SECONDARY_HWC_ADDRESS_ENABLE_DISABLE            0
+#define SECONDARY_HWC_ADDRESS_ENABLE_ENABLE             1
+#define SECONDARY_HWC_ADDRESS_MODE                      30:30
+#define SECONDARY_HWC_ADDRESS_MODE_MONO                 0
+#define SECONDARY_HWC_ADDRESS_MODE_COLOR                1
+#define SECONDARY_HWC_ADDRESS_EXT                       27:27
+#define SECONDARY_HWC_ADDRESS_EXT_LOCAL                 0
+#define SECONDARY_HWC_ADDRESS_EXT_EXTERNAL              1
+#define SECONDARY_HWC_ADDRESS_ADDRESS                   25:0
+
+#define SECONDARY_HWC_LOCATION                          0x080234
+#define SECONDARY_HWC_LOCATION_TOP                      27:27
+#define SECONDARY_HWC_LOCATION_TOP_INSIDE               0
+#define SECONDARY_HWC_LOCATION_TOP_OUTSIDE              1
+#define SECONDARY_HWC_LOCATION_Y                        26:16
+#define SECONDARY_HWC_LOCATION_LEFT                     11:11
+#define SECONDARY_HWC_LOCATION_LEFT_INSIDE              0
+#define SECONDARY_HWC_LOCATION_LEFT_OUTSIDE             1
+#define SECONDARY_HWC_LOCATION_X                        10:0
+
+#define SECONDARY_HWC_COLOR_12                          0x080238
+#define SECONDARY_HWC_COLOR_12_2_RGB565                 31:16
+#define SECONDARY_HWC_COLOR_12_1_RGB565                 15:0
+
+#define SECONDARY_HWC_COLOR_3                           0x08023C
+#define SECONDARY_HWC_COLOR_3_RGB565                    15:0
+
+/* This vertical expansion below start at 0x080240 ~ 0x080264 */
+#define SECONDARY_VERTICAL_EXPANSION                    0x080240
+#define SECONDARY_VERTICAL_EXPANSION_CENTERING_VALUE    31:24 
+#define SECONDARY_VERTICAL_EXPANSION_COMPARE_VALUE      23:16
+#define SECONDARY_VERTICAL_EXPANSION_LINE_BUFFER        15:12
+#define SECONDARY_VERTICAL_EXPANSION_SCALE_FACTOR       11:0
+
+/* This horizontal expansion below start at 0x080268 ~ 0x08027C */
+#define SECONDARY_HORIZONTAL_EXPANSION                  0x080268
+#define SECONDARY_HORIZONTAL_EXPANSION_CENTERING_VALUE  31:24 
+#define SECONDARY_HORIZONTAL_EXPANSION_COMPARE_VALUE    23:16
+#define SECONDARY_HORIZONTAL_EXPANSION_SCALE_FACTOR     11:0
+
+/* Auto Centering */
+#define SECONDARY_AUTO_CENTERING_TL                     0x080280
+#define SECONDARY_AUTO_CENTERING_TL_TOP                 26:16
+#define SECONDARY_AUTO_CENTERING_TL_LEFT                10:0
+
+#define SECONDARY_AUTO_CENTERING_BR                     0x080284
+#define SECONDARY_AUTO_CENTERING_BR_BOTTOM              26:16
+#define SECONDARY_AUTO_CENTERING_BR_RIGHT               10:0
+
+/* SM750LE new register to control panel output */
+#define DISPLAY_CONTROL_750LE                           0x80288
+#define DISPLAY_CONTROL_750LE_RESERVED                  31:5
+#define DISPLAY_CONTROL_750LE_PANEL                     4:4
+#define DISPLAY_CONTROL_750LE_PANEL_NORMAL              0
+#define DISPLAY_CONTROL_750LE_PANEL_TRISTATE            1
+#define DISPLAY_CONTROL_750LE_EN                        3:3
+#define DISPLAY_CONTROL_750LE_EN_LOW                    0
+#define DISPLAY_CONTROL_750LE_EN_HIGH                   1
+#define DISPLAY_CONTROL_750LE_BIAS                      2:2
+#define DISPLAY_CONTROL_750LE_BIAS_LOW                  0
+#define DISPLAY_CONTROL_750LE_BIAS_HIGH                 1
+#define DISPLAY_CONTROL_750LE_DATA                      1:1
+#define DISPLAY_CONTROL_750LE_DATA_DISABLE              0
+#define DISPLAY_CONTROL_750LE_DATA_ENABLE               1
+#define DISPLAY_CONTROL_750LE_VDD                       0:0 
+#define DISPLAY_CONTROL_750LE_VDD_LOW                   0
+#define DISPLAY_CONTROL_750LE_VDD_HIGH                  1
+
+/* SM750LE new register for display interrtup control */
+#define RAW_INT_750LE                                    0x080290
+#define RAW_INT_750LE_RESERVED1                          31:3
+#define RAW_INT_750LE_SECONDARY_VSYNC                    2:2
+#define RAW_INT_750LE_SECONDARY_VSYNC_INACTIVE           0
+#define RAW_INT_750LE_SECONDARY_VSYNC_ACTIVE             1
+#define RAW_INT_750LE_SECONDARY_VSYNC_CLEAR              1
+#define RAW_INT_750LE_PRIMARY_VSYNC                      1:1
+#define RAW_INT_750LE_PRIMARY_VSYNC_INACTIVE             0
+#define RAW_INT_750LE_PRIMARY_VSYNC_ACTIVE               1
+#define RAW_INT_750LE_PRIMARY_VSYNC_CLEAR                1
+#define RAW_INT_750LE_VGA_VSYNC                          0:0
+#define RAW_INT_750LE_VGA_VSYNC_INACTIVE                 0
+#define RAW_INT_750LE_VGA_VSYNC_ACTIVE                   1
+#define RAW_INT_750LE_VGA_VSYNC_CLEAR                    1
+
+#define INT_STATUS_750LE                                 0x080294
+#define INT_STATUS_750LE_RESERVED1                       31:3
+#define INT_STATUS_750LE_SECONDARY_VSYNC                 2:2
+#define INT_STATUS_750LE_SECONDARY_VSYNC_INACTIVE        0
+#define INT_STATUS_750LE_SECONDARY_VSYNC_ACTIVE          1
+#define INT_STATUS_750LE_PRIMARY_VSYNC                   1:1
+#define INT_STATUS_750LE_PRIMARY_VSYNC_INACTIVE          0
+#define INT_STATUS_750LE_PRIMARY_VSYNC_ACTIVE            1
+#define INT_STATUS_750LE_VGA_VSYNC                       0:0
+#define INT_STATUS_750LE_VGA_VSYNC_INACTIVE              0
+#define INT_STATUS_750LE_VGA_VSYNC_ACTIVE                1
+
+#define INT_MASK_750LE                                   0x080298
+#define INT_MASK_750LE_RESERVED1                         31:3
+#define INT_MASK_750LE_SECONDARY_VSYNC                   2:2
+#define INT_MASK_750LE_SECONDARY_VSYNC_DISABLE           0
+#define INT_MASK_750LE_SECONDARY_VSYNC_ENABLE            1
+#define INT_MASK_750LE_PRIMARY_VSYNC                     1:1
+#define INT_MASK_750LE_PRIMARY_VSYNC_DISABLE             0
+#define INT_MASK_750LE_PRIMARY_VSYNC_ENABLE              1
+#define INT_MASK_750LE_VGA_VSYNC                         0:0
+#define INT_MASK_750LE_VGA_VSYNC_DISABLE                 0
+#define INT_MASK_750LE_VGA_VSYNC_ENABLE                  1
+
+/* SM750HS new register and values for PLL control */
+#define CRT_PLL1_750HS                         0x802a8    
+#define CRT_PLL1_750HS_25MHZ                   0x00
+#define CRT_PLL1_750HS_40MHZ                   0x01
+#define CRT_PLL1_750HS_65MHZ                   0x03
+#define CRT_PLL1_750HS_78MHZ                   0x05
+#define CRT_PLL1_750HS_74MHZ                   0x04
+#define CRT_PLL1_750HS_80MHZ                   0x05
+#define CRT_PLL1_750HS_108MHZ                  0x06
+#define CRT_PLL1_750HS_162MHZ                  0x21
+#define CRT_PLL1_750HS_148MHZ                  0x20
+#define CRT_PLL1_750HS_193MHZ                  0x22
+
+/*
+#define CRT_PLL1_750HS_F_25MHZ	               0x1D40A02
+#define CRT_PLL1_750HS_F_40MHZ	               0x3940801
+#define CRT_PLL1_750HS_F_65MHZ	               0x3940D01
+#define CRT_PLL1_750HS_F_78MHZ	               0x1540F82
+#define CRT_PLL1_750HS_F_74MHZ	               0x1541D82
+#define CRT_PLL1_750HS_F_80MHZ	               0x3941001
+#define CRT_PLL1_750HS_F_108MHZ	               0x3941B01
+#define CRT_PLL1_750HS_F_162MHZ	               0x3942881
+#define CRT_PLL1_750HS_F_148MHZ	               0x1541D82
+#define CRT_PLL1_750HS_F_193MHZ	               0x1542682
+*/
+#define CRT_PLL1_750HS_F_25MHZ	               0x23d40f02
+#define CRT_PLL1_750HS_F_40MHZ	               0x23940801
+#define CRT_PLL1_750HS_F_65MHZ	               0x23940d01
+#define CRT_PLL1_750HS_F_78MHZ	               0x23540F82
+#define CRT_PLL1_750HS_F_74MHZ	               0x23941dc2
+#define CRT_PLL1_750HS_F_80MHZ	               0x23941001
+#define CRT_PLL1_750HS_F_80MHZ_1152	        0x23540fc2
+#define CRT_PLL1_750HS_F_108MHZ	               0x23b41b01
+#define CRT_PLL1_750HS_F_162MHZ	               0x23480681
+#define CRT_PLL1_750HS_F_148MHZ	               0x23541dc2
+#define CRT_PLL1_750HS_F_193MHZ	               0x234807c1
+
+#define CRT_PLL1_750HS_A_25MHZ	               0x1D40A02
+#define CRT_PLL1_750HS_A_40MHZ	               0x3940801
+#define CRT_PLL1_750HS_A_65MHZ	               0x3940D01
+#define CRT_PLL1_750HS_A_78MHZ	               0x1540F82
+#define CRT_PLL1_750HS_A_74MHZ	               0x1541D82
+#define CRT_PLL1_750HS_A_80MHZ	               0x3941001
+#define CRT_PLL1_750HS_A_108MHZ	               0x3941B01
+#define CRT_PLL1_750HS_A_162MHZ	               0x3942881
+#define CRT_PLL1_750HS_A_148MHZ	               0x1541D82
+#define CRT_PLL1_750HS_A_193MHZ	               0x1542682
+
+#define CRT_PLL2_750HS                         0x802ac
+#define CRT_PLL2_750HS_25MHZ                   0x0
+#define CRT_PLL2_750HS_40MHZ                   0x0
+#define CRT_PLL2_750HS_65MHZ                   0x0
+#define CRT_PLL2_750HS_78MHZ                   0x0
+#define CRT_PLL2_750HS_74MHZ                   0x0
+#define CRT_PLL2_750HS_80MHZ                   0x0
+#define CRT_PLL2_750HS_108MHZ                  0x0
+#define CRT_PLL2_750HS_162MHZ                  0x0
+#define CRT_PLL2_750HS_148MHZ                  0x0
+#define CRT_PLL2_750HS_193MHZ                  0x0
+
+#define CRT_PLL2_750HS_F_25MHZ	               0x206B851E
+#define CRT_PLL2_750HS_F_40MHZ	               0x30000000
+#define CRT_PLL2_750HS_F_65MHZ	               0x40000000
+#define CRT_PLL2_750HS_F_78MHZ	               0x50E147AE
+#define CRT_PLL2_750HS_F_74MHZ	               0x602B6AE7
+#define CRT_PLL2_750HS_F_80MHZ	               0x70000000
+#define CRT_PLL2_750HS_F_108MHZ	               0x80000000
+#define CRT_PLL2_750HS_F_162MHZ	               0xA0000000
+#define CRT_PLL2_750HS_F_148MHZ	               0xB0CCCCCD
+#define CRT_PLL2_750HS_F_193MHZ	               0xC0872B02
+
+#define CRT_PLL2_750HS_A_25MHZ	               0x206B851E
+#define CRT_PLL2_750HS_A_40MHZ	               0x30000000
+#define CRT_PLL2_750HS_A_65MHZ	               0x40000000
+#define CRT_PLL2_750HS_A_78MHZ	               0x50E147AE
+#define CRT_PLL2_750HS_A_74MHZ	               0x602B6AE7
+#define CRT_PLL2_750HS_A_80MHZ	               0x70000000
+#define CRT_PLL2_750HS_A_108MHZ	               0x80000000
+#define CRT_PLL2_750HS_A_162MHZ	               0xA0000000
+#define CRT_PLL2_750HS_A_148MHZ	               0xB0CCCCCD
+#define CRT_PLL2_750HS_A_193MHZ	               0xC0872B02
+
+/* SM750HS, the following PLL are for BIOS to set VGA modes.
+   DDK don't use them. Just keep here for the record. */
+#define VGA1_PLL1_750HS                               0x802b0
+#define VGA1_PLL2_750HS                               0x802b4
+#define VGA2_PLL1_750HS                               0x802b8
+#define VGA2_PLL2_750HS                               0x802bc
+
+/* Palette RAM */
+
+/* Panel Pallete register starts at 0x080400 ~ 0x0807FC */
+#define PRIMARY_PALETTE_RAM                             0x080400
+
+/* Panel Pallete register starts at 0x080C00 ~ 0x080FFC */
+#define SECONDARY_PALETTE_RAM                           0x080C00
diff --git a/drivers/gpu/drm/smi/ddk750/ddk750_regde.h b/drivers/gpu/drm/smi/ddk750/ddk750_regde.h
new file mode 100644
index 000000000000..70c26e3575b0
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk750/ddk750_regde.h
@@ -0,0 +1,359 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2007 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  RegDE.h --- Voyager GX SDK 
+*  This file contains the definitions for the Drawing Engine registers.
+* 
+*******************************************************************/
+/* 2D registers. */
+
+#define DE_SOURCE                                       0x100000
+#define DE_SOURCE_WRAP                                  31:31
+#define DE_SOURCE_WRAP_DISABLE                          0
+#define DE_SOURCE_WRAP_ENABLE                           1
+
+/* 
+ * The following definitions are used in different setting 
+ */
+
+/* Use these definitions in XY addressing mode or linear addressing mode. */
+#define DE_SOURCE_X_K1                                  27:16
+#define DE_SOURCE_Y_K2                                  11:0
+
+/* Use this definition in host write mode for mono. The Y_K2 is not used
+   in host write mode. */
+#define DE_SOURCE_X_K1_MONO                             20:16
+
+/* Use these definitions in Bresenham line drawing mode. */
+#define DE_SOURCE_X_K1_LINE                             29:16
+#define DE_SOURCE_Y_K2_LINE                             13:0
+
+#define DE_DESTINATION                                  0x100004
+#define DE_DESTINATION_WRAP                             31:31
+#define DE_DESTINATION_WRAP_DISABLE                     0
+#define DE_DESTINATION_WRAP_ENABLE                      1
+#if 1
+    #define DE_DESTINATION_X                            27:16
+    #define DE_DESTINATION_Y                            11:0
+#else
+    #define DE_DESTINATION_X                            28:16
+    #define DE_DESTINATION_Y                            15:0
+#endif
+
+#define DE_DIMENSION                                    0x100008
+#define DE_DIMENSION_X                                  28:16
+#define DE_DIMENSION_Y_ET                               15:0
+
+#define DE_CONTROL                                      0x10000C
+#define DE_CONTROL_STATUS                               31:31
+#define DE_CONTROL_STATUS_STOP                          0
+#define DE_CONTROL_STATUS_START                         1
+#define DE_CONTROL_PATTERN                              30:30
+#define DE_CONTROL_PATTERN_MONO                         0
+#define DE_CONTROL_PATTERN_COLOR                        1
+#define DE_CONTROL_UPDATE_DESTINATION_X                 29:29
+#define DE_CONTROL_UPDATE_DESTINATION_X_DISABLE         0
+#define DE_CONTROL_UPDATE_DESTINATION_X_ENABLE          1
+#define DE_CONTROL_QUICK_START                          28:28
+#define DE_CONTROL_QUICK_START_DISABLE                  0
+#define DE_CONTROL_QUICK_START_ENABLE                   1
+#define DE_CONTROL_DIRECTION                            27:27
+#define DE_CONTROL_DIRECTION_LEFT_TO_RIGHT              0
+#define DE_CONTROL_DIRECTION_RIGHT_TO_LEFT              1
+#define DE_CONTROL_MAJOR                                26:26
+#define DE_CONTROL_MAJOR_X                              0
+#define DE_CONTROL_MAJOR_Y                              1
+#define DE_CONTROL_STEP_X                               25:25
+#define DE_CONTROL_STEP_X_POSITIVE                      0
+#define DE_CONTROL_STEP_X_NEGATIVE                      1
+#define DE_CONTROL_STEP_Y                               24:24
+#define DE_CONTROL_STEP_Y_POSITIVE                      0
+#define DE_CONTROL_STEP_Y_NEGATIVE                      1
+#define DE_CONTROL_STRETCH                              23:23
+#define DE_CONTROL_STRETCH_DISABLE                      0
+#define DE_CONTROL_STRETCH_ENABLE                       1
+#define DE_CONTROL_HOST                                 22:22
+#define DE_CONTROL_HOST_COLOR                           0
+#define DE_CONTROL_HOST_MONO                            1
+#define DE_CONTROL_LAST_PIXEL                           21:21
+#define DE_CONTROL_LAST_PIXEL_OFF                       0
+#define DE_CONTROL_LAST_PIXEL_ON                        1
+#define DE_CONTROL_COMMAND                              20:16
+#define DE_CONTROL_COMMAND_BITBLT                       0
+#define DE_CONTROL_COMMAND_RECTANGLE_FILL               1
+#define DE_CONTROL_COMMAND_DE_TILE                      2
+#define DE_CONTROL_COMMAND_TRAPEZOID_FILL               3
+#define DE_CONTROL_COMMAND_ALPHA_BLEND                  4
+#define DE_CONTROL_COMMAND_RLE_STRIP                    5
+#define DE_CONTROL_COMMAND_SHORT_STROKE                 6
+#define DE_CONTROL_COMMAND_LINE_DRAW                    7
+#define DE_CONTROL_COMMAND_HOST_WRITE                   8
+#define DE_CONTROL_COMMAND_HOST_READ                    9
+#define DE_CONTROL_COMMAND_HOST_WRITE_BOTTOM_UP         10
+#define DE_CONTROL_COMMAND_ROTATE                       11
+#define DE_CONTROL_COMMAND_FONT                         12
+#define DE_CONTROL_COMMAND_TEXTURE_LOAD                 15
+#define DE_CONTROL_ROP_SELECT                           15:15
+#define DE_CONTROL_ROP_SELECT_ROP3                      0
+#define DE_CONTROL_ROP_SELECT_ROP2                      1
+#define DE_CONTROL_ROP2_SOURCE                          14:14
+#define DE_CONTROL_ROP2_SOURCE_BITMAP                   0
+#define DE_CONTROL_ROP2_SOURCE_PATTERN                  1
+#define DE_CONTROL_MONO_DATA                            13:12
+#define DE_CONTROL_MONO_DATA_NOT_PACKED                 0
+#define DE_CONTROL_MONO_DATA_8_PACKED                   1
+#define DE_CONTROL_MONO_DATA_16_PACKED                  2
+#define DE_CONTROL_MONO_DATA_32_PACKED                  3
+#define DE_CONTROL_REPEAT_ROTATE                        11:11
+#define DE_CONTROL_REPEAT_ROTATE_DISABLE                0
+#define DE_CONTROL_REPEAT_ROTATE_ENABLE                 1
+#define DE_CONTROL_TRANSPARENCY_MATCH                   10:10
+#define DE_CONTROL_TRANSPARENCY_MATCH_OPAQUE            0
+#define DE_CONTROL_TRANSPARENCY_MATCH_TRANSPARENT       1
+#define DE_CONTROL_TRANSPARENCY_SELECT                  9:9
+#define DE_CONTROL_TRANSPARENCY_SELECT_SOURCE           0
+#define DE_CONTROL_TRANSPARENCY_SELECT_DESTINATION      1
+#define DE_CONTROL_TRANSPARENCY                         8:8
+#define DE_CONTROL_TRANSPARENCY_DISABLE                 0
+#define DE_CONTROL_TRANSPARENCY_ENABLE                  1
+#define DE_CONTROL_ROP                                  7:0
+
+/* Pseudo fields. */
+
+#define DE_CONTROL_SHORT_STROKE_DIR                     27:24
+#define DE_CONTROL_SHORT_STROKE_DIR_225                 0
+#define DE_CONTROL_SHORT_STROKE_DIR_135                 1
+#define DE_CONTROL_SHORT_STROKE_DIR_315                 2
+#define DE_CONTROL_SHORT_STROKE_DIR_45                  3
+#define DE_CONTROL_SHORT_STROKE_DIR_270                 4
+#define DE_CONTROL_SHORT_STROKE_DIR_90                  5
+#define DE_CONTROL_SHORT_STROKE_DIR_180                 8
+#define DE_CONTROL_SHORT_STROKE_DIR_0                   10
+#define DE_CONTROL_ROTATION                             25:24
+#define DE_CONTROL_ROTATION_0                           0
+#define DE_CONTROL_ROTATION_270                         1
+#define DE_CONTROL_ROTATION_90                          2
+#define DE_CONTROL_ROTATION_180                         3
+
+#define DE_PITCH                                        0x100010
+#define DE_PITCH_DESTINATION                            28:16
+#define DE_PITCH_SOURCE                                 12:0
+
+#define DE_FOREGROUND                                   0x100014
+#define DE_FOREGROUND_COLOR                             31:0
+
+#define DE_BACKGROUND                                   0x100018
+#define DE_BACKGROUND_COLOR                             31:0
+
+#define DE_STRETCH_FORMAT                               0x10001C
+#define DE_STRETCH_FORMAT_PATTERN_XY                    30:30
+#define DE_STRETCH_FORMAT_PATTERN_XY_NORMAL             0
+#define DE_STRETCH_FORMAT_PATTERN_XY_OVERWRITE          1
+#define DE_STRETCH_FORMAT_PATTERN_Y                     29:27
+#define DE_STRETCH_FORMAT_PATTERN_X                     25:23
+#define DE_STRETCH_FORMAT_PIXEL_FORMAT                  21:20
+#define DE_STRETCH_FORMAT_PIXEL_FORMAT_8                0
+#define DE_STRETCH_FORMAT_PIXEL_FORMAT_16               1
+#define DE_STRETCH_FORMAT_PIXEL_FORMAT_32               2
+#define DE_STRETCH_FORMAT_ADDRESSING                    19:16
+#define DE_STRETCH_FORMAT_ADDRESSING_XY                 0
+#define DE_STRETCH_FORMAT_ADDRESSING_LINEAR             15
+#define DE_STRETCH_FORMAT_SOURCE_HEIGHT                 11:0
+
+#define DE_COLOR_COMPARE                                0x100020
+#define DE_COLOR_COMPARE_COLOR                          23:0
+
+#define DE_COLOR_COMPARE_MASK                           0x100024
+#define DE_COLOR_COMPARE_MASK_MASKS                     23:0
+
+#define DE_MASKS                                        0x100028
+#define DE_MASKS_BYTE_MASK                              31:16
+#define DE_MASKS_BIT_MASK                               15:0
+
+#define DE_CLIP_TL                                      0x10002C
+#define DE_CLIP_TL_TOP                                  31:16
+#define DE_CLIP_TL_STATUS                               13:13
+#define DE_CLIP_TL_STATUS_DISABLE                       0
+#define DE_CLIP_TL_STATUS_ENABLE                        1
+#define DE_CLIP_TL_INHIBIT                              12:12
+#define DE_CLIP_TL_INHIBIT_OUTSIDE                      0
+#define DE_CLIP_TL_INHIBIT_INSIDE                       1
+#define DE_CLIP_TL_LEFT                                 11:0
+
+#define DE_CLIP_BR                                      0x100030
+#define DE_CLIP_BR_BOTTOM                               31:16
+#define DE_CLIP_BR_RIGHT                                12:0
+
+#define DE_MONO_PATTERN_LOW                             0x100034
+#define DE_MONO_PATTERN_LOW_PATTERN                     31:0
+
+#define DE_MONO_PATTERN_HIGH                            0x100038
+#define DE_MONO_PATTERN_HIGH_PATTERN                    31:0
+
+#define DE_WINDOW_WIDTH                                 0x10003C
+#define DE_WINDOW_WIDTH_DESTINATION                     28:16
+#define DE_WINDOW_WIDTH_SOURCE                          12:0
+
+#define DE_WINDOW_SOURCE_BASE                           0x100040
+#define DE_WINDOW_SOURCE_BASE_EXT                       27:27
+#define DE_WINDOW_SOURCE_BASE_EXT_LOCAL                 0
+#define DE_WINDOW_SOURCE_BASE_EXT_EXTERNAL              1
+#define DE_WINDOW_SOURCE_BASE_CS                        26:26
+#define DE_WINDOW_SOURCE_BASE_CS_0                      0
+#define DE_WINDOW_SOURCE_BASE_CS_1                      1
+#define DE_WINDOW_SOURCE_BASE_ADDRESS                   25:0
+
+#define DE_WINDOW_DESTINATION_BASE                      0x100044
+#define DE_WINDOW_DESTINATION_BASE_EXT                  27:27
+#define DE_WINDOW_DESTINATION_BASE_EXT_LOCAL            0
+#define DE_WINDOW_DESTINATION_BASE_EXT_EXTERNAL         1
+#define DE_WINDOW_DESTINATION_BASE_CS                   26:26
+#define DE_WINDOW_DESTINATION_BASE_CS_0                 0
+#define DE_WINDOW_DESTINATION_BASE_CS_1                 1
+#define DE_WINDOW_DESTINATION_BASE_ADDRESS              25:0
+
+#define DE_ALPHA                                        0x100048
+#define DE_ALPHA_VALUE                                  7:0
+
+#define DE_WRAP                                         0x10004C
+#define DE_WRAP_X                                       31:16
+#define DE_WRAP_Y                                       15:0
+
+#define DE_STATUS                                       0x100050
+#define DE_STATUS_CSC                                   1:1
+#define DE_STATUS_CSC_CLEAR                             0
+#define DE_STATUS_CSC_NOT_ACTIVE                        0
+#define DE_STATUS_CSC_ACTIVE                            1
+#define DE_STATUS_2D                                    0:0
+#define DE_STATUS_2D_CLEAR                              0
+#define DE_STATUS_2D_NOT_ACTIVE                         0
+#define DE_STATUS_2D_ACTIVE                             1
+
+/* New register for SM750LE */
+#define DE_STATE1                                        0x100054
+#define DE_STATE1_DE_ABORT                               0:0
+#define DE_STATE1_DE_ABORT_OFF                           0
+#define DE_STATE1_DE_ABORT_ON                            1
+
+#define DE_STATE2                                        0x100058
+#define DE_STATE2_DE_FIFO                                3:3
+#define DE_STATE2_DE_FIFO_NOTEMPTY                       0
+#define DE_STATE2_DE_FIFO_EMPTY                          1
+#define DE_STATE2_DE_STATUS                              2:2
+#define DE_STATE2_DE_STATUS_IDLE                         0
+#define DE_STATE2_DE_STATUS_BUSY                         1
+#define DE_STATE2_DE_MEM_FIFO                            1:1
+#define DE_STATE2_DE_MEM_FIFO_NOTEMPTY                   0
+#define DE_STATE2_DE_MEM_FIFO_EMPTY                      1
+#define DE_STATE2_DE_RESERVED                            0:0
+
+/* Color Space Conversion registers. */
+
+#define CSC_Y_SOURCE_BASE                               0x1000C8
+#define CSC_Y_SOURCE_BASE_EXT                           27:27
+#define CSC_Y_SOURCE_BASE_EXT_LOCAL                     0
+#define CSC_Y_SOURCE_BASE_EXT_EXTERNAL                  1
+#define CSC_Y_SOURCE_BASE_CS                            26:26
+#define CSC_Y_SOURCE_BASE_CS_0                          0
+#define CSC_Y_SOURCE_BASE_CS_1                          1
+#define CSC_Y_SOURCE_BASE_ADDRESS                       25:0
+
+#define CSC_CONSTANTS                                   0x1000CC
+#define CSC_CONSTANTS_Y                                 31:24
+#define CSC_CONSTANTS_R                                 23:16
+#define CSC_CONSTANTS_G                                 15:8
+#define CSC_CONSTANTS_B                                 7:0
+
+#define CSC_Y_SOURCE_X                                  0x1000D0
+#define CSC_Y_SOURCE_X_INTEGER                          26:16
+#define CSC_Y_SOURCE_X_FRACTION                         15:3
+
+#define CSC_Y_SOURCE_Y                                  0x1000D4
+#define CSC_Y_SOURCE_Y_INTEGER                          27:16
+#define CSC_Y_SOURCE_Y_FRACTION                         15:3
+
+#define CSC_U_SOURCE_BASE                               0x1000D8
+#define CSC_U_SOURCE_BASE_EXT                           27:27
+#define CSC_U_SOURCE_BASE_EXT_LOCAL                     0
+#define CSC_U_SOURCE_BASE_EXT_EXTERNAL                  1
+#define CSC_U_SOURCE_BASE_CS                            26:26
+#define CSC_U_SOURCE_BASE_CS_0                          0
+#define CSC_U_SOURCE_BASE_CS_1                          1
+#define CSC_U_SOURCE_BASE_ADDRESS                       25:0
+
+#define CSC_V_SOURCE_BASE                               0x1000DC
+#define CSC_V_SOURCE_BASE_EXT                           27:27
+#define CSC_V_SOURCE_BASE_EXT_LOCAL                     0
+#define CSC_V_SOURCE_BASE_EXT_EXTERNAL                  1
+#define CSC_V_SOURCE_BASE_CS                            26:26
+#define CSC_V_SOURCE_BASE_CS_0                          0
+#define CSC_V_SOURCE_BASE_CS_1                          1
+#define CSC_V_SOURCE_BASE_ADDRESS                       25:0
+
+#define CSC_SOURCE_DIMENSION                            0x1000E0
+#define CSC_SOURCE_DIMENSION_X                          31:16
+#define CSC_SOURCE_DIMENSION_Y                          15:0
+
+#define CSC_SOURCE_PITCH                                0x1000E4
+#define CSC_SOURCE_PITCH_Y                              31:16
+#define CSC_SOURCE_PITCH_UV                             15:0
+
+#define CSC_DESTINATION                                 0x1000E8
+#define CSC_DESTINATION_WRAP                            31:31
+#define CSC_DESTINATION_WRAP_DISABLE                    0
+#define CSC_DESTINATION_WRAP_ENABLE                     1
+#define CSC_DESTINATION_X                               27:16
+#define CSC_DESTINATION_Y                               11:0
+
+#define CSC_DESTINATION_DIMENSION                       0x1000EC
+#define CSC_DESTINATION_DIMENSION_X                     31:16
+#define CSC_DESTINATION_DIMENSION_Y                     15:0
+
+#define CSC_DESTINATION_PITCH                           0x1000F0
+#define CSC_DESTINATION_PITCH_X                         31:16
+#define CSC_DESTINATION_PITCH_Y                         15:0
+
+#define CSC_SCALE_FACTOR                                0x1000F4
+#define CSC_SCALE_FACTOR_HORIZONTAL                     31:16
+#define CSC_SCALE_FACTOR_VERTICAL                       15:0
+
+#define CSC_DESTINATION_BASE                            0x1000F8
+#define CSC_DESTINATION_BASE_EXT                        27:27
+#define CSC_DESTINATION_BASE_EXT_LOCAL                  0
+#define CSC_DESTINATION_BASE_EXT_EXTERNAL               1
+#define CSC_DESTINATION_BASE_CS                         26:26
+#define CSC_DESTINATION_BASE_CS_0                       0
+#define CSC_DESTINATION_BASE_CS_1                       1
+#define CSC_DESTINATION_BASE_ADDRESS                    25:0
+
+#define CSC_CONTROL                                     0x1000FC
+#define CSC_CONTROL_STATUS                              31:31
+#define CSC_CONTROL_STATUS_STOP                         0
+#define CSC_CONTROL_STATUS_START                        1
+#define CSC_CONTROL_SOURCE_FORMAT                       30:28
+#define CSC_CONTROL_SOURCE_FORMAT_YUV422                0
+#define CSC_CONTROL_SOURCE_FORMAT_YUV420I               1
+#define CSC_CONTROL_SOURCE_FORMAT_YUV420                2
+#define CSC_CONTROL_SOURCE_FORMAT_YVU9                  3
+#define CSC_CONTROL_SOURCE_FORMAT_IYU1                  4
+#define CSC_CONTROL_SOURCE_FORMAT_IYU2                  5
+#define CSC_CONTROL_SOURCE_FORMAT_RGB565                6
+#define CSC_CONTROL_SOURCE_FORMAT_RGB8888               7
+#define CSC_CONTROL_DESTINATION_FORMAT                  27:26
+#define CSC_CONTROL_DESTINATION_FORMAT_RGB565           0
+#define CSC_CONTROL_DESTINATION_FORMAT_RGB8888          1
+#define CSC_CONTROL_HORIZONTAL_FILTER                   25:25
+#define CSC_CONTROL_HORIZONTAL_FILTER_DISABLE           0
+#define CSC_CONTROL_HORIZONTAL_FILTER_ENABLE            1
+#define CSC_CONTROL_VERTICAL_FILTER                     24:24
+#define CSC_CONTROL_VERTICAL_FILTER_DISABLE             0
+#define CSC_CONTROL_VERTICAL_FILTER_ENABLE              1
+#define CSC_CONTROL_BYTE_ORDER                          23:23
+#define CSC_CONTROL_BYTE_ORDER_YUYV                     0
+#define CSC_CONTROL_BYTE_ORDER_UYVY                     1
+
+#define DE_DATA_PORT                                    0x110000
diff --git a/drivers/gpu/drm/smi/ddk750/ddk750_reggpio.h b/drivers/gpu/drm/smi/ddk750/ddk750_reggpio.h
new file mode 100644
index 000000000000..eb08a8000ca0
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk750/ddk750_reggpio.h
@@ -0,0 +1,239 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2007 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  RegGPIO.h --- Voyager GX SDK 
+*  This file contains the definitions for the GPIO registers.
+* 
+*******************************************************************/
+#define GPIO_DATA                                       0x010000
+#define GPIO_DATA_31                                    31:31
+#define GPIO_DATA_30                                    30:30
+#define GPIO_DATA_29                                    29:29
+#define GPIO_DATA_28                                    28:28
+#define GPIO_DATA_27                                    27:27
+#define GPIO_DATA_26                                    26:26
+#define GPIO_DATA_25                                    25:25
+#define GPIO_DATA_24                                    24:24
+#define GPIO_DATA_23                                    23:23
+#define GPIO_DATA_22                                    22:22
+#define GPIO_DATA_21                                    21:21
+#define GPIO_DATA_20                                    20:20
+#define GPIO_DATA_19                                    19:19
+#define GPIO_DATA_18                                    18:18
+#define GPIO_DATA_17                                    17:17
+#define GPIO_DATA_16                                    16:16
+#define GPIO_DATA_15                                    15:15
+#define GPIO_DATA_14                                    14:14
+#define GPIO_DATA_13                                    13:13
+#define GPIO_DATA_12                                    12:12
+#define GPIO_DATA_11                                    11:11
+#define GPIO_DATA_10                                    10:10
+#define GPIO_DATA_9                                     9:9
+#define GPIO_DATA_8                                     8:8
+#define GPIO_DATA_7                                     7:7
+#define GPIO_DATA_6                                     6:6
+#define GPIO_DATA_5                                     5:5
+#define GPIO_DATA_4                                     4:4
+#define GPIO_DATA_3                                     3:3
+#define GPIO_DATA_2                                     2:2
+#define GPIO_DATA_1                                     1:1
+#define GPIO_DATA_0                                     0:0
+
+#define GPIO_DATA_DIRECTION                             0x010004
+#define GPIO_DATA_DIRECTION_31                          31:31
+#define GPIO_DATA_DIRECTION_31_INPUT                    0
+#define GPIO_DATA_DIRECTION_31_OUTPUT                   1
+#define GPIO_DATA_DIRECTION_30                          30:30
+#define GPIO_DATA_DIRECTION_30_INPUT                    0
+#define GPIO_DATA_DIRECTION_30_OUTPUT                   1
+#define GPIO_DATA_DIRECTION_29                          29:29
+#define GPIO_DATA_DIRECTION_29_INPUT                    0
+#define GPIO_DATA_DIRECTION_29_OUTPUT                   1
+#define GPIO_DATA_DIRECTION_28                          28:28
+#define GPIO_DATA_DIRECTION_28_INPUT                    0
+#define GPIO_DATA_DIRECTION_28_OUTPUT                   1
+#define GPIO_DATA_DIRECTION_27                          27:27
+#define GPIO_DATA_DIRECTION_27_INPUT                    0
+#define GPIO_DATA_DIRECTION_27_OUTPUT                   1
+#define GPIO_DATA_DIRECTION_26                          26:26
+#define GPIO_DATA_DIRECTION_26_INPUT                    0
+#define GPIO_DATA_DIRECTION_26_OUTPUT                   1
+#define GPIO_DATA_DIRECTION_25                          25:25
+#define GPIO_DATA_DIRECTION_25_INPUT                    0
+#define GPIO_DATA_DIRECTION_25_OUTPUT                   1
+#define GPIO_DATA_DIRECTION_24                          24:24
+#define GPIO_DATA_DIRECTION_24_INPUT                    0
+#define GPIO_DATA_DIRECTION_24_OUTPUT                   1
+#define GPIO_DATA_DIRECTION_23                          23:23
+#define GPIO_DATA_DIRECTION_23_INPUT                    0
+#define GPIO_DATA_DIRECTION_23_OUTPUT                   1
+#define GPIO_DATA_DIRECTION_22                          22:22
+#define GPIO_DATA_DIRECTION_22_INPUT                    0
+#define GPIO_DATA_DIRECTION_22_OUTPUT                   1
+#define GPIO_DATA_DIRECTION_21                          21:21
+#define GPIO_DATA_DIRECTION_21_INPUT                    0
+#define GPIO_DATA_DIRECTION_21_OUTPUT                   1
+#define GPIO_DATA_DIRECTION_20                          20:20
+#define GPIO_DATA_DIRECTION_20_INPUT                    0
+#define GPIO_DATA_DIRECTION_20_OUTPUT                   1
+#define GPIO_DATA_DIRECTION_19                          19:19
+#define GPIO_DATA_DIRECTION_19_INPUT                    0
+#define GPIO_DATA_DIRECTION_19_OUTPUT                   1
+#define GPIO_DATA_DIRECTION_18                          18:18
+#define GPIO_DATA_DIRECTION_18_INPUT                    0
+#define GPIO_DATA_DIRECTION_18_OUTPUT                   1
+#define GPIO_DATA_DIRECTION_17                          17:17
+#define GPIO_DATA_DIRECTION_17_INPUT                    0
+#define GPIO_DATA_DIRECTION_17_OUTPUT                   1
+#define GPIO_DATA_DIRECTION_16                          16:16
+#define GPIO_DATA_DIRECTION_16_INPUT                    0
+#define GPIO_DATA_DIRECTION_16_OUTPUT                   1
+#define GPIO_DATA_DIRECTION_15                          15:15
+#define GPIO_DATA_DIRECTION_15_INPUT                    0
+#define GPIO_DATA_DIRECTION_15_OUTPUT                   1
+#define GPIO_DATA_DIRECTION_14                          14:14
+#define GPIO_DATA_DIRECTION_14_INPUT                    0
+#define GPIO_DATA_DIRECTION_14_OUTPUT                   1
+#define GPIO_DATA_DIRECTION_13                          13:13
+#define GPIO_DATA_DIRECTION_13_INPUT                    0
+#define GPIO_DATA_DIRECTION_13_OUTPUT                   1
+#define GPIO_DATA_DIRECTION_12                          12:12
+#define GPIO_DATA_DIRECTION_12_INPUT                    0
+#define GPIO_DATA_DIRECTION_12_OUTPUT                   1
+#define GPIO_DATA_DIRECTION_11                          11:11
+#define GPIO_DATA_DIRECTION_11_INPUT                    0
+#define GPIO_DATA_DIRECTION_11_OUTPUT                   1
+#define GPIO_DATA_DIRECTION_10                          10:10
+#define GPIO_DATA_DIRECTION_10_INPUT                    0
+#define GPIO_DATA_DIRECTION_10_OUTPUT                   1
+#define GPIO_DATA_DIRECTION_9                           9:9
+#define GPIO_DATA_DIRECTION_9_INPUT                     0
+#define GPIO_DATA_DIRECTION_9_OUTPUT                    1
+#define GPIO_DATA_DIRECTION_8                           8:8
+#define GPIO_DATA_DIRECTION_8_INPUT                     0
+#define GPIO_DATA_DIRECTION_8_OUTPUT                    1
+#define GPIO_DATA_DIRECTION_7                           7:7
+#define GPIO_DATA_DIRECTION_7_INPUT                     0
+#define GPIO_DATA_DIRECTION_7_OUTPUT                    1
+#define GPIO_DATA_DIRECTION_6                           6:6
+#define GPIO_DATA_DIRECTION_6_INPUT                     0
+#define GPIO_DATA_DIRECTION_6_OUTPUT                    1
+#define GPIO_DATA_DIRECTION_5                           5:5
+#define GPIO_DATA_DIRECTION_5_INPUT                     0
+#define GPIO_DATA_DIRECTION_5_OUTPUT                    1
+#define GPIO_DATA_DIRECTION_4                           4:4
+#define GPIO_DATA_DIRECTION_4_INPUT                     0
+#define GPIO_DATA_DIRECTION_4_OUTPUT                    1
+#define GPIO_DATA_DIRECTION_3                           3:3
+#define GPIO_DATA_DIRECTION_3_INPUT                     0
+#define GPIO_DATA_DIRECTION_3_OUTPUT                    1
+#define GPIO_DATA_DIRECTION_2                           2:2
+#define GPIO_DATA_DIRECTION_2_INPUT                     0
+#define GPIO_DATA_DIRECTION_2_OUTPUT                    1
+#define GPIO_DATA_DIRECTION_1                           1:1
+#define GPIO_DATA_DIRECTION_1_INPUT                     0
+#define GPIO_DATA_DIRECTION_1_OUTPUT                    1
+#define GPIO_DATA_DIRECTION_0                           0:0
+#define GPIO_DATA_DIRECTION_0_INPUT                     0
+#define GPIO_DATA_DIRECTION_0_OUTPUT                    1
+
+#define GPIO_INTERRUPT_SETUP                            0x010008
+#define GPIO_INTERRUPT_SETUP_TRIGGER_31                 22:22
+#define GPIO_INTERRUPT_SETUP_TRIGGER_31_EDGE            0
+#define GPIO_INTERRUPT_SETUP_TRIGGER_31_LEVEL           1
+#define GPIO_INTERRUPT_SETUP_TRIGGER_30                 21:21
+#define GPIO_INTERRUPT_SETUP_TRIGGER_30_EDGE            0
+#define GPIO_INTERRUPT_SETUP_TRIGGER_30_LEVEL           1
+#define GPIO_INTERRUPT_SETUP_TRIGGER_29                 20:20
+#define GPIO_INTERRUPT_SETUP_TRIGGER_29_EDGE            0
+#define GPIO_INTERRUPT_SETUP_TRIGGER_29_LEVEL           1
+#define GPIO_INTERRUPT_SETUP_TRIGGER_28                 19:19
+#define GPIO_INTERRUPT_SETUP_TRIGGER_28_EDGE            0
+#define GPIO_INTERRUPT_SETUP_TRIGGER_28_LEVEL           1
+#define GPIO_INTERRUPT_SETUP_TRIGGER_27                 18:18
+#define GPIO_INTERRUPT_SETUP_TRIGGER_27_EDGE            0
+#define GPIO_INTERRUPT_SETUP_TRIGGER_27_LEVEL           1
+#define GPIO_INTERRUPT_SETUP_TRIGGER_26                 17:17
+#define GPIO_INTERRUPT_SETUP_TRIGGER_26_EDGE            0
+#define GPIO_INTERRUPT_SETUP_TRIGGER_26_LEVEL           1
+#define GPIO_INTERRUPT_SETUP_TRIGGER_25                 16:16
+#define GPIO_INTERRUPT_SETUP_TRIGGER_25_EDGE            0
+#define GPIO_INTERRUPT_SETUP_TRIGGER_25_LEVEL           1
+#define GPIO_INTERRUPT_SETUP_ACTIVE_31                  14:14
+#define GPIO_INTERRUPT_SETUP_ACTIVE_31_LOW              0
+#define GPIO_INTERRUPT_SETUP_ACTIVE_31_HIGH             1
+#define GPIO_INTERRUPT_SETUP_ACTIVE_30                  13:13
+#define GPIO_INTERRUPT_SETUP_ACTIVE_30_LOW              0
+#define GPIO_INTERRUPT_SETUP_ACTIVE_30_HIGH             1
+#define GPIO_INTERRUPT_SETUP_ACTIVE_29                  12:12
+#define GPIO_INTERRUPT_SETUP_ACTIVE_29_LOW              0
+#define GPIO_INTERRUPT_SETUP_ACTIVE_29_HIGH             1
+#define GPIO_INTERRUPT_SETUP_ACTIVE_28                  11:11
+#define GPIO_INTERRUPT_SETUP_ACTIVE_28_LOW              0
+#define GPIO_INTERRUPT_SETUP_ACTIVE_28_HIGH             1
+#define GPIO_INTERRUPT_SETUP_ACTIVE_27                  10:10
+#define GPIO_INTERRUPT_SETUP_ACTIVE_27_LOW              0
+#define GPIO_INTERRUPT_SETUP_ACTIVE_27_HIGH             1
+#define GPIO_INTERRUPT_SETUP_ACTIVE_26                  9:9
+#define GPIO_INTERRUPT_SETUP_ACTIVE_26_LOW              0
+#define GPIO_INTERRUPT_SETUP_ACTIVE_26_HIGH             1
+#define GPIO_INTERRUPT_SETUP_ACTIVE_25                  8:8
+#define GPIO_INTERRUPT_SETUP_ACTIVE_25_LOW              0
+#define GPIO_INTERRUPT_SETUP_ACTIVE_25_HIGH             1
+#define GPIO_INTERRUPT_SETUP_ENABLE_31                  6:6
+#define GPIO_INTERRUPT_SETUP_ENABLE_31_GPIO             0
+#define GPIO_INTERRUPT_SETUP_ENABLE_31_INTERRUPT        1
+#define GPIO_INTERRUPT_SETUP_ENABLE_30                  5:5
+#define GPIO_INTERRUPT_SETUP_ENABLE_30_GPIO             0
+#define GPIO_INTERRUPT_SETUP_ENABLE_30_INTERRUPT        1
+#define GPIO_INTERRUPT_SETUP_ENABLE_29                  4:4
+#define GPIO_INTERRUPT_SETUP_ENABLE_29_GPIO             0
+#define GPIO_INTERRUPT_SETUP_ENABLE_29_INTERRUPT        1
+#define GPIO_INTERRUPT_SETUP_ENABLE_28                  3:3
+#define GPIO_INTERRUPT_SETUP_ENABLE_28_GPIO             0
+#define GPIO_INTERRUPT_SETUP_ENABLE_28_INTERRUPT        1
+#define GPIO_INTERRUPT_SETUP_ENABLE_27                  2:2
+#define GPIO_INTERRUPT_SETUP_ENABLE_27_GPIO             0
+#define GPIO_INTERRUPT_SETUP_ENABLE_27_INTERRUPT        1
+#define GPIO_INTERRUPT_SETUP_ENABLE_26                  1:1
+#define GPIO_INTERRUPT_SETUP_ENABLE_26_GPIO             0
+#define GPIO_INTERRUPT_SETUP_ENABLE_26_INTERRUPT        1
+#define GPIO_INTERRUPT_SETUP_ENABLE_25                  0:0
+#define GPIO_INTERRUPT_SETUP_ENABLE_25_GPIO             0
+#define GPIO_INTERRUPT_SETUP_ENABLE_25_INTERRUPT        1
+
+#define GPIO_INTERRUPT_STATUS                           0x01000C
+#define GPIO_INTERRUPT_STATUS_31                        22:22
+#define GPIO_INTERRUPT_STATUS_31_INACTIVE               0
+#define GPIO_INTERRUPT_STATUS_31_ACTIVE                 1
+#define GPIO_INTERRUPT_STATUS_31_RESET                  1
+#define GPIO_INTERRUPT_STATUS_30                        21:21
+#define GPIO_INTERRUPT_STATUS_30_INACTIVE               0
+#define GPIO_INTERRUPT_STATUS_30_ACTIVE                 1
+#define GPIO_INTERRUPT_STATUS_30_RESET                  1
+#define GPIO_INTERRUPT_STATUS_29                        20:20
+#define GPIO_INTERRUPT_STATUS_29_INACTIVE               0
+#define GPIO_INTERRUPT_STATUS_29_ACTIVE                 1
+#define GPIO_INTERRUPT_STATUS_29_RESET                  1
+#define GPIO_INTERRUPT_STATUS_28                        19:19
+#define GPIO_INTERRUPT_STATUS_28_INACTIVE               0
+#define GPIO_INTERRUPT_STATUS_28_ACTIVE                 1
+#define GPIO_INTERRUPT_STATUS_28_RESET                  1
+#define GPIO_INTERRUPT_STATUS_27                        18:18
+#define GPIO_INTERRUPT_STATUS_27_INACTIVE               0
+#define GPIO_INTERRUPT_STATUS_27_ACTIVE                 1
+#define GPIO_INTERRUPT_STATUS_27_RESET                  1
+#define GPIO_INTERRUPT_STATUS_26                        17:17
+#define GPIO_INTERRUPT_STATUS_26_INACTIVE               0
+#define GPIO_INTERRUPT_STATUS_26_ACTIVE                 1
+#define GPIO_INTERRUPT_STATUS_26_RESET                  1
+#define GPIO_INTERRUPT_STATUS_25                        16:16
+#define GPIO_INTERRUPT_STATUS_25_INACTIVE               0
+#define GPIO_INTERRUPT_STATUS_25_ACTIVE                 1
+#define GPIO_INTERRUPT_STATUS_25_RESET                  1
+
+
diff --git a/drivers/gpu/drm/smi/ddk750/ddk750_regi2c.h b/drivers/gpu/drm/smi/ddk750/ddk750_regi2c.h
new file mode 100644
index 000000000000..62555c6424c2
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk750/ddk750_regi2c.h
@@ -0,0 +1,69 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2007 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  RegI2C.h --- Voyager GX SDK 
+*  This file contains the definitions for the HW I2C registers.
+* 
+*******************************************************************/
+#define I2C_BYTE_COUNT                                  0x010040
+#define I2C_BYTE_COUNT_COUNT                            3:0
+
+#define I2C_CTRL                                        0x010041
+#define I2C_CTRL_INT                                    4:4
+#define I2C_CTRL_INT_DISABLE                            0
+#define I2C_CTRL_INT_ENABLE                             1
+#define I2C_CTRL_CTRL                                   2:2
+#define I2C_CTRL_CTRL_STOP                              0
+#define I2C_CTRL_CTRL_START                             1
+#define I2C_CTRL_MODE                                   1:1
+#define I2C_CTRL_MODE_STANDARD                          0
+#define I2C_CTRL_MODE_FAST                              1
+#define I2C_CTRL_EN                                     0:0
+#define I2C_CTRL_EN_DISABLE                             0
+#define I2C_CTRL_EN_ENABLE                              1
+
+#define I2C_STATUS                                      0x010042
+#define I2C_STATUS_TX                                   3:3
+#define I2C_STATUS_TX_PROGRESS                          0
+#define I2C_STATUS_TX_COMPLETED                         1
+#define I2C_STATUS_ERR                                  2:2
+#define I2C_STATUS_ERR_NORMAL                           0
+#define I2C_STATUS_ERR_ERROR                            1
+#define I2C_STATUS_ERR_CLEAR                            0
+#define I2C_STATUS_ACK                                  1:1
+#define I2C_STATUS_ACK_RECEIVED                         0
+#define I2C_STATUS_ACK_NOT                              1
+#define I2C_STATUS_BSY                                  0:0
+#define I2C_STATUS_BSY_IDLE                             0
+#define I2C_STATUS_BSY_BUSY                             1
+
+#define I2C_RESET                                       0x010042
+#define I2C_RESET_BUS_ERROR                             2:2
+#define I2C_RESET_BUS_ERROR_CLEAR                       0
+
+#define I2C_SLAVE_ADDRESS                               0x010043
+#define I2C_SLAVE_ADDRESS_ADDRESS                       7:1
+#define I2C_SLAVE_ADDRESS_RW                            0:0
+#define I2C_SLAVE_ADDRESS_RW_W                          0
+#define I2C_SLAVE_ADDRESS_RW_R                          1
+
+#define I2C_DATA0                                       0x010044
+#define I2C_DATA1                                       0x010045
+#define I2C_DATA2                                       0x010046
+#define I2C_DATA3                                       0x010047
+#define I2C_DATA4                                       0x010048
+#define I2C_DATA5                                       0x010049
+#define I2C_DATA6                                       0x01004A
+#define I2C_DATA7                                       0x01004B
+#define I2C_DATA8                                       0x01004C
+#define I2C_DATA9                                       0x01004D
+#define I2C_DATA10                                      0x01004E
+#define I2C_DATA11                                      0x01004F
+#define I2C_DATA12                                      0x010050
+#define I2C_DATA13                                      0x010051
+#define I2C_DATA14                                      0x010052
+#define I2C_DATA15                                      0x010053
diff --git a/drivers/gpu/drm/smi/ddk750/ddk750_regsc.h b/drivers/gpu/drm/smi/ddk750/ddk750_regsc.h
new file mode 100644
index 000000000000..e70d39b6bfd5
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk750/ddk750_regsc.h
@@ -0,0 +1,900 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2007 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  RegSC.h --- SM718 SDK 
+*  This file contains the definitions for the System Configuration registers.
+* 
+*******************************************************************/
+#define SYSTEM_CTRL                                   0x000000
+#define SYSTEM_CTRL_DPMS                              31:30
+#define SYSTEM_CTRL_DPMS_VPHP                         0
+#define SYSTEM_CTRL_DPMS_VPHN                         1
+#define SYSTEM_CTRL_DPMS_VNHP                         2
+#define SYSTEM_CTRL_DPMS_VNHN                         3
+#define SYSTEM_CTRL_PCI_BURST                         29:29
+#define SYSTEM_CTRL_PCI_BURST_OFF                     0
+#define SYSTEM_CTRL_PCI_BURST_ON                      1
+#define SYSTEM_CTRL_PCI_MASTER                        25:25
+#define SYSTEM_CTRL_PCI_MASTER_OFF                    0
+#define SYSTEM_CTRL_PCI_MASTER_ON                     1
+#define SYSTEM_CTRL_LATENCY_TIMER                     24:24
+#define SYSTEM_CTRL_LATENCY_TIMER_ON                  0
+#define SYSTEM_CTRL_LATENCY_TIMER_OFF                 1
+#define SYSTEM_CTRL_DE_FIFO                           23:23
+#define SYSTEM_CTRL_DE_FIFO_NOTEMPTY                  0
+#define SYSTEM_CTRL_DE_FIFO_EMPTY                     1
+#define SYSTEM_CTRL_DE_STATUS                         22:22
+#define SYSTEM_CTRL_DE_STATUS_IDLE                    0
+#define SYSTEM_CTRL_DE_STATUS_BUSY                    1
+#define SYSTEM_CTRL_DE_MEM_FIFO                       21:21
+#define SYSTEM_CTRL_DE_MEM_FIFO_NOTEMPTY              0
+#define SYSTEM_CTRL_DE_MEM_FIFO_EMPTY                 1
+#define SYSTEM_CTRL_CSC_STATUS                        20:20
+#define SYSTEM_CTRL_CSC_STATUS_IDLE                   0
+#define SYSTEM_CTRL_CSC_STATUS_BUSY                   1
+#define SYSTEM_CTRL_SECONDARY_VSYNC                   19:19
+#define SYSTEM_CTRL_SECONDARY_VSYNC_INACTIVE          0
+#define SYSTEM_CTRL_SECONDARY_VSYNC_ACTIVE            1
+#define SYSTEM_CTRL_PRIMARY_VSYNC                     18:18
+#define SYSTEM_CTRL_PRIMARY_VSYNC_INACTIVE            0
+#define SYSTEM_CTRL_PRIMARY_VSYNC_ACTIVE              1
+#define SYSTEM_CTRL_CURRENT_BUFFER                    17:17
+#define SYSTEM_CTRL_CURRENT_BUFFER_NORMAL             0
+#define SYSTEM_CTRL_CURRENT_BUFFER_FLIP_PENDING       1
+#define SYSTEM_CTRL_DMA_STATUS                        16:16
+#define SYSTEM_CTRL_DMA_STATUS_IDLE                   0
+#define SYSTEM_CTRL_DMA_STATUS_BUSY                   1
+#define SYSTEM_CTRL_PCI_BURST_READ                    15:15
+#define SYSTEM_CTRL_PCI_BURST_READ_OFF                0
+#define SYSTEM_CTRL_PCI_BURST_READ_ON                 1
+#define SYSTEM_CTRL_DE_ABORT                          13:13
+#define SYSTEM_CTRL_DE_ABORT_OFF                      0
+#define SYSTEM_CTRL_DE_ABORT_ON                       1
+#define SYSTEM_CTRL_PCI_SUBSYS_ID_LOCK                11:11
+#define SYSTEM_CTRL_PCI_SUBSYS_ID_LOCK_OFF            0
+#define SYSTEM_CTRL_PCI_SUBSYS_ID_LOCK_ON             1
+#define SYSTEM_CTRL_PCI_RETRY                         7:7
+#define SYSTEM_CTRL_PCI_RETRY_ON                      0
+#define SYSTEM_CTRL_PCI_RETRY_OFF                     1
+#define SYSTEM_CTRL_PCI_SLAVE_BURST_READ_SIZE         5:4
+#define SYSTEM_CTRL_PCI_SLAVE_BURST_READ_SIZE_1       0
+#define SYSTEM_CTRL_PCI_SLAVE_BURST_READ_SIZE_2       1
+#define SYSTEM_CTRL_PCI_SLAVE_BURST_READ_SIZE_4       2
+#define SYSTEM_CTRL_PCI_SLAVE_BURST_READ_SIZE_8       3
+#define SYSTEM_CTRL_CRT_TRISTATE                      3:3
+#define SYSTEM_CTRL_CRT_TRISTATE_OFF                  0
+#define SYSTEM_CTRL_CRT_TRISTATE_ON                   1
+#define SYSTEM_CTRL_PCIMEM_TRISTATE                   2:2
+#define SYSTEM_CTRL_PCIMEM_TRISTATE_OFF               0
+#define SYSTEM_CTRL_PCIMEM_TRISTATE_ON                1
+#define SYSTEM_CTRL_LOCALMEM_TRISTATE                 1:1
+#define SYSTEM_CTRL_LOCALMEM_TRISTATE_OFF             0
+#define SYSTEM_CTRL_LOCALMEM_TRISTATE_ON              1
+#define SYSTEM_CTRL_PANEL_TRISTATE                    0:0
+#define SYSTEM_CTRL_PANEL_TRISTATE_OFF                0
+#define SYSTEM_CTRL_PANEL_TRISTATE_ON                 1
+
+#define MISC_CTRL                                     0x000004
+#define MISC_CTRL_DRAM_RERESH_COUNT                   27:27
+#define MISC_CTRL_DRAM_RERESH_COUNT_1ROW              0
+#define MISC_CTRL_DRAM_RERESH_COUNT_3ROW              1
+#define MISC_CTRL_DRAM_REFRESH_TIME                   26:25
+#define MISC_CTRL_DRAM_REFRESH_TIME_8                 0
+#define MISC_CTRL_DRAM_REFRESH_TIME_16                1
+#define MISC_CTRL_DRAM_REFRESH_TIME_32                2
+#define MISC_CTRL_DRAM_REFRESH_TIME_64                3
+#define MISC_CTRL_INT_OUTPUT                          24:24
+#define MISC_CTRL_INT_OUTPUT_NORMAL                   0
+#define MISC_CTRL_INT_OUTPUT_INVERT                   1
+#define MISC_CTRL_PLL_CLK_COUNT                       23:23
+#define MISC_CTRL_PLL_CLK_COUNT_OFF                   0
+#define MISC_CTRL_PLL_CLK_COUNT_ON                    1
+#define MISC_CTRL_DAC_POWER                           20:20
+#define MISC_CTRL_DAC_POWER_ON                        0
+#define MISC_CTRL_DAC_POWER_OFF                       1
+#define MISC_CTRL_CLK_SELECT                          16:16
+#define MISC_CTRL_CLK_SELECT_OSC                      0
+#define MISC_CTRL_CLK_SELECT_TESTCLK                  1
+#define MISC_CTRL_DRAM_COLUMN_SIZE                    15:14
+#define MISC_CTRL_DRAM_COLUMN_SIZE_256                0
+#define MISC_CTRL_DRAM_COLUMN_SIZE_512                1
+#define MISC_CTRL_DRAM_COLUMN_SIZE_1024               2
+#define MISC_CTRL_LOCALMEM_SIZE                       13:12
+#define MISC_CTRL_LOCALMEM_SIZE_8M                    3
+#define MISC_CTRL_LOCALMEM_SIZE_16M                   0
+#define MISC_CTRL_LOCALMEM_SIZE_32M                   1
+#define MISC_CTRL_LOCALMEM_SIZE_64M                   2
+#define MISC_CTRL_DRAM_TWTR                           11:11
+#define MISC_CTRL_DRAM_TWTR_2CLK                      0
+#define MISC_CTRL_DRAM_TWTR_1CLK                      1
+#define MISC_CTRL_DRAM_TWR                            10:10
+#define MISC_CTRL_DRAM_TWR_3CLK                       0
+#define MISC_CTRL_DRAM_TWR_2CLK                       1
+#define MISC_CTRL_DRAM_TRP                            9:9
+#define MISC_CTRL_DRAM_TRP_3CLK                       0
+#define MISC_CTRL_DRAM_TRP_4CLK                       1
+#define MISC_CTRL_DRAM_TRFC                           8:8
+#define MISC_CTRL_DRAM_TRFC_12CLK                     0
+#define MISC_CTRL_DRAM_TRFC_14CLK                     1
+#define MISC_CTRL_DRAM_TRAS                           7:7
+#define MISC_CTRL_DRAM_TRAS_7CLK                      0
+#define MISC_CTRL_DRAM_TRAS_8CLK                      1
+#define MISC_CTRL_LOCALMEM_RESET                      6:6
+#define MISC_CTRL_LOCALMEM_RESET_RESET                0
+#define MISC_CTRL_LOCALMEM_RESET_NORMAL               1
+#define MISC_CTRL_LOCALMEM_STATE                      5:5
+#define MISC_CTRL_LOCALMEM_STATE_ACTIVE               0
+#define MISC_CTRL_LOCALMEM_STATE_INACTIVE             1
+#define MISC_CTRL_CPU_CAS_LATENCY                     4:4
+#define MISC_CTRL_CPU_CAS_LATENCY_2CLK                0
+#define MISC_CTRL_CPU_CAS_LATENCY_3CLK                1
+#define MISC_CTRL_DLL                                 3:3
+#define MISC_CTRL_DLL_ON                              0
+#define MISC_CTRL_DLL_OFF                             1
+#define MISC_CTRL_DRAM_OUTPUT                         2:2
+#define MISC_CTRL_DRAM_OUTPUT_LOW                     0
+#define MISC_CTRL_DRAM_OUTPUT_HIGH                    1
+#define MISC_CTRL_LOCALMEM_BUS_SIZE                   1:1
+#define MISC_CTRL_LOCALMEM_BUS_SIZE_32                0
+#define MISC_CTRL_LOCALMEM_BUS_SIZE_64                1
+#define MISC_CTRL_EMBEDDED_LOCALMEM                   0:0
+#define MISC_CTRL_EMBEDDED_LOCALMEM_ON                0
+#define MISC_CTRL_EMBEDDED_LOCALMEM_OFF               1
+
+#define GPIO_MUX                                      0x000008
+#define GPIO_MUX_31                                   31:31
+#define GPIO_MUX_31_GPIO                              0
+#define GPIO_MUX_31_I2C                               1
+#define GPIO_MUX_30                                   30:30
+#define GPIO_MUX_30_GPIO                              0
+#define GPIO_MUX_30_I2C                               1
+#define GPIO_MUX_29                                   29:29
+#define GPIO_MUX_29_GPIO                              0
+#define GPIO_MUX_29_SSP1                              1
+#define GPIO_MUX_28                                   28:28
+#define GPIO_MUX_28_GPIO                              0
+#define GPIO_MUX_28_SSP1                              1
+#define GPIO_MUX_27                                   27:27
+#define GPIO_MUX_27_GPIO                              0
+#define GPIO_MUX_27_SSP1                              1
+#define GPIO_MUX_26                                   26:26
+#define GPIO_MUX_26_GPIO                              0
+#define GPIO_MUX_26_SSP1                              1
+#define GPIO_MUX_25                                   25:25
+#define GPIO_MUX_25_GPIO                              0
+#define GPIO_MUX_25_SSP1                              1
+#define GPIO_MUX_24                                   24:24
+#define GPIO_MUX_24_GPIO                              0
+#define GPIO_MUX_24_SSP0                              1
+#define GPIO_MUX_23                                   23:23
+#define GPIO_MUX_23_GPIO                              0
+#define GPIO_MUX_23_SSP0                              1
+#define GPIO_MUX_22                                   22:22
+#define GPIO_MUX_22_GPIO                              0
+#define GPIO_MUX_22_SSP0                              1
+#define GPIO_MUX_21                                   21:21
+#define GPIO_MUX_21_GPIO                              0
+#define GPIO_MUX_21_SSP0                              1
+#define GPIO_MUX_20                                   20:20
+#define GPIO_MUX_20_GPIO                              0
+#define GPIO_MUX_20_SSP0                              1
+#define GPIO_MUX_19                                   19:19
+#define GPIO_MUX_19_GPIO                              0
+#define GPIO_MUX_19_PWM                               1
+#define GPIO_MUX_18                                   18:18
+#define GPIO_MUX_18_GPIO                              0
+#define GPIO_MUX_18_PWM                               1
+#define GPIO_MUX_17                                   17:17
+#define GPIO_MUX_17_GPIO                              0
+#define GPIO_MUX_17_PWM                               1
+#define GPIO_MUX_16                                   16:16
+#define GPIO_MUX_16_GPIO_ZVPORT                       0
+#define GPIO_MUX_16_TEST_DATA                         1
+#define GPIO_MUX_15                                   15:15
+#define GPIO_MUX_15_GPIO_ZVPORT                       0
+#define GPIO_MUX_15_TEST_DATA                         1
+#define GPIO_MUX_14                                   14:14
+#define GPIO_MUX_14_GPIO_ZVPORT                       0
+#define GPIO_MUX_14_TEST_DATA                         1
+#define GPIO_MUX_13                                   13:13
+#define GPIO_MUX_13_GPIO_ZVPORT                       0
+#define GPIO_MUX_13_TEST_DATA                         1
+#define GPIO_MUX_12                                   12:12
+#define GPIO_MUX_12_GPIO_ZVPORT                       0
+#define GPIO_MUX_12_TEST_DATA                         1
+#define GPIO_MUX_11                                   11:11
+#define GPIO_MUX_11_GPIO_ZVPORT                       0
+#define GPIO_MUX_11_TEST_DATA                         1
+#define GPIO_MUX_10                                   10:10
+#define GPIO_MUX_10_GPIO_ZVPORT                       0
+#define GPIO_MUX_10_TEST_DATA                         1
+#define GPIO_MUX_9                                    9:9
+#define GPIO_MUX_9_GPIO_ZVPORT                        0
+#define GPIO_MUX_9_TEST_DATA                          1
+#define GPIO_MUX_8                                    8:8
+#define GPIO_MUX_8_GPIO_ZVPORT                        0
+#define GPIO_MUX_8_TEST_DATA                          1
+#define GPIO_MUX_7                                    7:7
+#define GPIO_MUX_7_GPIO_ZVPORT                        0
+#define GPIO_MUX_7_TEST_DATA                          1
+#define GPIO_MUX_6                                    6:6
+#define GPIO_MUX_6_GPIO_ZVPORT                        0
+#define GPIO_MUX_6_TEST_DATA                          1
+#define GPIO_MUX_5                                    5:5
+#define GPIO_MUX_5_GPIO_ZVPORT                        0
+#define GPIO_MUX_5_TEST_DATA                          1
+#define GPIO_MUX_4                                    4:4
+#define GPIO_MUX_4_GPIO_ZVPORT                        0
+#define GPIO_MUX_4_TEST_DATA                          1
+#define GPIO_MUX_3                                    3:3
+#define GPIO_MUX_3_GPIO_ZVPORT                        0
+#define GPIO_MUX_3_TEST_DATA                          1
+#define GPIO_MUX_2                                    2:2
+#define GPIO_MUX_2_GPIO_ZVPORT                        0
+#define GPIO_MUX_2_TEST_DATA                          1
+#define GPIO_MUX_1                                    1:1
+#define GPIO_MUX_1_GPIO_ZVPORT                        0
+#define GPIO_MUX_1_TEST_DATA                          1
+#define GPIO_MUX_0                                    0:0
+#define GPIO_MUX_0_GPIO_ZVPORT                        0
+#define GPIO_MUX_0_TEST_DATA                          1
+
+#define LOCALMEM_ARBITRATION                          0x00000C
+#define LOCALMEM_ARBITRATION_ROTATE                   28:28
+#define LOCALMEM_ARBITRATION_ROTATE_OFF               0
+#define LOCALMEM_ARBITRATION_ROTATE_ON                1
+#define LOCALMEM_ARBITRATION_VGA                      26:24
+#define LOCALMEM_ARBITRATION_VGA_OFF                  0
+#define LOCALMEM_ARBITRATION_VGA_PRIORITY_1           1
+#define LOCALMEM_ARBITRATION_VGA_PRIORITY_2           2
+#define LOCALMEM_ARBITRATION_VGA_PRIORITY_3           3
+#define LOCALMEM_ARBITRATION_VGA_PRIORITY_4           4
+#define LOCALMEM_ARBITRATION_VGA_PRIORITY_5           5
+#define LOCALMEM_ARBITRATION_VGA_PRIORITY_6           6
+#define LOCALMEM_ARBITRATION_VGA_PRIORITY_7           7
+#define LOCALMEM_ARBITRATION_DMA                      22:20
+#define LOCALMEM_ARBITRATION_DMA_OFF                  0
+#define LOCALMEM_ARBITRATION_DMA_PRIORITY_1           1
+#define LOCALMEM_ARBITRATION_DMA_PRIORITY_2           2
+#define LOCALMEM_ARBITRATION_DMA_PRIORITY_3           3
+#define LOCALMEM_ARBITRATION_DMA_PRIORITY_4           4
+#define LOCALMEM_ARBITRATION_DMA_PRIORITY_5           5
+#define LOCALMEM_ARBITRATION_DMA_PRIORITY_6           6
+#define LOCALMEM_ARBITRATION_DMA_PRIORITY_7           7
+#define LOCALMEM_ARBITRATION_ZVPORT1                  18:16
+#define LOCALMEM_ARBITRATION_ZVPORT1_OFF              0
+#define LOCALMEM_ARBITRATION_ZVPORT1_PRIORITY_1       1
+#define LOCALMEM_ARBITRATION_ZVPORT1_PRIORITY_2       2
+#define LOCALMEM_ARBITRATION_ZVPORT1_PRIORITY_3       3
+#define LOCALMEM_ARBITRATION_ZVPORT1_PRIORITY_4       4
+#define LOCALMEM_ARBITRATION_ZVPORT1_PRIORITY_5       5
+#define LOCALMEM_ARBITRATION_ZVPORT1_PRIORITY_6       6
+#define LOCALMEM_ARBITRATION_ZVPORT1_PRIORITY_7       7
+#define LOCALMEM_ARBITRATION_ZVPORT0                  14:12
+#define LOCALMEM_ARBITRATION_ZVPORT0_OFF              0
+#define LOCALMEM_ARBITRATION_ZVPORT0_PRIORITY_1       1
+#define LOCALMEM_ARBITRATION_ZVPORT0_PRIORITY_2       2
+#define LOCALMEM_ARBITRATION_ZVPORT0_PRIORITY_3       3
+#define LOCALMEM_ARBITRATION_ZVPORT0_PRIORITY_4       4
+#define LOCALMEM_ARBITRATION_ZVPORT0_PRIORITY_5       5
+#define LOCALMEM_ARBITRATION_ZVPORT0_PRIORITY_6       6
+#define LOCALMEM_ARBITRATION_ZVPORT0_PRIORITY_7       7
+#define LOCALMEM_ARBITRATION_VIDEO                    10:8
+#define LOCALMEM_ARBITRATION_VIDEO_OFF                0
+#define LOCALMEM_ARBITRATION_VIDEO_PRIORITY_1         1
+#define LOCALMEM_ARBITRATION_VIDEO_PRIORITY_2         2
+#define LOCALMEM_ARBITRATION_VIDEO_PRIORITY_3         3
+#define LOCALMEM_ARBITRATION_VIDEO_PRIORITY_4         4
+#define LOCALMEM_ARBITRATION_VIDEO_PRIORITY_5         5
+#define LOCALMEM_ARBITRATION_VIDEO_PRIORITY_6         6
+#define LOCALMEM_ARBITRATION_VIDEO_PRIORITY_7         7
+#define LOCALMEM_ARBITRATION_PANEL                    6:4
+#define LOCALMEM_ARBITRATION_PANEL_OFF                0
+#define LOCALMEM_ARBITRATION_PANEL_PRIORITY_1         1
+#define LOCALMEM_ARBITRATION_PANEL_PRIORITY_2         2
+#define LOCALMEM_ARBITRATION_PANEL_PRIORITY_3         3
+#define LOCALMEM_ARBITRATION_PANEL_PRIORITY_4         4
+#define LOCALMEM_ARBITRATION_PANEL_PRIORITY_5         5
+#define LOCALMEM_ARBITRATION_PANEL_PRIORITY_6         6
+#define LOCALMEM_ARBITRATION_PANEL_PRIORITY_7         7
+#define LOCALMEM_ARBITRATION_CRT                      2:0
+#define LOCALMEM_ARBITRATION_CRT_OFF                  0
+#define LOCALMEM_ARBITRATION_CRT_PRIORITY_1           1
+#define LOCALMEM_ARBITRATION_CRT_PRIORITY_2           2
+#define LOCALMEM_ARBITRATION_CRT_PRIORITY_3           3
+#define LOCALMEM_ARBITRATION_CRT_PRIORITY_4           4
+#define LOCALMEM_ARBITRATION_CRT_PRIORITY_5           5
+#define LOCALMEM_ARBITRATION_CRT_PRIORITY_6           6
+#define LOCALMEM_ARBITRATION_CRT_PRIORITY_7           7
+
+#define PCIMEM_ARBITRATION                            0x000010
+#define PCIMEM_ARBITRATION_ROTATE                     28:28
+#define PCIMEM_ARBITRATION_ROTATE_OFF                 0
+#define PCIMEM_ARBITRATION_ROTATE_ON                  1
+#define PCIMEM_ARBITRATION_VGA                        26:24
+#define PCIMEM_ARBITRATION_VGA_OFF                    0
+#define PCIMEM_ARBITRATION_VGA_PRIORITY_1             1
+#define PCIMEM_ARBITRATION_VGA_PRIORITY_2             2
+#define PCIMEM_ARBITRATION_VGA_PRIORITY_3             3
+#define PCIMEM_ARBITRATION_VGA_PRIORITY_4             4
+#define PCIMEM_ARBITRATION_VGA_PRIORITY_5             5
+#define PCIMEM_ARBITRATION_VGA_PRIORITY_6             6
+#define PCIMEM_ARBITRATION_VGA_PRIORITY_7             7
+#define PCIMEM_ARBITRATION_DMA                        22:20
+#define PCIMEM_ARBITRATION_DMA_OFF                    0
+#define PCIMEM_ARBITRATION_DMA_PRIORITY_1             1
+#define PCIMEM_ARBITRATION_DMA_PRIORITY_2             2
+#define PCIMEM_ARBITRATION_DMA_PRIORITY_3             3
+#define PCIMEM_ARBITRATION_DMA_PRIORITY_4             4
+#define PCIMEM_ARBITRATION_DMA_PRIORITY_5             5
+#define PCIMEM_ARBITRATION_DMA_PRIORITY_6             6
+#define PCIMEM_ARBITRATION_DMA_PRIORITY_7             7
+#define PCIMEM_ARBITRATION_ZVPORT1                    18:16
+#define PCIMEM_ARBITRATION_ZVPORT1_OFF                0
+#define PCIMEM_ARBITRATION_ZVPORT1_PRIORITY_1         1
+#define PCIMEM_ARBITRATION_ZVPORT1_PRIORITY_2         2
+#define PCIMEM_ARBITRATION_ZVPORT1_PRIORITY_3         3
+#define PCIMEM_ARBITRATION_ZVPORT1_PRIORITY_4         4
+#define PCIMEM_ARBITRATION_ZVPORT1_PRIORITY_5         5
+#define PCIMEM_ARBITRATION_ZVPORT1_PRIORITY_6         6
+#define PCIMEM_ARBITRATION_ZVPORT1_PRIORITY_7         7
+#define PCIMEM_ARBITRATION_ZVPORT0                    14:12
+#define PCIMEM_ARBITRATION_ZVPORT0_OFF                0
+#define PCIMEM_ARBITRATION_ZVPORT0_PRIORITY_1         1
+#define PCIMEM_ARBITRATION_ZVPORT0_PRIORITY_2         2
+#define PCIMEM_ARBITRATION_ZVPORT0_PRIORITY_3         3
+#define PCIMEM_ARBITRATION_ZVPORT0_PRIORITY_4         4
+#define PCIMEM_ARBITRATION_ZVPORT0_PRIORITY_5         5
+#define PCIMEM_ARBITRATION_ZVPORT0_PRIORITY_6         6
+#define PCIMEM_ARBITRATION_ZVPORT0_PRIORITY_7         7
+#define PCIMEM_ARBITRATION_VIDEO                      10:8
+#define PCIMEM_ARBITRATION_VIDEO_OFF                  0
+#define PCIMEM_ARBITRATION_VIDEO_PRIORITY_1           1
+#define PCIMEM_ARBITRATION_VIDEO_PRIORITY_2           2
+#define PCIMEM_ARBITRATION_VIDEO_PRIORITY_3           3
+#define PCIMEM_ARBITRATION_VIDEO_PRIORITY_4           4
+#define PCIMEM_ARBITRATION_VIDEO_PRIORITY_5           5
+#define PCIMEM_ARBITRATION_VIDEO_PRIORITY_6           6
+#define PCIMEM_ARBITRATION_VIDEO_PRIORITY_7           7
+#define PCIMEM_ARBITRATION_PANEL                      6:4
+#define PCIMEM_ARBITRATION_PANEL_OFF                  0
+#define PCIMEM_ARBITRATION_PANEL_PRIORITY_1           1
+#define PCIMEM_ARBITRATION_PANEL_PRIORITY_2           2
+#define PCIMEM_ARBITRATION_PANEL_PRIORITY_3           3
+#define PCIMEM_ARBITRATION_PANEL_PRIORITY_4           4
+#define PCIMEM_ARBITRATION_PANEL_PRIORITY_5           5
+#define PCIMEM_ARBITRATION_PANEL_PRIORITY_6           6
+#define PCIMEM_ARBITRATION_PANEL_PRIORITY_7           7
+#define PCIMEM_ARBITRATION_CRT                        2:0
+#define PCIMEM_ARBITRATION_CRT_OFF                    0
+#define PCIMEM_ARBITRATION_CRT_PRIORITY_1             1
+#define PCIMEM_ARBITRATION_CRT_PRIORITY_2             2
+#define PCIMEM_ARBITRATION_CRT_PRIORITY_3             3
+#define PCIMEM_ARBITRATION_CRT_PRIORITY_4             4
+#define PCIMEM_ARBITRATION_CRT_PRIORITY_5             5
+#define PCIMEM_ARBITRATION_CRT_PRIORITY_6             6
+#define PCIMEM_ARBITRATION_CRT_PRIORITY_7             7
+
+#define RAW_INT                                       0x000020
+#define RAW_INT_ZVPORT1_VSYNC                         4:4
+#define RAW_INT_ZVPORT1_VSYNC_INACTIVE                0
+#define RAW_INT_ZVPORT1_VSYNC_ACTIVE                  1
+#define RAW_INT_ZVPORT1_VSYNC_CLEAR                   1
+#define RAW_INT_ZVPORT0_VSYNC                         3:3
+#define RAW_INT_ZVPORT0_VSYNC_INACTIVE                0
+#define RAW_INT_ZVPORT0_VSYNC_ACTIVE                  1
+#define RAW_INT_ZVPORT0_VSYNC_CLEAR                   1
+#define RAW_INT_SECONDARY_VSYNC                       2:2
+#define RAW_INT_SECONDARY_VSYNC_INACTIVE              0
+#define RAW_INT_SECONDARY_VSYNC_ACTIVE                1
+#define RAW_INT_SECONDARY_VSYNC_CLEAR                 1
+#define RAW_INT_PRIMARY_VSYNC                         1:1
+#define RAW_INT_PRIMARY_VSYNC_INACTIVE                0
+#define RAW_INT_PRIMARY_VSYNC_ACTIVE                  1
+#define RAW_INT_PRIMARY_VSYNC_CLEAR                   1
+#define RAW_INT_VGA_VSYNC                             0:0
+#define RAW_INT_VGA_VSYNC_INACTIVE                    0
+#define RAW_INT_VGA_VSYNC_ACTIVE                      1
+#define RAW_INT_VGA_VSYNC_CLEAR                       1
+
+#define INT_STATUS                                    0x000024
+#define INT_STATUS_GPIO31                             31:31
+#define INT_STATUS_GPIO31_INACTIVE                    0
+#define INT_STATUS_GPIO31_ACTIVE                      1
+#define INT_STATUS_GPIO30                             30:30
+#define INT_STATUS_GPIO30_INACTIVE                    0
+#define INT_STATUS_GPIO30_ACTIVE                      1
+#define INT_STATUS_GPIO29                             29:29
+#define INT_STATUS_GPIO29_INACTIVE                    0
+#define INT_STATUS_GPIO29_ACTIVE                      1
+#define INT_STATUS_GPIO28                             28:28
+#define INT_STATUS_GPIO28_INACTIVE                    0
+#define INT_STATUS_GPIO28_ACTIVE                      1
+#define INT_STATUS_GPIO27                             27:27
+#define INT_STATUS_GPIO27_INACTIVE                    0
+#define INT_STATUS_GPIO27_ACTIVE                      1
+#define INT_STATUS_GPIO26                             26:26
+#define INT_STATUS_GPIO26_INACTIVE                    0
+#define INT_STATUS_GPIO26_ACTIVE                      1
+#define INT_STATUS_GPIO25                             25:25
+#define INT_STATUS_GPIO25_INACTIVE                    0
+#define INT_STATUS_GPIO25_ACTIVE                      1
+#define INT_STATUS_I2C                                12:12
+#define INT_STATUS_I2C_INACTIVE                       0
+#define INT_STATUS_I2C_ACTIVE                         1
+#define INT_STATUS_PWM                                11:11
+#define INT_STATUS_PWM_INACTIVE                       0
+#define INT_STATUS_PWM_ACTIVE                         1
+#if 1   /* SM750 new definition (DMA0 is removed in SM750), therefore, the interrupt is
+           moved to the DMA0 location.
+         */
+    #define INT_STATUS_DMA1                           9:9
+    #define INT_STATUS_DMA1_INACTIVE                  0
+    #define INT_STATUS_DMA1_ACTIVE                    1
+#else
+    #define INT_STATUS_DMA1                           10:10
+    #define INT_STATUS_DMA1_INACTIVE                  0
+    #define INT_STATUS_DMA1_ACTIVE                    1
+    #define INT_STATUS_DMA0                           9:9
+    #define INT_STATUS_DMA0_INACTIVE                  0
+    #define INT_STATUS_DMA0_ACTIVE                    1
+#endif
+#define INT_STATUS_PCI                                8:8
+#define INT_STATUS_PCI_INACTIVE                       0
+#define INT_STATUS_PCI_ACTIVE                         1
+#define INT_STATUS_SSP1                               7:7
+#define INT_STATUS_SSP1_INACTIVE                      0
+#define INT_STATUS_SSP1_ACTIVE                        1
+#define INT_STATUS_SSP0                               6:6
+#define INT_STATUS_SSP0_INACTIVE                      0
+#define INT_STATUS_SSP0_ACTIVE                        1
+#define INT_STATUS_DE                                 5:5
+#define INT_STATUS_DE_INACTIVE                        0
+#define INT_STATUS_DE_ACTIVE                          1
+#define INT_STATUS_ZVPORT1_VSYNC                      4:4
+#define INT_STATUS_ZVPORT1_VSYNC_INACTIVE             0
+#define INT_STATUS_ZVPORT1_VSYNC_ACTIVE               1
+#define INT_STATUS_ZVPORT0_VSYNC                      3:3
+#define INT_STATUS_ZVPORT0_VSYNC_INACTIVE             0
+#define INT_STATUS_ZVPORT0_VSYNC_ACTIVE               1
+#define INT_STATUS_SECONDARY_VSYNC                    2:2
+#define INT_STATUS_SECONDARY_VSYNC_INACTIVE           0
+#define INT_STATUS_SECONDARY_VSYNC_ACTIVE             1
+#define INT_STATUS_PRIMARY_VSYNC                      1:1
+#define INT_STATUS_PRIMARY_VSYNC_INACTIVE             0
+#define INT_STATUS_PRIMARY_VSYNC_ACTIVE               1
+#define INT_STATUS_VGA_VSYNC                          0:0
+#define INT_STATUS_VGA_VSYNC_INACTIVE                 0
+#define INT_STATUS_VGA_VSYNC_ACTIVE                   1
+
+#define INT_MASK                                      0x000028
+#define INT_MASK_GPIO31                               31:31
+#define INT_MASK_GPIO31_DISABLE                       0
+#define INT_MASK_GPIO31_ENABLE                        1
+#define INT_MASK_GPIO30                               30:30
+#define INT_MASK_GPIO30_DISABLE                       0
+#define INT_MASK_GPIO30_ENABLE                        1
+#define INT_MASK_GPIO29                               29:29
+#define INT_MASK_GPIO29_DISABLE                       0
+#define INT_MASK_GPIO29_ENABLE                        1
+#define INT_MASK_GPIO28                               28:28
+#define INT_MASK_GPIO28_DISABLE                       0
+#define INT_MASK_GPIO28_ENABLE                        1
+#define INT_MASK_GPIO27                               27:27
+#define INT_MASK_GPIO27_DISABLE                       0
+#define INT_MASK_GPIO27_ENABLE                        1
+#define INT_MASK_GPIO26                               26:26
+#define INT_MASK_GPIO26_DISABLE                       0
+#define INT_MASK_GPIO26_ENABLE                        1
+#define INT_MASK_GPIO25                               25:25
+#define INT_MASK_GPIO25_DISABLE                       0
+#define INT_MASK_GPIO25_ENABLE                        1
+#define INT_MASK_I2C                                  12:12
+#define INT_MASK_I2C_DISABLE                          0
+#define INT_MASK_I2C_ENABLE                           1
+#define INT_MASK_PWM                                  11:11
+#define INT_MASK_PWM_DISABLE                          0
+#define INT_MASK_PWM_ENABLE                           1
+#if 1   /* SM750 new definition (DMA0 is removed in SM750), therefore, the interrupt is
+           moved to the DMA0 location.
+         */
+    #define INT_MASK_DMA1                             9:9
+    #define INT_MASK_DMA1_DISABLE                     0
+    #define INT_MASK_DMA1_ENABLE                      1
+#else
+    #define INT_MASK_DMA1                             10:10
+    #define INT_MASK_DMA1_DISABLE                     0
+    #define INT_MASK_DMA1_ENABLE                      1
+    #define INT_MASK_DMA                              9:9
+    #define INT_MASK_DMA_DISABLE                      0
+    #define INT_MASK_DMA_ENABLE                       1
+#endif
+#define INT_MASK_PCI                                  8:8
+#define INT_MASK_PCI_DISABLE                          0
+#define INT_MASK_PCI_ENABLE                           1
+#define INT_MASK_SSP1                                 7:7
+#define INT_MASK_SSP1_DISABLE                         0
+#define INT_MASK_SSP1_ENABLE                          1
+#define INT_MASK_SSP0                                 6:6
+#define INT_MASK_SSP0_DISABLE                         0
+#define INT_MASK_SSP0_ENABLE                          1
+#define INT_MASK_DE                                   5:5
+#define INT_MASK_DE_DISABLE                           0
+#define INT_MASK_DE_ENABLE                            1
+#define INT_MASK_ZVPORT1_VSYNC                        4:4
+#define INT_MASK_ZVPORT1_VSYNC_DISABLE                0
+#define INT_MASK_ZVPORT1_VSYNC_ENABLE                 1
+#define INT_MASK_ZVPORT0_VSYNC                        3:3
+#define INT_MASK_ZVPORT0_VSYNC_DISABLE                0
+#define INT_MASK_ZVPORT0_VSYNC_ENABLE                 1
+#define INT_MASK_SECONDARY_VSYNC                      2:2
+#define INT_MASK_SECONDARY_VSYNC_DISABLE              0
+#define INT_MASK_SECONDARY_VSYNC_ENABLE               1
+#define INT_MASK_PRIMARY_VSYNC                        1:1
+#define INT_MASK_PRIMARY_VSYNC_DISABLE                0
+#define INT_MASK_PRIMARY_VSYNC_ENABLE                 1
+#define INT_MASK_VGA_VSYNC                            0:0
+#define INT_MASK_VGA_VSYNC_DISABLE                    0
+#define INT_MASK_VGA_VSYNC_ENABLE                     1
+
+#define CURRENT_GATE                                  0x000040
+#define CURRENT_GATE_MCLK                             15:14
+#define CURRENT_GATE_MCLK_DIV_3                       0
+#define CURRENT_GATE_MCLK_DIV_4                       1
+#define CURRENT_GATE_MCLK_DIV_6                       2
+#define CURRENT_GATE_MCLK_DIV_8                       3
+#define CURRENT_GATE_M2XCLK                           13:12
+#define CURRENT_GATE_M2XCLK_DIV_1                     0
+#define CURRENT_GATE_M2XCLK_DIV_2                     1
+#define CURRENT_GATE_M2XCLK_DIV_3                     2
+#define CURRENT_GATE_M2XCLK_DIV_4                     3
+#define CURRENT_GATE_VGA                              10:10
+#define CURRENT_GATE_VGA_OFF                          0
+#define CURRENT_GATE_VGA_ON                           1
+#define CURRENT_GATE_PWM                              9:9
+#define CURRENT_GATE_PWM_OFF                          0
+#define CURRENT_GATE_PWM_ON                           1
+#define CURRENT_GATE_I2C                              8:8
+#define CURRENT_GATE_I2C_OFF                          0
+#define CURRENT_GATE_I2C_ON                           1
+#define CURRENT_GATE_SSP                              7:7
+#define CURRENT_GATE_SSP_OFF                          0
+#define CURRENT_GATE_SSP_ON                           1
+#define CURRENT_GATE_GPIO                             6:6
+#define CURRENT_GATE_GPIO_OFF                         0
+#define CURRENT_GATE_GPIO_ON                          1
+#define CURRENT_GATE_ZVPORT                           5:5
+#define CURRENT_GATE_ZVPORT_OFF                       0
+#define CURRENT_GATE_ZVPORT_ON                        1
+#define CURRENT_GATE_CSC                              4:4
+#define CURRENT_GATE_CSC_OFF                          0
+#define CURRENT_GATE_CSC_ON                           1
+#define CURRENT_GATE_DE                               3:3
+#define CURRENT_GATE_DE_OFF                           0
+#define CURRENT_GATE_DE_ON                            1
+#define CURRENT_GATE_DISPLAY                          2:2
+#define CURRENT_GATE_DISPLAY_OFF                      0
+#define CURRENT_GATE_DISPLAY_ON                       1
+#define CURRENT_GATE_LOCALMEM                         1:1
+#define CURRENT_GATE_LOCALMEM_OFF                     0
+#define CURRENT_GATE_LOCALMEM_ON                      1
+#define CURRENT_GATE_DMA                              0:0
+#define CURRENT_GATE_DMA_OFF                          0
+#define CURRENT_GATE_DMA_ON                           1
+
+#define MODE0_GATE                                    0x000044
+#define MODE0_GATE_MCLK                               15:14
+#define MODE0_GATE_MCLK_112MHZ                        0
+#define MODE0_GATE_MCLK_84MHZ                         1
+#define MODE0_GATE_MCLK_56MHZ                         2
+#define MODE0_GATE_MCLK_42MHZ                         3
+#define MODE0_GATE_M2XCLK                             13:12
+#define MODE0_GATE_M2XCLK_336MHZ                      0
+#define MODE0_GATE_M2XCLK_168MHZ                      1
+#define MODE0_GATE_M2XCLK_112MHZ                      2
+#define MODE0_GATE_M2XCLK_84MHZ                       3
+#define MODE0_GATE_VGA                                10:10
+#define MODE0_GATE_VGA_OFF                            0
+#define MODE0_GATE_VGA_ON                             1
+#define MODE0_GATE_PWM                                9:9
+#define MODE0_GATE_PWM_OFF                            0
+#define MODE0_GATE_PWM_ON                             1
+#define MODE0_GATE_I2C                                8:8
+#define MODE0_GATE_I2C_OFF                            0
+#define MODE0_GATE_I2C_ON                             1
+#define MODE0_GATE_SSP                                7:7
+#define MODE0_GATE_SSP_OFF                            0
+#define MODE0_GATE_SSP_ON                             1
+#define MODE0_GATE_GPIO                               6:6
+#define MODE0_GATE_GPIO_OFF                           0
+#define MODE0_GATE_GPIO_ON                            1
+#define MODE0_GATE_ZVPORT                             5:5
+#define MODE0_GATE_ZVPORT_OFF                         0
+#define MODE0_GATE_ZVPORT_ON                          1
+#define MODE0_GATE_CSC                                4:4
+#define MODE0_GATE_CSC_OFF                            0
+#define MODE0_GATE_CSC_ON                             1
+#define MODE0_GATE_DE                                 3:3
+#define MODE0_GATE_DE_OFF                             0
+#define MODE0_GATE_DE_ON                              1
+#define MODE0_GATE_DISPLAY                            2:2
+#define MODE0_GATE_DISPLAY_OFF                        0
+#define MODE0_GATE_DISPLAY_ON                         1
+#define MODE0_GATE_LOCALMEM                           1:1
+#define MODE0_GATE_LOCALMEM_OFF                       0
+#define MODE0_GATE_LOCALMEM_ON                        1
+#define MODE0_GATE_DMA                                0:0
+#define MODE0_GATE_DMA_OFF                            0
+#define MODE0_GATE_DMA_ON                             1
+
+#define MODE1_GATE                                    0x000048
+#define MODE1_GATE_MCLK                               15:14
+#define MODE1_GATE_MCLK_112MHZ                        0
+#define MODE1_GATE_MCLK_84MHZ                         1
+#define MODE1_GATE_MCLK_56MHZ                         2
+#define MODE1_GATE_MCLK_42MHZ                         3
+#define MODE1_GATE_M2XCLK                             13:12
+#define MODE1_GATE_M2XCLK_336MHZ                      0
+#define MODE1_GATE_M2XCLK_168MHZ                      1
+#define MODE1_GATE_M2XCLK_112MHZ                      2
+#define MODE1_GATE_M2XCLK_84MHZ                       3
+#define MODE1_GATE_VGA                                10:10
+#define MODE1_GATE_VGA_OFF                            0
+#define MODE1_GATE_VGA_ON                             1
+#define MODE1_GATE_PWM                                9:9
+#define MODE1_GATE_PWM_OFF                            0
+#define MODE1_GATE_PWM_ON                             1
+#define MODE1_GATE_I2C                                8:8
+#define MODE1_GATE_I2C_OFF                            0
+#define MODE1_GATE_I2C_ON                             1
+#define MODE1_GATE_SSP                                7:7
+#define MODE1_GATE_SSP_OFF                            0
+#define MODE1_GATE_SSP_ON                             1
+#define MODE1_GATE_GPIO                               6:6
+#define MODE1_GATE_GPIO_OFF                           0
+#define MODE1_GATE_GPIO_ON                            1
+#define MODE1_GATE_ZVPORT                             5:5
+#define MODE1_GATE_ZVPORT_OFF                         0
+#define MODE1_GATE_ZVPORT_ON                          1
+#define MODE1_GATE_CSC                                4:4
+#define MODE1_GATE_CSC_OFF                            0
+#define MODE1_GATE_CSC_ON                             1
+#define MODE1_GATE_DE                                 3:3
+#define MODE1_GATE_DE_OFF                             0
+#define MODE1_GATE_DE_ON                              1
+#define MODE1_GATE_DISPLAY                            2:2
+#define MODE1_GATE_DISPLAY_OFF                        0
+#define MODE1_GATE_DISPLAY_ON                         1
+#define MODE1_GATE_LOCALMEM                           1:1
+#define MODE1_GATE_LOCALMEM_OFF                       0
+#define MODE1_GATE_LOCALMEM_ON                        1
+#define MODE1_GATE_DMA                                0:0
+#define MODE1_GATE_DMA_OFF                            0
+#define MODE1_GATE_DMA_ON                             1
+
+#define POWER_MODE_CTRL                               0x00004C
+#define POWER_MODE_CTRL_OSC_INPUT                     3:3
+#define POWER_MODE_CTRL_OSC_INPUT_OFF                 0
+#define POWER_MODE_CTRL_OSC_INPUT_ON                  1
+#define POWER_MODE_CTRL_ACPI                          2:2
+#define POWER_MODE_CTRL_ACPI_OFF                      0
+#define POWER_MODE_CTRL_ACPI_ON                       1
+#define POWER_MODE_CTRL_MODE                          1:0
+#define POWER_MODE_CTRL_MODE_MODE0                    0
+#define POWER_MODE_CTRL_MODE_MODE1                    1
+#define POWER_MODE_CTRL_MODE_SLEEP                    2
+
+/* This definition is for SM750 */
+#define PCI_MASTER_BASE                               0x000050
+#define PCI_MASTER_BASE_ADDRESS                       7:0
+
+/* This definition is for SM718 */
+#define SM718_PCI_MASTER_BASE                         0x000050
+#define SM718_PCI_MASTER_BASE_ADDRESS                 31:20
+
+#define DEVICE_ID                                     0x000054
+#define DEVICE_ID_DEVICE_ID                           31:16
+#define DEVICE_ID_REVISION_ID                         7:0
+
+#define PLL_CLK_COUNT                                 0x000058
+#define PLL_CLK_COUNT_COUNTER                         15:0
+
+#define PRIMARY_PLL_CTRL                              0x00005C
+#define PRIMARY_PLL_CTRL_BYPASS                       18:18
+#define PRIMARY_PLL_CTRL_BYPASS_OFF                   0
+#define PRIMARY_PLL_CTRL_BYPASS_ON                    1
+#define PRIMARY_PLL_CTRL_POWER                        17:17
+#define PRIMARY_PLL_CTRL_POWER_OFF                    0
+#define PRIMARY_PLL_CTRL_POWER_ON                     1
+#define PRIMARY_PLL_CTRL_INPUT                        16:16
+#define PRIMARY_PLL_CTRL_INPUT_OSC                    0
+#define PRIMARY_PLL_CTRL_INPUT_TESTCLK                1
+#define PRIMARY_PLL_CTRL_POD                          15:14
+#define PRIMARY_PLL_CTRL_OD                           13:12
+#define PRIMARY_PLL_CTRL_N                            11:8
+#define PRIMARY_PLL_CTRL_M                            7:0
+
+#define SECONDARY_PLL_CTRL                            0x000060
+#define SECONDARY_PLL_CTRL_BYPASS                     18:18
+#define SECONDARY_PLL_CTRL_BYPASS_OFF                 0
+#define SECONDARY_PLL_CTRL_BYPASS_ON                  1
+#define SECONDARY_PLL_CTRL_POWER                      17:17
+#define SECONDARY_PLL_CTRL_POWER_OFF                  0
+#define SECONDARY_PLL_CTRL_POWER_ON                   1
+#define SECONDARY_PLL_CTRL_INPUT                      16:16
+#define SECONDARY_PLL_CTRL_INPUT_OSC                  0
+#define SECONDARY_PLL_CTRL_INPUT_TESTCLK              1
+#define SECONDARY_PLL_CTRL_POD                        15:14
+#define SECONDARY_PLL_CTRL_OD                         13:12    
+#define SECONDARY_PLL_CTRL_N                          11:8
+#define SECONDARY_PLL_CTRL_M                          7:0
+
+#define VGA_PLL0_CTRL                                 0x000064
+#define VGA_PLL0_CTRL_BYPASS                          18:18
+#define VGA_PLL0_CTRL_BYPASS_OFF                      0
+#define VGA_PLL0_CTRL_BYPASS_ON                       1
+#define VGA_PLL0_CTRL_POWER                           17:17
+#define VGA_PLL0_CTRL_POWER_OFF                       0
+#define VGA_PLL0_CTRL_POWER_ON                        1
+#define VGA_PLL0_CTRL_INPUT                           16:16
+#define VGA_PLL0_CTRL_INPUT_OSC                       0
+#define VGA_PLL0_CTRL_INPUT_TESTCLK                   1
+#define VGA_PLL0_CTRL_POD                             15:14
+#define VGA_PLL0_CTRL_OD                              13:12
+#define VGA_PLL0_CTRL_N                               11:8
+#define VGA_PLL0_CTRL_M                               7:0
+
+#define VGA_PLL1_CTRL                                 0x000068
+#define VGA_PLL1_CTRL_BYPASS                          18:18
+#define VGA_PLL1_CTRL_BYPASS_OFF                      0
+#define VGA_PLL1_CTRL_BYPASS_ON                       1
+#define VGA_PLL1_CTRL_POWER                           17:17
+#define VGA_PLL1_CTRL_POWER_OFF                       0
+#define VGA_PLL1_CTRL_POWER_ON                        1
+#define VGA_PLL1_CTRL_INPUT                           16:16
+#define VGA_PLL1_CTRL_INPUT_OSC                       0
+#define VGA_PLL1_CTRL_INPUT_TESTCLK                   1
+#define VGA_PLL1_CTRL_POD                             15:14
+#define VGA_PLL1_CTRL_OD                              13:12
+#define VGA_PLL1_CTRL_N                               11:8
+#define VGA_PLL1_CTRL_M                               7:0
+#define VGA_PLL1_MASK                                 0x00FFFFFF
+
+/* Use peekRegisterByte to access this scratch data */
+#define SCRATCH_DATA                                  0x00006b
+/* The following register is used by HW */
+/*#define SCRATCH_DATA                                  0x00006c*/
+
+#define MXCLK_PLL_CTRL                                0x000070
+#define MXCLK_PLL_CTRL_BYPASS                         18:18
+#define MXCLK_PLL_CTRL_BYPASS_OFF                     0
+#define MXCLK_PLL_CTRL_BYPASS_ON                      1
+#define MXCLK_PLL_CTRL_POWER                          17:17
+#define MXCLK_PLL_CTRL_POWER_OFF                      0
+#define MXCLK_PLL_CTRL_POWER_ON                       1
+#define MXCLK_PLL_CTRL_INPUT                          16:16
+#define MXCLK_PLL_CTRL_INPUT_OSC                      0
+#define MXCLK_PLL_CTRL_INPUT_TESTCLK                  1
+#define MXCLK_PLL_CTRL_POD                            15:14
+#define MXCLK_PLL_CTRL_OD                             13:12
+#define MXCLK_PLL_CTRL_N                              11:8
+#define MXCLK_PLL_CTRL_M                              7:0
+
+/* Host Interface registers support. Only applies to SM718 */
+#define HOST_INTERFACE                                0x000074
+#define HOST_INTERFACE_NON_CACHE_ADDRESS              30:17
+/* The following status is read-only. 
+   When SM718 is transitioning back from sleep mode to normal mode, software needs 
+   to poll this bit until it becomes "0" before writing any other command to the chip. */
+#define HOST_INTERFACE_STATUS                         16:16
+#define HOST_INTERFACE_STATUS_NORMAL                  0
+#define HOST_INTERFACE_STATUS_SLEEP                   1
+#define HOST_INTERFACE_CPU                            15:15
+#define HOST_INTERFACE_CPU_32BIT                      0
+#define HOST_INTERFACE_CPU_16BIT                      1
+#define HOST_INTERFACE_XSCALE_INPUT_SOURCE            14:14
+#define HOST_INTERFACE_XSCALE_INPUT_SOURCE_PLL        0
+#define HOST_INTERFACE_XSCALE_INPUT_SOURCE_HCLK       1
+#define HOST_INTERFACE_ENDIAN                         7:7
+#define HOST_INTERFACE_ENDIAN_LITTLE                  0
+#define HOST_INTERFACE_ENDIAN_BIG                     1
+/* The following polarity is determined by GPIO20 pin at reset */
+#define HOST_INTERFACE_HITACHI_POLARITY               6:6
+#define HOST_INTERFACE_HITACHI_POLARITY_ACTIVE_LOW    0
+#define HOST_INTERFACE_HITACHI_POLARITY_ACTIVE_HIGH   1
+#define HOST_INTERFACE_NEC_MEMORY_MAP_LOCATION        5:5
+#define HOST_INTERFACE_NEC_MEMORY_MAP_LOCATION_30MB   0
+#define HOST_INTERFACE_NEC_MEMORY_MAP_LOCATION_62MB   1
+#define HOST_INTERFACE_SH4_READY                      4:3
+#define HOST_INTERFACE_SH4_READY_ONE_CLOCK            0
+#define HOST_INTERFACE_SH4_READY_TWO_CLOCKS           1
+#define HOST_INTERFACE_SH4_READY_CS_CONTROL           2
+/* The following bus type is determined by GPIO19, GPIO18, and GPIO17 pins at reset */
+#define HOST_INTERFACE_BUS_TYPE                       2:0
+#define HOST_INTERFACE_BUS_TYPE_HITACHI_SH3_SH4       0
+#define HOST_INTERFACE_BUS_TYPE_PCI                   1
+#define HOST_INTERFACE_BUS_TYPE_INTEL_XSCALE          2
+#define HOST_INTERFACE_BUS_TYPE_NEC                   6
+
+/* System memory register. Only applies to SM718 */
+#define SYSTEM_MEMORY                                 0x000078
+/* Extend the bus holding when SM718 is a host bust master to access system SDRAM. */
+#define SYSTEM_MEMORY_HOST_BUS_HOLDING_EXT            23:20
+#define SYSTEM_MEMORY_HOST_BUS_HOLDING_EXT_0          0
+#define SYSTEM_MEMORY_HOST_BUS_HOLDING_EXT_16         1
+#define SYSTEM_MEMORY_HOST_BUS_HOLDING_EXT_32         2
+#define SYSTEM_MEMORY_HOST_BUS_HOLDING_EXT_48         3
+#define SYSTEM_MEMORY_HOST_BUS_HOLDING_EXT_64         4
+#define SYSTEM_MEMORY_HOST_BUS_HOLDING_EXT_80         5
+#define SYSTEM_MEMORY_HOST_BUS_HOLDING_EXT_96         6
+#define SYSTEM_MEMORY_HOST_BUS_HOLDING_EXT_112        7
+#define SYSTEM_MEMORY_BURST_LENGTH                    19:17
+#define SYSTEM_MEMORY_BURST_LENGTH_1_WORD             0
+#define SYSTEM_MEMORY_BURST_LENGTH_2_WORDS            1
+#define SYSTEM_MEMORY_BURST_LENGTH_4_WORDS            2
+#define SYSTEM_MEMORY_BURST_LENGTH_8_WORDS            3
+#define SYSTEM_MEMORY_CAS_LATENCY                     16:16
+#define SYSTEM_MEMORY_CAS_LATENCY_2_CLOCKS            0
+#define SYSTEM_MEMORY_CAS_LATENCY_3_CLOCKS            1
+#define SYSTEM_MEMORY_BUS_HOLD_TIME                   15:13
+#define SYSTEM_MEMORY_BUS_HOLD_TIME_FIFO_EMPTY        0
+#define SYSTEM_MEMORY_BUS_HOLD_TIME_8_TRANSACTIONS    1
+#define SYSTEM_MEMORY_BUS_HOLD_TIME_16_TRANSACTIONS   2
+#define SYSTEM_MEMORY_BUS_HOLD_TIME_24_TRANSACTIONS   3
+#define SYSTEM_MEMORY_BUS_HOLD_TIME_32_TRANSACTIONS   4
+#define SYSTEM_MEMORY_COLUMN_SIZE                     12:11
+#define SYSTEM_MEMORY_COLUMN_SIZE_1024_WORDS          0
+#define SYSTEM_MEMORY_COLUMN_SIZE_512_WORDS           2
+#define SYSTEM_MEMORY_COLUMN_SIZE_256_WORDS           3
+#define SYSTEM_MEMORY_SIZE                            10:8
+#define SYSTEM_MEMORY_SIZE_2MB                        0
+#define SYSTEM_MEMORY_SIZE_4MB                        1
+#define SYSTEM_MEMORY_SIZE_64MB                       4
+#define SYSTEM_MEMORY_SIZE_32MB                       5
+#define SYSTEM_MEMORY_SIZE_16MB                       6
+#define SYSTEM_MEMORY_SIZE_8MB                        7
+/* System Memory Active to Pre-charge delay */
+#define SYSTEM_MEMORY_ACTIVE_DELAY                    7:7
+#define SYSTEM_MEMORY_ACTIVE_DELAY_6_CLOCKS           0
+#define SYSTEM_MEMORY_ACTIVE_DELAY_7_CLOCKS           1
+/* System Memory Write to Pre-charge delay */
+#define SYSTEM_MEMORY_WRITE_DELAY                     6:6
+#define SYSTEM_MEMORY_WRITE_DELAY_2_CLOCKS            0
+#define SYSTEM_MEMORY_WRITE_DELAY_1_CLOCK             1
+#define SYSTEM_MEMORY_BANK                            5:5
+#define SYSTEM_MEMORY_BANK_4                          0
+#define SYSTEM_MEMORY_BANK_2                          1
+#define SYSTEM_MEMORY_RESET                           4:4
+#define SYSTEM_MEMORY_RESET_ENABLE                    0
+#define SYSTEM_MEMORY_RESET_DISABLE                   1
+/* Delay time to latch read data for external SDRAM controller (in 1/2 ns step) */
+#define SYSTEM_MEMORY_LATCH_DELAY                     3:1
+#define SYSTEM_MEMORY_LATCH_DELAY_0                   0
+#define SYSTEM_MEMORY_LATCH_DELAY_1                   1
+#define SYSTEM_MEMORY_LATCH_DELAY_2                   2
+#define SYSTEM_MEMORY_LATCH_DELAY_3                   3
+#define SYSTEM_MEMORY_LATCH_DELAY_4                   4
+#define SYSTEM_MEMORY_LATCH_DELAY_5                   5
+#define SYSTEM_MEMORY_CPU_MASTER_BURST_LENGTH         0:0
+#define SYSTEM_MEMORY_CPU_MASTER_BURST_LENGTH_8       0
+#define SYSTEM_MEMORY_CPU_MASTER_BURST_LENGTH_1       1
+
+#define VGA_CONFIGURATION                             0x000088
+#define	VGA_CONFIGURATION_A0000_ACCESS				  7:7
+#define VGA_CONFIGURATION_A0000_ACCESS_DISABLE        0
+#define VGA_CONFIGURATION_A0000_ACCESS_ENABLE         1
+#define VGA_CONFIGURATION_USER_DEFINE                 5:4
+#define VGA_CONFIGURATION_PLL                         2:2
+#define VGA_CONFIGURATION_PLL_VGA                     0
+#define VGA_CONFIGURATION_PLL_PRIMARY                 1
+#define VGA_CONFIGURATION_MODE                        1:1
+#define VGA_CONFIGURATION_MODE_TEXT                   0
+#define VGA_CONFIGURATION_MODE_GRAPHIC                1
+/* The following only applies to SM718 (Strap pin MA Line 11) */
+#define VGA_CONFIGURATION_C0000_ACCESS                0:0
+#define VGA_CONFIGURATION_C0000_ACCESS_DISABLE        0
+#define VGA_CONFIGURATION_C0000_ACCESS_ENABLE         1
diff --git a/drivers/gpu/drm/smi/ddk750/ddk750_sii9022.c b/drivers/gpu/drm/smi/ddk750/ddk750_sii9022.c
new file mode 100644
index 000000000000..4e5ee31d903d
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk750/ddk750_sii9022.c
@@ -0,0 +1,67 @@
+#ifdef USE_HDMICHIP
+
+#include <linux/kernel.h>
+#include <linux/i2c.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/delay.h>	
+
+
+#include "siHdmiTx_902x_TPI.h"
+#include "ddk750_hwi2c.h"
+#include "ddk750_swi2c.h"
+
+
+#define SII9022_DEVICE_ID					0xb0
+
+#define i2cWriteReg swI2CWriteReg
+#define i2cReadReg  swI2CReadReg
+
+
+
+unsigned char sii9022xIsConnected(void)	
+{
+	return 1;
+}
+
+
+static void dump9022a(uint8_t reg){
+#if 1
+	printk("reg%x=%x\n",reg,i2cReadReg(SII9022A_I2C_ADDRESS,reg));
+#endif
+}
+int sii9022xSetMode(int num)
+{
+	int ret;
+
+	swI2CInit(DEFAULT_I2C_SCL, DEFAULT_I2C_SDA);
+	siHdmiTx_VideoSel(num);
+	siHdmiTx_AudioSel(0x02);
+	siHdmiTx_TPI_Init();
+	ret = siHdmiTx_VideoSet();
+	i2cWriteReg(SII9022A_I2C_ADDRESS,0x63,0);
+	return ret;
+}
+
+int sii9022xInitChip(void)
+{
+	int  rcc,retries = 10;
+    
+	swI2CInit(DEFAULT_I2C_SCL, DEFAULT_I2C_SDA);
+	
+	/* enter TPI mode */
+    	i2cWriteReg(SII9022A_I2C_ADDRESS,0xc7,0);
+	do{
+		msleep(1);
+		rcc = i2cReadReg(SII9022A_I2C_ADDRESS,0x1B);
+	}while((rcc != SII9022_DEVICE_ID) && retries--);
+
+	if(rcc != SII9022_DEVICE_ID){
+		printk("cannot detect sii9022a chip:rcc=%x\n",rcc);
+		return -1;
+	}
+	return 0;
+}
+
+
+#endif
diff --git a/drivers/gpu/drm/smi/ddk750/ddk750_sii9022.h b/drivers/gpu/drm/smi/ddk750/ddk750_sii9022.h
new file mode 100644
index 000000000000..59ba010b6103
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk750/ddk750_sii9022.h
@@ -0,0 +1,3 @@
+int sii9022xInitChip(void);
+int sii9022xSetMode(int);
+unsigned char sii9022xIsConnected(void);
diff --git a/drivers/gpu/drm/smi/ddk750/ddk750_sw2d.h b/drivers/gpu/drm/smi/ddk750/ddk750_sw2d.h
new file mode 100644
index 000000000000..a52f69de32c2
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk750/ddk750_sw2d.h
@@ -0,0 +1,200 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2007 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  sw2d.h --- SM750/SM718 DDK 
+*  This file contains the function prototype for 2D Function
+*  implementation.
+* 
+*******************************************************************/
+#ifndef _SW2D_H_
+#define _SW2D_H_
+
+/* Some color definitions */
+#define BPP32_RED    0x00ff0000
+#define BPP32_GREEN  0x0000ff00
+#define BPP32_BLUE   0x000000ff
+#define BPP32_WHITE  0x00ffffff
+#define BPP32_GRAY   0x00808080
+#define BPP32_YELLOW 0x00ffff00
+#define BPP32_CYAN   0x0000ffff
+#define BPP32_PINK   0x00ff00ff
+#define BPP32_BLACK  0x00000000
+
+#define BPP16_RED    0x0000f800
+#define BPP16_GREEN  0x000007e0
+#define BPP16_BLUE   0x0000001f
+#define BPP16_WHITE  0x0000ffff
+#define BPP16_GRAY   0x00008410
+#define BPP16_YELLOW 0x0000ffe0
+#define BPP16_CYAN   0x000007ff
+#define BPP16_PINK   0x0000f81f
+#define BPP16_BLACK  0x00000000
+
+#define BPP8_RED     0x000000b4
+#define BPP8_GREEN   0x0000001e
+#define BPP8_BLUE    0x00000005
+#define BPP8_WHITE   0x000000ff
+#define BPP8_GRAY    0x000000ec
+#define BPP8_YELLOW  0x000000d2
+#define BPP8_CYAN    0x00000023
+#define BPP8_PINK    0x000000b9
+#define BPP8_BLACK   0x00000000
+
+/* Raster Op 2 functions */
+#define ROP2_XOR        0x06
+#define ROP2_AND        0x08
+#define ROP2_COPY       0x0C
+#define ROP2_OR         0x0E
+
+#define ROP2_BLACK      0x00
+#define ROP2_DSon       0x01
+#define ROP2_DSna       0x02
+#define ROP2_Sn         0x03
+#define ROP2_SDna       0x04
+#define ROP2_Dn         0x05
+#define ROP2_DSx        0x06
+#define ROP2_SDan       0x07
+#define ROP2_DSa        0x08
+#define ROP2_SDnx       0x09
+#define ROP2_D          0x0A
+#define ROP2_DSno       0x0B
+#define ROP2_S          0x0C
+#define ROP2_SDno       0x0D
+#define ROP2_DSo        0x0E
+#define ROP2_WHITE      0x0F
+
+/* Blt Direction definitions */
+#define TOP_TO_BOTTOM 0
+#define LEFT_TO_RIGHT 0
+#define BOTTOM_TO_TOP 1
+#define RIGHT_TO_LEFT 1
+
+unsigned long swRasterOp2(unsigned long S, unsigned long D, unsigned long rop2);
+
+/*
+ * This function set up a pixel value in the frame buffer.
+ *
+ * Note:
+ * 1) It can only set pixel within the frame buffer.
+ * 2) This function is NOT for drawing surface created in system memory.
+ *
+ */
+void swSetPixel(
+unsigned long destBase, /* Base address of destination surface counted from beginning of video frame buffer */
+unsigned long pitch,    /* Pitch value of destination surface in BYTES */
+unsigned long bpp,      /* Color depth of destination surface: 8, 16 or 32 */
+unsigned long x, 
+unsigned long y,        /* Position (X, Y) to set in pixel value */
+unsigned long color,    /* Color */
+unsigned long rop2);     /* ROP value */
+
+/*
+ * This function gets a pixel value in the frame buffer.
+ *
+ * Note:
+ * 1) It can only get pixel within the frame buffer.
+ * 2) This function is NOT for drawing surface created in system memory.
+ * 3) This function always return a 32 bit pixel value disregard bpp = 8, 16, or 32.
+ *    The calling funtion has to type cast the return value into Byte, word or 
+ *    DWord according to BPP.
+ *
+ */
+unsigned long swGetPixel(
+unsigned long destBase, /* Base address of destination surface counted from beginning of video frame buffer */
+unsigned long pitch,    /* Pitch value of destination surface in BYTES */
+unsigned long bpp,      /* Color depth of destination surface: 8, 16 or 32 */
+unsigned long x, 
+unsigned long y);        /* Position (X, Y) to set in pixel value */
+
+/*
+ *  This function uses software only method to fill a rectangular area with a specific color.
+ * Input: See comment of code below.
+ * 
+ */
+void swRectFill(
+unsigned long destBase, /* Base address of destination surface counted from beginning of video frame buffer */
+unsigned long pitch,    /* Pitch value of destination surface in BYTES */
+unsigned long bpp,      /* Color depth of destination surface: 8, 16 or 32 */
+unsigned long x,
+unsigned long y,        /* Upper left corner (X, Y) of rectangle in pixel value */
+unsigned long width, 
+unsigned long height,   /* width and height of rectange in pixel value */
+unsigned long color,    /* Fill color */
+unsigned long rop2);    /* ROP value */
+
+/*
+ * This function draws a hollow rectangle, no fills.
+ */
+void swRect(
+unsigned long destBase, /* Base address of destination surface counted from beginning of video frame buffer */
+unsigned long pitch,    /* Pitch value of destination surface in BYTES */
+unsigned long bpp,      /* Color depth of destination surface: 8, 16 or 32 */
+unsigned long x,
+unsigned long y,        /* Upper left corner (X, Y) of rectangle in pixel value */
+unsigned long width, 
+unsigned long height,   /* width and height of rectange in pixel value */
+unsigned long color,    /* border color */
+unsigned long rop2);     /* ROP value */
+
+void swHorizontalLine(
+unsigned long destBase, /* Base address of destination surface counted from beginning of video frame buffer */
+unsigned long pitch,    /* Pitch value of destination surface in BYTES */
+unsigned long bpp,      /* Color depth of destination surface: 8, 16 or 32 */
+unsigned long x,
+unsigned long y,        /* Starting point (X, Y) of line */
+unsigned long length,   /* Length of line */
+unsigned long color,    /* Color */
+unsigned long rop2);    /* ROP value */
+
+void swVerticalLine(
+unsigned long destBase, /* Base address of destination surface counted from beginning of video frame buffer */
+unsigned long pitch,    /* Pitch value of destination surface in BYTES */
+unsigned long bpp,      /* Color depth of destination surface: 8, 16 or 32 */
+unsigned long x,
+unsigned long y,        /* Starting point (X, Y) of line */
+unsigned long length,   /* Length of line */
+unsigned long color,    /* Color */
+unsigned long rop2);    /* ROP value */
+
+/* 
+ * Function to draw a line.
+ */
+long swLine(
+    unsigned long destBase, /* Base address of destination surface counted from beginning of video frame buffer */
+    unsigned long pitch,    /* Pitch value of destination surface in BYTES */
+    unsigned long bpp,      /* Color depth of destination surface: 8, 16 or 32 */
+    unsigned long x0,       /* Starting X Coordinate */
+    unsigned long y0,       /* Starting Y Coordinate */
+    unsigned long x1,       /* Ending X Coordinate */
+    unsigned long y1,       /* Ending Y Coordinate */
+    unsigned long color,    /* Color of the line */
+    unsigned long rop2      /* ROP value */
+);
+
+/*
+ * Video Memory to Video Memroy data transfer.
+ *
+ * Note: 
+ * 1) All addresses are offset from the beginning for frame buffer.
+ * 2) Both source and destination have to be same bpp (color depth).
+ * 
+ */
+void swVideoMem2VideoMemBlt(
+unsigned long sBase,  /* Address of source: offset in frame buffer */
+unsigned long sPitch, /* Pitch value of source surface in BYTE */
+unsigned long sx,
+unsigned long sy,     /* Starting coordinate of source surface */
+unsigned long dBase,  /* Address of destination: offset in frame buffer */
+unsigned long dPitch, /* Pitch value of destination surface in BYTE */
+unsigned long bpp,   /* color depth of destiination, source must have same bpp */
+unsigned long dx,
+unsigned long dy,     /* Starting coordinate of destination surface */
+unsigned long width, 
+unsigned long height, /* width and height of rectange in pixel value */
+unsigned long rop2);  /* ROP value */
+
+#endif /* _SW2D_H_ */ 
diff --git a/drivers/gpu/drm/smi/ddk750/ddk750_swi2c.c b/drivers/gpu/drm/smi/ddk750/ddk750_swi2c.c
new file mode 100644
index 000000000000..b905f5adfc3a
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk750/ddk750_swi2c.c
@@ -0,0 +1,463 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2007 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  swi2c.c --- SM750/SM718 DDK 
+*  This file contains the source code for I2C using software
+*  implementation.
+* 
+*******************************************************************/
+#include "ddk750_defs.h"
+#include "ddk750_hardware.h"
+#include "ddk750_power.h"
+#include "ddk750_help.h"
+#include "ddk750_swi2c.h"
+
+/*******************************************************************
+ * I2C Software Master Driver:   
+ * ===========================
+ * Each i2c cycle is split into 4 sections. Each of these section marks
+ * a point in time where the SCL or SDA may be changed. 
+ * 
+ * 1 Cycle == |  Section I. |  Section 2. |  Section 3. |  Section 4. |
+ *            +-------------+-------------+-------------+-------------+
+ *            | SCL set LOW |SCL no change| SCL set HIGH|SCL no change|
+ *                 
+ *                                          ____________ _____________
+ * SCL == XXXX _____________ ____________ /
+ *                 
+ * I.e. the SCL may only be changed in section 1. and section 3. while
+ * the SDA may only be changed in section 2. and section 4. The table
+ * below gives the changes for these 2 lines in the varios sections.
+ * 
+ * Section changes Table:        
+ * ======================
+ * blank = no change, L = set bit LOW, H = set bit HIGH
+ *                       
+ *                                | 1.| 2.| 3.| 4.|      
+ *                 ---------------+---+---+---+---+      
+ *                 Tx Start   SDA |   | H |   | L |      
+ *                            SCL | L |   | H |   |      
+ *                 ---------------+---+---+---+---+                
+ *                 Tx Stop    SDA |   | L |   | H |      
+ *                            SCL | L |   | H |   |      
+ *                 ---------------+---+---+---+---+                
+ *                 Tx bit H   SDA |   | H |   |   |      
+ *                            SCL | L |   | H |   |      
+ *                 ---------------+---+---+---+---+                
+ *                 Tx bit L   SDA |   | L |   |   |      
+ *                            SCL | L |   | H |   |      
+ *                 ---------------+---+---+---+---+                
+ *                                  
+ ******************************************************************/
+
+/* GPIO pins used for this I2C. It ranges from 0 to 63. */
+static unsigned char g_i2cClockGPIO = DEFAULT_I2C_SCL;
+static unsigned char g_i2cDataGPIO = DEFAULT_I2C_SDA;
+
+/*
+ *  Below is the variable declaration for the GPIO pin register usage
+ *  for the i2c Clock and i2c Data.
+ *
+ *  Note:
+ *      Notice that the GPIO usage for the i2c clock and i2c Data are
+ *      separated. This is to make this code flexible enough when 
+ *      two separate GPIO pins for the clock and data are located
+ *      in two different GPIO register set (worst case).
+ */
+
+/* i2c Clock GPIO Register usage */
+static unsigned long g_i2cClkGPIOMuxReg = GPIO_MUX;
+static unsigned long g_i2cClkGPIODataReg = GPIO_DATA;
+static unsigned long g_i2cClkGPIODataDirReg = GPIO_DATA_DIRECTION;
+
+/* i2c Data GPIO Register usage */
+static unsigned long g_i2cDataGPIOMuxReg = GPIO_MUX;
+static unsigned long g_i2cDataGPIODataReg = GPIO_DATA;
+static unsigned long g_i2cDataGPIODataDirReg = GPIO_DATA_DIRECTION;
+
+/*
+ *  This function puts a delay between command
+ */        
+static void swI2CWait(void)
+{
+    int i, Temp;
+
+    for(i=0; i<600; i++)
+    {
+        Temp = i;
+        Temp += i;
+    }
+}
+
+/*
+ *  This function set/reset the SCL GPIO pin
+ *
+ *  Parameters:
+ *      value	- Bit value to set to the SCL or SDA (0 = low, 1 = high)
+ *
+ *  Notes:
+ *      When setting SCL to high, just set the GPIO as input where the pull up
+ *      resistor will pull the signal up. Do not use software to pull up the
+ *      signal because the i2c will fail when other device try to drive the
+ *      signal due to SM50x will drive the signal to always high.
+ */ 
+void swI2CSCL(unsigned char value)
+{
+    unsigned long ulGPIOData;
+    unsigned long ulGPIODirection;
+
+    ulGPIODirection = peekRegisterDWord(g_i2cClkGPIODataDirReg);
+    if (value)      /* High */
+    {
+        /* Set direction as input. This will automatically pull the signal up. */
+        ulGPIODirection &= ~(1 << g_i2cClockGPIO);	
+        pokeRegisterDWord(g_i2cClkGPIODataDirReg, ulGPIODirection);
+    }
+    else            /* Low */
+    {
+        /* Set the signal down */
+        ulGPIOData = peekRegisterDWord(g_i2cClkGPIODataReg);
+        ulGPIOData &= ~(1 << g_i2cClockGPIO);
+        pokeRegisterDWord(g_i2cClkGPIODataReg, ulGPIOData);
+
+        /* Set direction as output */
+        ulGPIODirection |= (1 << g_i2cClockGPIO);		
+        pokeRegisterDWord(g_i2cClkGPIODataDirReg, ulGPIODirection);
+    }
+}
+
+/*
+ *  This function set/reset the SDA GPIO pin
+ *
+ *  Parameters:
+ *      value	- Bit value to set to the SCL or SDA (0 = low, 1 = high)
+ *
+ *  Notes:
+ *      When setting SCL to high, just set the GPIO as input where the pull up
+ *      resistor will pull the signal up. Do not use software to pull up the
+ *      signal because the i2c will fail when other device try to drive the
+ *      signal due to SM50x will drive the signal to always high.
+ */
+void swI2CSDA(unsigned char value)
+{
+    unsigned long ulGPIOData;
+    unsigned long ulGPIODirection;
+
+    ulGPIODirection = peekRegisterDWord(g_i2cDataGPIODataDirReg);
+    if (value)      /* High */
+    {
+        /* Set direction as input. This will automatically pull the signal up. */
+        ulGPIODirection &= ~(1 << g_i2cDataGPIO);	
+        pokeRegisterDWord(g_i2cDataGPIODataDirReg, ulGPIODirection);
+    }
+    else            /* Low */
+    {
+        /* Set the signal down */
+        ulGPIOData = peekRegisterDWord(g_i2cDataGPIODataReg);
+        ulGPIOData &= ~(1 << g_i2cDataGPIO);
+        pokeRegisterDWord(g_i2cDataGPIODataReg, ulGPIOData);
+
+        /* Set direction as output */
+        ulGPIODirection |= (1 << g_i2cDataGPIO);		
+        pokeRegisterDWord(g_i2cDataGPIODataDirReg, ulGPIODirection);
+    }
+}
+
+/*
+ *  This function read the data from the SDA GPIO pin
+ *
+ *  Return Value:
+ *      The SDA data bit sent by the Slave
+ */
+static unsigned char swI2CReadSDA(void)
+{
+    unsigned long ulGPIODirection;
+    unsigned long ulGPIOData;
+
+    /* Make sure that the direction is input (High) */
+    ulGPIODirection = peekRegisterDWord(g_i2cDataGPIODataDirReg);
+    if ((ulGPIODirection & (1 << g_i2cDataGPIO)) != (~(1 << g_i2cDataGPIO)))
+    {
+        ulGPIODirection &= ~(1 << g_i2cDataGPIO);
+        pokeRegisterDWord(g_i2cDataGPIODataDirReg, ulGPIODirection);
+    }
+
+    /* Now read the SDA line */
+    ulGPIOData = peekRegisterDWord(g_i2cDataGPIODataReg);
+    if (ulGPIOData & (1 << g_i2cDataGPIO)) 
+        return 1;
+    else 
+        return 0;
+}
+
+#pragma optimize( "", off )
+
+/*
+ *  This function sends ACK signal
+ */
+static void swI2CAck(void)
+{
+    return;  /* Single byte read is ok without it. */
+}
+
+/*
+ *  This function sends the start command to the slave device
+ */
+void swI2CStart(void)
+{
+    /* Start I2C */
+    swI2CSDA(1);
+    swI2CSCL(1);
+    swI2CSDA(0);
+}
+
+/*
+ *  This function sends the stop command to the slave device
+ */
+void swI2CStop(void)
+{
+    /* Stop the I2C */
+    swI2CSCL(1);
+    swI2CSDA(0);
+    swI2CSDA(1);
+}
+
+/*
+ *  This function writes one byte to the slave device
+ *
+ *  Parameters:
+ *      data    - Data to be write to the slave device
+ *
+ *  Return Value:
+ *       0   - Success
+ *      -1   - Fail to write byte
+ */
+long swI2CWriteByte(unsigned char data) 
+{
+    unsigned char value = data;
+    int i;
+
+    /* Sending the data bit by bit */
+    for (i=0; i<8; i++)
+    {
+        /* Set SCL to low */
+        swI2CSCL(0);
+
+        /* Send data bit */
+        if ((value & 0x80) != 0)
+            swI2CSDA(1);
+        else
+            swI2CSDA(0);
+
+        swI2CWait();
+
+        /* Toggle clk line to one */
+        swI2CSCL(1);
+
+        /* Shift byte to be sent */
+        value = value << 1;
+    }
+
+    /* Set the SCL Low and SDA High (prepare to get input) */
+    swI2CSCL(0);
+    swI2CSDA(1);
+
+    /* Set the SCL High for ack */
+    swI2CWait();
+    swI2CSCL(1);
+
+    /* Read SDA, until SDA==0 */
+    for(i=0; i<0xff; i++) 
+    {
+        swI2CWait();
+        swI2CWait();
+        if (!swI2CReadSDA())
+            break;
+    }
+
+    /* Set the SCL Low and SDA High */
+    swI2CSCL(0);
+    swI2CSDA(1);
+
+    if (i<0xff)
+        return 0;
+    else
+        return (-1);
+}
+
+/*
+ *  This function reads one byte from the slave device
+ *
+ *  Parameters:
+ *      ack	- Flag to indicate either to send the acknowledge
+ *            message to the slave device or not
+ *
+ *  Return Value:
+ *      One byte data read from the Slave device
+ */
+unsigned char swI2CReadByte(unsigned char ack)
+{
+    int i;
+    unsigned char data = 0;
+
+    for(i=7; i>=0; i--)
+    {
+        /* Set the SCL to Low and SDA to High (Input) */
+        swI2CSCL(0);
+        swI2CSDA(1);
+        swI2CWait();
+
+        /* Set the SCL High */
+        swI2CSCL(1);
+        swI2CWait();
+
+        /* Read data bits from SDA */
+        data |= (swI2CReadSDA() << i);
+    }
+
+    if (ack)
+        swI2CAck();
+
+    /* Set the SCL Low and SDA High */
+    swI2CSCL(0);
+    swI2CSDA(1);
+
+    return data;
+}
+#pragma optimize( "", on )
+
+/*
+ * This function initializes the i2c attributes and bus
+ *
+ * Parameters:
+ *      i2cClkGPIO      - The GPIO pin to be used as i2c SCL
+ *      i2cDataGPIO     - The GPIO pin to be used as i2c SDA
+ *
+ * Return Value:
+ *      -1   - Fail to initialize the i2c
+ *       0   - Success
+ */
+long swI2CInit(
+    unsigned char i2cClkGPIO, 
+    unsigned char i2cDataGPIO
+)
+{
+    int i;
+    
+    /* Return 0 if the GPIO pins to be used is out of range. The range is only from [0..63] */
+    if ((i2cClkGPIO > 31) || (i2cDataGPIO > 31))
+        return (-1);
+    
+    /* Initialize the GPIO pin for the i2c Clock Register */
+    g_i2cClkGPIOMuxReg = GPIO_MUX;   
+    g_i2cClkGPIODataReg = GPIO_DATA;    
+    g_i2cClkGPIODataDirReg = GPIO_DATA_DIRECTION;
+    
+    /* Initialize the Clock GPIO Offset */
+    g_i2cClockGPIO = i2cClkGPIO;
+    
+    /* Initialize the GPIO pin for the i2c Data Register */
+    g_i2cDataGPIOMuxReg = GPIO_MUX;    
+    g_i2cDataGPIODataReg = GPIO_DATA;    
+    g_i2cDataGPIODataDirReg = GPIO_DATA_DIRECTION;
+    
+    /* Initialize the Data GPIO Offset */
+    g_i2cDataGPIO = i2cDataGPIO;
+
+    /* Enable the GPIO pins for the i2c Clock and Data (GPIO MUX) */
+    pokeRegisterDWord(g_i2cClkGPIOMuxReg, 
+                      peekRegisterDWord(g_i2cClkGPIOMuxReg) & ~(1 << g_i2cClockGPIO));
+    pokeRegisterDWord(g_i2cDataGPIOMuxReg, 
+                      peekRegisterDWord(g_i2cDataGPIOMuxReg) & ~(1 << g_i2cDataGPIO));
+
+    /* Enable GPIO power */
+    enableGPIO(1);
+
+    /* Clear the i2c lines. */
+    for(i=0; i<9; i++) 
+        swI2CStop();
+
+    return 0;
+}
+
+/*
+ *  This function reads the slave device's register
+ *
+ *  Parameters:
+ *      deviceAddress   - i2c Slave device address which register
+ *                        to be read from
+ *      registerIndex   - Slave device's register to be read
+ *
+ *  Return Value:
+ *      Register value
+ */
+unsigned char swI2CReadReg(
+    unsigned char deviceAddress, 
+    unsigned char registerIndex
+)
+{
+    unsigned char data;
+
+    /* Send the Start signal */
+    swI2CStart();
+
+    /* Send the device address */
+    swI2CWriteByte(deviceAddress);                                                  
+
+    /* Send the register index */
+    swI2CWriteByte(registerIndex);               
+
+    /* Get the bus again and get the data from the device read address */
+    swI2CStart();
+    swI2CWriteByte(deviceAddress + 1);
+    data = swI2CReadByte(1);
+
+    /* Stop swI2C and release the bus */
+    swI2CStop();
+
+    return data;
+}
+
+/*
+ *  This function writes a value to the slave device's register
+ *
+ *  Parameters:
+ *      deviceAddress   - i2c Slave device address which register
+ *                        to be written
+ *      registerIndex   - Slave device's register to be written
+ *      data            - Data to be written to the register
+ *
+ *  Result:
+ *          0   - Success
+ *         -1   - Fail
+ */
+long swI2CWriteReg(
+    unsigned char deviceAddress, 
+    unsigned char registerIndex, 
+    unsigned char data
+)
+{
+    long returnValue = 0;
+    
+    /* Send the Start signal */
+    swI2CStart();
+
+    /* Send the device address and read the data. All should return success
+       in order for the writing processed to be successful
+     */
+    if ((swI2CWriteByte(deviceAddress) != 0) ||
+        (swI2CWriteByte(registerIndex) != 0) ||
+        (swI2CWriteByte(data) != 0))
+    {
+        returnValue = -1;
+    }
+    
+    /* Stop i2c and release the bus */
+    swI2CStop();
+
+    return returnValue;
+}
diff --git a/drivers/gpu/drm/smi/ddk750/ddk750_swi2c.h b/drivers/gpu/drm/smi/ddk750/ddk750_swi2c.h
new file mode 100644
index 000000000000..3451f041a042
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk750/ddk750_swi2c.h
@@ -0,0 +1,92 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2007 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  swi2c.h --- SM750/SM718 DDK 
+*  This file contains the definitions for i2c using software 
+*  implementation.
+* 
+*******************************************************************/
+#ifndef _SWI2C_H_
+#define _SWI2C_H_
+
+/* Default i2c CLK and Data GPIO. These are the default i2c pins */
+#define DEFAULT_I2C_SCL                     30
+#define DEFAULT_I2C_SDA                     31
+
+/*
+ * This function initializes the i2c attributes and bus
+ *
+ * Parameters:
+ *      i2cClkGPIO  - The GPIO pin to be used as i2c SCL
+ *      i2cDataGPIO - The GPIO pin to be used as i2c SDA
+ *
+ * Return Value:
+ *      -1   - Fail to initialize the i2c
+ *       0   - Success
+ */
+long swI2CInit(
+    unsigned char i2cClkGPIO, 
+    unsigned char i2cDataGPIO
+);
+
+/*
+ *  This function reads the slave device's register
+ *
+ *  Parameters:
+ *      deviceAddress   - i2c Slave device address which register
+ *                        to be read from
+ *      registerIndex   - Slave device's register to be read
+ *
+ *  Return Value:
+ *      Register value
+ */
+unsigned char swI2CReadReg(
+    unsigned char deviceAddress, 
+    unsigned char registerIndex
+);
+
+/*
+ *  This function writes a value to the slave device's register
+ *
+ *  Parameters:
+ *      deviceAddress   - i2c Slave device address which register
+ *                        to be written
+ *      registerIndex   - Slave device's register to be written
+ *      data            - Data to be written to the register
+ *
+ *  Result:
+ *          0   - Success
+ *         -1   - Fail
+ */
+long swI2CWriteReg(
+    unsigned char deviceAddress, 
+    unsigned char registerIndex, 
+    unsigned char data
+);
+
+/*
+ *  These two functions are used to toggle the data on the SCL and SDA I2C lines.
+ *  The used of these two functions are not recommended unless it is necessary.
+ */
+
+/*
+ *  This function set/reset the SCL GPIO pin
+ *
+ *  Parameters:
+ *      value	- Bit value to set to the SCL or SDA (0 = low, 1 = high)
+ */ 
+void swI2CSCL(unsigned char value);
+
+/*
+ *  This function set/reset the SDA GPIO pin
+ *
+ *  Parameters:
+ *      value	- Bit value to set to the SCL or SDA (0 = low, 1 = high)
+ */
+void swI2CSDA(unsigned char value);
+
+#endif  /* _SWI2C_H_ */
diff --git a/drivers/gpu/drm/smi/ddk750/ddkdebug.h b/drivers/gpu/drm/smi/ddk750/ddkdebug.h
new file mode 100644
index 000000000000..aa1df840174f
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk750/ddkdebug.h
@@ -0,0 +1,141 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2007 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  ddkdebug.h --- DDK Debug module 
+*  This file contains the definitions for the SMI DDK debugging.
+* 
+*******************************************************************/
+#ifndef _DDKDEBUG_H_
+#define _DDKDEBUG_H_
+
+#ifdef DDKDEBUG
+
+/*********************
+ * Definition  
+ *********************/
+ 
+/* Debug Print Level definitions */
+/* Bit 16 ~ 31 are used by the library. Bit 0 ~ 15 can be used by application */
+#define ERROR_LEVEL                 0x00010000
+#define WARNING_LEVEL               0x00020000
+#define INIT_LEVEL                  0x00040000
+#define DISPLAY_LEVEL               0x00080000
+#define DMA_LEVEL                   0x00100000
+#define DE_LEVEL                    0x00200000
+#define CAPTURE_LEVEL               0x00400000
+#define SSP_LEVEL                   0x00800000
+#define RESERVED8_LEVEL             0x01000000
+#define RESERVED9_LEVEL             0x02000000
+#define RESERVED10_LEVEL            0x04000000
+#define RESERVED11_LEVEL            0x08000000
+#define RESERVED12_LEVEL            0x10000000
+#define RESERVED13_LEVEL            0x20000000
+#define RESERVED14_LEVEL            0x40000000
+#define RESERVED15_LEVEL            0x80000000
+
+#define SYSTEM_LEVEL_MASK           0xFFFF0000
+#define APPLICATION_LEVEL_MASK      0x0000FFFF
+
+/*********************
+ * Structure 
+ *********************/
+typedef enum _ddk_debug_output_t
+{
+    DEBUG_OUTPUT_SCREEN = 0,
+    DEBUG_OUTPUT_FILE,
+    DEBUG_OUTPUT_SERIAL
+} 
+ddk_debug_output_t;
+
+/*********************
+ * MACROS 
+ *********************/
+ 
+/* This function has to be called before calling other DEBUGPIRNT functions. */
+#define DDKDEBUGPRINTINIT(debugOutput, debugLevelMask) \
+    ddkDebugPrintInit(debugOutput, debugLevelMask)
+
+/* This function enable or disable the debug message. 
+ *  Note:
+ *      This function can be used to enable/disable the debug message
+ *      at certain point of software, so that the debug messages, that
+ *      are printed, are only the important ones.
+ */
+#define DDKDEBUGENABLE(arg)                           \
+    ddkDebugEnable(arg)
+
+/* Calling the DDKDEBUGPRINT needs to have the arg to be enclosed with
+   two of open and close brackets.
+   Example:
+            DDKDEBUGPRINT(("Hello World: %s\n", pszString));
+ */
+#define DDKDEBUGPRINT(arg)                             \
+    ddkDebugPrint arg
+    
+/* This function has to be called when exiting the application.
+   It is necessary to clean up the debug module. */
+#define DDKDEBUGPRINTEXIT()                            \
+    ddkDebugPrintExit()
+
+/*********************
+ * Function prototype 
+ *********************/
+ 
+/*
+ * This function initializes the debug print out system.
+ *  
+ *  Input:
+ *      debugOutput - Output where to print out the debug. It could be 
+ *                    screen, file, or serial port.
+ *      debugLevel  - Debugging level      
+ */
+void ddkDebugPrintInit(ddk_debug_output_t debugOutput, unsigned long debugLevelMask);
+
+/*
+ *  This function enable or disable the debug message.
+ *  
+ *  Input:
+ *      enableDebugMessage  - Enable/disable the debug message
+ *                            0 - Disable Debug Message
+ *                            1 - Enable Debug Message
+ *
+ *  Note:
+ *      This function can be used to enable/disable the debug message
+ *      at certain point of software, so that the debug messages, that
+ *      are printed, are only the important ones.     
+ */
+void ddkDebugEnable(unsigned char enableDebugMessage);
+
+/*
+ * This function prints out the formatted string.
+ *  
+ *  Input:
+ *      debugLevel  - The level of the debug of which the message is intended for.
+ *      pszFormat   - Format of the printed message      
+ */
+void ddkDebugPrint(unsigned long debugLevel, const char* pszFormat, ...);
+
+/*
+ * This function cleans up (such as closing the debug file, etc...) when
+ * exiting the debug module.      
+ */
+void ddkDebugPrintExit();
+
+#else
+
+/* 
+ * If there is no DEBUG definition, then treat the macro as an empty macro.
+ * Therefore all the debug print will be stripped out. 
+ */
+#define DDKDEBUGPRINTINIT(debugOutput, debugLevelMask)
+#define DDKDEBUGENABLE(arg)
+#define DDKDEBUGPRINT(arg)
+#define DDKDEBUGPRINTEXIT()
+
+#endif
+
+#endif /* _DDKDEBUG_H_ */
diff --git a/drivers/gpu/drm/smi/ddk750/siHdmiTx_902x_TPI.c b/drivers/gpu/drm/smi/ddk750/siHdmiTx_902x_TPI.c
new file mode 100644
index 000000000000..719241faec7b
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk750/siHdmiTx_902x_TPI.c
@@ -0,0 +1,3514 @@
+/***************************************************************************
+ *
+ * SIMG PART NUMBER - HDMI Transmitter Driver
+ *
+ * Copyright (C) (2011, Silicon Image)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ *****************************************************************************/
+#include <linux/wait.h>
+#include <linux/delay.h>
+#include <linux/mutex.h>
+#include <linux/bug.h>
+#include <linux/err.h>
+#include <linux/i2c.h>
+#include <linux/kernel.h>
+#include "siHdmiTx_902x_TPI.h"
+#include "ddk750_hwi2c.h"
+#include "ddk750_swi2c.h"
+
+#define i2cWriteReg swI2CWriteReg
+#define i2cReadReg  swI2CReadReg
+
+
+
+SIHDMITX_CONFIG		siHdmiTx;
+GLOBAL_SYSTEM 		g_sys;
+GLOBAL_HDCP 		g_hdcp;
+GLOBAL_EDID 		g_edid;
+byte 				tpivmode[3];  // saved TPI Reg0x08/Reg0x09/Reg0x0A values.
+
+bool Sii9024A_HDCP_supported=false;  //if the chip is 9024A, you can support HDCP by set this variable to 1.If the chip is 9022A, it means noting.
+
+
+//bool HDCP_Supported=false;
+
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+///////////         The following functions are related with target system!!!    //////////////
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+
+//sbit siHdmiTx_HwResetPin = P2^1; 	// Connected to 9022A/4A pin C3 (CRST#)
+
+//extern void DelayMS (word MS);
+//extern byte I2CReadByte ( byte SlaveAddr, byte RegAddr );
+//extern void I2CWriteByte ( byte SlaveAddr, byte RegAddr, byte Data );
+//extern byte I2CReadBlock( byte SlaveAddr, byte RegAddr, byte NBytes, byte * Data );
+//extern byte I2CWriteBlock( byte SlaveAddr, byte RegAddr, byte NBytes, byte * Data );
+//extern byte siiReadSegmentBlockEDID(byte SlaveAddr, byte Segment, byte Offset, byte *Buffer, byte Length);
+
+struct i2c_client *sii902xA = NULL;
+struct i2c_client *siiEDID = NULL;
+struct i2c_client *siiSegEDID = NULL;
+struct i2c_client *siiHDCP = NULL;
+
+//static struct mxc_lcd_platform_data *Sii902xA_plat_data;
+
+void DelayMS (word MS)
+{
+	mdelay(MS);//call linux kernel delay API function
+}
+
+
+byte I2CReadBlock(struct i2c_client *client, byte RegAddr, byte NBytes, byte * Data )
+{
+	byte i = 0;
+	while(i<NBytes){
+		Data[i] = i2cReadReg(SII9022A_I2C_ADDRESS,RegAddr+i);
+		i++;
+	}
+	return IIC_OK;
+}
+
+byte I2CWriteBlock( struct i2c_client *client, byte RegAddr, byte NBytes, byte * Data )
+{
+	byte i = 0;
+	while(i < NBytes){
+		i2cWriteReg(SII9022A_I2C_ADDRESS,RegAddr+i,Data[i]);
+		i++;
+	}
+	return IIC_OK;
+}
+
+static s32 i2c_smbus_write_byte_nostop(struct i2c_client *client, u8 value)
+{
+	return IIC_OK;
+}
+
+byte siiReadSegmentBlockEDID(struct i2c_client *client, byte Segment, byte Offset, byte *Buffer, byte Length)
+{
+	int rc;
+	i2c_smbus_write_byte_nostop(siiSegEDID,Segment);
+	rc = I2CReadBlock(client, Offset, Length, Buffer);
+	if (rc < 0)
+		return -EIO;
+	return IIC_OK;
+}
+
+byte ReadByteTPI (byte RegOffset)
+{
+	return i2cReadReg(SII9022A_I2C_ADDRESS,	RegOffset);
+}
+
+void WriteByteTPI (byte RegOffset, byte Data)
+{
+	i2cWriteReg(SII9022A_I2C_ADDRESS,RegOffset,Data);
+}
+
+
+//------------------------------------------------------------------------------
+// Function Name: ReadSetWriteTPI()
+// Function Description: Write "1" to all bits in TPI offset "Offset" that are set
+//                  to "1" in "Pattern"; Leave all other bits in "Offset"
+//                  unchanged.
+//------------------------------------------------------------------------------
+void ReadSetWriteTPI (byte Offset, byte Pattern)
+{
+	byte Tmp;
+	Tmp = ReadByteTPI(Offset);
+	Tmp |= Pattern;
+	WriteByteTPI(Offset, Tmp);
+}
+
+//------------------------------------------------------------------------------
+// Function Name: ReadSetWriteTPI()
+// Function Description: Write "0" to all bits in TPI offset "Offset" that are set
+//                  to "1" in "Pattern"; Leave all other bits in "Offset"
+//                  unchanged.
+//------------------------------------------------------------------------------
+void ReadClearWriteTPI (byte Offset, byte Pattern)
+{
+	byte Tmp;
+	Tmp = ReadByteTPI(Offset);
+	Tmp &= ~Pattern;
+	WriteByteTPI(Offset, Tmp);
+}
+
+//------------------------------------------------------------------------------
+// Function Name: ReadSetWriteTPI()
+// Function Description: Write "Value" to all bits in TPI offset "Offset" that are set
+//                  to "1" in "Mask"; Leave all other bits in "Offset"
+//                  unchanged.
+//------------------------------------------------------------------------------
+void ReadModifyWriteTPI (byte Offset, byte Mask, byte Value)
+{
+	byte Tmp;
+	Tmp = ReadByteTPI(Offset);
+	Tmp &= ~Mask;
+	Tmp |= (Value & Mask);
+	WriteByteTPI(Offset, Tmp);
+}
+
+//------------------------------------------------------------------------------
+// Function Name: ReadBlockTPI()
+// Function Description: Read NBytes from offset Addr of the TPI slave address
+//                      into a byte Buffer pointed to by Data
+//------------------------------------------------------------------------------
+void ReadBlockTPI(byte TPI_Offset, word NBytes, byte * pData)
+{
+	I2CReadBlock(sii902xA,TPI_Offset,NBytes,pData);
+		//	i2c_smbus_read_i2c_block_data(sii902xA, TPI_Offset,NBytes, pData);
+}
+
+//------------------------------------------------------------------------------
+// Function Name: WriteBlockTPI()
+// Function Description: Write NBytes from a byte Buffer pointed to by Data to
+//                      the TPI I2C slave starting at offset Addr
+//------------------------------------------------------------------------------
+void WriteBlockTPI (byte TPI_Offset, word NBytes, byte * pData)
+{
+	I2CWriteBlock(sii902xA,TPI_Offset, NBytes, pData);
+	//i2c_smbus_write_i2c_block_data(sii902xA,TPI_Offset, NBytes, pData);
+}
+
+//------------------------------------------------------------------------------
+// Function Name: ReadIndexedRegister()
+// Function Description: Read an indexed register value
+//
+//                  Write:
+//                      1. 0xBC => Internal page num
+//                      2. 0xBD => Indexed register offset
+//
+//                  Read:
+//                      3. 0xBE => Returns the indexed register value
+//------------------------------------------------------------------------------
+byte ReadIndexedRegister(byte PageNum, byte RegOffset) 
+{
+	WriteByteTPI(TPI_INTERNAL_PAGE_REG, PageNum);		// Internal page
+	WriteByteTPI(TPI_INDEXED_OFFSET_REG, RegOffset);	// Indexed register
+	return ReadByteTPI(TPI_INDEXED_VALUE_REG); 		// Return read value
+}
+
+//------------------------------------------------------------------------------
+// Function Name: WriteIndexedRegister()
+// Function Description: Write a value to an indexed register
+//
+//                  Write:
+//                      1. 0xBC => Internal page num
+//                      2. 0xBD => Indexed register offset
+//                      3. 0xBE => Set the indexed register value
+//------------------------------------------------------------------------------
+void WriteIndexedRegister (byte PageNum, byte RegOffset, byte RegValue) 
+{
+	WriteByteTPI(TPI_INTERNAL_PAGE_REG, PageNum);  // Internal page
+	WriteByteTPI(TPI_INDEXED_OFFSET_REG, RegOffset);  // Indexed register
+	WriteByteTPI(TPI_INDEXED_VALUE_REG, RegValue);    // Read value into buffer
+}
+
+//------------------------------------------------------------------------------
+// Function Name: ReadModifyWriteIndexedRegister()
+// Function Description: Write "Value" to all bits in TPI offset "Offset" that are set
+//                  to "1" in "Mask"; Leave all other bits in "Offset"
+//                  unchanged.
+//------------------------------------------------------------------------------
+void ReadModifyWriteIndexedRegister(byte PageNum, byte RegOffset, byte Mask, byte Value)
+{
+	byte Tmp;
+	WriteByteTPI(TPI_INTERNAL_PAGE_REG, PageNum);
+	WriteByteTPI(TPI_INDEXED_OFFSET_REG, RegOffset);
+	Tmp = ReadByteTPI(TPI_INDEXED_VALUE_REG);
+
+	Tmp &= ~Mask;
+	Tmp |= (Value & Mask);
+
+	WriteByteTPI(TPI_INDEXED_VALUE_REG, Tmp);
+}
+
+//------------------------------------------------------------------------------
+void TXHAL_InitPostReset (void) 
+{
+	// Set terminations to default.
+	WriteByteTPI(TMDS_CONT_REG, 0x25);
+	// HW debounce to 64ms (0x14)
+	WriteByteTPI(0x7C, 0x14);
+}
+
+#if 0
+void TxHW_Reset (void)
+{
+	TPI_TRACE_PRINT((">>TxHW_Reset()\n"));
+
+	Sii902xA_plat_data = sii902xA->dev.platform_data;
+	if (Sii902xA_plat_data->reset)
+		Sii902xA_plat_data->reset();
+	/*
+	   siHdmiTx_HwResetPin = LOW;
+	   DelayMS(TX_HW_RESET_PERIOD);
+	   siHdmiTx_HwResetPin = HIGH;
+	   */
+	TXHAL_InitPostReset();
+}
+#endif
+
+//------------------------------------------------------------------------------
+// Function Name: InitializeStateVariables()
+// Function Description: Initialize system state variables
+//------------------------------------------------------------------------------
+void InitializeStateVariables (void)
+{
+	g_sys.tmdsPoweredUp = FALSE;
+	g_sys.hdmiCableConnected = FALSE;
+	g_sys.dsRxPoweredUp = FALSE;
+
+#ifdef DEV_SUPPORT_EDID
+	g_edid.edidDataValid = FALSE;
+#endif
+}
+
+//------------------------------------------------------------------------------
+// Function Name: EnableTMDS()
+// Function Description: Enable TMDS
+//------------------------------------------------------------------------------
+void EnableTMDS (void)
+{	
+	TPI_DEBUG_PRINT(("TMDS -> Enabled\n"));
+	ReadModifyWriteTPI(TPI_SYSTEM_CONTROL_DATA_REG, TMDS_OUTPUT_CONTROL_MASK, TMDS_OUTPUT_CONTROL_ACTIVE);
+	WriteByteTPI(TPI_PIX_REPETITION, tpivmode[0]);      		// Write register 0x08
+	g_sys.tmdsPoweredUp = TRUE;
+}
+
+//------------------------------------------------------------------------------
+// Function Name: DisableTMDS()
+// Function Description: Disable TMDS
+//------------------------------------------------------------------------------
+void DisableTMDS (void)
+{
+	TPI_DEBUG_PRINT(("TMDS -> Disabled\n"));
+	ReadModifyWriteTPI(TPI_SYSTEM_CONTROL_DATA_REG, TMDS_OUTPUT_CONTROL_MASK | AV_MUTE_MASK,
+			TMDS_OUTPUT_CONTROL_POWER_DOWN | AV_MUTE_MUTED);
+	g_sys.tmdsPoweredUp = FALSE;
+}
+
+//------------------------------------------------------------------------------
+// Function Name: EnableInterrupts()
+// Function Description: Enable the interrupts specified in the input parameter
+//
+// Accepts: A bit pattern with "1" for each interrupt that needs to be
+//                  set in the Interrupt Enable Register (TPI offset 0x3C)
+// Returns: TRUE
+// Globals: none
+//------------------------------------------------------------------------------
+byte EnableInterrupts(byte Interrupt_Pattern)
+{
+	TPI_TRACE_PRINT((">>EnableInterrupts()\n"));
+	ReadSetWriteTPI(TPI_INTERRUPT_ENABLE_REG, Interrupt_Pattern);
+	return TRUE;
+}
+
+//------------------------------------------------------------------------------
+// Function Name: DisableInterrupts()
+// Function Description: Disable the interrupts specified in the input parameter
+//
+// Accepts: A bit pattern with "1" for each interrupt that needs to be
+//                  cleared in the Interrupt Enable Register (TPI offset 0x3C)
+// Returns: TRUE
+// Globals: none
+//------------------------------------------------------------------------------
+byte DisableInterrupts (byte Interrupt_Pattern)
+{
+	TPI_TRACE_PRINT((">>DisableInterrupts()\n"));
+	ReadClearWriteTPI(TPI_INTERRUPT_ENABLE_REG, Interrupt_Pattern);
+
+	return TRUE;
+}
+
+
+
+#ifdef DEV_SUPPORT_EDID
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////*************************///////////////////////////////
+///////////////////////                   EDID                 ///////////////////////////////
+///////////////////////*************************///////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+
+static u8 g_CommData [EDID_BLOCK_SIZE];
+
+#define ReadBlockEDID(a,b,c)            		I2CReadBlock(siiEDID, a, b, c)
+#define ReadSegmentBlockEDID(a,b,c,d)   		siiReadSegmentBlockEDID(siiEDID, a, b, d, c)
+
+//------------------------------------------------------------------------------
+// Function Name: GetDDC_Access()
+// Function Description: Request access to DDC bus from the receiver
+//
+// Accepts: none
+// Returns: TRUE or FLASE
+// Globals: none
+//------------------------------------------------------------------------------
+#define T_DDC_ACCESS    50
+
+byte GetDDC_Access (byte* SysCtrlRegVal)
+{
+	byte sysCtrl;
+	byte DDCReqTimeout = T_DDC_ACCESS;
+	byte TPI_ControlImage;
+
+	TPI_TRACE_PRINT((">>GetDDC_Access()\n"));
+
+	sysCtrl = ReadByteTPI (TPI_SYSTEM_CONTROL_DATA_REG);			// Read and store original value. Will be passed into ReleaseDDC()
+	*SysCtrlRegVal = sysCtrl;
+
+	sysCtrl |= DDC_BUS_REQUEST_REQUESTED;
+	WriteByteTPI (TPI_SYSTEM_CONTROL_DATA_REG, sysCtrl);
+
+	while (DDCReqTimeout--)											// Loop till 0x1A[1] reads "1"
+	{
+		TPI_ControlImage = ReadByteTPI(TPI_SYSTEM_CONTROL_DATA_REG);
+
+		if (TPI_ControlImage & DDC_BUS_GRANT_MASK)					// When 0x1A[1] reads "1"
+		{
+			sysCtrl |= DDC_BUS_GRANT_GRANTED;
+			WriteByteTPI(TPI_SYSTEM_CONTROL_DATA_REG, sysCtrl);		// lock host DDC bus access (0x1A[2:1] = 11)
+			return TRUE;
+		}
+		WriteByteTPI(TPI_SYSTEM_CONTROL_DATA_REG, sysCtrl);			// 0x1A[2] = "1" - Requst the DDC bus
+		DelayMS(200);
+	}
+
+	WriteByteTPI(TPI_SYSTEM_CONTROL_DATA_REG, sysCtrl);				// Failure... restore original value.
+	return FALSE;
+}
+
+//------------------------------------------------------------------------------
+// Function Name: ReleaseDDC()
+// Function Description: Release DDC bus
+//
+// Accepts: none
+// Returns: TRUE if bus released successfully. FALSE if failed.
+// Globals: none
+//------------------------------------------------------------------------------
+byte ReleaseDDC (byte SysCtrlRegVal)
+{
+	byte DDCReqTimeout = T_DDC_ACCESS;
+	byte TPI_ControlImage;
+
+	TPI_TRACE_PRINT((">>ReleaseDDC()\n"));
+
+	SysCtrlRegVal &= ~BITS_2_1;					// Just to be sure bits [2:1] are 0 before it is written
+
+	while (DDCReqTimeout--)						// Loop till 0x1A[1] reads "0"
+	{
+		// Cannot use ReadClearWriteTPI() here. A read of TPI_SYSTEM_CONTROL is invalid while DDC is granted.
+		// Doing so will return 0xFF, and cause an invalid value to be written back.
+		//ReadClearWriteTPI(TPI_SYSTEM_CONTROL,BITS_2_1); // 0x1A[2:1] = "0" - release the DDC bus
+
+		WriteByteTPI(TPI_SYSTEM_CONTROL_DATA_REG, SysCtrlRegVal);
+		TPI_ControlImage = ReadByteTPI(TPI_SYSTEM_CONTROL_DATA_REG);
+
+		if (!(TPI_ControlImage & BITS_2_1))		// When 0x1A[2:1] read "0"
+			return TRUE;
+	}
+
+	return FALSE;								// Failed to release DDC bus control
+}
+
+//------------------------------------------------------------------------------
+// Function Name: CheckEDID_Header()
+// Function Description: Checks if EDID header is correct per VESA E-EDID standard
+//
+// Accepts: Pointer to 1st EDID block
+// Returns: TRUE or FLASE
+// Globals: EDID data
+//------------------------------------------------------------------------------
+byte CheckEDID_Header (byte *Block)
+{
+	byte i = 0;
+
+	if (Block[i])               // byte 0 must be 0
+		return FALSE;
+
+	for (i = 1; i < 1 + EDID_HDR_NO_OF_FF; i++)
+	{
+		if(Block[i] != 0xFF)    // bytes [1..6] must be 0xFF
+			return FALSE;
+	}
+
+	if (Block[i])               // byte 7 must be 0
+		return FALSE;
+
+	return TRUE;
+}
+
+//------------------------------------------------------------------------------
+// Function Name: DoEDID_Checksum()
+// Function Description: Calculte checksum of the 128 byte block pointed to by the
+//                  pointer passed as parameter
+//
+// Accepts: Pointer to a 128 byte block whose checksum needs to be calculated
+// Returns: TRUE or FLASE
+// Globals: EDID data
+//------------------------------------------------------------------------------
+byte DoEDID_Checksum (byte *Block)
+{
+	byte i;
+	byte CheckSum = 0;
+
+	for (i = 0; i < EDID_BLOCK_SIZE; i++)
+		CheckSum += Block[i];
+
+	if (CheckSum)
+		return FALSE;
+
+	return TRUE;
+}
+
+//------------------------------------------------------------------------------
+// Function Name: ParseEstablishedTiming()
+// Function Description: Parse the established timing section of EDID Block 0 and
+//                  print their decoded meaning to the screen.
+//
+// Accepts: Pointer to the 128 byte array where the data read from EDID Block0 is stored.
+// Returns: none
+// Globals: EDID data
+//------------------------------------------------------------------------------
+#if (CONF__TPI_EDID_PRINT == ENABLE)
+void ParseEstablishedTiming (byte *Data)
+{
+	TPI_EDID_PRINT(("Parsing Established Timing:\n"));
+	TPI_EDID_PRINT(("===========================\n"));
+
+	// Parse Established Timing Byte #0
+	if(Data[ESTABLISHED_TIMING_INDEX] & BIT_7)
+		TPI_EDID_PRINT(("720 x 400 @ 70Hz\n"));
+	if(Data[ESTABLISHED_TIMING_INDEX] & BIT_6)
+		TPI_EDID_PRINT(("720 x 400 @ 88Hz\n"));
+	if(Data[ESTABLISHED_TIMING_INDEX] & BIT_5)
+		TPI_EDID_PRINT(("640 x 480 @ 60Hz\n"));
+	if(Data[ESTABLISHED_TIMING_INDEX] & BIT_4)
+		TPI_EDID_PRINT(("640 x 480 @ 67Hz\n"));
+	if(Data[ESTABLISHED_TIMING_INDEX] & BIT_3)
+		TPI_EDID_PRINT(("640 x 480 @ 72Hz\n"));
+	if(Data[ESTABLISHED_TIMING_INDEX] & BIT_2)
+		TPI_EDID_PRINT(("640 x 480 @ 75Hz\n"));
+	if(Data[ESTABLISHED_TIMING_INDEX] & BIT_1)
+		TPI_EDID_PRINT(("800 x 600 @ 56Hz\n"));
+	if(Data[ESTABLISHED_TIMING_INDEX] & BIT_0)
+		TPI_EDID_PRINT(("800 x 400 @ 60Hz\n"));
+
+	// Parse Established Timing Byte #1:
+	if(Data[ESTABLISHED_TIMING_INDEX + 1]  & BIT_7)
+		TPI_EDID_PRINT(("800 x 600 @ 72Hz\n"));
+	if(Data[ESTABLISHED_TIMING_INDEX + 1]  & BIT_6)
+		TPI_EDID_PRINT(("800 x 600 @ 75Hz\n"));
+	if(Data[ESTABLISHED_TIMING_INDEX + 1]  & BIT_5)
+		TPI_EDID_PRINT(("832 x 624 @ 75Hz\n"));
+	if(Data[ESTABLISHED_TIMING_INDEX + 1]  & BIT_4)
+		TPI_EDID_PRINT(("1024 x 768 @ 87Hz\n"));
+	if(Data[ESTABLISHED_TIMING_INDEX + 1]  & BIT_3)
+		TPI_EDID_PRINT(("1024 x 768 @ 60Hz\n"));
+	if(Data[ESTABLISHED_TIMING_INDEX + 1]  & BIT_2)
+		TPI_EDID_PRINT(("1024 x 768 @ 70Hz\n"));
+	if(Data[ESTABLISHED_TIMING_INDEX + 1]  & BIT_1)
+		TPI_EDID_PRINT(("1024 x 768 @ 75Hz\n"));
+	if(Data[ESTABLISHED_TIMING_INDEX + 1]  & BIT_0)
+		TPI_EDID_PRINT(("1280 x 1024 @ 75Hz\n"));
+
+	// Parse Established Timing Byte #2:
+	if(Data[ESTABLISHED_TIMING_INDEX + 2] & 0x80)
+		TPI_EDID_PRINT(("1152 x 870 @ 75Hz\n"));
+
+	if((!Data[0])&&(!Data[ESTABLISHED_TIMING_INDEX + 1]  )&&(!Data[2]))
+		TPI_EDID_PRINT(("No established video modes\n"));
+}
+
+//------------------------------------------------------------------------------
+// Function Name: ParseStandardTiming()
+// Function Description: Parse the standard timing section of EDID Block 0 and
+//                  print their decoded meaning to the screen.
+//
+// Accepts: Pointer to the 128 byte array where the data read from EDID Block0 is stored.
+// Returns: none
+// Globals: EDID data
+//------------------------------------------------------------------------------
+void ParseStandardTiming (byte *Data)
+{
+	byte i;
+	byte AR_Code;
+
+	TPI_EDID_PRINT(("Parsing Standard Timing:\n"));
+	TPI_EDID_PRINT(("========================\n"));
+
+	for (i = 0; i < NUM_OF_STANDARD_TIMINGS; i += 2)
+	{
+		if ((Data[STANDARD_TIMING_OFFSET + i] == 0x01) && ((Data[STANDARD_TIMING_OFFSET + i +1]) == 1))
+		{
+			TPI_EDID_PRINT(("Standard Timing Undefined\n")); // per VESA EDID standard, Release A, Revision 1, February 9, 2000, Sec. 3.9
+		}
+		else
+		{
+			TPI_EDID_PRINT(("Horizontal Active pixels: %i\n", (int)((Data[STANDARD_TIMING_OFFSET + i] + 31)*8)));    // per VESA EDID standard, Release A, Revision 1, February 9, 2000, Table 3.15
+
+			AR_Code = (Data[STANDARD_TIMING_OFFSET + i +1] & TWO_MSBITS) >> 6;
+			TPI_EDID_PRINT(("Aspect Ratio: "));
+
+			switch(AR_Code)
+			{
+				case AR16_10:
+					TPI_EDID_PRINT(("16:10\n"));
+					break;
+
+				case AR4_3:
+					TPI_EDID_PRINT(("4:3\n"));
+					break;
+
+				case AR5_4:
+					TPI_EDID_PRINT(("5:4\n"));
+					break;
+
+				case AR16_9:
+					TPI_EDID_PRINT(("16:9\n"));
+					break;
+			}
+		}
+	}
+}
+
+//------------------------------------------------------------------------------
+// Function Name: ParseDetailedTiming()
+// Function Description: Parse the detailed timing section of EDID Block 0 and
+//                  print their decoded meaning to the screen.
+//
+// Accepts: Pointer to the 128 byte array where the data read from EDID Block0 is stored.
+//              Offset to the beginning of the Detailed Timing Descriptor data.
+//
+//              Block indicator to distinguish between block #0 and blocks #2, #3
+// Returns: none
+// Globals: EDID data
+//------------------------------------------------------------------------------
+byte ParseDetailedTiming (byte *Data, byte DetailedTimingOffset, byte Block)
+{
+	byte TmpByte;
+	byte i;
+	word TmpWord;
+
+	TmpWord = Data[DetailedTimingOffset + PIX_CLK_OFFSET] +
+		256 * Data[DetailedTimingOffset + PIX_CLK_OFFSET + 1];
+
+	if (TmpWord == 0x00)            // 18 byte partition is used as either for Monitor Name or for Monitor Range Limits or it is unused
+	{
+		if (Block == EDID_BLOCK_0)      // if called from Block #0 and first 2 bytes are 0 => either Monitor Name or for Monitor Range Limits
+		{
+			if (Data[DetailedTimingOffset + 3] == 0xFC) // these 13 bytes are ASCII coded monitor name
+			{
+				TPI_EDID_PRINT(("Monitor Name: "));
+
+				for (i = 0; i < 13; i++)
+				{
+					TPI_EDID_PRINT(("%c", Data[DetailedTimingOffset + 5 + i])); // Display monitor name on SiIMon
+				}
+				TPI_EDID_PRINT(("\n"));
+			}
+
+			else if (Data[DetailedTimingOffset + 3] == 0xFD) // these 13 bytes contain Monitor Range limits, binary coded
+			{
+				TPI_EDID_PRINT(("Monitor Range Limits:\n\n"));
+
+				i = 0;
+				TPI_EDID_PRINT(("Min Vertical Rate in Hz: %d\n", (int) Data[DetailedTimingOffset + 5 + i++])); //
+				TPI_EDID_PRINT(("Max Vertical Rate in Hz: %d\n", (int) Data[DetailedTimingOffset + 5 + i++])); //
+				TPI_EDID_PRINT(("Min Horizontal Rate in Hz: %d\n", (int) Data[DetailedTimingOffset + 5 + i++])); //
+				TPI_EDID_PRINT(("Max Horizontal Rate in Hz: %d\n", (int) Data[DetailedTimingOffset + 5 + i++])); //
+				TPI_EDID_PRINT(("Max Supported pixel clock rate in MHz/10: %d\n", (int) Data[DetailedTimingOffset + 5 + i++])); //
+				TPI_EDID_PRINT(("Tag for secondary timing formula (00h=not used): %d\n", (int) Data[DetailedTimingOffset + 5 + i++])); //
+				TPI_EDID_PRINT(("Min Vertical Rate in Hz %d\n", (int) Data[DetailedTimingOffset + 5 + i])); //
+				TPI_EDID_PRINT(("\n"));
+			}
+		}
+
+		else if (Block == EDID_BLOCK_2_3)                          // if called from block #2 or #3 and first 2 bytes are 0x00 (padding) then this
+		{                                                                                          // descriptor partition is not used and parsing should be stopped
+			TPI_EDID_PRINT(("No More Detailed descriptors in this block\n"));
+			TPI_EDID_PRINT(("\n"));
+			return FALSE;
+		}
+	}
+
+	else                                            // first 2 bytes are not 0 => this is a detailed timing descriptor from either block
+	{
+		if((Block == EDID_BLOCK_0) && (DetailedTimingOffset == 0x36))
+		{
+			TPI_EDID_PRINT(("\n\n\nParse Results, EDID Block #0, Detailed Descriptor Number 1:\n"));
+			TPI_EDID_PRINT(("===========================================================\n\n"));
+		}
+		else if((Block == EDID_BLOCK_0) && (DetailedTimingOffset == 0x48))
+		{
+			TPI_EDID_PRINT(("\n\n\nParse Results, EDID Block #0, Detailed Descriptor Number 2:\n"));
+			TPI_EDID_PRINT(("===========================================================\n\n"));
+		}
+
+		TPI_EDID_PRINT(("Pixel Clock (MHz * 100): %d\n", (int)TmpWord));
+
+		TmpWord = Data[DetailedTimingOffset + H_ACTIVE_OFFSET] +
+			256 * ((Data[DetailedTimingOffset + H_ACTIVE_OFFSET + 2] >> 4) & FOUR_LSBITS);
+		TPI_EDID_PRINT(("Horizontal Active Pixels: %d\n", (int)TmpWord));
+
+		TmpWord = Data[DetailedTimingOffset + H_BLANKING_OFFSET] +
+			256 * (Data[DetailedTimingOffset + H_BLANKING_OFFSET + 1] & FOUR_LSBITS);
+		TPI_EDID_PRINT(("Horizontal Blanking (Pixels): %d\n", (int)TmpWord));
+
+		TmpWord = (Data[DetailedTimingOffset + V_ACTIVE_OFFSET] )+
+			256 * ((Data[DetailedTimingOffset + (V_ACTIVE_OFFSET) + 2] >> 4) & FOUR_LSBITS);
+		TPI_EDID_PRINT(("Vertical Active (Lines): %d\n", (int)TmpWord));
+
+		TmpWord = Data[DetailedTimingOffset + V_BLANKING_OFFSET] +
+			256 * (Data[DetailedTimingOffset + V_BLANKING_OFFSET + 1] & LOW_NIBBLE);
+		TPI_EDID_PRINT(("Vertical Blanking (Lines): %d\n", (int)TmpWord));
+
+		TmpWord = Data[DetailedTimingOffset + H_SYNC_OFFSET] +
+			256 * ((Data[DetailedTimingOffset + (H_SYNC_OFFSET + 3)] >> 6) & TWO_LSBITS);
+		TPI_EDID_PRINT(("Horizontal Sync Offset (Pixels): %d\n", (int)TmpWord));
+
+		TmpWord = Data[DetailedTimingOffset + H_SYNC_PW_OFFSET] +
+			256 * ((Data[DetailedTimingOffset + (H_SYNC_PW_OFFSET + 2)] >> 4) & TWO_LSBITS);
+		TPI_EDID_PRINT(("Horizontal Sync Pulse Width (Pixels): %d\n", (int)TmpWord));
+
+		TmpWord = (Data[DetailedTimingOffset + V_SYNC_OFFSET] >> 4) & FOUR_LSBITS +
+			256 * ((Data[DetailedTimingOffset + (V_SYNC_OFFSET + 1)] >> 2) & TWO_LSBITS);
+		TPI_EDID_PRINT(("Vertical Sync Offset (Lines): %d\n", (int)TmpWord));
+
+		TmpWord = (Data[DetailedTimingOffset + V_SYNC_PW_OFFSET]) & FOUR_LSBITS +
+			256 * (Data[DetailedTimingOffset + (V_SYNC_PW_OFFSET + 1)] & TWO_LSBITS);
+		TPI_EDID_PRINT(("Vertical Sync Pulse Width (Lines): %d\n", (int)TmpWord));
+
+		TmpWord = Data[DetailedTimingOffset + H_IMAGE_SIZE_OFFSET] +
+			256 * (((Data[DetailedTimingOffset + (H_IMAGE_SIZE_OFFSET + 2)]) >> 4) & FOUR_LSBITS);
+		TPI_EDID_PRINT(("Horizontal Image Size (mm): %d\n", (int)TmpWord));
+
+		TmpWord = Data[DetailedTimingOffset + V_IMAGE_SIZE_OFFSET] +
+			256 * (Data[DetailedTimingOffset + (V_IMAGE_SIZE_OFFSET + 1)] & FOUR_LSBITS);
+		TPI_EDID_PRINT(("Vertical Image Size (mm): %d\n", (int)TmpWord));
+
+		TmpByte = Data[DetailedTimingOffset + H_BORDER_OFFSET];
+		TPI_EDID_PRINT(("Horizontal Border (Pixels): %d\n", (int)TmpByte));
+
+		TmpByte = Data[DetailedTimingOffset + V_BORDER_OFFSET];
+		TPI_EDID_PRINT(("Vertical Border (Lines): %d\n", (int)TmpByte));
+
+		TmpByte = Data[DetailedTimingOffset + FLAGS_OFFSET];
+		if (TmpByte & BIT_7)
+			TPI_EDID_PRINT(("Interlaced\n"));
+		else
+			TPI_EDID_PRINT(("Non-Interlaced\n"));
+
+		if (!(TmpByte & BIT_5) && !(TmpByte & BIT_6))
+			TPI_EDID_PRINT(("Normal Display, No Stereo\n"));
+		else
+			TPI_EDID_PRINT(("Refer to VESA E-EDID Release A, Revision 1, table 3.17\n"));
+
+		if (!(TmpByte & BIT_3) && !(TmpByte & BIT_4))
+			TPI_EDID_PRINT(("Analog Composite\n"));
+		if ((TmpByte & BIT_3) && !(TmpByte & BIT_4))
+			TPI_EDID_PRINT(("Bipolar Analog Composite\n"));
+		else if (!(TmpByte & BIT_3) && (TmpByte & BIT_4))
+			TPI_EDID_PRINT(("Digital Composite\n"));
+
+		else if ((TmpByte & BIT_3) && (TmpByte & BIT_4))
+			TPI_EDID_PRINT(("Digital Separate\n"));
+
+		TPI_EDID_PRINT(("\n"));
+	}
+	return TRUE;
+}
+
+//------------------------------------------------------------------------------
+// Function Name: ParseBlock_0_TimingDescriptors()
+// Function Description: Parse EDID Block 0 timing descriptors per EEDID 1.3
+//                  standard. printf() values to screen.
+//
+// Accepts: Pointer to the 128 byte array where the data read from EDID Block0 is stored.
+// Returns: none
+// Globals: EDID data
+//------------------------------------------------------------------------------
+void ParseBlock_0_TimingDescriptors (byte *Data)
+{
+	byte i;
+	byte Offset;
+
+	ParseEstablishedTiming(Data);
+	ParseStandardTiming(Data);
+
+	for (i = 0; i < NUM_OF_DETAILED_DESCRIPTORS; i++)
+	{
+		Offset = DETAILED_TIMING_OFFSET + (LONG_DESCR_LEN * i);
+		ParseDetailedTiming(Data, Offset, EDID_BLOCK_0);
+	}
+}
+#endif
+
+//------------------------------------------------------------------------------
+// Function Name: ParseEDID()
+// Function Description: Extract sink properties from its EDID file and save them in
+//                  global structure g_edid.
+//
+// Accepts: none
+// Returns: TRUE or FLASE
+// Globals: EDID data
+// NOTE: Fields that are not supported by the 9022/4 (such as deep color) were not parsed.
+//------------------------------------------------------------------------------
+byte ParseEDID (byte *pEdid, byte *numExt)
+{
+	byte i, j, k;
+
+	TPI_EDID_PRINT(("\n"));
+	TPI_EDID_PRINT(("EDID DATA (Segment = 0 Block = 0 Offset = %d):\n", (int) EDID_BLOCK_0_OFFSET));
+
+	for (j = 0, i = 0; j < 128; j++)
+	{
+		k = pEdid[j];
+		TPI_EDID_PRINT(("%2.2X ", (int) k));
+		i++;
+
+		if (i == 0x10)
+		{
+			TPI_EDID_PRINT(("\n"));
+			i = 0;
+		}
+	}
+	TPI_EDID_PRINT(("\n"));
+
+	if (!CheckEDID_Header(pEdid))                      //Checks if EDID header is correct per VESA E-EDID standard(/byte 0 must be 0, bytes [1..6] must be 0xFF,byte 7 must be 0)
+	{
+		// first 8 bytes of EDID must be {0, FF, FF, FF, FF, FF, FF, 0}
+		TPI_DEBUG_PRINT(("EDID -> Incorrect Header\n"));
+		return EDID_INCORRECT_HEADER;
+	}
+
+	if (!DoEDID_Checksum(pEdid))
+	{
+		// non-zero EDID checksum
+		TPI_DEBUG_PRINT(("EDID -> Checksum Error\n"));
+		return EDID_CHECKSUM_ERROR;
+	}
+
+#if (CONF__TPI_EDID_PRINT == ENABLE)
+	ParseBlock_0_TimingDescriptors(pEdid);			// Parse EDID Block #0 Desctiptors
+#endif
+
+	*numExt = pEdid[NUM_OF_EXTEN_ADDR];	// read # of extensions from offset 0x7E of block 0
+	TPI_EDID_PRINT(("EDID -> 861 Extensions = %d\n", (int) *numExt));
+
+	if (!(*numExt))
+	{
+		// No extensions to worry about
+		return EDID_NO_861_EXTENSIONS;
+	}
+
+	//return Parse861Extensions(NumOfExtensions);			// Parse 861 Extensions (short and long descriptors);
+	return (EDID_OK);
+}
+
+//------------------------------------------------------------------------------
+// Function Name: Parse861ShortDescriptors()
+// Function Description: Parse CEA-861 extension short descriptors of the EDID block
+//                  passed as a parameter and save them in global structure g_edid.
+//
+// Accepts: A pointer to the EDID 861 Extension block being parsed.
+// Returns: EDID_PARSED_OK if EDID parsed correctly. Error code if failed.
+// Globals: EDID data
+// NOTE: Fields that are not supported by the 9022/4 (such as deep color) were not parsed.
+//------------------------------------------------------------------------------
+byte Parse861ShortDescriptors (byte *Data)
+{
+	byte LongDescriptorOffset;
+	byte DataBlockLength;
+	byte DataIndex;
+	byte ExtendedTagCode;
+	byte VSDB_BaseOffset = 0;
+
+	byte V_DescriptorIndex = 0;  // static to support more than one extension
+	byte A_DescriptorIndex = 0;  // static to support more than one extension
+
+	byte TagCode;
+
+	byte i;
+	byte j;
+
+	if (Data[EDID_TAG_ADDR] != EDID_EXTENSION_TAG)
+	{
+		TPI_EDID_PRINT(("EDID -> Extension Tag Error\n"));
+		return EDID_EXT_TAG_ERROR;
+	}
+
+	if (Data[EDID_REV_ADDR] != EDID_REV_THREE)
+	{
+		TPI_EDID_PRINT(("EDID -> Revision Error\n"));
+		return EDID_REV_ADDR_ERROR;
+	}
+
+	LongDescriptorOffset = Data[LONG_DESCR_PTR_IDX];    // block offset where long descriptors start
+
+	g_edid.UnderScan = ((Data[MISC_SUPPORT_IDX]) >> 7) & LSBIT;  // byte #3 of CEA extension version 3
+	g_edid.BasicAudio = ((Data[MISC_SUPPORT_IDX]) >> 6) & LSBIT;
+	g_edid.YCbCr_4_4_4 = ((Data[MISC_SUPPORT_IDX]) >> 5) & LSBIT;
+	g_edid.YCbCr_4_2_2 = ((Data[MISC_SUPPORT_IDX]) >> 4) & LSBIT;
+
+	DataIndex = EDID_DATA_START;            // 4
+
+	while (DataIndex < LongDescriptorOffset)
+	{
+		TagCode = (Data[DataIndex] >> 5) & THREE_LSBITS;
+		DataBlockLength = Data[DataIndex++] & FIVE_LSBITS;
+		if ((DataIndex + DataBlockLength) > LongDescriptorOffset)
+		{
+			TPI_EDID_PRINT(("EDID -> V Descriptor Overflow\n"));
+			return EDID_V_DESCR_OVERFLOW;
+		}
+
+		i = 0;                                  // num of short video descriptors in current data block
+
+		switch (TagCode)
+		{
+			case VIDEO_D_BLOCK:
+				while ((i < DataBlockLength) && (i < MAX_V_DESCRIPTORS))        // each SVD is 1 byte long
+				{
+					g_edid.VideoDescriptor[V_DescriptorIndex++] = Data[DataIndex++];
+					i++;
+				}
+				DataIndex += DataBlockLength - i;   // if there are more STDs than MAX_V_DESCRIPTORS, skip the last ones. Update DataIndex
+
+				TPI_EDID_PRINT(("EDID -> Short Descriptor Video Block\n"));
+				break;
+
+			case AUDIO_D_BLOCK:
+				while (i < DataBlockLength/3)       // each SAD is 3 bytes long
+				{
+					j = 0;
+					while (j < AUDIO_DESCR_SIZE)    // 3
+					{
+						g_edid.AudioDescriptor[A_DescriptorIndex][j++] = Data[DataIndex++];
+					}
+					A_DescriptorIndex++;
+					i++;
+				}
+				TPI_EDID_PRINT(("EDID -> Short Descriptor Audio Block\n"));
+				break;
+
+			case  SPKR_ALLOC_D_BLOCK:
+				g_edid.SpkrAlloc[i++] = Data[DataIndex++];       // although 3 bytes are assigned to Speaker Allocation, only
+				DataIndex += 2;                                     // the first one carries information, so the next two are ignored by this code.
+				TPI_EDID_PRINT(("EDID -> Short Descriptor Speaker Allocation Block\n"));
+				break;
+
+			case USE_EXTENDED_TAG:
+				ExtendedTagCode = Data[DataIndex++];
+
+				switch (ExtendedTagCode)
+				{
+					case VIDEO_CAPABILITY_D_BLOCK:
+						TPI_EDID_PRINT(("EDID -> Short Descriptor Video Capability Block\n"));
+
+						// TO BE ADDED HERE: Save "video capability" parameters in g_edid data structure
+						// Need to modify that structure definition
+						// In the meantime: just increment DataIndex by 1
+						DataIndex += 1;    // replace with reading and saving the proper data per CEA-861 sec. 7.5.6 while incrementing DataIndex
+						break;
+
+					case COLORIMETRY_D_BLOCK:
+						g_edid.ColorimetrySupportFlags = Data[DataIndex++] & BITS_1_0;
+						g_edid.MetadataProfile = Data[DataIndex++] & BITS_2_1_0;
+
+						TPI_EDID_PRINT(("EDID -> Short Descriptor Colorimetry Block\n"));
+						break;
+				}
+				break;
+
+			case VENDOR_SPEC_D_BLOCK:
+				VSDB_BaseOffset = DataIndex - 1;
+
+				if ((Data[DataIndex++] == 0x03) &&    // check if sink is HDMI compatible
+						(Data[DataIndex++] == 0x0C) &&
+						(Data[DataIndex++] == 0x00))
+
+					g_edid.HDMI_Sink = TRUE;
+				else
+					g_edid.HDMI_Sink = FALSE;
+
+				g_edid.CEC_A_B = Data[DataIndex++];  // CEC Physical address
+				g_edid.CEC_C_D = Data[DataIndex++];
+
+#ifdef DEV_SUPPORT_CEC
+				// Take the Address that was passed in the EDID and use this API
+				// to set the physical address for CEC.
+				{
+					word	phyAddr;
+					phyAddr = (word)g_edid.CEC_C_D;	 // Low-order nibbles
+					phyAddr |= ((word)g_edid.CEC_A_B << 8); // Hi-order nibbles
+					// Is the new PA different from the current PA?
+					if (phyAddr != SI_CecGetDevicePA ())
+					{
+						// Yes!  So change the PA
+						SI_CecSetDevicePA (phyAddr);
+					}
+				}
+#endif
+
+				if ((DataIndex + 7) > VSDB_BaseOffset + DataBlockLength)        // Offset of 3D_Present bit in VSDB
+					g_edid._3D_Supported = FALSE;
+				else if (Data[DataIndex + 7] >> 7)
+					g_edid._3D_Supported = TRUE;
+				else
+					g_edid._3D_Supported = FALSE;
+
+				DataIndex += DataBlockLength - HDMI_SIGNATURE_LEN - CEC_PHYS_ADDR_LEN; // Point to start of next block
+				TPI_EDID_PRINT(("EDID -> Short Descriptor Vendor Block\n"));
+				TPI_EDID_PRINT(("\n"));
+				break;
+
+			default:
+				TPI_EDID_PRINT(("EDID -> Unknown Tag Code\n"));
+				return EDID_UNKNOWN_TAG_CODE;
+
+		}                   // End, Switch statement
+	}                       // End, while (DataIndex < LongDescriptorOffset) statement
+
+	return EDID_SHORT_DESCRIPTORS_OK;
+}
+
+//------------------------------------------------------------------------------
+// Function Name: Parse861LongDescriptors()
+// Function Description: Parse CEA-861 extension long descriptors of the EDID block
+//                  passed as a parameter and printf() them to the screen.
+//
+// Accepts: A pointer to the EDID block being parsed
+// Returns: An error code if no long descriptors found; EDID_PARSED_OK if descriptors found.
+// Globals: none
+//------------------------------------------------------------------------------
+byte Parse861LongDescriptors (byte *Data)
+{
+	byte LongDescriptorsOffset;
+	byte DescriptorNum = 1;
+
+	LongDescriptorsOffset = Data[LONG_DESCR_PTR_IDX];   // EDID block offset 2 holds the offset
+
+	if (!LongDescriptorsOffset)                         // per CEA-861-D, table 27
+	{
+		TPI_DEBUG_PRINT(("EDID -> No Detailed Descriptors\n"));
+		return EDID_NO_DETAILED_DESCRIPTORS;
+	}
+
+	// of the 1st 18-byte descriptor
+	while (LongDescriptorsOffset + LONG_DESCR_LEN < EDID_BLOCK_SIZE)
+	{
+		TPI_EDID_PRINT(("Parse Results - CEA-861 Long Descriptor #%d:\n", (int) DescriptorNum));
+		TPI_EDID_PRINT(("===============================================================\n"));
+
+#if (CONF__TPI_EDID_PRINT == ENABLE)
+		if (!ParseDetailedTiming(Data, LongDescriptorsOffset, EDID_BLOCK_2_3))
+			break;
+#endif
+		LongDescriptorsOffset +=  LONG_DESCR_LEN;
+		DescriptorNum++;
+	}
+
+	return EDID_LONG_DESCRIPTORS_OK;
+}
+
+//------------------------------------------------------------------------------
+// Function Name: Parse861Extensions()
+// Function Description: Parse CEA-861 extensions from EDID ROM (EDID blocks beyond
+//                  block #0). Save short descriptors in global structure
+//                  g_edid. printf() long descriptors to the screen.
+//
+// Accepts: The number of extensions in the EDID being parsed
+// Returns: EDID_PARSED_OK if EDID parsed correctly. Error code if failed.
+// Globals: EDID data
+// NOTE: Fields that are not supported by the 9022/4 (such as deep color) were not parsed.
+//------------------------------------------------------------------------------
+byte Parse861Extensions (byte NumOfExtensions)
+{
+	byte i,j,k;
+
+	byte ErrCode;
+
+	//byte V_DescriptorIndex = 0;
+	//byte A_DescriptorIndex = 0;
+
+	byte Segment = 0;
+	byte Block = 0;
+	byte Offset = 0;
+
+	g_edid.HDMI_Sink = FALSE;
+
+	do
+	{
+		Block++;
+
+		Offset = 0;
+		if ((Block % 2) > 0)
+		{
+			Offset = EDID_BLOCK_SIZE;
+		}
+
+		Segment = (byte) (Block / 2);
+
+		if (Block == 1)
+		{
+			ReadBlockEDID(EDID_BLOCK_1_OFFSET, EDID_BLOCK_SIZE, g_CommData);    // read first 128 bytes of EDID ROM
+		}
+		else
+		{
+			ReadSegmentBlockEDID(Segment, Offset, EDID_BLOCK_SIZE, g_CommData);     // read next 128 bytes of EDID ROM
+		}
+
+		TPI_TRACE_PRINT(("\n"));
+		TPI_TRACE_PRINT(("EDID DATA (Segment = %d Block = %d Offset = %d):\n", (int) Segment, (int) Block, (int) Offset));
+		for (j=0, i=0; j<128; j++)
+		{
+			k = g_CommData[j];
+			TPI_EDID_PRINT(("%2.2X ", (int) k));
+			i++;
+
+			if (i == 0x10)
+			{
+				TPI_EDID_PRINT(("\n"));
+				i = 0;
+			}
+		}
+		TPI_EDID_PRINT(("\n"));
+
+		if ((NumOfExtensions > 1) && (Block == 1))
+		{
+			continue;
+		}
+
+		ErrCode = Parse861ShortDescriptors(g_CommData);
+		if (ErrCode != EDID_SHORT_DESCRIPTORS_OK)
+		{
+			return ErrCode;
+		}
+
+		ErrCode = Parse861LongDescriptors(g_CommData);
+		if (ErrCode != EDID_LONG_DESCRIPTORS_OK)
+		{
+			return ErrCode;
+		}
+
+	} while (Block < NumOfExtensions);
+
+	return EDID_OK;
+}
+
+//------------------------------------------------------------------------------
+// Function Name: DoEdidRead()
+// Function Description: EDID processing
+//
+// Accepts: none
+// Returns: TRUE or FLASE
+// Globals: none
+//------------------------------------------------------------------------------
+byte DoEdidRead (void)
+{
+	byte SysCtrlReg;
+	byte Result;
+	byte NumOfExtensions;
+
+	// If we already have valid EDID data, ship this whole thing
+	if (g_edid.edidDataValid == FALSE)
+	{
+		// Request access to DDC bus from the receiver
+		if (GetDDC_Access(&SysCtrlReg))
+		{
+			ReadBlockEDID(EDID_BLOCK_0_OFFSET, EDID_BLOCK_SIZE, g_CommData);		// read first 128 bytes of EDID ROM
+			Result = ParseEDID(g_CommData, &NumOfExtensions);
+			if (Result != EDID_OK)
+			{
+				if (Result == EDID_NO_861_EXTENSIONS)
+				{
+					TPI_DEBUG_PRINT (("EDID -> No 861 Extensions\n"));
+					g_edid.HDMI_Sink = FALSE;
+					g_edid.YCbCr_4_4_4 = FALSE;
+					g_edid.YCbCr_4_2_2 = FALSE;
+					g_edid.CEC_A_B = 0x00;
+					g_edid.CEC_C_D = 0x00;
+				}
+				else
+				{
+					TPI_DEBUG_PRINT (("EDID -> Parse FAILED\n"));
+					g_edid.HDMI_Sink = TRUE;
+					g_edid.YCbCr_4_4_4 = FALSE;
+					g_edid.YCbCr_4_2_2 = FALSE;
+					g_edid.CEC_A_B = 0x00;
+					g_edid.CEC_C_D = 0x00;
+				}
+			}
+			else
+			{
+				TPI_DEBUG_PRINT (("EDID -> Parse OK\n"));
+				Result = Parse861Extensions(NumOfExtensions);		// Parse 861 Extensions (short and long descriptors);
+				if (Result != EDID_OK)
+				{
+					TPI_DEBUG_PRINT(("EDID -> Extension Parse FAILED\n"));
+					g_edid.HDMI_Sink = TRUE;
+					g_edid.YCbCr_4_4_4 = FALSE;
+					g_edid.YCbCr_4_2_2 = FALSE;
+					g_edid.CEC_A_B = 0x00;
+					g_edid.CEC_C_D = 0x00;
+				}
+			}
+
+			if (!ReleaseDDC(SysCtrlReg))				// Host must release DDC bus once it is done reading EDID
+			{
+				TPI_DEBUG_PRINT (("EDID -> DDC bus release failed\n"));
+				return EDID_DDC_BUS_RELEASE_FAILURE;
+			}
+		}
+		else
+		{
+			TPI_DEBUG_PRINT (("EDID -> DDC bus request failed\n"));
+			g_edid.HDMI_Sink = TRUE;
+			g_edid.YCbCr_4_4_4 = FALSE;
+			g_edid.YCbCr_4_2_2 = FALSE;
+			g_edid.CEC_A_B = 0x00;
+			g_edid.CEC_C_D = 0x00;
+			return EDID_DDC_BUS_REQ_FAILURE;
+		}
+
+		TPI_DEBUG_PRINT(("EDID -> g_edid.HDMI_Sink = %d\n", (int)g_edid.HDMI_Sink));
+		TPI_DEBUG_PRINT(("EDID -> g_edid.YCbCr_4_4_4 = %d\n", (int)g_edid.YCbCr_4_4_4));
+		TPI_DEBUG_PRINT(("EDID -> g_edid.YCbCr_4_2_2 = %d\n", (int)g_edid.YCbCr_4_2_2));
+		TPI_DEBUG_PRINT(("EDID -> g_edid.CEC_A_B = 0x%x\n", (int)g_edid.CEC_A_B));
+		TPI_DEBUG_PRINT(("EDID -> g_edid.CEC_C_D = 0x%x\n", (int)g_edid.CEC_C_D));
+
+		g_edid.edidDataValid = TRUE;
+	}
+	return 0;
+}
+
+#endif
+
+
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////*************************///////////////////////////////
+///////////////////////                  HDCP                 ///////////////////////////////
+///////////////////////*************************///////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+//------------------------------------------------------------------------------
+// Function Name: IsHDCP_Supported()
+// Function Description: Check Tx revision number to find if this Tx supports HDCP
+//                  by reading the HDCP revision number from TPI register 0x30.
+//
+// Accepts: none
+// Returns: TRUE if Tx supports HDCP. FALSE if not.
+// Globals: none
+//------------------------------------------------------------------------------
+byte IsHDCP_Supported (void)
+{
+	byte HDCP_Rev;
+	byte HDCP_Supported;
+
+	TPI_TRACE_PRINT((">>IsHDCP_Supported()\n"));
+
+	HDCP_Supported = TRUE;
+
+	// Check Device ID
+	HDCP_Rev = ReadByteTPI(TPI_HDCP_REVISION_DATA_REG);
+
+	if (HDCP_Rev != (HDCP_MAJOR_REVISION_VALUE | HDCP_MINOR_REVISION_VALUE))
+	{
+		HDCP_Supported = FALSE;
+	}
+
+	// Even if HDCP is supported check for incorrect Device ID // for SiI_9022AYBT_DEVICEID_CHECK
+	HDCP_Rev = ReadByteTPI(TPI_AKSV_1_REG);
+	if (HDCP_Rev == 0x09)
+	{
+		HDCP_Rev = ReadByteTPI(TPI_AKSV_2_REG);
+		if (HDCP_Rev == 0x00)
+		{
+			HDCP_Rev = ReadByteTPI(TPI_AKSV_3_REG);
+			if (HDCP_Rev == 0x02)
+			{
+				HDCP_Rev = ReadByteTPI(TPI_AKSV_4_REG);
+				if (HDCP_Rev == 0x02)
+				{
+					HDCP_Rev = ReadByteTPI(TPI_AKSV_5_REG);
+					if (HDCP_Rev == 0x0a)
+					{
+						HDCP_Supported = FALSE;
+						TPI_TRACE_PRINT((">>sii902xA found, NO HDCP supported\n"));
+					}
+				}
+			}
+		}
+	}
+	return HDCP_Supported;
+}
+
+//------------------------------------------------------------------------------
+// Function Name: AreAKSV_OK()
+// Function Description: Check if AKSVs contain 20 '0' and 20 '1'
+//
+// Accepts: none
+// Returns: TRUE if 20 zeros and 20 ones found in AKSV. FALSE OTHERWISE
+// Globals: none
+//------------------------------------------------------------------------------
+byte AreAKSV_OK (void)
+{
+	byte B_Data[AKSV_SIZE];
+	byte NumOfOnes = 0;
+	byte i, j;
+
+	TPI_TRACE_PRINT((">>AreAKSV_OK()\n"));
+
+	ReadBlockTPI(TPI_AKSV_1_REG, AKSV_SIZE, B_Data);
+
+	for (i=0; i<AKSV_SIZE; i++)
+	{
+		for (j=0; j<BYTE_SIZE; j++)
+		{
+			if (B_Data[i] & 0x01)
+			{
+				NumOfOnes++;
+			}
+			B_Data[i] >>= 1;
+		}
+	}
+	if (NumOfOnes != NUM_OF_ONES_IN_KSV)
+		return FALSE;
+
+	return TRUE;
+}
+
+//------------------------------------------------------------------------------
+// Function Name: HDCP_Off()
+// Function Description: Switch hdcp off.
+//------------------------------------------------------------------------------
+void HDCP_Off (void)
+{
+	TPI_TRACE_PRINT((">>HDCP_Off()\n"));
+
+	// AV MUTE
+	ReadModifyWriteTPI(TPI_SYSTEM_CONTROL_DATA_REG, AV_MUTE_MASK, AV_MUTE_MUTED);
+	WriteByteTPI(TPI_HDCP_CONTROL_DATA_REG, PROTECTION_LEVEL_MIN);
+
+	g_hdcp.HDCP_Started = FALSE;
+	g_hdcp.HDCP_LinkProtectionLevel = EXTENDED_LINK_PROTECTION_NONE | LOCAL_LINK_PROTECTION_NONE;
+}
+
+//------------------------------------------------------------------------------
+// Function Name: HDCP_On()
+// Function Description: Switch hdcp on.
+//------------------------------------------------------------------------------
+void HDCP_On (void)
+{
+	if (g_hdcp.HDCP_Override == FALSE)
+	{
+		TPI_DEBUG_PRINT(("HDCP Started\n"));
+
+		WriteByteTPI(TPI_HDCP_CONTROL_DATA_REG, PROTECTION_LEVEL_MAX);
+
+		g_hdcp.HDCP_Started = TRUE;
+	}
+	else
+	{
+		g_hdcp.HDCP_Started = FALSE;
+	}
+}
+
+//------------------------------------------------------------------------------
+// Function Name: RestartHDCP()
+// Function Description: Restart HDCP.
+//------------------------------------------------------------------------------
+void RestartHDCP (void)
+{
+	TPI_DEBUG_PRINT (("HDCP -> Restart\n"));
+
+	DisableTMDS();
+	HDCP_Off();
+	EnableTMDS();
+}
+
+//------------------------------------------------------------------------------
+// Function Name: HDCP_Init()
+// Function Description: Tests Tx and Rx support of HDCP. If found, checks if
+//                  and attempts to set the security level accordingly.
+//
+// Accepts: none
+// Returns: TRUE if HW TPI started successfully. FALSE if failed to.
+// Globals: HDCP_TxSupports - initialized to FALSE, set to TRUE if supported by this device
+//		   HDCP_AksvValid - initialized to FALSE, set to TRUE if valid AKSVs are read from this device
+//		   HDCP_Started - initialized to FALSE
+//		   HDCP_LinkProtectionLevel - initialized to (EXTENDED_LINK_PROTECTION_NONE | LOCAL_LINK_PROTECTION_NONE)
+//------------------------------------------------------------------------------
+void HDCP_Init (void)
+{
+	TPI_TRACE_PRINT((">>HDCP_Init()\n"));
+
+	g_hdcp.HDCP_TxSupports = FALSE;
+	g_hdcp.HDCP_AksvValid = FALSE;
+	g_hdcp.HDCP_Started = FALSE;
+	g_hdcp.HDCP_LinkProtectionLevel = EXTENDED_LINK_PROTECTION_NONE | LOCAL_LINK_PROTECTION_NONE;
+
+	// This is TX-related... need only be done once.
+	if (!IsHDCP_Supported())
+	{
+		// The TX does not support HDCP, so authentication will never be attempted.
+		// Video will be shown as soon as TMDS is enabled.
+		TPI_DEBUG_PRINT(("HDCP -> TX does not support HDCP\n"));
+		return;
+	}
+	g_hdcp.HDCP_TxSupports = TRUE;
+
+	// This is TX-related... need only be done once.
+	if (!AreAKSV_OK())
+	{
+		// The TX supports HDCP, but does not have valid AKSVs.
+		// Video will not be shown.
+		TPI_DEBUG_PRINT(("HDCP -> Illegal AKSV\n"));
+		return;
+	}
+	g_hdcp.HDCP_AksvValid = TRUE;
+
+#ifdef KSVFORWARD
+	// Enable the KSV Forwarding feature and the KSV FIFO Intererrupt
+	ReadModifyWriteTPI(TPI_HDCP_CONTROL_DATA_REG, KSV_FORWARD_MASK, KSV_FORWARD_ENABLE);
+	ReadModifyWriteTPI(TPI_KSV_FIFO_READY_INT_EN, KSV_FIFO_READY_EN_MASK, KSV_FIFO_READY_ENABLE);
+#endif
+
+	TPI_DEBUG_PRINT(("HDCP -> Supported by TX, AKSVs valid\n"));
+}
+
+#ifdef READKSV
+//------------------------------------------------------------------------------
+// Function Name: IsRepeater()
+// Function Description: Test if sink is a repeater.
+//
+// Accepts: none
+// Returns: TRUE if sink is a repeater. FALSE if not.
+// Globals: none
+//------------------------------------------------------------------------------
+byte IsRepeater (void)
+{
+	byte RegImage;
+
+	TPI_TRACE_PRINT((">>IsRepeater()\n"));
+
+	RegImage = ReadByteTPI(TPI_HDCP_QUERY_DATA_REG);
+
+	if (RegImage & HDCP_REPEATER_MASK)
+		return TRUE;
+
+	return FALSE;           // not a repeater
+}
+
+//------------------------------------------------------------------------------
+// Function Name: ReadBlockHDCP()
+// Function Description: Read NBytes from offset Addr of the HDCP slave address
+//                      into a byte Buffer pointed to by Data
+//
+// Accepts: HDCP port offset, number of bytes to read and a pointer to the data buffer where 
+//               the data read will be saved
+// Returns: none
+// Globals: none
+//------------------------------------------------------------------------------
+void ReadBlockHDCP (byte TPI_Offset, word NBytes, byte * pData)
+{
+	I2CReadBlock(siiHDCP, TPI_Offset, NBytes, pData);
+}
+
+//------------------------------------------------------------------------------
+// Function Name: GetKSV()
+// Function Description: Collect all downstrean KSV for verification.
+//
+// Accepts: none
+// Returns: TRUE if KSVs collected successfully. False if not.
+// Globals: KSV_Array[], The buffer is limited to KSV_ARRAY_SIZE due to the 8051 implementation.
+//------------------------------------------------------------------------------
+byte GetKSV (void)
+{
+	byte i;
+	word KeyCount;
+	byte KSV_Array[KSV_ARRAY_SIZE];
+
+	TPI_TRACE_PRINT((">>GetKSV()\n"));
+	ReadBlockHDCP(DDC_BSTATUS_ADDR_L, 1, &i);
+	KeyCount = (i & DEVICE_COUNT_MASK) * 5;
+	if (KeyCount != 0)
+	{
+		ReadBlockHDCP(DDC_KSV_FIFO_ADDR, KeyCount, KSV_Array);
+	}
+
+	/*
+	   TPI_TRACE_PRINT(("KeyCount = %d\n", (int) KeyCount));
+	   for (i=0; i<KeyCount; i++)
+	   {
+	   TPI_TRACE_PRINT(("KSV[%2d] = %2.2X\n", (int) i, (int) KSV_Array[i]));
+	   }
+	   */
+
+	return TRUE;
+}
+#endif
+
+//------------------------------------------------------------------------------
+// Function Name: HDCP_CheckStatus()
+// Function Description: Check HDCP status.
+//
+// Accepts: InterruptStatus
+// Returns: none
+// Globals: none
+//------------------------------------------------------------------------------
+void HDCP_CheckStatus (byte InterruptStatusImage)
+{
+	byte QueryData;
+	byte LinkStatus;
+	byte RegImage;
+	byte NewLinkProtectionLevel;
+
+#ifdef READKSV
+	byte RiCnt;
+#endif
+#ifdef KSVFORWARD
+	byte ksv;
+#endif
+
+	if ((g_hdcp.HDCP_TxSupports == TRUE) && (g_hdcp.HDCP_AksvValid == TRUE))
+	{
+		if ((g_hdcp.HDCP_LinkProtectionLevel == (EXTENDED_LINK_PROTECTION_NONE | LOCAL_LINK_PROTECTION_NONE)) && (g_hdcp.HDCP_Started == FALSE))
+		{
+			QueryData = ReadByteTPI(TPI_HDCP_QUERY_DATA_REG);
+
+			if (QueryData & PROTECTION_TYPE_MASK)   // Is HDCP avaialable
+			{
+				HDCP_On();
+			}
+		}
+
+		// Check if Link Status has changed:
+		if (InterruptStatusImage & SECURITY_CHANGE_EVENT) 
+		{
+			TPI_DEBUG_PRINT (("HDCP -> "));
+
+			LinkStatus = ReadByteTPI(TPI_HDCP_QUERY_DATA_REG);
+			LinkStatus &= LINK_STATUS_MASK;
+
+			ClearInterrupt(SECURITY_CHANGE_EVENT);
+
+			switch (LinkStatus)
+			{
+				case LINK_STATUS_NORMAL:
+					TPI_DEBUG_PRINT (("Link = Normal\n"));
+					break;
+
+				case LINK_STATUS_LINK_LOST:
+					TPI_DEBUG_PRINT (("Link = Lost\n"));
+					RestartHDCP();
+					break;
+
+				case LINK_STATUS_RENEGOTIATION_REQ:
+					TPI_DEBUG_PRINT (("Link = Renegotiation Required\n"));
+					HDCP_Off();
+					HDCP_On();
+					break;
+
+				case LINK_STATUS_LINK_SUSPENDED:
+					TPI_DEBUG_PRINT (("Link = Suspended\n"));
+					HDCP_On();
+					break;
+			}
+		}
+
+		// Check if HDCP state has changed:
+		if (InterruptStatusImage & HDCP_CHANGE_EVENT)
+		{
+			RegImage = ReadByteTPI(TPI_HDCP_QUERY_DATA_REG);
+
+			NewLinkProtectionLevel = RegImage & (EXTENDED_LINK_PROTECTION_MASK | LOCAL_LINK_PROTECTION_MASK);
+			if (NewLinkProtectionLevel != g_hdcp.HDCP_LinkProtectionLevel)
+			{
+				TPI_DEBUG_PRINT (("HDCP -> "));
+
+				g_hdcp.HDCP_LinkProtectionLevel = NewLinkProtectionLevel;
+
+				switch (g_hdcp.HDCP_LinkProtectionLevel)
+				{
+					case (EXTENDED_LINK_PROTECTION_NONE | LOCAL_LINK_PROTECTION_NONE):
+						TPI_DEBUG_PRINT (("Protection = None\n"));
+						RestartHDCP();
+						break;
+
+					case LOCAL_LINK_PROTECTION_SECURE:
+
+						if (IsHDMI_Sink())
+						{
+							ReadModifyWriteTPI(TPI_AUDIO_INTERFACE_REG, AUDIO_MUTE_MASK, AUDIO_MUTE_NORMAL);
+						}
+
+						ReadModifyWriteTPI(TPI_SYSTEM_CONTROL_DATA_REG, AV_MUTE_MASK, AV_MUTE_NORMAL);
+						TPI_DEBUG_PRINT (("Protection = Local, Video Unmuted\n"));
+						break;
+
+					case (EXTENDED_LINK_PROTECTION_SECURE | LOCAL_LINK_PROTECTION_SECURE):
+						TPI_DEBUG_PRINT (("Protection = Extended\n"));
+#ifdef READKSV
+						if (IsRepeater())
+						{
+							RiCnt = ReadIndexedRegister(INDEXED_PAGE_0, 0x25);
+							while (RiCnt > 0x70)  // Frame 112
+							{
+								RiCnt = ReadIndexedRegister(INDEXED_PAGE_0, 0x25);
+							}
+							ReadModifyWriteTPI(TPI_SYSTEM_CONTROL_DATA_REG, 0x06, 0x06);
+							GetKSV();
+							RiCnt = ReadByteTPI(TPI_SYSTEM_CONTROL_DATA_REG);
+							ReadModifyWriteTPI(TPI_SYSTEM_CONTROL_DATA_REG, 0x08, 0x00);
+						}
+#endif
+						break;
+
+					default:
+						TPI_DEBUG_PRINT (("Protection = Extended but not Local?\n"));
+						RestartHDCP();
+						break;
+				}
+			}
+
+#ifdef KSVFORWARD			
+			// Check if KSV FIFO is ready and forward - Bug# 17892
+			// If interrupt never goes off:
+			//   a) KSV formwarding is not enabled
+			//   b) not a repeater
+			//   c) a repeater with device count == 0
+			// and therefore no KSV list to forward
+			if ((ReadByteTPI(TPI_KSV_FIFO_READY_INT) & KSV_FIFO_READY_MASK) == KSV_FIFO_READY_YES)
+			{
+				ReadModifyWriteTPI(TPI_KSV_FIFO_READY_INT, KSV_FIFO_READY_MASK, KSV_FIFO_READY_YES);
+				TPI_DEBUG_PRINT (("KSV Fwd: KSV FIFO has data...\n"));
+				{
+					// While !(last byte has been read from KSV FIFO)
+					// if (count = 0) then a byte is not in the KSV FIFO yet, do not read
+					//   else read a byte from the KSV FIFO and forward it or keep it for revocation check
+					do 
+					{
+						ksv = ReadByteTPI(TPI_KSV_FIFO_STATUS_REG);
+						if (ksv & KSV_FIFO_COUNT_MASK)
+						{
+							TPI_DEBUG_PRINT (("KSV Fwd: KSV FIFO Count = %d, ", (int)(ksv & KSV_FIFO_COUNT_MASK)));
+							ksv = ReadByteTPI(TPI_KSV_FIFO_VALUE_REG);	// Forward or store for revocation check
+							TPI_DEBUG_PRINT (("Value = %d\n", (int)ksv));
+						}
+					} while ((ksv & KSV_FIFO_LAST_MASK) == KSV_FIFO_LAST_NO);
+					TPI_DEBUG_PRINT (("KSV Fwd: Last KSV FIFO forward complete\n"));
+				}
+			}
+#endif
+			ClearInterrupt(HDCP_CHANGE_EVENT);
+		}
+	}
+}
+
+
+
+
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////*************************///////////////////////////////
+///////////////////////             AV CONFIG              ///////////////////////////////
+///////////////////////*************************///////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+
+//------------------------------------------------------------------------------
+// Video mode table
+//------------------------------------------------------------------------------
+struct ModeIdType
+{
+	byte Mode_C1;
+	byte Mode_C2;
+	byte SubMode;
+};
+
+struct PxlLnTotalType
+{
+	word Pixels;
+	word Lines;
+} ;
+struct HVPositionType
+{
+	word H;
+	word V;
+};
+
+struct HVResolutionType
+{
+	word H;
+	word V;
+};
+
+struct TagType
+{
+	byte           	RefrTypeVHPol;
+	word           	VFreq;
+	struct PxlLnTotalType 	Total;
+};
+
+struct  _656Type
+{
+	byte IntAdjMode;
+	word HLength;
+	byte VLength;
+	word Top;
+	word Dly;
+	word HBit2HSync;
+	byte VBit2VSync;
+	word Field2Offset;
+};
+
+struct Vspace_Vblank
+{
+	byte VactSpace1;
+	byte VactSpace2;
+	byte Vblank1;
+	byte Vblank2;
+	byte Vblank3;
+};
+
+//
+// WARNING!  The entries in this enum must remian in the samre order as the PC Codes part
+// of the VideoModeTable[].
+//
+typedef	enum
+{
+	PC_640x350_85_08 = 0,
+	PC_640x400_85_08,
+	PC_720x400_70_08,
+	PC_720x400_85_04,
+	PC_640x480_59_94,
+	PC_640x480_72_80,
+	PC_640x480_75_00,
+	PC_640x480_85_00,
+	PC_800x600_56_25,
+	PC_800x600_60_317,
+	PC_800x600_72_19,
+	PC_800x600_75,
+	PC_800x600_85_06,
+	PC_1024x768_60,
+	PC_1024x768_70_07,
+	PC_1024x768_75_03,
+	PC_1024x768_85,
+	PC_1152x864_75,
+	PC_1600x1200_60,
+	PC_1280x768_59_95,
+	PC_1280x768_59_87,
+	PC_280x768_74_89,
+	PC_1280x768_85,
+	PC_1280x960_60,
+	PC_1280x960_85,
+	PC_1280x1024_60,
+	PC_1280x1024_75,
+	PC_1280x1024_85,
+	PC_1360x768_60,
+	PC_1400x105_59_95,
+	PC_1400x105_59_98,
+	PC_1400x105_74_87,
+	PC_1400x105_84_96,
+	PC_1600x1200_65,
+	PC_1600x1200_70,
+	PC_1600x1200_75,
+	PC_1600x1200_85,
+	PC_1792x1344_60,
+	PC_1792x1344_74_997,
+	PC_1856x1392_60,
+	PC_1856x1392_75,
+	PC_1920x1200_59_95,
+	PC_1920x1200_59_88,
+	PC_1920x1200_74_93,
+	PC_1920x1200_84_93,
+	PC_1920x1440_60,
+	PC_1920x1440_75,
+	PC_12560x1440_60,
+	PC_SIZE			// Must be last
+} PcModeCode_t;
+
+struct VModeInfoType
+{
+	struct ModeIdType       	ModeId;
+	dword             		PixClk;
+	struct TagType          		Tag;
+	struct HVPositionType  	Pos;
+	struct HVResolutionType 	Res;
+	byte             		AspectRatio;
+	struct _656Type         		_656;
+	byte             		PixRep;
+	struct Vspace_Vblank 		VsVb;
+	byte             		_3D_Struct;
+};
+
+#define NSM                     0   // No Sub-Mode
+
+#define	DEFAULT_VIDEO_MODE		0	// 640  x 480p @ 60 VGA
+
+#define ProgrVNegHNeg           0x00
+#define ProgrVNegHPos           	0x01
+#define ProgrVPosHNeg           	0x02
+#define ProgrVPosHPos           	0x03
+
+#define InterlaceVNegHNeg   	0x04
+#define InterlaceVPosHNeg      0x05
+#define InterlaceVNgeHPos    	0x06
+#define InterlaceVPosHPos     	0x07
+
+#define VIC_BASE                	0
+#define HDMI_VIC_BASE           43
+#define VIC_3D_BASE             	47
+#define PC_BASE                 	64
+
+// Aspect ratio
+//=================================================
+#define R_4                      		0   // 4:3
+#define R_4or16                  	1   // 4:3 or 16:9
+#define R_16                     		2   // 16:9
+
+//
+// These are the VIC codes that we support in a 3D mode
+//
+#define VIC_FOR_480P_60Hz_4X3			2		// 720p x 480p @60Hz
+#define VIC_FOR_480P_60Hz_16X9			3		// 720p x 480p @60Hz
+#define VIC_FOR_720P_60Hz				4		// 1280 x 720p @60Mhz
+#define VIC_FOR_1080i_60Hz				5		// 1920 x 1080i @60Mhz
+#define VIC_FOR_1080p_60Hz				16		// 1920 x 1080i @60hz
+#define VIC_FOR_720P_50Hz				19		// 1280 x 720p @50Mhz
+#define VIC_FOR_1080i_50Hz				20		// 1920 x 1080i @50Mhz
+#define VIC_FOR_1080p_50Hz				31		// 1920 x 720p @50Hz
+#define VIC_FOR_1080p_24Hz				32		// 1920 x 720p @24Hz
+
+
+static struct VModeInfoType VModesTable[] =
+{
+	//===================================================================================================================================================================================================================================
+	//         VIC                  Refresh type Refresh-Rate Pixel-Totals  Position     Active     Aspect   Int  Length          Hbit  Vbit  Field  Pixel          Vact Space/Blank
+	//        1   2  SubM   PixClk  V/H Position       VFreq   H      V      H    V       H    V    Ratio    Adj  H   V  Top  Dly HSync VSync Offset Repl  Space1 Space2 Blank1 Blank2 Blank3  3D
+	//===================================================================================================================================================================================================================================
+	{{        1,  0, NSM},  2517,  {ProgrVNegHNeg,     6000, { 800,  525}}, {144, 35}, { 640, 480}, R_4,     {0,  96, 2, 33,  48,  16,  10,    0},    0,    {0,     0,     0,     0,    0},    NO_3D_SUPPORT}, // 0 - 1.       640  x 480p @ 60 VGA
+	{{        2,  3, NSM},  2700,  {ProgrVNegHNeg,     6000, { 858,  525}}, {122, 36}, { 720, 480}, R_4or16, {0,  62, 6, 30,  60,  19,   9,    0},    0,    {0,     0,     0,     0,    0},    NO_3D_SUPPORT}, // 1 - 2,3      720  x 480p
+	{{        4,  0, NSM},  7425,  {ProgrVPosHPos,     6000, {1650,  750}}, {260, 25}, {1280, 720}, R_16,    {0,  40, 5, 20, 220, 110,   5,    0},    0,    {0,     0,     0,     0,    0},    NO_3D_SUPPORT}, // 2 - 4        1280 x 720p@60Hz
+	{{        5,  0, NSM},  7425,  {InterlaceVPosHPos, 6000, {2200,  562}}, {192, 20}, {1920,1080}, R_16,    {0,  44, 5, 15, 148,  88,   2, 1100},    0,    {0,     0,     0,     0,    0},    NO_3D_SUPPORT}, // 3 - 5        1920 x 1080i
+	{{        6,  7, NSM},  2700,  {InterlaceVNegHNeg, 6000, {1716,  264}}, {119, 18}, { 720, 480}, R_4or16, {3,  62, 3, 15, 114,  17,   5,  429},    1,    {0,     0,     0,     0,    0},    NO_3D_SUPPORT}, // 4 - 6,7      1440 x 480i,pix repl
+	{{        8,  9,   1},  2700,  {ProgrVNegHNeg,     6000, {1716,  262}}, {119, 18}, {1440, 240}, R_4or16, {0, 124, 3, 15, 114,  38,   4,    0},    1,    {0,     0,     0,     0,    0},    NO_3D_SUPPORT}, // 5 - 8,9(1)   1440 x 240p
+	{{        8,  9,   2},  2700,  {ProgrVNegHNeg,     6000, {1716,  263}}, {119, 18}, {1440, 240}, R_4or16, {0, 124, 3, 15, 114,  38,   4,    0},    1,    {0,     0,     0,     0,    0},    NO_3D_SUPPORT}, // 6 - 8,9(2)   1440 x 240p
+	{{       10, 11, NSM},  5400,  {InterlaceVNegHNeg, 6000, {3432,  525}}, {238, 18}, {2880, 480}, R_4or16, {0, 248, 3, 15, 228,  76,   4, 1716},    0,    {0,     0,     0,     0,    0},    NO_3D_SUPPORT}, // 7 - 10,11    2880 x 480i
+	{{       12, 13,   1},  5400,  {ProgrVNegHNeg,     6000, {3432,  262}}, {238, 18}, {2880, 240}, R_4or16, {0, 248, 3, 15, 228,  76,   4,    0},    1,    {0,     0,     0,     0,    0},    NO_3D_SUPPORT}, // 8 - 12,13(1) 2880 x 240p
+	{{       12, 13,   2},  5400,  {ProgrVNegHNeg,     6000, {3432,  263}}, {238, 18}, {2880, 240}, R_4or16, {0, 248, 3, 15, 228,  76,   4,    0},    1,    {0,     0,     0,     0,    0},    NO_3D_SUPPORT}, // 9 - 12,13(2) 2880 x 240p
+	{{       14, 15, NSM},  5400,  {ProgrVNegHNeg,     6000, {1716,  525}}, {244, 36}, {1440, 480}, R_4or16, {0, 124, 6, 30, 120,  32,   9,    0},    0,    {0,     0,     0,     0,    0},    NO_3D_SUPPORT}, // 10 - 14,15    1440 x 480p
+	{{       16,  0, NSM}, 14835,  {ProgrVPosHPos,     6000, {2200, 1125}}, {192, 41}, {1920,1080}, R_16,    {0,  44, 5, 36, 148,  88,   4,    0},    0,    {0,     0,     0,     0,    0},    NO_3D_SUPPORT}, // 11 - 16       1920 x 1080p
+	{{       17, 18, NSM},  2700,  {ProgrVNegHNeg,     5000, { 864,  625}}, {132, 44}, { 720, 576}, R_4or16, {0,  64, 5, 39,  68,  12,   5,    0},    0,    {0,     0,     0,     0,    0},    NO_3D_SUPPORT}, // 12 - 17,18    720  x 576p
+	{{       19,  0, NSM},  7425,  {ProgrVPosHPos,     5000, {1980,  750}}, {260, 25}, {1280, 720}, R_16,    {0,  40, 5, 20, 220, 440,   5,    0},    0,    {0,     0,     0,     0,    0},    NO_3D_SUPPORT}, // 13 - 19       1280 x 720p@50Hz
+	{{       20,  0, NSM},  7425,  {InterlaceVPosHPos, 5000, {2640, 1125}}, {192, 20}, {1920,1080}, R_16,    {0,  44, 5, 15, 148, 528,   2, 1320},    0,    {0,     0,     0,     0,    0},    NO_3D_SUPPORT}, // 14 - 20       1920 x 1080i
+	{{       21, 22, NSM},  2700,  {InterlaceVNegHNeg, 5000, {1728,  625}}, {132, 22}, { 720, 576}, R_4,     {3,  63, 3, 19, 138,  24,   2,  432},    1,    {0,     0,     0,     0,    0},    NO_3D_SUPPORT}, // 15 - 21,22    1440 x 576i
+	{{       23, 24,   1},  2700,  {ProgrVNegHNeg,     5000, {1728,  312}}, {132, 22}, {1440, 288}, R_4or16, {0, 126, 3, 19, 138,  24,   2,    0},    1,    {0,     0,     0,     0,    0},    NO_3D_SUPPORT}, // 16 - 23,24(1) 1440 x 288p
+	{{       23, 24,   2},  2700,  {ProgrVNegHNeg,     5000, {1728,  313}}, {132, 22}, {1440, 288}, R_4or16, {0, 126, 3, 19, 138,  24,   2,    0},    1,    {0,     0,     0,     0,    0},    NO_3D_SUPPORT}, // 17 - 23,24(2) 1440 x 288p
+	{{       23, 24,   3},  2700,  {ProgrVNegHNeg,     5000, {1728,  314}}, {132, 22}, {1440, 288}, R_4or16, {0, 126, 3, 19, 138,  24,   2,    0},    1,    {0,     0,     0,     0,    0},    NO_3D_SUPPORT}, // 18 - 23,24(3) 1440 x 288p
+	{{       25, 26, NSM},  5400,  {InterlaceVNegHNeg, 5000, {3456,  625}}, {264, 22}, {2880, 576}, R_4or16, {0, 252, 3, 19, 276,  48,   2, 1728},    1,    {0,     0,     0,     0,    0},    NO_3D_SUPPORT}, // 19 - 25,26    2880 x 576i
+	{{       27, 28,   1},  5400,  {ProgrVNegHNeg,     5000, {3456,  312}}, {264, 22}, {2880, 288}, R_4or16, {0, 252, 3, 19, 276,  48,   2,    0},    1,    {0,     0,     0,     0,    0},    NO_3D_SUPPORT}, // 20 - 27,28(1) 2880 x 288p
+	{{       27, 28,   2},  5400,  {ProgrVNegHNeg,     5000, {3456,  313}}, {264, 22}, {2880, 288}, R_4or16, {0, 252, 3, 19, 276,  48,   3,    0},    1,    {0,     0,     0,     0,    0},    NO_3D_SUPPORT}, // 21 - 27,28(2) 2880 x 288p
+	{{       27, 28,   3},  5400,  {ProgrVNegHNeg,     5000, {3456,  314}}, {264, 22}, {2880, 288}, R_4or16, {0, 252, 3, 19, 276,  48,   4,    0},    1,    {0,     0,     0,     0,    0},    NO_3D_SUPPORT}, // 22 - 27,28(3) 2880 x 288p
+	{{       29, 30, NSM},  5400,  {ProgrVPosHNeg,     5000, {1728,  625}}, {264, 44}, {1440, 576}, R_4or16, {0, 128, 5, 39, 136,  24,   5,    0},    0,    {0,     0,     0,     0,    0},    NO_3D_SUPPORT}, // 23 - 29,30    1440 x 576p
+	{{       31,  0, NSM}, 14850,  {ProgrVPosHPos,     5000, {2640, 1125}}, {192, 41}, {1920,1080}, R_16,    {0,  44, 5, 36, 148, 528,   4,    0},    0,    {0,     0,     0,     0,    0},    NO_3D_SUPPORT}, // 24 - 31(1)    1920 x 1080p
+	{{       32,  0, NSM},  7417,  {ProgrVPosHPos,     2400, {2750, 1125}}, {192, 41}, {1920,1080}, R_16,    {0,  44, 5, 36, 148, 638,   4,    0},    0,    {0,     0,     0,     0,    0},    NO_3D_SUPPORT}, // 25 - 32(2)    1920 x 1080p@24Hz
+	{{       33,  0, NSM},  7425,  {ProgrVPosHPos,     2500, {2640, 1125}}, {192, 41}, {1920,1080}, R_16,    {0,  44, 5, 36, 148, 528,   4,    0},    0,    {0,     0,     0,     0,    0},    NO_3D_SUPPORT}, // 26 - 33(3)    1920 x 1080p
+	{{       34,  0, NSM},  7417,  {ProgrVPosHPos,     3000, {2200, 1125}}, {192, 41}, {1920,1080}, R_16,    {0,  44, 5, 36, 148, 528,   4,    0},    0,    {0,     0,     0,     0,    0},    NO_3D_SUPPORT}, // 27 - 34(4)    1920 x 1080p
+	{{       35, 36, NSM}, 10800,  {ProgrVNegHNeg,     5994, {3432,  525}}, {488, 36}, {2880, 480}, R_4or16, {0, 248, 6, 30, 240,  64,  10,    0},    0,    {0,     0,     0,     0,    0},    NO_3D_SUPPORT}, // 28 - 35, 36   2880 x 480p@59.94/60Hz
+	{{       37, 38, NSM}, 10800,  {ProgrVNegHNeg,     5000, {3456,  625}}, {272, 39}, {2880, 576}, R_4or16, {0, 256, 5, 40, 272,  48,   5,    0},    0,    {0,     0,     0,     0,    0},    NO_3D_SUPPORT}, // 29 - 37, 38   2880 x 576p@50Hz
+	{{       39,  0, NSM},  7200,  {InterlaceVNegHNeg, 5000, {2304, 1250}}, {352, 62}, {1920,1080}, R_16,    {0, 168, 5, 87, 184,  32,  24,    0},    0,    {0,     0,     0,     0,    0},    NO_3D_SUPPORT}, // 30 - 39       1920 x 1080i@50Hz
+	{{       40,  0, NSM}, 14850,  {InterlaceVPosHPos, 10000,{2640, 1125}}, {192, 20}, {1920,1080}, R_16,    {0,  44, 5, 15, 148, 528,   2, 1320},    0,    {0,     0,     0,     0,    0},    NO_3D_SUPPORT}, // 31 - 40       1920 x 1080i@100Hz
+	{{       41,  0, NSM}, 14850,  {InterlaceVPosHPos, 10000,{1980,  750}}, {260, 25}, {1280, 720}, R_16,    {0,  40, 5, 20, 220, 400,   5,    0},    0,    {0,     0,     0,     0,    0},    NO_3D_SUPPORT}, // 32 - 41       1280 x 720p@100Hz
+	{{       42, 43, NSM},  5400,  {ProgrVNegHNeg,     10000,{ 864,  144}}, {132, 44}, { 720, 576}, R_4or16, {0,  64, 5, 39,  68,  12,   5,    0},    0,    {0,     0,     0,     0,    0},    NO_3D_SUPPORT}, // 33 - 42, 43,  720p x 576p@100Hz
+	{{       44, 45, NSM},  5400,  {InterlaceVNegHNeg, 10000,{ 864,  625}}, {132, 22}, { 720, 576}, R_4or16, {0,  63, 3, 19,  69,  12,   2,  432},    1,    {0,     0,     0,     0,    0},    NO_3D_SUPPORT}, // 34 - 44, 45,  720p x 576i@100Hz, pix repl
+	{{       46,  0, NSM}, 14835,  {InterlaceVPosHPos, 11988,{2200, 1125}}, {192, 20}, {1920,1080}, R_16,    {0,  44, 5, 15, 149,  88,   2, 1100},    0,    {0,     0,     0,     0,    0},    NO_3D_SUPPORT}, // 35 - 46,      1920 x 1080i@119.88/120Hz
+	{{       47,  0, NSM}, 14835,  {ProgrVPosHPos,     11988,{1650,  750}}, {260, 25}, {1280, 720}, R_16,    {0,  40, 5, 20, 220, 110,   5, 1100},    0,    {0,     0,     0,     0,    0},    NO_3D_SUPPORT}, // 36 - 47,      1280 x 720p@119.88/120Hz
+	{{       48, 49, NSM},  5400,  {ProgrVNegHNeg,     11988,{ 858,  525}}, {122, 36}, { 720, 480}, R_4or16, {0,  62, 6, 30,  60,  16,  10,    0},    0,    {0,     0,     0,     0,    0},    NO_3D_SUPPORT}, // 37 - 48, 49   720  x 480p@119.88/120Hz
+	{{       50, 51, NSM},  5400,  {InterlaceVNegHNeg, 11988,{ 858,  525}}, {119, 18}, { 720, 480}, R_4or16, {0,  62, 3, 15,  57,  19,   4,  429},    1,    {0,     0,     0,     0,    0},    NO_3D_SUPPORT}, // 38 - 50, 51   720  x 480i@119.88/120Hz
+	{{       52, 53, NSM}, 10800,  {ProgrVNegHNeg,     20000,{ 864,  625}}, {132, 44}, { 720, 576}, R_4or16, {0,  64, 5, 39,  68,  12,   5,    0},    0,    {0,     0,     0,     0,    0},    NO_3D_SUPPORT}, // 39 - 52, 53,  720  x 576p@200Hz
+	{{       54, 55, NSM}, 10800,  {InterlaceVNegHNeg, 20000,{ 864,  625}}, {132, 22}, { 720, 576}, R_4or16, {0,  63, 3, 19,  69,  12,   2,  432},    1,    {0,     0,     0,     0,    0},    NO_3D_SUPPORT}, // 40 - 54, 55,  1440 x 576i @200Hz, pix repl
+	{{       56, 57, NSM}, 10800,  {ProgrVNegHNeg,     24000,{ 858,  525}}, {122, 42}, { 720, 480}, R_4or16, {0,  62, 6, 30,  60,  16,   9,    0},    0,    {0,     0,     0,     0,    0},    NO_3D_SUPPORT}, // 41 - 56, 57,  720  x 480p @239.76/240Hz
+	{{       58, 59, NSM}, 10800,  {InterlaceVNegHNeg, 24000,{ 858,  525}}, {119, 18}, { 720, 480}, R_4or16, {0,  62, 3, 15,  57,  19,   4,  429},    1,    {0,     0,     0,     0,    0},    NO_3D_SUPPORT}, // 42 - 58, 59,  1440 x 480i @239.76/240Hz, pix repl
+
+
+	{{PC_BASE  , 0,NSM},    3150,   {ProgrVNegHPos,     8508,   {832, 445}},    {160,63},   {640,350},   R_16,  {0,  64,  3,  60,  96,  32,  32,       0},  0,  {0,     0,     0,     0,    0},   NO_3D_SUPPORT}, // 64 - 640x350@85.08
+	{{PC_BASE+1, 0,NSM},    3150,   {ProgrVPosHNeg,     8508,   {832, 445}},    {160,44},   {640,400},   R_16,  {0,  64,  3,  41,  96,  32,   1,       0},  0,  {0,     0,     0,     0,    0},   NO_3D_SUPPORT}, // 65 - 640x400@85.08
+	{{PC_BASE+2, 0,NSM},    2700,   {ProgrVPosHNeg,     7008,   {900, 449}},    {0,0},      {720,400},   R_16,  {0,   0,  0,   0,   0,   0,   0,       0},  0,  {0,     0,     0,     0,    0},   NO_3D_SUPPORT}, // 66 - 720x400@70.08
+	{{PC_BASE+3, 0,NSM},    3500,   {ProgrVPosHNeg,     8504,   {936, 446}},    {20,45},    {720,400},   R_16,  {0,  72,  3,  42, 108,  36,   1,       0},  0,  {0,     0,     0,     0,    0},   NO_3D_SUPPORT}, // 67 - 720x400@85.04
+	{{PC_BASE+4, 0,NSM},    2517,   {ProgrVNegHNeg,     5994,   {800, 525}},    {144,35},   {640,480},   R_4,   {0,  96,  2,  33,  48,  16,  10,       0},  0,  {0,     0,     0,     0,    0},   NO_3D_SUPPORT}, // 68 - 640x480@59.94
+	{{PC_BASE+5, 0,NSM},    3150,   {ProgrVNegHNeg,     7281,   {832, 520}},    {144,31},   {640,480},   R_4,   {0,  40,  3,  28, 128, 128,   9,       0},  0,  {0,     0,     0,     0,    0},   NO_3D_SUPPORT}, // 69 - 640x480@72.80
+	{{PC_BASE+6, 0,NSM},    3150,   {ProgrVNegHNeg,     7500,   {840, 500}},    {21,19},    {640,480},   R_4,   {0,  64,  3,  28, 128,  24,   9,       0},  0,  {0,     0,     0,     0,    0},   NO_3D_SUPPORT}, // 70 - 640x480@75.00
+	{{PC_BASE+7,0,NSM},     3600,   {ProgrVNegHNeg,     8500,   {832, 509}},    {168,28},   {640,480},   R_4,   {0,  56,  3,  25, 128,  24,   9,       0},  0,  {0,     0,     0,     0,    0},   NO_3D_SUPPORT}, // 71 - 640x480@85.00
+	{{PC_BASE+8,0,NSM},     3600,   {ProgrVPosHPos,     5625,   {1024, 625}},   {200,24},   {800,600},   R_4,   {0,  72,  2,  22, 128,  24,   1,       0},  0,  {0,     0,     0,     0,    0},   NO_3D_SUPPORT}, // 72 - 800x600@56.25
+	{{PC_BASE+9,0,NSM},     4000,   {ProgrVPosHPos,     6032,   {1056, 628}},   {216,27},   {800,600},   R_4,   {0, 128,  4,  23,  88,  40,   1,       0},  0,  {0,     0,     0,     0,    0},   NO_3D_SUPPORT}, // 73 - 800x600@60.317
+	{{PC_BASE+10,0,NSM},    5000,   {ProgrVPosHPos,     7219,   {1040, 666}},   {184,29},   {800,600},   R_4,   {0, 120,  6,  23,  64,  56,  37,       0},  0,  {0,     0,     0,     0,    0},   NO_3D_SUPPORT}, // 74 - 800x600@72.19
+	{{PC_BASE+11,0,NSM},    4950,   {ProgrVPosHPos,     7500,   {1056, 625}},   {240,24},   {800,600},   R_4,   {0,  80,  3,  21, 160,  16,   1,       0},  0,  {0,     0,     0,     0,    0},   NO_3D_SUPPORT}, // 75 - 800x600@75
+	{{PC_BASE+12,0,NSM},    5625,   {ProgrVPosHPos,     8506,   {1048, 631}},   {216,30},   {800,600},   R_4,   {0,  64,  3,  27, 152,  32,   1,       0},  0,  {0,     0,     0,     0,    0},   NO_3D_SUPPORT}, // 76 - 800x600@85.06
+	{{PC_BASE+13,0,NSM},    6500,   {ProgrVNegHNeg,     6000,   {1344, 806}},   {296,35},   {1024,768},  R_4,   {0, 136,  6,  29, 160,  24,   3,       0},  0,  {0,     0,     0,     0,    0},   NO_3D_SUPPORT}, // 77 - 1024x768@60
+	{{PC_BASE+14,0,NSM},    7500,   {ProgrVNegHNeg,     7007,   {1328, 806}},   {280,35},   {1024,768},  R_4,   {0, 136,  6,  19, 144,  24,   3,       0},  0,  {0,     0,     0,     0,    0},   NO_3D_SUPPORT}, // 78 - 1024x768@70.07
+	{{PC_BASE+15,0,NSM},    7875,   {ProgrVPosHPos,     7503,   {1312, 800}},   {272,31},   {1024,768},  R_4,   {0,  96,  3,  28, 176,  16,   1,       0},  0,  {0,     0,     0,     0,    0},   NO_3D_SUPPORT}, // 79 - 1024x768@75.03
+	{{PC_BASE+16,0,NSM},    9450,   {ProgrVPosHPos,     8500,   {1376, 808}},   {304,39},   {1024,768},  R_4,   {0,  96,  3,  36, 208,  48,   1,       0},  0,  {0,     0,     0,     0,    0},   NO_3D_SUPPORT}, // 80 - 1024x768@85
+	{{PC_BASE+17,0,NSM},   10800,   {ProgrVPosHPos,     7500,   {1600, 900}},   {384,35},   {1152,864},  R_4,   {0, 128,  3,  32, 256,  64,   1,       0},  0,  {0,     0,     0,     0,    0},   NO_3D_SUPPORT}, // 81 - 1152x864@75
+	{{PC_BASE+18,0,NSM},   16200,   {ProgrVPosHPos,     6000,   {2160, 1250}},  {496,49},   {1600,1200}, R_4,   {0, 304,  3,  46, 304,  64,   1,       0},  0,  {0,     0,     0,     0,    0},   NO_3D_SUPPORT}, // 82 - 1600x1200@60
+	{{PC_BASE+19,0,NSM},    6825,   {ProgrVNegHPos,     6000,   {1440, 790}},   {112,19},   {1280,768},  R_16,  {0,  32,  7,  12,  80,  48,   3,       0},  0,  {0,     0,     0,     0,    0},   NO_3D_SUPPORT}, // 83 - 1280x768@59.95
+	{{PC_BASE+20,0,NSM},    7950,   {ProgrVPosHNeg,     5987,   {1664, 798}},   {320,27},   {1280,768},  R_16,  {0, 128,  7,  20, 192,  64,   3,       0},  0,  {0,     0,     0,     0,    0},   NO_3D_SUPPORT}, // 84 - 1280x768@59.87
+	{{PC_BASE+21,0,NSM},   10220,   {ProgrVPosHNeg,     6029,   {1696, 805}},   {320,27},   {1280,768},  R_16,  {0, 128,  7,  27, 208,  80,   3,       0},  0,  {0,     0,     0,     0,    0},   NO_3D_SUPPORT}, // 85 - 1280x768@74.89
+	{{PC_BASE+22,0,NSM},   11750,   {ProgrVPosHNeg,     8484,   {1712, 809}},   {352,38},   {1280,768},  R_16,  {0, 136,  7,  31, 216,  80,   3,       0},  0,  {0,     0,     0,     0,    0},   NO_3D_SUPPORT}, // 86 - 1280x768@85
+	{{PC_BASE+23,0,NSM},   10800,   {ProgrVPosHPos,     6000,   {1800, 1000}},  {424,39},   {1280,960},  R_4,   {0, 112,  3,  36, 312,  96,   1,       0},  0,  {0,     0,     0,     0,    0},   NO_3D_SUPPORT}, // 87 - 1280x960@60
+	{{PC_BASE+24,0,NSM},   14850,   {ProgrVPosHPos,     8500,   {1728, 1011}},  {384,50},   {1280,960},  R_4,   {0, 160,  3,  47, 224,  64,   1,       0},  0,  {0,     0,     0,     0,    0},   NO_3D_SUPPORT}, // 88 - 1280x960@85
+	{{PC_BASE+25,0,NSM},   10800,   {ProgrVPosHPos,     6002,   {1688, 1066}},  {360,41},   {1280,1024}, R_4,   {0, 112,  3,  38, 248,  48,   1,       0},  0,  {0,     0,     0,     0,    0},   NO_3D_SUPPORT}, // 89 - 1280x1024@60
+	{{PC_BASE+26,0,NSM},   13500,   {ProgrVPosHPos,     7502,   {1688, 1066}},  {392,41},   {1280,1024}, R_4,   {0, 144,  3,  38, 248,  16,   1,       0},  0,  {0,     0,     0,     0,    0},   NO_3D_SUPPORT}, // 90 - 1280x1024@75
+	{{PC_BASE+27,0,NSM},   15750,   {ProgrVPosHPos,     8502,   {1728, 1072}},  {384,47},   {1280,1024}, R_4,   {0, 160,  3,   4, 224,  64,   1,       0},  0,  {0,     0,     0,     0,    0},   NO_3D_SUPPORT}, // 91 - 1280x1024@85
+	{{PC_BASE+28,0,NSM},    8550,   {ProgrVPosHPos,     6002,   {1792, 795}},   {368,24},   {1360,768},  R_16,  {0, 112,  6,  18, 256,  64,   3,       0},  0,  {0,     0,     0,     0,    0},   NO_3D_SUPPORT}, // 92 - 1360x768@60
+	{{PC_BASE+29,0,NSM},   10100,   {ProgrVNegHPos,     5995,   {1560, 1080}},  {112,27},   {1400,1050}, R_4,   {0,  32,  4,  23,  80,  48,   3,       0},  0,  {0,     0,     0,     0,    0},   NO_3D_SUPPORT}, // 93 - 1400x105@59.95
+	{{PC_BASE+30,0,NSM},   12175,   {ProgrVPosHNeg,     5998,   {1864, 1089}},  {376,36},   {1400,1050}, R_4,   {0, 144,  4,  32, 232,  88,   3,       0},  0,  {0,     0,     0,     0,    0},   NO_3D_SUPPORT}, // 94 - 1400x105@59.98
+	{{PC_BASE+31,0,NSM},   15600,   {ProgrVPosHNeg,     7487,   {1896, 1099}},  {392,46},   {1400,1050}, R_4,   {0, 144,  4,  22, 248, 104,   3,       0},  0,  {0,     0,     0,     0,    0},   NO_3D_SUPPORT}, // 95 - 1400x105@74.87
+	{{PC_BASE+32,0,NSM},   17950,   {ProgrVPosHNeg,     8496,   {1912, 1105}},  {408,52},   {1400,1050}, R_4,   {0, 152,  4,  48, 256, 104,   3,       0},  0,  {0,     0,     0,     0,    0},   NO_3D_SUPPORT}, // 96 - 1400x105@84.96
+	{{PC_BASE+33,0,NSM},   17550,   {ProgrVPosHPos,     6500,   {2160, 1250}},  {496,49},   {1600,1200}, R_4,   {0, 192,  3,  46, 304,  64,   1,       0},  0,  {0,     0,     0,     0,    0},   NO_3D_SUPPORT}, // 97 - 1600x1200@65
+	{{PC_BASE+34,0,NSM},   18900,   {ProgrVPosHPos,     7000,   {2160, 1250}},  {496,49},   {1600,1200}, R_4,   {0, 192,  3,  46, 304,  64,   1,       0},  0,  {0,     0,     0,     0,    0},   NO_3D_SUPPORT}, // 98 - 1600x1200@70
+	{{PC_BASE+35,0,NSM},   20250,   {ProgrVPosHPos,     7500,   {2160, 1250}},  {496,49},   {1600,1200}, R_4,   {0, 192,  3,  46, 304,  64,   1,       0},  0,  {0,     0,     0,     0,    0},   NO_3D_SUPPORT}, // 99 - 1600x1200@75
+	{{PC_BASE+36,0,NSM},   22950,   {ProgrVPosHPos,     8500,   {2160, 1250}},  {496,49},   {1600,1200}, R_4,   {0, 192,  3,  46, 304,  64,   1,       0},  0,  {0,     0,     0,     0,    0},   NO_3D_SUPPORT}, // 100 - 1600x1200@85
+	{{PC_BASE+37,0,NSM},   20475,   {ProgrVPosHNeg,     6000,   {2448, 1394}},  {528,49},   {1792,1344}, R_4,   {0, 200,  3,  46, 328, 128,   1,       0},  0,  {0,     0,     0,     0,    0},   NO_3D_SUPPORT}, // 101 - 1792x1344@60
+	{{PC_BASE+38,0,NSM},   26100,   {ProgrVPosHNeg,     7500,   {2456, 1417}},  {568,72},   {1792,1344}, R_4,   {0, 216,  3,  69, 352,  96,   1,       0},  0,  {0,     0,     0,     0,    0},   NO_3D_SUPPORT}, // 102 - 1792x1344@74.997
+	{{PC_BASE+39,0,NSM},   21825,   {ProgrVPosHNeg,     6000,   {2528, 1439}},  {576,46},   {1856,1392}, R_4,   {0, 224,  3,  43, 352,  96,   1,       0},  0,  {0,     0,     0,     0,    0},   NO_3D_SUPPORT}, // 103 - 1856x1392@60
+	{{PC_BASE+40,0,NSM},   28800,   {ProgrVPosHNeg,     7500,   {2560, 1500}},  {576,107},  {1856,1392}, R_4,   {0, 224,  3, 104, 352, 128,   1,       0},  0,  {0,     0,     0,     0,    0},   NO_3D_SUPPORT}, // 104 - 1856x1392@75
+	{{PC_BASE+41,0,NSM},   15400,   {ProgrVNegHPos,     5995,   {2080, 1235}},  {112,32},   {1920,1200}, R_16,  {0,  32,  6,  26,  80,  48,   3,       0},  0,  {0,     0,     0,     0,    0},   NO_3D_SUPPORT}, // 106 - 1920x1200@59.95
+	{{PC_BASE+42,0,NSM},   19325,   {ProgrVPosHNeg,     5988,   {2592, 1245}},  {536,42},   {1920,1200}, R_16,  {0, 200,  6,  36, 336, 136,   3,       0},  0,  {0,     0,     0,     0,    0},   NO_3D_SUPPORT}, // 107 - 1920x1200@59.88
+	{{PC_BASE+43,0,NSM},   24525,   {ProgrVPosHNeg,     7493,   {2608, 1255}},  {552,52},   {1920,1200}, R_16,  {0, 208,  6,  46, 344, 136,   3,       0},  0,  {0,     0,     0,     0,    0},   NO_3D_SUPPORT}, // 108 - 1920x1200@74.93
+	{{PC_BASE+44,0,NSM},   28125,   {ProgrVPosHNeg,     8493,   {2624, 1262}},  {560,59},   {1920,1200}, R_16,  {0, 208,  6,  53, 352, 144,   3,       0},  0,  {0,     0,     0,     0,    0},   NO_3D_SUPPORT}, // 109 - 1920x1200@84.93
+	{{PC_BASE+45,0,NSM},   23400,   {ProgrVPosHNeg,     6000,   {2600, 1500}},  {552,59},   {1920,1440}, R_4,   {0, 208,  3,  56, 344, 128,   1,       0},  0,  {0,     0,     0,     0,    0},   NO_3D_SUPPORT}, // 110 - 1920x1440@60
+	{{PC_BASE+46,0,NSM},   29700,   {ProgrVPosHNeg,     7500,   {2640, 1500}},  {576,59},   {1920,1440}, R_4,   {0, 224,  3,  56, 352, 144,   1,       0},  0,  {0,     0,     0,     0,    0},   NO_3D_SUPPORT}, // 111 - 1920x1440@75
+	{{PC_BASE+47,0,NSM},   24150,   {ProgrVPosHNeg,     6000,   {2720, 1481}},  {48,  3},   {2560,1440}, R_16,  {0,  32,  5,  56, 352, 144,   1,       0},  0,  {0,     0,     0,     0,    0},   NO_3D_SUPPORT}, // 112 - 2560x1440@60 // %%% need work
+	{{PC_BASE+48,0,NSM},    2700,   {InterlaceVNegHNeg, 6000,   {1716,  264}},  {244,18},   {1440, 480},R_4or16,{3, 124,  3,  15, 114,  17,   5,     429},  0,  {0,     0,     0,     0,    0},   NO_3D_SUPPORT}, // 113 - 1440 x 480i 
+};
+
+
+//------------------------------------------------------------------------------
+// Aspect Ratio table defines the aspect ratio as function of VIC. This table
+// should be used in conjunction with the 861-D part of VModeInfoType VModesTable[]
+// (formats 0 - 59) because some formats that differ only in their AR are grouped
+// together (e.g., formats 2 and 3).
+//------------------------------------------------------------------------------
+static u8 AspectRatioTable[] =
+{
+	R_4,   R_4, R_16, R_16, R_16,  R_4, R_16,  R_4, R_16,  R_4,
+	R_16,  R_4, R_16,  R_4, R_16, R_16,  R_4, R_16, R_16, R_16,
+	R_4,   R_16, R_4, R_16,  R_4, R_16,  R_4, R_16,  R_4, R_16,
+	R_16,  R_16, R_16, R_16,  R_4, R_16,  R_4, R_16, R_16, R_16,
+	R_16,  R_4, R_16,  R_4, R_16, R_16, R_16,  R_4, R_16,  R_4,
+	R_16,  R_4, R_16,  R_4, R_16,  R_4, R_16,  R_4, R_16
+};
+
+//------------------------------------------------------------------------------
+// VIC to Indexc table defines which VideoModeTable entry is appropreate for this VIC code. 
+// Note: This table is valid ONLY for VIC codes in 861-D formats, NOT for HDMI_VIC codes
+// or 3D codes!
+//------------------------------------------------------------------------------
+static u8 VIC2Index[] =
+{
+	0,  0,  1,  1,  2,  3,  4,  4,  5,  5,
+	7,  7,  8,  8, 10, 10, 11, 12, 12, 13,
+	14, 15, 15, 16, 16, 19, 19, 20, 20, 23,
+	23, 24, 25, 26, 27, 28, 28, 29, 29, 30,
+	31, 32, 33, 33, 34, 34, 35, 36, 37, 37,
+	38, 38, 39, 39, 40, 40, 41, 41, 42, 42
+};
+
+//------------------------------------------------------------------------------
+// Function Name: ConvertVIC_To_VM_Index()
+// Function Description: Convert Video Identification Code to the corresponding
+//                  		index of VModesTable[]. Conversion also depends on the 
+//					value of the 3D_Structure parameter in the case of 3D video format.
+// Accepts: VIC to be converted; 3D_Structure value
+// Returns: Index into VModesTable[] corrsponding to VIC
+// Globals: VModesTable[] siHdmiTx
+// Note: Conversion is for 861-D formats, HDMI_VIC or 3D
+//------------------------------------------------------------------------------
+byte ConvertVIC_To_VM_Index (void)
+{
+	byte index;
+
+	//
+	// The global VideoModeDescription contains all the information we need about
+	// the Video mode for use to find its entry in the Videio mode table.
+	//
+	// The first issue.  The "VIC" may be a 891-D VIC code, or it might be an
+	// HDMI_VIC code, or it might be a 3D code.  Each require different handling
+	// to get the proper video mode table index.
+	//
+	if (siHdmiTx.HDMIVideoFormat == VMD_HDMIFORMAT_CEA_VIC)
+	{
+		//
+		// This is a regular 861-D format VIC, so we use the VIC to Index
+		// table to look up the index.
+		//
+		index = VIC2Index[siHdmiTx.VIC];
+	}
+	else if (siHdmiTx.HDMIVideoFormat == VMD_HDMIFORMAT_HDMI_VIC)
+	{
+		//
+		// HDMI_VIC conversion is simple.  We need to subtract one because the codes start
+		// with one instead of zero.  These values are from HDMI 1.4 Spec Table 8-13. 
+		//
+		if ((siHdmiTx.VIC < 1) || (siHdmiTx.VIC > 4))
+		{
+			index = DEFAULT_VIDEO_MODE;
+		}
+		else
+		{
+			index = (HDMI_VIC_BASE - 1) + siHdmiTx.VIC;
+		}
+	}
+	else if (siHdmiTx.HDMIVideoFormat == VMD_HDMIFORMAT_3D)
+	{
+		//
+		// Currently there are only a few VIC modes that we can do in 3D.  If the VIC code is not
+		// one of these OR if the packing type is not supported for that VIC code, then it is an
+		// error and we go to the default video mode.  See HDMI Spec 1.4 Table H-6.
+		//
+		switch (siHdmiTx.VIC)
+		{
+			case VIC_FOR_480P_60Hz_4X3:
+			case VIC_FOR_480P_60Hz_16X9:
+				// We only support Side-by-Side (Half) for these modes
+				if (siHdmiTx.ThreeDStructure == SIDE_BY_SIDE_HALF)
+					index = VIC_3D_BASE + 0;
+				else
+					index = DEFAULT_VIDEO_MODE;
+				break;
+
+			case VIC_FOR_720P_60Hz:
+				switch(siHdmiTx.ThreeDStructure)
+				{
+					case FRAME_PACKING:
+						index = VIC_3D_BASE + 1;
+						break;
+					default:
+						index = DEFAULT_VIDEO_MODE;
+						break;
+				}
+				break;
+
+			case VIC_FOR_1080i_60Hz:
+				switch(siHdmiTx.ThreeDStructure)
+				{
+					case FRAME_PACKING:
+						index = VIC_3D_BASE + 2;
+						break;
+					case VMD_3D_FIELDALTERNATIVE:
+						index = VIC_3D_BASE + 3;
+						break;
+					default:
+						index = DEFAULT_VIDEO_MODE;
+						break;
+				}
+				break;
+
+			case VIC_FOR_1080p_60Hz:
+				switch(siHdmiTx.ThreeDStructure)
+				{
+					case FRAME_PACKING:
+						index = VIC_3D_BASE + 4;
+						break;
+					case VMD_3D_LINEALTERNATIVE:
+						index = VIC_3D_BASE + 5;
+						break;
+					case SIDE_BY_SIDE_FULL:
+						index = VIC_3D_BASE + 6;
+						break;
+					case SIDE_BY_SIDE_HALF:
+						index = VIC_3D_BASE + 7;
+						break;
+					default:
+						index = DEFAULT_VIDEO_MODE;
+						break;
+				}
+				break;
+
+			case VIC_FOR_720P_50Hz:
+				switch(siHdmiTx.ThreeDStructure)
+				{
+					case FRAME_PACKING:
+						index = VIC_3D_BASE + 8;
+						break;
+					case VMD_3D_LDEPTH:
+						index = VIC_3D_BASE + 9;
+						break;
+					case VMD_3D_LDEPTHGRAPHICS:
+						index = VIC_3D_BASE + 10;
+						break;
+					default:
+						index = DEFAULT_VIDEO_MODE;
+						break;
+				}
+				break;
+
+			case VIC_FOR_1080i_50Hz:
+				switch(siHdmiTx.ThreeDStructure)
+				{
+					case FRAME_PACKING:
+						index = VIC_3D_BASE + 11;			
+						break;
+					case VMD_3D_FIELDALTERNATIVE:
+						index = VIC_3D_BASE + 12;			
+						break;
+					default:
+						index = DEFAULT_VIDEO_MODE;
+						break;
+				}
+				break;
+
+			case VIC_FOR_1080p_50Hz:
+				switch(siHdmiTx.ThreeDStructure)
+				{
+					case FRAME_PACKING:
+						index = VIC_3D_BASE + 13;
+						break;
+					case VMD_3D_LINEALTERNATIVE:
+						index = VIC_3D_BASE + 14;
+						break;
+					case SIDE_BY_SIDE_FULL:
+						index = VIC_3D_BASE + 15;
+						break;
+					default:
+						index = DEFAULT_VIDEO_MODE;
+						break;
+				}
+				break;
+
+			case VIC_FOR_1080p_24Hz:
+				switch(siHdmiTx.ThreeDStructure)
+				{
+					case FRAME_PACKING:
+						index = VIC_3D_BASE + 16;
+						break;
+					default:
+						index = DEFAULT_VIDEO_MODE;
+						break;
+				}
+				break;
+
+			default:
+				index = DEFAULT_VIDEO_MODE;
+				break;
+		}
+	}
+	else if (siHdmiTx.HDMIVideoFormat == VMD_HDMIFORMAT_PC)
+	{
+		if (siHdmiTx.VIC < PC_SIZE)
+		{
+			index = siHdmiTx.VIC + PC_BASE;
+		}
+		else
+		{
+			index = DEFAULT_VIDEO_MODE;
+		}
+	}
+	else
+	{
+		// This should never happen!  If so, default to first table entry
+		index = DEFAULT_VIDEO_MODE;
+	}
+
+	return index;
+}
+
+
+// Patches
+//========
+byte TPI_REG0x63_SAVED = 0;
+
+//------------------------------------------------------------------------------
+// Function Name: SetEmbeddedSync()
+// Function Description: Set the 9022/4 registers to extract embedded sync.
+//
+// Accepts: Index of video mode to set
+// Returns: TRUE
+// Globals: VModesTable[]
+//------------------------------------------------------------------------------
+byte SetEmbeddedSync (void)
+{
+	byte	ModeTblIndex;
+	word H_Bit_2_H_Sync;
+	word Field2Offset;
+	word H_SyncWidth;
+
+	byte V_Bit_2_V_Sync;
+	byte V_SyncWidth;
+	byte B_Data[8];
+
+	TPI_TRACE_PRINT((">>SetEmbeddedSync()\n"));
+
+	ReadModifyWriteIndexedRegister(INDEXED_PAGE_0, 0x0A, 0x01, 0x01);   //set Output Format YCbCr 4:4:4
+	ReadClearWriteTPI(TPI_SYNC_GEN_CTRL, MSBIT);	 // set 0x60[7] = 0 for External DE mode
+	WriteByteTPI(TPI_DE_CTRL, 0x30);                           //Vsync and Hsync Polarity settings 1 : Negative(leading edge falls)
+	ReadSetWriteTPI(TPI_SYNC_GEN_CTRL, MSBIT);       // set 0x60[7] = 1 for Embedded Sync
+
+	ModeTblIndex = ConvertVIC_To_VM_Index(); 
+
+	H_Bit_2_H_Sync = VModesTable[ModeTblIndex]._656.HBit2HSync;
+	Field2Offset = VModesTable[ModeTblIndex]._656.Field2Offset;
+	H_SyncWidth = VModesTable[ModeTblIndex]._656.HLength;
+	V_Bit_2_V_Sync = VModesTable[ModeTblIndex]._656.VBit2VSync;
+	V_SyncWidth = VModesTable[ModeTblIndex]._656.VLength;
+
+	B_Data[0] = H_Bit_2_H_Sync & LOW_BYTE;                  // Setup HBIT_TO_HSYNC 8 LSBits (0x62)
+
+	B_Data[1] = (H_Bit_2_H_Sync >> 8) & TWO_LSBITS;         // HBIT_TO_HSYNC 2 MSBits
+	//B_Data[1] |= BIT_EN_SYNC_EXTRACT;                     // and Enable Embedded Sync to 0x63
+	TPI_REG0x63_SAVED = B_Data[1];
+
+	B_Data[2] = Field2Offset & LOW_BYTE;                    // 8 LSBits of "Field2 Offset" to 0x64
+	B_Data[3] = (Field2Offset >> 8) & LOW_NIBBLE;           // 2 MSBits of "Field2 Offset" to 0x65
+
+	B_Data[4] = H_SyncWidth & LOW_BYTE;
+	B_Data[5] = (H_SyncWidth >> 8) & TWO_LSBITS;                    // HWIDTH to 0x66, 0x67
+	B_Data[6] = V_Bit_2_V_Sync;                                     // VBIT_TO_VSYNC to 0x68
+	B_Data[7] = V_SyncWidth;                                        // VWIDTH to 0x69
+
+	WriteBlockTPI(TPI_HBIT_TO_HSYNC_7_0, 8, &B_Data[0]);
+
+	return TRUE;
+}
+
+//------------------------------------------------------------------------------
+// Function Name: EnableEmbeddedSync()
+// Function Description: EnableEmbeddedSync
+//
+// Accepts: none
+// Returns: none
+// Globals: none
+//------------------------------------------------------------------------------
+void EnableEmbeddedSync (void)
+{
+	TPI_TRACE_PRINT((">>EnableEmbeddedSync()\n"));
+
+	ReadClearWriteTPI(TPI_SYNC_GEN_CTRL, MSBIT);	 // set 0x60[7] = 0 for DE mode
+	WriteByteTPI(TPI_DE_CTRL, 0x30);
+	ReadSetWriteTPI(TPI_SYNC_GEN_CTRL, MSBIT);       // set 0x60[7] = 1 for Embedded Sync
+	ReadSetWriteTPI(TPI_DE_CTRL, BIT_6);
+}
+
+//------------------------------------------------------------------------------
+// Function Name: SetDE()
+// Function Description: Set the 9022/4 internal DE generator parameters
+//
+// Accepts: none
+// Returns: DE_SET_OK
+// Globals: none
+//
+// NOTE: 0x60[7] must be set to "0" for the follwing settings to take effect
+//------------------------------------------------------------------------------
+byte SetDE (void)
+{
+	byte RegValue;
+	byte	ModeTblIndex;
+
+	word H_StartPos, V_StartPos;
+	word Htotal, Vtotal;
+	word H_Res, V_Res;
+
+	byte Polarity;
+	byte B_Data[12];
+
+	TPI_TRACE_PRINT((">>SetDE()\n"));
+
+	ModeTblIndex = ConvertVIC_To_VM_Index();
+
+	if (VModesTable[ModeTblIndex]._3D_Struct != NO_3D_SUPPORT)
+	{
+		return DE_CANNOT_BE_SET_WITH_3D_MODE;
+		TPI_TRACE_PRINT((">>SetDE() not allowed with 3D video format\n"));
+	}
+
+	// Make sure that External Sync method is set before enableing the DE Generator:
+	RegValue = ReadByteTPI(TPI_SYNC_GEN_CTRL);
+
+	if (RegValue & BIT_7)
+	{
+		return DE_CANNOT_BE_SET_WITH_EMBEDDED_SYNC;
+	}
+
+	H_StartPos = VModesTable[ModeTblIndex].Pos.H;
+	V_StartPos = VModesTable[ModeTblIndex].Pos.V;
+
+	Htotal = VModesTable[ModeTblIndex].Tag.Total.Pixels;
+	Vtotal = VModesTable[ModeTblIndex].Tag.Total.Lines;
+
+	Polarity = (~VModesTable[ModeTblIndex].Tag.RefrTypeVHPol) & TWO_LSBITS;
+
+	H_Res = VModesTable[ModeTblIndex].Res.H;
+
+	if ((VModesTable[ModeTblIndex].Tag.RefrTypeVHPol & 0x04))
+	{
+		V_Res = (VModesTable[ModeTblIndex].Res.V) >> 1;       //if interlace V-resolution divided by 2
+	}
+	else
+	{
+		V_Res = (VModesTable[ModeTblIndex].Res.V);
+	}
+
+	B_Data[0] = H_StartPos & LOW_BYTE;              // 8 LSB of DE DLY in 0x62
+
+	B_Data[1] = (H_StartPos >> 8) & TWO_LSBITS;     // 2 MSBits of DE DLY to 0x63
+	B_Data[1] |= (Polarity << 4);                   // V and H polarity
+	B_Data[1] |= BIT_EN_DE_GEN;                     // enable DE generator
+
+	B_Data[2] = V_StartPos & SEVEN_LSBITS;      // DE_TOP in 0x64
+	B_Data[3] = 0x00;                           // 0x65 is reserved
+	B_Data[4] = H_Res & LOW_BYTE;               // 8 LSBits of DE_CNT in 0x66
+	B_Data[5] = (H_Res >> 8) & LOW_NIBBLE;      // 4 MSBits of DE_CNT in 0x67
+	B_Data[6] = V_Res & LOW_BYTE;               // 8 LSBits of DE_LIN in 0x68
+	B_Data[7] = (V_Res >> 8) & THREE_LSBITS;    // 3 MSBits of DE_LIN in 0x69
+	B_Data[8] = Htotal & LOW_BYTE;				// 8 LSBits of H_RES in 0x6A
+	B_Data[9] =	(Htotal >> 8) & LOW_NIBBLE;		// 4 MSBITS of H_RES in 0x6B
+	B_Data[10] = Vtotal & LOW_BYTE;				// 8 LSBits of V_RES in 0x6C
+	B_Data[11] = (Vtotal >> 8) & BITS_2_1_0;	// 3 MSBITS of V_RES in 0x6D
+
+	WriteBlockTPI(TPI_DE_DLY, 12, &B_Data[0]);
+	TPI_REG0x63_SAVED = B_Data[1];
+
+	return DE_SET_OK;                               // Write completed successfully
+}
+
+//------------------------------------------------------------------------------
+// Function Name: SetFormat()
+// Function Description: Set the 9022/4 format
+//
+// Accepts: none
+// Returns: DE_SET_OK
+// Globals: none
+//------------------------------------------------------------------------------
+void SetFormat (byte *Data)
+{
+	ReadModifyWriteTPI(TPI_SYSTEM_CONTROL_DATA_REG, OUTPUT_MODE_MASK, OUTPUT_MODE_HDMI); // Set HDMI mode to allow color space conversion
+
+	WriteBlockTPI(TPI_INPUT_FORMAT_REG, 2, Data);   // Program TPI AVI Input and Output Format
+	WriteByteTPI(TPI_END_RIGHT_BAR_MSB, 0x00);	  // Set last byte of TPI AVI InfoFrame for TPI AVI I/O Format to take effect
+
+	if (!IsHDMI_Sink()) 
+	{
+		ReadModifyWriteTPI(TPI_SYSTEM_CONTROL_DATA_REG, OUTPUT_MODE_MASK, OUTPUT_MODE_DVI);
+	}
+
+	if (siHdmiTx.SyncMode == EMBEDDED_SYNC)
+		EnableEmbeddedSync();					// Last byte of TPI AVI InfoFrame resets Embedded Sync Extraction
+}
+
+//------------------------------------------------------------------------------
+// Function Name: printVideoMode()
+// Function Description: print video mode
+//
+// Accepts: siHdmiTx.VIC
+// Returns: none
+// Globals: none
+//------------------------------------------------------------------------------
+void printVideoMode (void)
+{
+	TPI_TRACE_PRINT((">>Video mode = "));
+
+	switch (siHdmiTx.VIC)
+	{
+		case 6:
+			TPI_TRACE_PRINT(("HDMI_480I60_4X3 \n"));
+			break;
+		case 21:
+			TPI_TRACE_PRINT(("HDMI_576I50_4X3 \n"));
+			break;
+		case 2:
+			TPI_TRACE_PRINT(("HDMI_480P60_4X3 \n"));
+			break;
+		case 17:
+			TPI_TRACE_PRINT(("HDMI_576P50_4X3 \n"));
+			break;
+		case 4:
+			TPI_TRACE_PRINT(("HDMI_720P60 \n"));
+			break;
+		case 19:
+			TPI_TRACE_PRINT(("HDMI_720P50 \n"));
+			break;
+		case 5:
+			TPI_TRACE_PRINT(("HDMI_1080I60 \n"));
+			break;
+		case 20:
+			TPI_TRACE_PRINT(("HDMI_1080I50 \n"));
+			break;
+		case 16:
+			TPI_TRACE_PRINT(("HDMI_1080P60 \n"));
+			break;
+		case 31:
+			TPI_TRACE_PRINT(("HDMI_1080P50 \n"));
+			break;
+		case PC_BASE+13:
+			TPI_TRACE_PRINT(("HDMI_1024_768_60 \n"));
+			break;
+		case PC_BASE+9:
+			TPI_TRACE_PRINT(("HDMI_800_600_60 \n"));
+			break;
+		default:
+			break;
+	}
+}
+
+//------------------------------------------------------------------------------
+// Function Name: InitVideo()
+// Function Description: Set the 9022/4 to the video mode determined by GetVideoMode()
+//
+// Accepts: Index of video mode to set; Flag that distinguishes between
+//                  calling this function after power up and after input
+//                  resolution change
+// Returns: TRUE
+// Globals: VModesTable, VideoCommandImage
+//------------------------------------------------------------------------------
+byte InitVideo (byte TclkSel)
+{
+	byte	ModeTblIndex;
+
+#ifdef DEEP_COLOR
+	byte temp;
+#endif
+	byte B_Data[8];
+
+	byte EMB_Status; //EmbeddedSync set flag
+	byte DE_Status;
+	byte Pattern;
+
+	TPI_TRACE_PRINT((">>InitVideo()\n"));
+	printVideoMode();
+	TPI_TRACE_PRINT((" HF:%d", (int) siHdmiTx.HDMIVideoFormat));
+	TPI_TRACE_PRINT((" VIC:%d", (int) siHdmiTx.VIC));
+	TPI_TRACE_PRINT((" A:%x", (int) siHdmiTx.AspectRatio));
+	TPI_TRACE_PRINT((" CS:%x", (int) siHdmiTx.ColorSpace));
+	TPI_TRACE_PRINT((" CD:%x", (int) siHdmiTx.ColorDepth));
+	TPI_TRACE_PRINT((" CR:%x", (int) siHdmiTx.Colorimetry));
+	TPI_TRACE_PRINT((" SM:%x", (int) siHdmiTx.SyncMode));
+	TPI_TRACE_PRINT((" TCLK:%x", (int) siHdmiTx.TclkSel)); 
+	TPI_TRACE_PRINT((" 3D:%d", (int) siHdmiTx.ThreeDStructure));
+	TPI_TRACE_PRINT((" 3Dx:%d\n", (int) siHdmiTx.ThreeDExtData));
+
+	ModeTblIndex = (byte)ConvertVIC_To_VM_Index();
+
+	Pattern = (TclkSel << 6) & TWO_MSBITS;							// Use TPI 0x08[7:6] for 9022A/24A video clock multiplier
+	ReadSetWriteTPI(TPI_PIX_REPETITION, Pattern);			//TClkSel1:Ratio of output TMDS clock to input video clock,00-x0.5,01- x1 (default),10 -x2,11-x4
+
+	// Take values from VModesTable[]:
+	if( (siHdmiTx.VIC == 6) || (siHdmiTx.VIC == 7) ||	//480i
+			(siHdmiTx.VIC == 21) || (siHdmiTx.VIC == 22) )	//576i
+	{
+		if( siHdmiTx.ColorSpace == YCBCR422_8BITS)	//27Mhz pixel clock
+		{
+			B_Data[0] = VModesTable[ModeTblIndex].PixClk & 0x00FF;
+			B_Data[1] = (VModesTable[ModeTblIndex].PixClk >> 8) & 0xFF;
+		}
+		else											//13.5Mhz pixel clock
+		{
+			B_Data[0] = (VModesTable[ModeTblIndex].PixClk /2) & 0x00FF;
+			B_Data[1] = ((VModesTable[ModeTblIndex].PixClk /2) >> 8) & 0xFF;
+		}
+
+	}
+	else
+	{
+		B_Data[0] = VModesTable[ModeTblIndex].PixClk & 0x00FF;			// write Pixel clock to TPI registers 0x00, 0x01
+		B_Data[1] = (VModesTable[ModeTblIndex].PixClk >> 8) & 0xFF;
+	}
+
+	B_Data[2] = VModesTable[ModeTblIndex].Tag.VFreq & 0x00FF;		// write Vertical Frequency to TPI registers 0x02, 0x03
+	B_Data[3] = (VModesTable[ModeTblIndex].Tag.VFreq >> 8) & 0xFF;
+
+	if( (siHdmiTx.VIC == 6) || (siHdmiTx.VIC == 7) ||	//480i
+			(siHdmiTx.VIC == 21) || (siHdmiTx.VIC == 22) )	//576i
+	{
+		B_Data[4] = (VModesTable[ModeTblIndex].Tag.Total.Pixels /2) & 0x00FF;	// write total number of pixels to TPI registers 0x04, 0x05
+		B_Data[5] = ((VModesTable[ModeTblIndex].Tag.Total.Pixels /2) >> 8) & 0xFF;
+	}
+	else
+	{
+		B_Data[4] = VModesTable[ModeTblIndex].Tag.Total.Pixels & 0x00FF;	// write total number of pixels to TPI registers 0x04, 0x05
+		B_Data[5] = (VModesTable[ModeTblIndex].Tag.Total.Pixels >> 8) & 0xFF;
+	}
+
+	B_Data[6] = VModesTable[ModeTblIndex].Tag.Total.Lines & 0x00FF;	// write total number of lines to TPI registers 0x06, 0x07
+	B_Data[7] = (VModesTable[ModeTblIndex].Tag.Total.Lines >> 8) & 0xFF;
+
+	WriteBlockTPI(TPI_PIX_CLK_LSB, 8, B_Data);						// Write TPI Mode data.//0x00-0x07 :Video Mode Defines the incoming resolution
+
+	// TPI Input Bus and Pixel Repetition Data
+	// B_Data[0] = Reg0x08;
+	B_Data[0] = 0;  // Set to default 0 for use again
+	//B_Data[0] = (VModesTable[ModeTblIndex].PixRep) & LOW_BYTE;		// Set pixel replication field of 0x08
+	B_Data[0] |= BIT_BUS_24;										// Set 24 bit bus:Input Bus Select. The input data bus can be either one pixel wide or 1/2  pixel wide. The bit defaults to 1 to select full pixel mode. In  1/2  pixel mode, the full pixel is brought in on two successive clock edges (one rising, one falling). 
+	//All parts support 24-bit full-pixel and 12-bit half-pixel input modes.
+	B_Data[0] |= (TclkSel << 6) & TWO_MSBITS;
+
+#ifdef CLOCK_EDGE_FALLING
+	B_Data[0] &= ~BIT_EDGE_RISE;									// Set to falling edge
+#elif defined(CLOCK_EDGE_RISING)
+	B_Data[0] |= BIT_EDGE_RISE;									// Set to rising edge
+#endif
+
+	tpivmode[0] = B_Data[0]; // saved TPI Reg0x08 value.
+	WriteByteTPI(TPI_PIX_REPETITION, B_Data[0]);					// 0x08
+
+	// TPI AVI Input and Output Format Data
+	// B_Data[0] = Reg0x09;
+	// B_Data[1] = Reg0x0A;	
+	B_Data[0] = 0;  // Set to default 0 for use again
+	B_Data[1] = 0;  // Set to default 0 for use again
+
+	if (siHdmiTx.SyncMode == EMBEDDED_SYNC)
+	{
+		EMB_Status = SetEmbeddedSync();
+		EnableEmbeddedSync();    //enablle EmbeddedSync
+	}
+
+	if (siHdmiTx.SyncMode == INTERNAL_DE)
+	{
+		ReadClearWriteTPI(TPI_SYNC_GEN_CTRL, MSBIT);	// set 0x60[7] = 0 for External Sync
+		DE_Status = SetDE();								// Call SetDE() with Video Mode as a parameter
+	}
+
+	if (siHdmiTx.ColorSpace == RGB)
+		B_Data[0] = (((BITS_IN_RGB | BITS_IN_AUTO_RANGE) & ~BIT_EN_DITHER_10_8) & ~BIT_EXTENDED_MODE); // reg0x09
+
+	else if (siHdmiTx.ColorSpace == YCBCR444)
+		B_Data[0] = (((BITS_IN_YCBCR444 | BITS_IN_AUTO_RANGE) & ~BIT_EN_DITHER_10_8) & ~BIT_EXTENDED_MODE); // 0x09
+
+	else if ((siHdmiTx.ColorSpace == YCBCR422_16BITS) ||(siHdmiTx.ColorSpace == YCBCR422_8BITS))
+		B_Data[0] = (((BITS_IN_YCBCR422 | BITS_IN_AUTO_RANGE) & ~BIT_EN_DITHER_10_8) & ~BIT_EXTENDED_MODE); // 0x09
+
+#ifdef DEEP_COLOR
+	switch (siHdmiTx.ColorDepth)
+	{
+		case 0:  temp = 0x00; ReadModifyWriteTPI(TPI_DEEP_COLOR_GCP, BIT_2, 0x00); break;
+		case 1:  temp = 0x80; ReadModifyWriteTPI(TPI_DEEP_COLOR_GCP, BIT_2, BIT_2); break;
+		case 2:  temp = 0xC0; ReadModifyWriteTPI(TPI_DEEP_COLOR_GCP, BIT_2, BIT_2); break;
+		case 3:  temp = 0x40; ReadModifyWriteTPI(TPI_DEEP_COLOR_GCP, BIT_2, BIT_2); break;
+		default: temp = 0x00; ReadModifyWriteTPI(TPI_DEEP_COLOR_GCP, BIT_2, 0x00); break;
+				 //General Control Packet C Deep color settings require the General Control Packet to be sent once per video field
+				 //with the correct PP and CD information. This must be enabled by software via TPI Deep Color Packet Enable
+				 //Register 0x40[2] = 1, enable transmission of the GCP packet.
+	}
+	B_Data[0] = ((B_Data[0] & 0x3F) | temp);// reg0x09
+#endif
+
+	B_Data[1] = (BITS_OUT_RGB | BITS_OUT_AUTO_RANGE);  //Reg0x0A
+
+	if ((siHdmiTx.VIC == 6) || (siHdmiTx.VIC == 7) ||	//480i
+			(siHdmiTx.VIC == 21) || (siHdmiTx.VIC == 22) ||//576i
+			(siHdmiTx.VIC == 2) || (siHdmiTx.VIC == 3) ||	//480p
+			(siHdmiTx.VIC == 17) ||(siHdmiTx.VIC == 18))	//576p
+	{
+		B_Data[1] &= ~BIT_BT_709;
+	}
+	else
+	{
+		B_Data[1] |= BIT_BT_709;
+	}
+
+#ifdef DEEP_COLOR
+	B_Data[1] = ((B_Data[1] & 0x3F) | temp);
+#endif
+
+#ifdef DEV_SUPPORT_EDID
+	if (!IsHDMI_Sink()) 
+	{
+		B_Data[1] = ((B_Data[1] & 0xFC) | BITS_OUT_RGB);
+	}
+	else 
+	{
+		// Set YCbCr color space depending on EDID
+		if (g_edid.YCbCr_4_4_4) 
+		{
+			B_Data[1] = ((B_Data[1] & 0xFC) | BITS_OUT_YCBCR444);
+		}
+		else 
+		{
+			if (g_edid.YCbCr_4_2_2)
+			{
+				B_Data[1] = ((B_Data[1] & 0xFC) | BITS_OUT_YCBCR422);
+			}
+			else
+			{
+				B_Data[1] = ((B_Data[1] & 0xFC) | BITS_OUT_RGB);
+			}
+		}
+	}
+#endif
+
+	tpivmode[1] = B_Data[0];	// saved TPI Reg0x09 value.
+	tpivmode[2] = B_Data[1];  // saved TPI Reg0x0A value.
+	SetFormat(B_Data);
+
+	ReadClearWriteTPI(TPI_SYNC_GEN_CTRL, BIT_2);	// Number HSync pulses from VSync active edge to Video Data Period should be 20 (VS_TO_VIDEO)
+
+	return TRUE;
+}
+
+//------------------------------------------------------------------------------
+// Function Name: SetAVI_InfoFrames()
+// Function Description: Load AVI InfoFrame data into registers and send to sink
+//
+// Accepts: An API_Cmd parameter that holds the data to be sent in the InfoFrames
+// Returns: TRUE
+// Globals: none
+//
+// Note:          : Infoframe contents are from spec CEA-861-D
+//
+//------------------------------------------------------------------------------
+byte SetAVI_InfoFrames (void)
+{
+	byte B_Data[SIZE_AVI_INFOFRAME];
+	byte i;
+	byte TmpVal;
+	byte VModeTblIndex;
+
+	TPI_TRACE_PRINT((">>SetAVI_InfoFrames()\n"));
+
+	for (i = 0; i < SIZE_AVI_INFOFRAME; i++)
+		B_Data[i] = 0;
+
+#ifdef DEV_SUPPORT_EDID
+	if (g_edid.YCbCr_4_4_4)
+		TmpVal = 2;
+	else if (g_edid.YCbCr_4_2_2)
+		TmpVal = 1;
+	else
+		TmpVal = 0;
+#else
+	TmpVal = 0;
+#endif
+
+	B_Data[1] = (TmpVal << 5) & BITS_OUT_FORMAT;	// AVI Byte1: Y1Y0 (output format)
+	B_Data[1] |= 0x11;  // A0 = 1; Active format identification data is present in the AVI InfoFrame. // S1:S0 = 01; Overscanned (television).
+
+	if (siHdmiTx.ColorSpace == XVYCC444)                // Extended colorimetry - xvYCC
+	{
+		B_Data[2] = 0xC0;                                          // Extended colorimetry info (B_Data[3] valid (CEA-861D, Table 11)
+
+		if (siHdmiTx.Colorimetry == COLORIMETRY_601)   		// xvYCC601
+			B_Data[3] &= ~BITS_6_5_4;
+
+		else if (siHdmiTx.Colorimetry == COLORIMETRY_709)	// xvYCC709
+			B_Data[3] = (B_Data[3] & ~BITS_6_5_4) | BIT_4;
+	}
+
+	else if (siHdmiTx.Colorimetry == COLORIMETRY_709)		// BT.709
+		B_Data[2] = 0x80;		// AVI Byte2: C1C0
+
+	else if (siHdmiTx.Colorimetry == COLORIMETRY_601)		// BT.601
+		B_Data[2] = 0x40;		// AVI Byte2: C1C0
+
+	else													// Carries no data
+	{													// AVI Byte2: C1C0
+		B_Data[2] &= ~BITS_7_6;							// colorimetry = 0
+		B_Data[3] &= ~BITS_6_5_4;						// Extended colorimetry = 0
+	}
+
+	VModeTblIndex = ConvertVIC_To_VM_Index();
+
+	B_Data[4] = siHdmiTx.VIC;
+
+	//  Set the Aspect Ration info into the Infoframe Byte 2
+	if (siHdmiTx.AspectRatio == VMD_ASPECT_RATIO_16x9)
+	{
+		B_Data[2] |= _16_To_9;                          // AVI Byte2: M1M0
+		// If the Video Mode table says this mode can be 4x3 OR 16x9, and we are pointing to the
+		// table entry that is 4x3, then we bump to the next Video Table entry which will be for 16x9.
+		if ((VModesTable[VModeTblIndex].AspectRatio == R_4or16) && (AspectRatioTable[siHdmiTx.VIC - 1] == R_4))
+		{
+			siHdmiTx.VIC++;
+			B_Data[4]++;
+		}
+	}
+	else
+	{
+		B_Data[2] |= _4_To_3;                       // AVI Byte4: VIC
+	}
+
+	B_Data[2] |= SAME_AS_AR;                        // AVI Byte2: R3..R1 - Set to "Same as Picture Aspect Ratio"
+	B_Data[5] = VModesTable[VModeTblIndex].PixRep;      // AVI Byte5: Pixel Replication - PR3..PR0
+
+	// Calculate AVI InfoFrame ChecKsum
+	B_Data[0] = 0x82 + 0x02 +0x0D;
+	for (i = 1; i < SIZE_AVI_INFOFRAME; i++)
+	{
+		B_Data[0] += B_Data[i];
+	}
+	B_Data[0] = 0x100 - B_Data[0];
+
+	// Write the Inforframe data to the TPI Infoframe registers
+	WriteBlockTPI(TPI_AVI_BYTE_0, SIZE_AVI_INFOFRAME, B_Data);
+
+	if (siHdmiTx.SyncMode == EMBEDDED_SYNC)
+		EnableEmbeddedSync();
+
+	return TRUE;
+}
+
+extern void siHdmiTx_PowerStateD0 (void);
+extern void SetAudioMute (byte audioMute);
+//------------------------------------------------------------------------------
+// Function Name: siHdmiTx_Init()
+// Function Description: Set the 9022/4 video and video.
+//
+// Accepts: none
+// Returns: none
+// Globals: siHdmiTx
+//------------------------------------------------------------------------------
+void siHdmiTx_Init (void) 
+{
+	TPI_TRACE_PRINT((">>siHdmiTx_Init()\n"));
+
+	// workaround for Bug#18128
+	if (siHdmiTx.ColorDepth == VMD_COLOR_DEPTH_8BIT)
+	{
+		// Yes it is, so force 16bpps first!
+		siHdmiTx.ColorDepth = VMD_COLOR_DEPTH_16BIT;
+		InitVideo(siHdmiTx.TclkSel);
+		// Now put it back to 8bit and go do the expected InitVideo() call
+		siHdmiTx.ColorDepth = VMD_COLOR_DEPTH_8BIT;
+	}
+	// end workaround
+
+	InitVideo(siHdmiTx.TclkSel);			// Set PLL Multiplier to x1 upon power up
+
+	siHdmiTx_PowerStateD0();
+
+	if (IsHDMI_Sink())					// Set InfoFrames only if HDMI output mode
+	{
+		SetAVI_InfoFrames();
+		siHdmiTx_AudioSet();			// set audio interface to basic audio (an external command is needed to set to any other mode
+	}
+	else
+	{
+		SetAudioMute(AUDIO_MUTE_MUTED);
+	}
+
+	// THIS PATCH IS NEEDED BECAUSE SETTING UP AVI InfoFrames CLEARS 0x63 and 0x60[5]
+	if (siHdmiTx.ColorSpace == YCBCR422_8BITS)
+		ReadSetWriteTPI(TPI_SYNC_GEN_CTRL, BIT_5);       // Set 0x60[5] according to input color space.
+
+	// THIS PATCH IS NEEDED BECAUSE SETTING UP AVI InfoFrames CLEARS 0x63
+	TPI_REG0x63_SAVED = 0x30;
+	printk("set 0x63 to %02x\n",TPI_REG0x63_SAVED);
+	WriteByteTPI(TPI_DE_CTRL, TPI_REG0x63_SAVED);
+
+	//==========================================================
+	WriteByteTPI(TPI_YC_Input_Mode, 0x00);
+
+
+	if ((g_hdcp.HDCP_TxSupports == TRUE) && (g_hdcp.HDCPAuthenticated == VMD_HDCP_AUTHENTICATED)&&(Sii9024A_HDCP_supported))
+	{
+		if (g_hdcp.HDCP_AksvValid == TRUE)
+		{
+			// AV MUTE
+			TPI_DEBUG_PRINT (("TMDS -> Enabled (Video Muted)\n"));
+			ReadModifyWriteTPI(TPI_SYSTEM_CONTROL_DATA_REG, LINK_INTEGRITY_MODE_MASK | TMDS_OUTPUT_CONTROL_MASK | AV_MUTE_MASK,
+					LINK_INTEGRITY_DYNAMIC | TMDS_OUTPUT_CONTROL_ACTIVE | AV_MUTE_MUTED);
+
+			WriteByteTPI(TPI_PIX_REPETITION, tpivmode[0]);      		// Write register 0x08
+			g_sys.tmdsPoweredUp = TRUE;
+			EnableInterrupts(HOT_PLUG_EVENT | RX_SENSE_EVENT | AUDIO_ERROR_EVENT | SECURITY_CHANGE_EVENT | HDCP_CHANGE_EVENT);
+		}
+	}
+	else{
+		TPI_DEBUG_PRINT (("TMDS -> Enabled\n"));
+		ReadModifyWriteTPI(TPI_SYSTEM_CONTROL_DATA_REG, LINK_INTEGRITY_MODE_MASK | TMDS_OUTPUT_CONTROL_MASK | AV_MUTE_MASK, 
+				LINK_INTEGRITY_DYNAMIC | TMDS_OUTPUT_CONTROL_ACTIVE | AV_MUTE_NORMAL);
+
+		WriteByteTPI(TPI_PIX_REPETITION, tpivmode[0]);      		// Write register 0x08
+		g_sys.tmdsPoweredUp = TRUE;
+		EnableInterrupts(HOT_PLUG_EVENT | RX_SENSE_EVENT );//| AUDIO_ERROR_EVENT);
+	}
+}
+
+//------------------------------------------------------------------------------
+// Function Name: siHdmiTx_VideoSet()
+// Function Description: Set the 9022/4 video resolution
+//
+// Accepts: none
+// Returns: Success message if video resolution changed successfully.
+//                  Error Code if resolution change failed
+// Globals: siHdmiTx
+//------------------------------------------------------------------------------
+
+byte siHdmiTx_VideoSet (void)   
+{
+	TPI_TRACE_PRINT((">>siHdmiTx_VideoSet()\n"));
+	// Note: this's necessary for fixing 480i_13.5MHz to 1080p_148.5MHz no display issue.
+	siHdmiTx_TPI_Init();
+	g_sys.hdmiCableConnected = TRUE;
+	g_sys.dsRxPoweredUp = TRUE;
+	siHdmiTx_Init();
+	if (Sii9024A_HDCP_supported)
+		HDCP_CheckStatus( ReadByteTPI(TPI_INTERRUPT_STATUS_REG) );
+
+	return VIDEO_MODE_SET_OK;
+}
+
+
+byte SetAudioInfoFrames(byte ChannelCount,byte CodingType,byte ss,byte Fs, byte SpeakerConfig)
+{
+	byte B_Data[SIZE_AUDIO_INFOFRAME];
+	byte i;
+
+	TPI_TRACE_PRINT((">>SetAudioInfoFrames()\n"));
+
+	for (i = 0; i < SIZE_AUDIO_INFOFRAME; i++)
+		B_Data[i] = 0;
+
+	WriteByteTPI(MISC_INFO_FRAMES_CTRL, DISABLE_AUDIO); 
+
+	B_Data[0] = TYPE_AUDIO_INFOFRAMES;
+	B_Data[1] = AUDIO_INFOFRAMES_VERSION;
+	B_Data[2] = AUDIO_INFOFRAMES_LENGTH;
+	B_Data[3] = TYPE_AUDIO_INFOFRAMES + AUDIO_INFOFRAMES_VERSION + AUDIO_INFOFRAMES_LENGTH;
+
+	B_Data[4] = ChannelCount;
+	B_Data[4] |= (CodingType << 4);
+	B_Data[5] = ((Fs & THREE_LSBITS) << 2) | (ss & TWO_LSBITS);
+	B_Data[7] = SpeakerConfig;
+
+	for (i = 4; i < SIZE_AUDIO_INFOFRAME; i++)
+		B_Data[3] += B_Data[i];
+
+	B_Data[3] = 0x100 - B_Data[3];
+	WriteByteTPI(MISC_INFO_FRAMES_CTRL, EN_AND_RPT_AUDIO);
+	WriteBlockTPI(MISC_INFO_FRAMES_TYPE, SIZE_AUDIO_INFOFRAME, B_Data);
+	if (siHdmiTx.SyncMode == EMBEDDED_SYNC)
+		EnableEmbeddedSync();
+
+	return TRUE;
+}
+
+//------------------------------------------------------------------------------
+// Function Name: SetAudioMute()
+// Function Description: Mute audio
+//
+// Accepts: Mute or unmute.
+// Returns: none
+// Globals: none
+//------------------------------------------------------------------------------
+void SetAudioMute (byte audioMute)
+{
+	ReadModifyWriteTPI(TPI_AUDIO_INTERFACE_REG, AUDIO_MUTE_MASK, audioMute);
+}
+
+#ifndef F_9022A_9334
+//------------------------------------------------------------------------------
+// Function Name: SetChannelLayout()
+// Function Description: Set up the Channel layout field of internal register 0x2F (0x2F[1])
+//
+// Accepts: Number of audio channels: "0 for 2-Channels ."1" for 8.
+// Returns: none
+// Globals: none
+//------------------------------------------------------------------------------
+void SetChannelLayout (byte Count)
+{
+	// Indexed register 0x7A:0x2F[1]:
+	WriteByteTPI(TPI_INTERNAL_PAGE_REG, 0x02); // Internal page 2
+	WriteByteTPI(TPI_INDEXED_OFFSET_REG, 0x2F);
+
+	Count &= THREE_LSBITS;
+
+	if (Count == TWO_CHANNEL_LAYOUT)
+	{
+		// Clear 0x2F[1]:
+		ReadClearWriteTPI(TPI_INDEXED_VALUE_REG, BIT_1);
+	}
+
+	else if (Count == EIGHT_CHANNEL_LAYOUT)
+	{
+		// Set 0x2F[1]:
+		ReadSetWriteTPI(TPI_INDEXED_VALUE_REG, BIT_1);
+	}
+}
+#endif
+
+//------------------------------------------------------------------------------
+// Function Name: siHdmiTx_AudioSet()
+// Function Description: Set the 9022/4 audio interface to basic audio.
+//
+// Accepts: none
+// Returns: Success message if audio changed successfully.
+//                  Error Code if resolution change failed
+// Globals: siHdmiTx
+//------------------------------------------------------------------------------
+byte siHdmiTx_AudioSet (void)
+{
+	TPI_TRACE_PRINT((">>siHdmiTx_AudioSet()\n"));
+
+	SetAudioMute(AUDIO_MUTE_MUTED);  // mute output
+
+	if (siHdmiTx.AudioMode == AMODE_I2S)  	// I2S input
+	{
+		ReadModifyWriteTPI(TPI_AUDIO_INTERFACE_REG, AUDIO_SEL_MASK, AUD_IF_I2S);	// 0x26 = 0x80
+		WriteByteTPI(TPI_AUDIO_HANDLING, 0x08 | AUD_DO_NOT_CHECK);	  // 0x25
+	}
+	else									// SPDIF input
+	{
+		ReadModifyWriteTPI(TPI_AUDIO_INTERFACE_REG, AUDIO_SEL_MASK, AUD_IF_SPDIF);	// 0x26 = 0x40
+		WriteByteTPI(TPI_AUDIO_HANDLING, AUD_PASS_BASIC);                   // 0x25 = 0x00
+	}
+
+#ifndef F_9022A_9334
+	if (siHdmiTx.AudioChannels == ACHANNEL_2CH)
+		SetChannelLayout(TWO_CHANNELS);             // Always 2 channesl in S/PDIF
+	else
+		SetChannelLayout(EIGHT_CHANNELS);
+#else
+	if (siHdmiTx.AudioChannels == ACHANNEL_2CH)
+		ReadClearWriteTPI(TPI_AUDIO_INTERFACE_REG, BIT_5); // Use TPI 0x26[5] for 9022A/24A and 9334 channel layout
+	else
+		ReadSetWriteTPI(TPI_AUDIO_INTERFACE_REG, BIT_5); // Use TPI 0x26[5] for 9022A/24A and 9334 channel layout
+#endif
+
+	if (siHdmiTx.AudioMode == AMODE_I2S)  	// I2S input
+	{
+		// I2S - Map channels - replace with call to API MAPI2S
+		WriteByteTPI(TPI_I2S_EN, 0x80); // 0x1F
+
+		if (siHdmiTx.AudioChannels > ACHANNEL_2CH)
+			WriteByteTPI(TPI_I2S_EN, 0x91);
+
+		if (siHdmiTx.AudioChannels > ACHANNEL_4CH)
+			WriteByteTPI(TPI_I2S_EN, 0xA2);
+
+		if (siHdmiTx.AudioChannels > ACHANNEL_6CH)
+			WriteByteTPI(TPI_I2S_EN, 0xB3);
+
+		// I2S - Stream Header Settings - replace with call to API SetI2S_StreamHeader
+		WriteByteTPI(TPI_I2S_CHST_0, 0x00); // 0x21
+		WriteByteTPI(TPI_I2S_CHST_1, 0x00);
+		WriteByteTPI(TPI_I2S_CHST_2, 0x00);
+		WriteByteTPI(TPI_I2S_CHST_3, siHdmiTx.AudioFs);
+		WriteByteTPI(TPI_I2S_CHST_4, (siHdmiTx.AudioFs << 4) |siHdmiTx.AudioWordLength);
+
+		// Oscar 20100929 added for 16bit auido noise issue
+		WriteIndexedRegister(INDEXED_PAGE_1, AUDIO_INPUT_LENGTH, siHdmiTx.AudioWordLength);
+
+		// I2S - Input Configuration
+		WriteByteTPI(TPI_I2S_IN_CFG, siHdmiTx.AudioI2SFormat); //TPI_Reg0x20
+	}
+
+	WriteByteTPI(TPI_AUDIO_SAMPLE_CTRL, REFER_TO_STREAM_HDR);
+	SetAudioInfoFrames(siHdmiTx.AudioChannels & THREE_LSBITS, REFER_TO_STREAM_HDR, REFER_TO_STREAM_HDR, REFER_TO_STREAM_HDR, 0x00); 	
+
+	SetAudioMute(AUDIO_MUTE_NORMAL);  // unmute output
+
+	return AUDIO_MODE_SET_OK;
+}
+
+#ifdef F_9022A_9334
+//------------------------------------------------------------------------------
+// Function Name: SetGBD_InfoFrame()
+// Function Description: Sets and sends the the 9022A/4A GBD InfoFrames.
+//
+// Accepts: none
+// Returns: Success message if GBD packet set successfully. Error
+//                  Code if failed
+// Globals: none
+// NOTE: Currently this function is a place holder. It always returns a Success message
+//------------------------------------------------------------------------------
+byte SetGBD_InfoFrame (void)
+{
+	byte CheckSum;
+
+	TPI_TRACE_PRINT((">>SetGBD_InfoFrame()\n"));
+
+	// Set MPEG InfoFrame Header to GBD InfoFrame Header values:
+	WriteByteTPI(MISC_INFO_FRAMES_CTRL, DISABLE_MPEG);                    	// 0xBF = Use MPEG      InfoFrame for GBD - 0x03
+	WriteByteTPI(MISC_INFO_FRAMES_TYPE, TYPE_GBD_INFOFRAME);                        	// 0xC0 = 0x0A
+	WriteByteTPI(MISC_INFO_FRAMES_VER, NEXT_FIELD | GBD_PROFILE | AFFECTED_GAMUT_SEQ_NUM);   // 0x0C1 = 0x81
+	WriteByteTPI(MISC_INFO_FRAMES_LEN, ONLY_PACKET | CURRENT_GAMUT_SEQ_NUM);                         // 0x0C2 = 0x31
+
+	CheckSum = TYPE_GBD_INFOFRAME +
+		NEXT_FIELD +
+		GBD_PROFILE +
+		AFFECTED_GAMUT_SEQ_NUM +
+		ONLY_PACKET +
+		CURRENT_GAMUT_SEQ_NUM;
+
+	CheckSum = 0x100 - CheckSum;
+
+	WriteByteTPI(MISC_INFO_FRAMES_CTRL, EN_AND_RPT_MPEG);  // Enable and Repeat MPEG InfoFrames
+	WriteByteTPI(MISC_INFO_FRAMES_CHKSUM, CheckSum);                        // 0X00 - Send header only
+
+	return GBD_SET_SUCCESSFULLY;
+}
+#endif
+
+#ifdef DEV_SUPPORT_3D
+//------------------------------------------------------------------------------
+// Function Name: Set_VSIF()
+// Function Description: Construct Vendor Specific InfoFrame for 3D support. use MPEG InfoFrame
+//
+// Accepts: none
+// Returns: none
+// Globals: siHdmiTx
+//------------------------------------------------------------------------------
+// VSIF Constants
+//============================================================
+#define VSIF_TYPE  			0x81
+#define VSIF_VERSION		0x01
+#define VSIF_LEN				0x06
+
+void Set_VSIF (void)
+{
+	byte i;
+	byte Data[SIZE_MPEG_INFOFRAME];		//10
+
+	for (i = 0; i < SIZE_MPEG_INFOFRAME; i++)	
+	{        
+		Data[i] = 0;
+	}
+
+	// Disable transmission of VSIF during re-configuration
+	WriteByteTPI(MISC_INFO_FRAMES_CTRL, DISABLE_MPEG);          
+
+	// Header Bytes
+	Data[0] = VSIF_TYPE;            // HB0 Packet Type 0x81
+	Data[1] = VSIF_VERSION; 		// HB1 Version = 0x01
+
+	// PB1 - PB3 contain the 24bit IEEE Registration Identifier
+	Data[4] = 0x03;                     // HDMI Signature LS Byte
+	Data[5] = 0x0C;                     // HDMI Signature middle byte
+	Data[6] = 0x00;                     // HDMI Signature MS Byte
+
+	// PB4 - HDMI_Video_Format into bits 7:5
+	Data[7] = siHdmiTx.HDMIVideoFormat << 5;
+
+	// PB5 - Depending on the video format, this byte will contain either the HDMI_VIC
+	// code in buts 7:0, OR the 3D_Structure in bits 7:4.
+	switch(siHdmiTx.HDMIVideoFormat)
+	{
+		case VMD_HDMIFORMAT_HDMI_VIC:
+			// This is a 2x4K mode, set the HDMI_VIC in buts 7:0.  Values
+			// are from HDMI 1.4 Spec, 8.2.3.1 (Table 8-13).
+			Data[8] = siHdmiTx.VIC;
+			Data[9] = 0;
+			break;
+
+		case VMD_HDMIFORMAT_3D:
+			// This is a 3D mode, set the 3D_Structure in buts 7:4
+			// Bits 3:0 are reseved so set to 0.  Values are from HDMI 1.4
+			// Spec, Appendix H (Table H-2).
+			Data[8] = siHdmiTx.ThreeDStructure << 4;
+			// Add the Extended data field when the 3D format is Side-by-Side(Half).
+			// See Spec Table H-3 for details.			
+			if ((Data[8] >> 4) == VMD_3D_SIDEBYSIDEHALF)
+			{
+				Data[2] = VSIF_LEN;
+				Data[9] = siHdmiTx.ThreeDExtData << 4;;	
+			}
+			else 
+			{
+				Data[2] = VSIF_LEN-1;
+			}
+			break;
+
+		case VMD_HDMIFORMAT_CEA_VIC:
+		default:
+			Data[8] = 0;
+			Data[9] = 0;
+			break;
+	}
+
+	// Packet Bytes
+	Data[3] = VSIF_TYPE+                // PB0 partial checksum
+		VSIF_VERSION+
+		Data[2];
+
+	// Complete the checksum with PB1 through PB7
+	for (i = 4; i < SIZE_MPEG_INFOFRAME; i++)
+	{
+		Data[3] += Data[i];
+	}
+	// Data[3] %= 0x100;
+	Data[3] = 0x100 - Data[3];            // Final checksum
+
+	WriteByteTPI(MISC_INFO_FRAMES_CTRL, EN_AND_RPT_MPEG);         // Enable and Repeat MPEG/Vendor Specific InfoFrames
+
+	WriteBlockTPI(MISC_INFO_FRAMES_TYPE, SIZE_MPEG_INFOFRAME, Data);             // Write VSIF to MPEG registers and start transmission
+	WriteByteTPI(0xDE, 0x00);		// Set last byte of MPEG InfoFrame for data to be sent to sink.
+}
+#endif
+
+
+
+
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////*************************///////////////////////////////
+///////////////////////                  TPI                     ///////////////////////////////
+///////////////////////*************************///////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+
+
+//------------------------------------------------------------------------------
+// Function Name: StartTPI()
+// Function Description: Start HW TPI mode by writing 0x00 to TPI address 0xC7.
+//
+// Accepts: none
+// Returns: TRUE if HW TPI started successfully. FALSE if failed to.
+// Globals: none
+//------------------------------------------------------------------------------
+byte StartTPI (void)
+{
+	byte devID = 0x00;
+	word wID = 0x0000;	
+
+	TPI_TRACE_PRINT((">>StartTPI()\n"));
+
+	WriteByteTPI(TPI_ENABLE, 0x00);            // Write "0" to 72:C7 to start HW TPI mode
+
+	DelayMS(100);
+
+	devID = ReadIndexedRegister(INDEXED_PAGE_0, 0x03);
+	wID = devID;
+	wID <<= 8;
+	devID = ReadIndexedRegister(INDEXED_PAGE_0, 0x02);
+	wID |= devID;
+
+	devID = ReadByteTPI(TPI_DEVICE_ID);
+
+	TPI_TRACE_PRINT(("0x%04X\n", (int)wID));
+	TPI_TRACE_PRINT(("%s:%d:devID=0x%04x \n", __func__,__LINE__,devID));
+
+	if (wID == 0x9022)
+		Sii9024A_HDCP_supported = false;
+	if (devID == SII902XA_DEVICE_ID)
+		return TRUE;
+
+	TPI_TRACE_PRINT(("Unsupported TX, devID = 0x%X\n", (int)devID));
+	return FALSE;
+}
+
+//------------------------------------------------------------------------------
+// Function Name: siHdmiTx_TPI_Init()
+// Function Description: TPI initialization: HW Reset, Interrupt enable.
+//
+// Accepts: none
+// Returns: TRUE or FLASE
+// Globals: none
+//------------------------------------------------------------------------------
+byte siHdmiTx_TPI_Init (void)
+{
+	TPI_TRACE_PRINT(("\n>>siHdmiTx_TPI_Init()\n"));
+	TPI_TRACE_PRINT(("\n%s\n", TPI_FW_VERSION));
+
+	// Chip powers up in D2 mode.
+	g_sys.txPowerState = TX_POWER_STATE_D0;
+
+	InitializeStateVariables();
+
+	// Toggle TX reset pin
+	//TxHW_Reset();							
+	WriteByteTPI(0xF5, 0x00);	
+	// Enable HW TPI mode, check device ID
+	if (StartTPI())
+	{
+		if (Sii9024A_HDCP_supported){
+			g_hdcp.HDCP_Override = FALSE;
+			g_hdcp.HDCPAuthenticated = VMD_HDCP_AUTHENTICATED;
+			HDCP_Init();
+		}
+
+#ifdef DEV_SUPPORT_CEC
+		//SI_CecInit();
+#endif
+
+		EnableInterrupts(HOT_PLUG_EVENT);
+
+		return 0;
+	}
+
+	return EPERM;
+}
+
+//------------------------------------------------------------------------------
+// Function Name: OnDownstreamRxPoweredDown()
+// Function Description: HDMI cable unplug handle.
+//
+// Accepts: none
+// Returns: none
+// Globals: none
+//------------------------------------------------------------------------------
+void OnDownstreamRxPoweredDown (void)
+{
+	TPI_DEBUG_PRINT (("DSRX -> Powered Down\n"));
+	g_sys.dsRxPoweredUp = FALSE;
+
+	if (g_hdcp.HDCP_Started == TRUE && Sii9024A_HDCP_supported)
+		HDCP_Off();
+	DisableTMDS();
+	ReadModifyWriteTPI(TPI_SYSTEM_CONTROL_DATA_REG, OUTPUT_MODE_MASK,OUTPUT_MODE_DVI);	// Set to DVI output mode to reset HDCP
+}
+
+extern void HotPlugService(void);
+//------------------------------------------------------------------------------
+// Function Name: OnDownstreamRxPoweredUp()
+// Function Description: DSRX power up handle.
+//
+// Accepts: none
+// Returns: none
+// Globals: none
+//------------------------------------------------------------------------------
+void OnDownstreamRxPoweredUp (void)
+{
+	TPI_DEBUG_PRINT (("DSRX -> Powered Up\n"));
+	g_sys.dsRxPoweredUp = TRUE;
+
+	HotPlugService();
+}
+
+//------------------------------------------------------------------------------
+// Function Name: OnHdmiCableDisconnected()
+// Function Description: HDMI cable unplug handle.
+//
+// Accepts: none
+// Returns: none
+// Globals: none
+//------------------------------------------------------------------------------
+void OnHdmiCableDisconnected (void)
+{
+	TPI_DEBUG_PRINT (("HDMI Disconnected\n"));
+
+	g_sys.hdmiCableConnected = FALSE;
+
+#ifdef DEV_SUPPORT_EDID
+	g_edid.edidDataValid = FALSE;
+#endif
+
+	OnDownstreamRxPoweredDown();
+}
+
+//------------------------------------------------------------------------------
+// Function Name: OnHdmiCableConnected()
+// Function Description: HDMI cable plug in handle.
+//
+// Accepts: none
+// Returns: none
+// Globals: none
+//------------------------------------------------------------------------------
+void OnHdmiCableConnected (void)
+{
+	TPI_DEBUG_PRINT (("Cable Connected\n"));
+	// No need to call TPI_Init here unless TX has been powered down on cable removal.
+	//TPI_Init();
+
+	g_sys.hdmiCableConnected = TRUE;
+
+	if ((Sii9024A_HDCP_supported) 
+			&& (g_hdcp.HDCP_TxSupports == TRUE) 
+			&& (g_hdcp.HDCP_AksvValid == TRUE) 
+			&& (g_hdcp.HDCPAuthenticated == VMD_HDCP_AUTHENTICATED)) 
+	{
+		WriteIndexedRegister(INDEXED_PAGE_0, 0xCE, 0x00); // Clear BStatus
+		WriteIndexedRegister(INDEXED_PAGE_0, 0xCF, 0x00);
+	}
+
+
+	// Added for EDID read for Michael Wang recommaned by oscar 20100908
+	//siHdmiTx_PowerStateD0();
+	//ReadModifyWriteTPI(TPI_SYSTEM_CONTROL_DATA_REG, TMDS_OUTPUT_CONTROL_MASK | AV_MUTE_MASK, TMDS_OUTPUT_CONTROL_ACTIVE | AV_MUTE_MUTED);
+
+#ifdef DEV_SUPPORT_EDID
+	DoEdidRead();
+#endif
+
+#ifdef READKSV
+	ReadModifyWriteTPI(0xBB, 0x08, 0x08);
+#endif
+
+	if (IsHDMI_Sink())              // select output mode (HDMI/DVI) according to sink capabilty
+	{
+		TPI_DEBUG_PRINT (("HDMI Sink Detected\n"));
+		ReadModifyWriteTPI(TPI_SYSTEM_CONTROL_DATA_REG, OUTPUT_MODE_MASK, OUTPUT_MODE_HDMI);
+	}
+	else
+	{
+		TPI_DEBUG_PRINT (("DVI Sink Detected\n"));
+		ReadModifyWriteTPI(TPI_SYSTEM_CONTROL_DATA_REG, OUTPUT_MODE_MASK, OUTPUT_MODE_DVI);
+	}
+}
+
+//------------------------------------------------------------------------------
+// Function Name: siHdmiTx_PowerStateD0()
+// Function Description: Set TX to D0 mode.
+//------------------------------------------------------------------------------
+void siHdmiTx_PowerStateD0 (void)
+{
+	ReadModifyWriteTPI(TPI_DEVICE_POWER_STATE_CTRL_REG, TX_POWER_STATE_MASK, TX_POWER_STATE_D0);
+	TPI_DEBUG_PRINT(("TX Power State D0\n"));
+	g_sys.txPowerState = TX_POWER_STATE_D0;
+}
+
+//------------------------------------------------------------------------------
+// Function Name: siHdmiTx_PowerStateD2()
+// Function Description: Set TX to D2 mode.
+//------------------------------------------------------------------------------
+void siHdmiTx_PowerStateD2 (void)
+{
+	ReadModifyWriteTPI(TPI_DEVICE_POWER_STATE_CTRL_REG, TX_POWER_STATE_MASK, TX_POWER_STATE_D2);
+	TPI_DEBUG_PRINT(("TX Power State D2\n"));
+	g_sys.txPowerState = TX_POWER_STATE_D2;
+}
+
+//------------------------------------------------------------------------------
+// Function Name: siHdmiTx_PowerStateD0fromD2()
+// Function Description: Set TX to D0 mode from D2 mode.
+//------------------------------------------------------------------------------
+void siHdmiTx_PowerStateD0fromD2 (void)
+{
+	ReadModifyWriteTPI(TPI_DEVICE_POWER_STATE_CTRL_REG, TX_POWER_STATE_MASK, TX_POWER_STATE_D0);
+
+	if (Sii9024A_HDCP_supported)
+		RestartHDCP();
+	else
+		EnableTMDS();
+
+	TPI_DEBUG_PRINT(("TX Power State D0 from D2\n"));
+	g_sys.txPowerState = TX_POWER_STATE_D0;
+}
+
+//------------------------------------------------------------------------------
+// Function Name: HotPlugService()
+// Function Description: Implement Hot Plug Service Loop activities
+//
+// Accepts: none
+// Returns: An error code that indicates success or cause of failure
+// Globals: LinkProtectionLevel
+//------------------------------------------------------------------------------
+void HotPlugService (void)
+{
+	TPI_TRACE_PRINT((">>HotPlugService()\n"));
+
+	DisableInterrupts(0xFF);
+
+	//siHdmiTx.VIC = g_edid.VideoDescriptor[0];	// use 1st mode supported by sink
+
+	siHdmiTx_Init();
+}
+
+//------------------------------------------------------------------------------
+// Function Name: siHdmiTx_TPI_Poll()
+// Function Description: Poll Interrupt Status register for new interrupts
+//
+// Accepts: none
+// Returns: none
+// Globals: none
+//------------------------------------------------------------------------------
+
+void siHdmiTx_TPI_Poll (void)
+{
+	byte InterruptStatus;
+
+	if (g_sys.txPowerState == TX_POWER_STATE_D0)
+	{
+		InterruptStatus = ReadByteTPI(TPI_INTERRUPT_STATUS_REG);
+
+		if (InterruptStatus & HOT_PLUG_EVENT)		  //judge if HPD is connected
+		{
+			TPI_DEBUG_PRINT (("HPD	-> "));
+			ReadSetWriteTPI(TPI_INTERRUPT_ENABLE_REG, HOT_PLUG_EVENT);	// Enable HPD interrupt bit
+
+			// Repeat this loop while cable is bouncing:
+			do
+			{
+				WriteByteTPI(TPI_INTERRUPT_STATUS_REG, HOT_PLUG_EVENT);   //Write 1 to interrupt bits to clear the 'pending' status.
+				DelayMS(T_HPD_DELAY); // Delay for metastability protection and to help filter out connection bouncing
+				InterruptStatus = ReadByteTPI(TPI_INTERRUPT_STATUS_REG);	// Read Interrupt status register
+			} while (InterruptStatus & HOT_PLUG_EVENT); 			 // loop as long as HP interrupts recur
+
+			if (((InterruptStatus & HOT_PLUG_STATE) >> 2) != g_sys.hdmiCableConnected)
+			{
+				if (g_sys.hdmiCableConnected == TRUE)
+				{
+					OnHdmiCableDisconnected();
+				}
+				else
+				{
+					OnHdmiCableConnected();
+					ReadModifyWriteIndexedRegister(INDEXED_PAGE_0, 0x0A, 0x08, 0x08);
+				}
+
+				if (g_sys.hdmiCableConnected == FALSE)
+				{
+					return;
+				}
+			}
+		}
+
+		// Check rx power
+		if (((InterruptStatus & RX_SENSE_STATE) >> 3) != g_sys.dsRxPoweredUp)
+		{
+			if (g_sys.hdmiCableConnected == TRUE)
+			{
+				if (g_sys.dsRxPoweredUp == TRUE)
+				{
+					OnDownstreamRxPoweredDown();
+				}
+				else
+				{
+					OnDownstreamRxPoweredUp();
+				}
+			}
+			DelayMS(100); // Delay for metastability protection and to help filter out connection bouncing
+			ClearInterrupt(RX_SENSE_EVENT);
+		}
+
+		// Check if Audio Error event has occurred:
+		if (InterruptStatus & AUDIO_ERROR_EVENT)
+		{
+			//TPI_DEBUG_PRINT (("TP -> Audio Error Event\n"));
+			//	The hardware handles the event without need for host intervention (PR, p. 31)
+			ClearInterrupt(AUDIO_ERROR_EVENT);
+		}
+
+		if ((Sii9024A_HDCP_supported)
+				&& (g_sys.hdmiCableConnected == TRUE)
+				&& (g_sys.dsRxPoweredUp == TRUE)
+				&& (g_hdcp.HDCPAuthenticated == VMD_HDCP_AUTHENTICATED))
+		{
+			HDCP_CheckStatus(InterruptStatus);
+		}
+
+#ifdef DEV_SUPPORT_CEC
+		//SI_CecHandler(0 , 0);
+#endif
+	}
+
+}
+
+void siHdmiTx_VideoSel (byte vmode)
+{
+	siHdmiTx.HDMIVideoFormat 	= VMD_HDMIFORMAT_CEA_VIC;
+	siHdmiTx.ColorSpace 		= RGB;
+	siHdmiTx.ColorDepth			= VMD_COLOR_DEPTH_8BIT;
+	siHdmiTx.SyncMode 			= EXTERNAL_HSVSDE;
+//	siHdmiTx.SyncMode 			= 1;
+
+	switch (vmode)
+	{
+		case HDMI_480I60_4X3:
+			siHdmiTx.VIC 		= 6;
+			siHdmiTx.AspectRatio 	= VMD_ASPECT_RATIO_4x3;
+			siHdmiTx.Colorimetry	= COLORIMETRY_601;
+			siHdmiTx.TclkSel		= X2;
+			break;
+
+		case HDMI_576I50_4X3:
+			siHdmiTx.VIC 		= 21;
+			siHdmiTx.AspectRatio 	= VMD_ASPECT_RATIO_4x3;
+			siHdmiTx.Colorimetry	= COLORIMETRY_601;
+			siHdmiTx.TclkSel		= X2;
+			break;
+
+		case HDMI_480P60_4X3:
+			siHdmiTx.VIC 		= 2;
+			siHdmiTx.AspectRatio 	= VMD_ASPECT_RATIO_4x3;
+			siHdmiTx.Colorimetry	= COLORIMETRY_601;
+			siHdmiTx.TclkSel		= X1;
+			break;
+
+		case HDMI_576P50_4X3:
+			siHdmiTx.VIC 		= 17;
+			siHdmiTx.AspectRatio 	= VMD_ASPECT_RATIO_4x3;
+			siHdmiTx.Colorimetry	= COLORIMETRY_601;
+			siHdmiTx.TclkSel		= X1;
+			break;
+
+		case HDMI_720P60:
+			siHdmiTx.VIC 		= 4;
+			siHdmiTx.AspectRatio 	= VMD_ASPECT_RATIO_16x9;
+			siHdmiTx.Colorimetry	= COLORIMETRY_709;
+			siHdmiTx.TclkSel		= X1;
+			break;
+
+		case HDMI_720P50:
+			siHdmiTx.VIC 		= 19;
+			siHdmiTx.AspectRatio 	= VMD_ASPECT_RATIO_16x9;
+			siHdmiTx.Colorimetry	= COLORIMETRY_709;
+			siHdmiTx.TclkSel		= X1;
+			break;
+
+		case HDMI_1080I60:
+			siHdmiTx.VIC 		= 5;
+			siHdmiTx.AspectRatio 	= VMD_ASPECT_RATIO_16x9;
+			siHdmiTx.Colorimetry	= COLORIMETRY_709;
+			siHdmiTx.TclkSel		= X1;
+			break;
+
+		case HDMI_1080I50:
+			siHdmiTx.VIC 		= 20;
+			siHdmiTx.AspectRatio 	= VMD_ASPECT_RATIO_16x9;
+			siHdmiTx.Colorimetry	= COLORIMETRY_709;
+			siHdmiTx.TclkSel		= X1;
+			break;
+
+		case HDMI_1080P60:
+			siHdmiTx.VIC 		= 16;
+			siHdmiTx.AspectRatio 	= VMD_ASPECT_RATIO_16x9;
+			siHdmiTx.Colorimetry	= COLORIMETRY_709;
+			siHdmiTx.TclkSel		= X1;
+			break;
+
+		case HDMI_1080P50:
+			siHdmiTx.VIC 		= 31;
+			siHdmiTx.AspectRatio 	= VMD_ASPECT_RATIO_16x9;
+			siHdmiTx.Colorimetry	= COLORIMETRY_709;
+			siHdmiTx.TclkSel		= X1;
+			break;
+
+		case HDMI_1024_768_60:
+			siHdmiTx.VIC 		= PC_BASE+13;
+			siHdmiTx.AspectRatio 	= VMD_ASPECT_RATIO_4x3;
+			siHdmiTx.Colorimetry	= COLORIMETRY_709;
+			siHdmiTx.TclkSel		= X1;
+			break;
+		case HDMI_800_600_60:
+			siHdmiTx.VIC 		= PC_BASE+9;
+			siHdmiTx.AspectRatio 	= VMD_ASPECT_RATIO_4x3;
+			siHdmiTx.Colorimetry	= COLORIMETRY_709;
+			siHdmiTx.TclkSel		= X1;
+			break;
+		default:
+			break;
+	}
+}
+
+//------------------------------------------------------------------------------
+// Function Name: siHdmiTx_AudioSel()
+// Function Description: Select output audio mode
+//
+// Accepts: Audio Fs
+// Returns: none
+// Globals: none
+//------------------------------------------------------------------------------
+void siHdmiTx_AudioSel (byte Afs)
+{
+	siHdmiTx.AudioMode			= AMODE_I2S;
+	siHdmiTx.AudioChannels		= ACHANNEL_2CH;
+	siHdmiTx.AudioFs				= Afs;
+	siHdmiTx.AudioWordLength		= ALENGTH_24BITS;
+	siHdmiTx.AudioI2SFormat		= (MCLK256FS << 4) |SCK_SAMPLE_RISING_EDGE |0x00; //last num 0x00-->0x02
+}
+
diff --git a/drivers/gpu/drm/smi/ddk750/siHdmiTx_902x_TPI.h b/drivers/gpu/drm/smi/ddk750/siHdmiTx_902x_TPI.h
new file mode 100644
index 000000000000..d9eb2fdfb00a
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk750/siHdmiTx_902x_TPI.h
@@ -0,0 +1,1124 @@
+/***************************************************************************
+*
+* SIMG PART NUMBER -HDMI Transmitter Driver
+*
+* Copyright (C) (2011, Silicon Image)
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation version 2.
+*
+* This program is distributed "as is" WITHOUT ANY WARRANTY of any
+* kind, whether express or implied; without even the implied warranty
+* of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+*****************************************************************************/
+
+
+#ifndef _SIHDMITX_902X_TPI_H_
+#define _SIHDMITX_902X_TPI_H_
+
+/* smi added */
+#define SII9022A_I2C_ADDRESS                  0x72
+#ifdef USE_HW_I2C
+#define i2cWriteReg hwI2CWriteReg
+#define i2cReadReg  hwI2CReadReg
+#else
+#define i2cWriteReg swI2CWriteReg
+#define i2cReadReg  swI2CReadReg
+#endif
+
+//--------------------------------------------------------------------
+// typedef
+//--------------------------------------------------------------------
+
+typedef unsigned char		byte;
+typedef unsigned short		word;
+typedef unsigned int		dword;
+
+//--------------------------------------------------------------------
+// System Macro definition
+//--------------------------------------------------------------------
+#define IIC_OK 0
+
+
+#define DEV_SUPPORT_EDID  0
+//#define DEV_SUPPORT_HDCP
+//#define DEV_SUPPORT_CEC
+//#define DEV_SUPPORT_3D
+
+#define CLOCK_EDGE_RISING
+//#define CLOCK_EDGE_FALLING
+
+#define F_9022A_9334
+//#define HW_INT_ENABLE
+
+
+
+//--------------------------------------------------------------------
+// TPI Firmware Version
+//--------------------------------------------------------------------
+static const char TPI_FW_VERSION[] = "TPI Firmware v6.6.3_APP v1.3";
+
+// Generic Constants
+//====================================================
+#define FALSE                0
+#define TRUE                  1
+
+#define OFF                    0
+#define ON                      1
+
+#define LOW                   0
+#define HIGH                  1
+
+#define DISABLE 	0x00
+#define ENABLE  	0xFF
+
+
+#define MAX_V_DESCRIPTORS				20
+#define MAX_A_DESCRIPTORS				10
+#define MAX_SPEAKER_CONFIGURATIONS	4
+#define AUDIO_DESCR_SIZE			 	3
+
+#define RGB					0
+#define YCBCR444			1
+#define YCBCR422_16BITS		2
+#define YCBCR422_8BITS		3
+#define XVYCC444			4
+
+#define EXTERNAL_HSVSDE	0
+#define INTERNAL_DE			1
+#define EMBEDDED_SYNC		2
+
+#define COLORIMETRY_601	0
+#define COLORIMETRY_709	1
+
+//====================================================
+#define MCLK128FS 			0
+#define MCLK256FS 			1
+#define MCLK384FS 			2
+#define MCLK512FS 			3
+#define MCLK768FS 			4
+#define MCLK1024FS 			5
+#define MCLK1152FS 			6
+#define MCLK192FS 			7
+
+#define SCK_SAMPLE_FALLING_EDGE 	0x00
+#define SCK_SAMPLE_RISING_EDGE 	0x80
+
+//====================================================
+// Video mode define
+#define HDMI_480I60_4X3	1
+#define HDMI_576I50_4X3	2
+#define HDMI_480P60_4X3	3
+#define HDMI_576P50_4X3	4
+#define HDMI_720P60			5
+#define HDMI_720P50			6
+#define HDMI_1080I60		7
+#define HDMI_1080I50		8
+#define HDMI_1080P60		9
+#define HDMI_1080P50		10
+#define HDMI_1024_768_60	11
+#define HDMI_800_600_60		12
+
+
+
+
+
+//====================================================
+#define AMODE_I2S 			0
+#define AMODE_SPDIF 		1
+#define AMODE_HBR 			2
+#define AMODE_DSD 			3
+
+#define ACHANNEL_2CH		1
+#define ACHANNEL_3CH 		2
+#define ACHANNEL_4CH 		3
+#define ACHANNEL_5CH 		4
+#define ACHANNEL_6CH 		5
+#define ACHANNEL_7CH 		6
+#define ACHANNEL_8CH 		7
+
+#define AFS_44K1			0x00
+#define AFS_48K				0x02
+#define AFS_32K				0x03
+#define AFS_88K2			0x08
+#define AFS_768K			0x09
+#define AFS_96K				0x0a
+#define AFS_176K4			0x0c
+#define AFS_192K			0x0e
+
+#define ALENGTH_16BITS		0x02
+#define ALENGTH_17BITS		0x0c
+#define ALENGTH_18BITS		0x04
+#define ALENGTH_19BITS		0x08
+#define ALENGTH_20BITS		0x0a
+#define ALENGTH_21BITS		0x0d
+#define ALENGTH_22BITS		0x05
+#define ALENGTH_23BITS		0x09
+#define ALENGTH_24BITS		0x0b
+
+//====================================================
+typedef struct
+{
+    	byte HDMIVideoFormat;	// 0 = CEA-861 VIC; 1 = HDMI_VIC; 2 = 3D
+    	byte VIC;				// VIC or the HDMI_VIC
+    	byte AspectRatio;		// 4x3 or 16x9
+    	byte ColorSpace;		// 0 = RGB; 1 = YCbCr4:4:4; 2 = YCbCr4:2:2_16bits; 3 = YCbCr4:2:2_8bits; 4 = xvYCC4:4:4
+    	byte ColorDepth;		// 0 = 8bits; 1 = 10bits; 2 = 12bits
+    	byte Colorimetry;		// 0 = 601; 1 = 709
+		byte SyncMode;			// 0 = external HS/VS/DE; 1 = external HS/VS and internal DE; 2 = embedded sync  
+		byte TclkSel;			// 0 = x0.5CLK; 1 = x1CLK; 2 = x2CLK; 3 = x4CLK
+    	byte ThreeDStructure;	// Valid when (HDMIVideoFormat == VMD_HDMIFORMAT_3D)
+		byte ThreeDExtData;		// Valid when (HDMIVideoFormat == VMD_HDMIFORMAT_3D) && (ThreeDStructure == VMD_3D_SIDEBYSIDEHALF)
+
+		byte AudioMode;			// 0 = I2S; 1 = S/PDIF; 2 = HBR; 3 = DSD;
+		byte AudioChannels;		// 1 = 2chs; 2 = 3chs; 3 = 4chs; 4 = 5chs; 5 = 6chs; 6 = 7chs; 7 = 8chs;
+		byte AudioFs;			// 0-44.1kHz; 2-48kHz; 3-32kHz; 8-88.2kHz; 9-768kHz; A-96kHz; C-176.4kHz; E-192kHz; 1/4/5/6/7/B/D/F-not indicated
+     	byte AudioWordLength; 	// 0/1-not available; 2-16 bit; 4-18 bit; 8-19 bit; A-20 bit; C-17 bit; 5-22 bit; 9-23 bit; B-24 bit; D-21 bit
+     	byte AudioI2SFormat;   	// Please refer to TPI reg0x20 for detailed. 
+     						 	//[7]_SCK Sample Edge: 0 = Falling; 1 = Rising
+     						 	//[6:4]_MCLK Multiplier: 000:MCLK=128Fs; 001:MCLK=256Fs; 010:MCLK=384Fs; 011:MCLK=512Fs; 100:MCLK=768Fs; 101:MCLK=1024Fs; 110:MCLK=1152Fs; 111:MCLK=192Fs;   
+     						 	//[3]_WS Polarity-Left when: 0 = WS is low when Left; 1 = WS is high when Left
+     						 	//[2]_SD Justify Data is justified: 0 = Left; 1 = Right
+     						 	//[1]_SD Direction Byte shifted first: 0 = MSB; 1 = LSB
+     						 	//[0]_WS to SD First Bit Shift: 0 = Yes; 1 = No
+
+}SIHDMITX_CONFIG;
+
+//====================================================
+typedef struct
+{
+	byte txPowerState;
+	byte tmdsPoweredUp;
+	byte hdmiCableConnected;
+	byte dsRxPoweredUp;
+	
+}GLOBAL_SYSTEM;
+
+//====================================================
+typedef struct
+{
+	byte HDCP_TxSupports;
+	byte HDCP_AksvValid;
+	byte HDCP_Started;
+	byte HDCP_LinkProtectionLevel;
+	byte HDCP_Override;
+	byte HDCPAuthenticated;
+	
+}GLOBAL_HDCP;
+
+//====================================================
+typedef struct
+{												// for storing EDID parsed data
+	byte edidDataValid;
+	byte VideoDescriptor[MAX_V_DESCRIPTORS];	// maximum number of video descriptors
+	byte AudioDescriptor[MAX_A_DESCRIPTORS][3];	// maximum number of audio descriptors
+	byte SpkrAlloc[MAX_SPEAKER_CONFIGURATIONS];	// maximum number of speaker configurations
+	byte UnderScan;								// "1" if DTV monitor underscans IT video formats by default
+	byte BasicAudio;								// Sink supports Basic Audio
+	byte YCbCr_4_4_4;							// Sink supports YCbCr 4:4:4
+	byte YCbCr_4_2_2;							// Sink supports YCbCr 4:2:2
+	byte HDMI_Sink;								// "1" if HDMI signature found
+	byte CEC_A_B;								// CEC Physical address. See HDMI 1.3 Table 8-6
+	byte CEC_C_D;
+	byte ColorimetrySupportFlags;				// IEC 61966-2-4 colorimetry support: 1 - xvYCC601; 2 - xvYCC709 
+	byte MetadataProfile;
+	byte _3D_Supported;
+	
+} GLOBAL_EDID;
+
+enum EDID_ErrorCodes
+{
+	EDID_OK,
+	EDID_INCORRECT_HEADER,
+	EDID_CHECKSUM_ERROR,
+	EDID_NO_861_EXTENSIONS,
+	EDID_SHORT_DESCRIPTORS_OK,
+	EDID_LONG_DESCRIPTORS_OK,
+	EDID_EXT_TAG_ERROR,
+	EDID_REV_ADDR_ERROR,
+	EDID_V_DESCR_OVERFLOW,
+	EDID_UNKNOWN_TAG_CODE,
+	EDID_NO_DETAILED_DESCRIPTORS,
+	EDID_DDC_BUS_REQ_FAILURE,
+	EDID_DDC_BUS_RELEASE_FAILURE
+};
+
+
+#ifdef DEV_SUPPORT_EDID
+#define IsHDMI_Sink()		(g_edid.HDMI_Sink)
+#define IsCEC_DEVICE()		(((g_edid.CEC_A_B != 0xFF) && (g_edid.CEC_C_D != 0xFF)) ? TRUE : FALSE)
+
+#else
+#define IsHDMI_Sink()		(TRUE)
+#define IsCEC_DEVICE()		(FALSE)
+#endif
+
+
+
+//--------------------------------------------------------------------
+// Debug Definitions
+//--------------------------------------------------------------------
+// Compile debug prints inline or not
+#define CONF__TPI_TRACE_PRINT		(ENABLE)
+#define CONF__TPI_DEBUG_PRINT   	(ENABLE)
+#define CONF__TPI_EDID_PRINT    		(DISABLE)
+#define CONF__CPI_DEBUG_PRINT   	(DISABLE)
+
+
+// Trace Print Macro
+// Note: TPI_TRACE_PRINT Requires double parenthesis
+// Example:  TPI_TRACE_PRINT(("hello, world!\n"));
+#if (CONF__TPI_TRACE_PRINT == ENABLE)
+    #define TPI_TRACE_PRINT(x)	printk x; 
+#else
+	#define TPI_TRACE_PRINT(x)
+#endif
+
+// Debug Print Macro
+// Note: TPI_DEBUG_PRINT Requires double parenthesis
+// Example:  TPI_DEBUG_PRINT(("hello, world!\n"));
+#if (CONF__TPI_DEBUG_PRINT == ENABLE)
+    #define TPI_DEBUG_PRINT(x)	printk x; 
+#else
+    #define TPI_DEBUG_PRINT(x)
+#endif
+
+// EDID Print Macro
+// Note: To enable EDID description printing, both CONF__TPI_EDID_PRINT and CONF__TPI_DEBUG_PRINT must be enabled
+// Note: TPI_EDID_PRINT Requires double parenthesis
+// Example:  TPI_EDID_PRINT(("hello, world!\n"));
+#if (CONF__TPI_EDID_PRINT == ENABLE)
+    #define TPI_EDID_PRINT(x)		TPI_DEBUG_PRINT(x)
+#else
+    #define TPI_EDID_PRINT(x)
+#endif
+
+// CPI Debug Print Macro
+// Note: To enable CPI description printing, both CONF__CPI_DEBUG_PRINT and CONF__TPI_DEBUG_PRINT must be enabled
+// Note: CPI_DEBUG_PRINT Requires double parenthesis
+// Example:  CPI_DEBUG_PRINT(("hello, world!\n"));
+#if (CONF__CPI_DEBUG_PRINT == ENABLE)
+    #define CPI_DEBUG_PRINT(x)	TPI_DEBUG_PRINT(x)
+#else
+    #define CPI_DEBUG_PRINT(x)
+#endif
+
+
+
+enum AV_ConfigErrorCodes
+{
+    DE_CANNOT_BE_SET_WITH_EMBEDDED_SYNC,
+    V_MODE_NOT_SUPPORTED,
+    SET_EMBEDDED_SYC_FAILURE,
+    I2S_MAPPING_SUCCESSFUL,
+    I2S_INPUT_CONFIG_SUCCESSFUL,
+    I2S_HEADER_SET_SUCCESSFUL,
+    EHDMI_ARC_SINGLE_SET_SUCCESSFUL,
+    EHDMI_ARC_COMMON_SET_SUCCESSFUL,
+    EHDMI_HEC_SET_SUCCESSFUL,
+    EHDMI_ARC_CM_WITH_HEC_SET_SUCCESSFUL,
+    AUD_MODE_NOT_SUPPORTED,
+    I2S_NOT_SET,
+    DE_SET_OK,
+    VIDEO_MODE_SET_OK,
+    AUDIO_MODE_SET_OK,
+    GBD_SET_SUCCESSFULLY,
+    DE_CANNOT_BE_SET_WITH_3D_MODE,
+};
+
+
+#define ClearInterrupt(x)       WriteByteTPI(TPI_INTERRUPT_STATUS_REG, x)   // write "1" to clear interrupt bit
+
+// Generic Masks
+//====================================================
+#define LOW_BYTE      0x00FF
+
+#define LOW_NIBBLE	0x0F
+#define HI_NIBBLE  	0xF0
+
+#define MSBIT       	0x80
+#define LSBIT          	0x01
+
+#define BIT_0                   0x01
+#define BIT_1                   0x02
+#define BIT_2                   0x04
+#define BIT_3                   0x08
+#define BIT_4                   0x10
+#define BIT_5                   0x20
+#define BIT_6                   0x40
+#define BIT_7                   0x80
+
+#define TWO_LSBITS        	0x03
+#define THREE_LSBITS   	0x07
+#define FOUR_LSBITS    	0x0F
+#define FIVE_LSBITS    	0x1F
+#define SEVEN_LSBITS    	0x7F
+#define TWO_MSBITS     	0xC0
+#define EIGHT_BITS      	0xFF
+#define BYTE_SIZE        	0x08
+#define BITS_1_0          	0x03
+#define BITS_2_1          	0x06
+#define BITS_2_1_0        	0x07
+#define BITS_3_2              	0x0C
+#define BITS_4_3_2       	0x1C  
+#define BITS_5_4              	0x30
+#define BITS_5_4_3		0x38
+#define BITS_6_5             	0x60
+#define BITS_6_5_4        	0x70
+#define BITS_7_6            	0xC0
+
+#define TPI_INTERNAL_PAGE_REG		0xBC
+#define TPI_INDEXED_OFFSET_REG	0xBD
+#define TPI_INDEXED_VALUE_REG		0xBE
+
+// Interrupt Masks
+//====================================================
+#define HOT_PLUG_EVENT          0x01
+#define RX_SENSE_EVENT          0x02
+#define HOT_PLUG_STATE          0x04
+#define RX_SENSE_STATE          0x08
+
+#define AUDIO_ERROR_EVENT       0x10
+#define SECURITY_CHANGE_EVENT   0x20
+#define V_READY_EVENT           0x40
+#define HDCP_CHANGE_EVENT       0x80
+
+#define NON_MASKABLE_INT		0xFF
+
+// TPI Control Masks
+//====================================================
+
+#define CS_HDMI_RGB         0x00
+#define CS_DVI_RGB          0x03
+
+#define ENABLE_AND_REPEAT	0xC0
+#define EN_AND_RPT_MPEG	0xC3
+#define DISABLE_MPEG		0x03	// Also Vendor Specific InfoFrames
+
+// Pixel Repetition Masks
+//====================================================
+#define BIT_BUS_24          0x20
+#define BIT_EDGE_RISE       0x10
+
+//Audio Maps
+//====================================================
+#define BIT_AUDIO_MUTE      0x10
+
+// Input/Output Format Masks
+//====================================================
+#define BITS_IN_RGB         0x00
+#define BITS_IN_YCBCR444    0x01
+#define BITS_IN_YCBCR422    0x02
+
+#define BITS_IN_AUTO_RANGE  0x00
+#define BITS_IN_FULL_RANGE  0x04
+#define BITS_IN_LTD_RANGE   0x08
+
+#define BIT_EN_DITHER_10_8  0x40
+#define BIT_EXTENDED_MODE   0x80
+
+#define BITS_OUT_RGB        0x00
+#define BITS_OUT_YCBCR444   0x01
+#define BITS_OUT_YCBCR422   0x02
+
+#define BITS_OUT_AUTO_RANGE 0x00
+#define BITS_OUT_FULL_RANGE 0x04
+#define BITS_OUT_LTD_RANGE  0x08
+
+#define BIT_BT_709          0x10
+
+
+// DE Generator Masks
+//====================================================
+#define BIT_EN_DE_GEN       0x40
+#define DE 					0x00
+#define DeDataNumBytes 		12
+
+// Embedded Sync Masks
+//====================================================
+#define BIT_EN_SYNC_EXTRACT 0x40
+#define EMB                 0x80
+#define EmbDataNumBytes     8
+
+
+// Audio Modes
+//====================================================
+#define AUD_PASS_BASIC      0x00
+#define AUD_PASS_ALL        0x01
+#define AUD_DOWN_SAMPLE     0x02
+#define AUD_DO_NOT_CHECK    0x03
+
+#define REFER_TO_STREAM_HDR     0x00
+#define TWO_CHANNELS            	0x00
+#define EIGHT_CHANNELS          	0x01
+#define AUD_IF_SPDIF            		0x40
+#define AUD_IF_I2S              		0x80
+#define AUD_IF_DSD				0xC0
+#define AUD_IF_HBR				0x04
+
+#define TWO_CHANNEL_LAYOUT      0x00
+#define EIGHT_CHANNEL_LAYOUT    0x20
+
+
+// I2C Slave Addresses
+//====================================================
+#define TX_SLAVE_ADDR       	0x72
+#define CBUS_SLAVE_ADDR     	0xC8
+#define HDCP_SLAVE_ADDR     	0x74
+#define EDID_ROM_ADDR       	0xA0
+#define EDID_SEG_ADDR	    	0x60
+
+// Indexed Register Offsets, Constants
+//====================================================
+#define INDEXED_PAGE_0		0x01
+#define INDEXED_PAGE_1		0x02
+#define INDEXED_PAGE_2		0x03
+
+#define TMDS_CONT_REG          0x82
+
+// DDC Bus Addresses
+//====================================================
+#define DDC_BSTATUS_ADDR_L  0x41
+#define DDC_BSTATUS_ADDR_H  0x42
+#define DDC_KSV_FIFO_ADDR   0x43
+#define KSV_ARRAY_SIZE      128
+
+// DDC Bus Bit Masks
+//====================================================
+#define BIT_DDC_HDMI        0x80
+#define BIT_DDC_REPEATER    0x40
+#define BIT_DDC_FIFO_RDY    0x20
+#define DEVICE_COUNT_MASK   0x7F
+
+// KSV Buffer Size
+//====================================================
+#define DEVICE_COUNT         128    // May be tweaked as needed
+
+// InfoFrames
+//====================================================
+#define SIZE_AVI_INFOFRAME      0x0E     // including checksum byte
+#define BITS_OUT_FORMAT         0x60    // Y1Y0 field
+
+#define _4_To_3                 0x10    // Aspect ratio - 4:3  in InfoFrame DByte 1
+#define _16_To_9                0x20    // Aspect ratio - 16:9 in InfoFrame DByte 1
+#define SAME_AS_AR              0x08    // R3R2R1R0 - in AVI InfoFrame DByte 2
+
+#define BT_601                  0x40
+#define BT_709                  0x80
+
+//#define EN_AUDIO_INFOFRAMES         0xC2
+#define TYPE_AUDIO_INFOFRAMES       0x84
+#define AUDIO_INFOFRAMES_VERSION    0x01
+#define AUDIO_INFOFRAMES_LENGTH     0x0A
+
+#define TYPE_GBD_INFOFRAME       	0x0A
+
+#define ENABLE_AND_REPEAT			0xC0
+
+#define EN_AND_RPT_MPEG				0xC3
+#define DISABLE_MPEG				0x03	// Also Vendor Specific InfoFrames
+
+#define EN_AND_RPT_AUDIO			0xC2
+#define DISABLE_AUDIO				0x02
+
+#define EN_AND_RPT_AVI				0xC0	// Not normally used.  Write to TPI 0x19 instead
+#define DISABLE_AVI					0x00	// But this is used to Disable
+
+#define NEXT_FIELD					0x80
+#define GBD_PROFILE					0x00
+#define AFFECTED_GAMUT_SEQ_NUM		0x01
+
+#define ONLY_PACKET					0x30
+#define CURRENT_GAMUT_SEQ_NUM		0x01
+
+// FPLL Multipliers:
+//====================================================
+
+#define X0d5                      				0x00
+#define X1                      					0x01
+#define X2                      					0x02
+#define X4                      					0x03
+
+// 3D Constants
+//====================================================
+
+#define _3D_STRUC_PRESENT				0x02
+
+// 3D_Stucture Constants
+//====================================================
+#define FRAME_PACKING					0x00
+#define FIELD_ALTERNATIVE				0x01
+#define LINE_ALTERNATIVE				0x02
+#define SIDE_BY_SIDE_FULL				0x03
+#define L_PLUS_DEPTH					0x04
+#define L_PLUS_DEPTH_PLUS_GRAPHICS	0x05
+#define SIDE_BY_SIDE_HALF				0x08
+
+// 3D_Ext_Data Constants
+//====================================================
+#define HORIZ_ODD_LEFT_ODD_RIGHT		0x00
+#define HORIZ_ODD_LEFT_EVEN_RIGHT		0x01
+#define HORIZ_EVEN_LEFT_ODD_RIGHT  		0x02
+#define HORIZ_EVEN_LEFT_EVEN_RIGHT		0x03
+
+#define QUINCUNX_ODD_LEFT_EVEN_RIGHT	0x04
+#define QUINCUNX_ODD_LEFT_ODD_RIGHT		0x05
+#define QUINCUNX_EVEN_LEFT_ODD_RIGHT	0x06
+#define QUINCUNX_EVEN_LEFT_EVEN_RIGHT	0x07
+
+#define NO_3D_SUPPORT					0x0F
+
+// InfoFrame Type Code
+//====================================================
+#define AVI  						0x00 
+#define SPD  						0x01  
+#define AUDIO 						0x02   
+#define MPEG 						0x03 
+#define GEN_1	 					0x04
+#define GEN_2 						0x05  
+#define HDMI_VISF 					0x06 
+#define GBD 						0x07 
+
+// Size of InfoFrame Data types
+#define MAX_SIZE_INFOFRAME_DATA     0x22
+#define SIZE_AVI_INFOFRAME			0x0E	// 14 bytes
+#define SIZE_SPD_INFOFRAME 			0x19	// 25 bytes
+#define SISE_AUDIO_INFOFRAME_IFORM  0x0A    // 10 bytes
+#define SIZE_AUDIO_INFOFRAME		0x0F	// 15 bytes
+#define SIZE_MPRG_HDMI_INFOFRAME    0x1B	// 27 bytes		
+#define SIZE_MPEG_INFOFRAME 		0x0A	// 10 bytes
+#define SIZE_GEN_1_INFOFRAME    	0x1F	// 31 bytes
+#define SIZE_GEN_2_INFOFRAME    	0x1F	// 31 bytes
+#define SIZE_HDMI_VISF_INFOFRAME    0x1E	// 31 bytes
+#define SIZE_GBD_INFOFRAME     		0x1C  	// 28 bytes
+
+#define AVI_INFOFRM_OFFSET          0x0C
+#define OTHER_INFOFRM_OFFSET        0xC4
+#define TPI_INFOFRAME_ACCESS_REG    0xBF
+
+// Serial Communication Buffer constants
+#define MAX_COMMAND_ARGUMENTS       50
+#define GLOBAL_BYTE_BUF_BLOCK_SIZE  131
+
+
+// Video Mode Constants
+//====================================================
+#define VMD_ASPECT_RATIO_4x3			0x01
+#define VMD_ASPECT_RATIO_16x9			0x02
+
+#define VMD_COLOR_SPACE_RGB			0x00
+#define VMD_COLOR_SPACE_YCBCR422		0x01
+#define VMD_COLOR_SPACE_YCBCR444		0x02
+
+#define VMD_COLOR_DEPTH_8BIT			0x00
+#define VMD_COLOR_DEPTH_10BIT			0x01
+#define VMD_COLOR_DEPTH_12BIT			0x02
+#define VMD_COLOR_DEPTH_16BIT			0x03
+
+#define VMD_HDCP_NOT_AUTHENTICATED	0x00
+#define VMD_HDCP_AUTHENTICATED		0x01
+
+#define VMD_HDMIFORMAT_CEA_VIC          	0x00
+#define VMD_HDMIFORMAT_HDMI_VIC         	0x01
+#define VMD_HDMIFORMAT_3D               	0x02
+#define VMD_HDMIFORMAT_PC               	0x03
+
+// These values are from HDMI Spec 1.4 Table H-2
+#define VMD_3D_FRAMEPACKING			0
+#define VMD_3D_FIELDALTERNATIVE		1
+#define VMD_3D_LINEALTERNATIVE		2              
+#define VMD_3D_SIDEBYSIDEFULL			3
+#define VMD_3D_LDEPTH					4
+#define VMD_3D_LDEPTHGRAPHICS			5
+#define VMD_3D_SIDEBYSIDEHALF			8
+
+
+//--------------------------------------------------------------------
+// System Macro Definitions
+//--------------------------------------------------------------------
+#define TX_HW_RESET_PERIOD      200
+#define SII902XA_DEVICE_ID         0xB0
+
+#define T_HPD_DELAY    			10
+
+//--------------------------------------------------------------------
+// HDCP Macro Definitions
+//--------------------------------------------------------------------
+#define AKSV_SIZE              		5
+#define NUM_OF_ONES_IN_KSV	20
+
+//--------------------------------------------------------------------
+// EDID Constants Definition
+//--------------------------------------------------------------------
+#define EDID_BLOCK_0_OFFSET 0x00
+#define EDID_BLOCK_1_OFFSET 0x80
+
+#define EDID_BLOCK_SIZE      128
+#define EDID_HDR_NO_OF_FF   0x06
+#define NUM_OF_EXTEN_ADDR   0x7E
+
+#define EDID_TAG_ADDR       0x00
+#define EDID_REV_ADDR       0x01
+#define EDID_TAG_IDX        0x02
+#define LONG_DESCR_PTR_IDX  0x02
+#define MISC_SUPPORT_IDX    0x03
+
+#define ESTABLISHED_TIMING_INDEX        35      // Offset of Established Timing in EDID block
+#define NUM_OF_STANDARD_TIMINGS          8
+#define STANDARD_TIMING_OFFSET          38
+#define LONG_DESCR_LEN                  18
+#define NUM_OF_DETAILED_DESCRIPTORS      4
+
+#define DETAILED_TIMING_OFFSET        0x36
+
+// Offsets within a Long Descriptors Block
+//====================================================
+#define PIX_CLK_OFFSET                	 	0
+#define H_ACTIVE_OFFSET               	2
+#define H_BLANKING_OFFSET          	3
+#define V_ACTIVE_OFFSET                  	5
+#define V_BLANKING_OFFSET                6
+#define H_SYNC_OFFSET                    	8
+#define H_SYNC_PW_OFFSET                 9
+#define V_SYNC_OFFSET                   	10
+#define V_SYNC_PW_OFFSET                	10
+#define H_IMAGE_SIZE_OFFSET            	12
+#define V_IMAGE_SIZE_OFFSET           	13
+#define H_BORDER_OFFSET                 	15
+#define V_BORDER_OFFSET                 	16
+#define FLAGS_OFFSET                    	17
+
+#define AR16_10                          		0
+#define AR4_3                            		1
+#define AR5_4                            		2
+#define AR16_9                           		3
+
+// Data Block Tag Codes
+//====================================================
+#define AUDIO_D_BLOCK       0x01
+#define VIDEO_D_BLOCK       0x02
+#define VENDOR_SPEC_D_BLOCK 0x03
+#define SPKR_ALLOC_D_BLOCK  0x04
+#define USE_EXTENDED_TAG    0x07
+
+// Extended Data Block Tag Codes
+//====================================================
+#define COLORIMETRY_D_BLOCK 0x05
+
+#define HDMI_SIGNATURE_LEN  0x03
+
+#define CEC_PHYS_ADDR_LEN   0x02
+#define EDID_EXTENSION_TAG  0x02
+#define EDID_REV_THREE      0x03
+#define EDID_DATA_START     0x04
+
+#define EDID_BLOCK_0        0x00
+#define EDID_BLOCK_2_3      0x01
+
+#define VIDEO_CAPABILITY_D_BLOCK 0x00
+
+
+
+
+
+//--------------------------------------------------------------------
+// TPI Register Definition
+//--------------------------------------------------------------------
+
+// TPI Video Mode Data
+#define TPI_PIX_CLK_LSB							(0x00)
+#define TPI_PIX_CLK_MSB							(0x01)
+#define TPI_VERT_FREQ_LSB						(0x02)
+#define TPI_VERT_FREQ_MSB						(0x03)
+#define TPI_TOTAL_PIX_LSB						(0x04)
+#define TPI_TOTAL_PIX_MSB						(0x05)
+#define TPI_TOTAL_LINES_LSB					(0x06)
+#define TPI_TOTAL_LINES_MSB					(0x07)
+
+// Pixel Repetition Data
+#define TPI_PIX_REPETITION						(0x08)
+
+// TPI AVI Input and Output Format Data
+/// AVI Input Format Data
+#define TPI_INPUT_FORMAT_REG					(0x09)
+#define INPUT_COLOR_SPACE_MASK				(BIT_1 | BIT_0)
+#define INPUT_COLOR_SPACE_RGB					(0x00)
+#define INPUT_COLOR_SPACE_YCBCR444			(0x01)
+#define INPUT_COLOR_SPACE_YCBCR422			(0x02)
+#define INPUT_COLOR_SPACE_BLACK_MODE			(0x03)
+
+/// AVI Output Format Data
+#define TPI_OUTPUT_FORMAT_REG					(0x0A)
+#define TPI_YC_Input_Mode						(0x0B)
+
+// TPI InfoFrame related constants
+#define TPI_AVI_INFO_REG_ADDR					(0x0C) // AVI InfoFrame Checksum
+#define TPI_OTHER_INFO_REG_ADDR		  		(0xBF)
+#define TPI_INFO_FRAME_REG_OFFSET				(0xC4)
+
+// TPI AVI InfoFrame Data
+#define TPI_AVI_BYTE_0							(0x0C)
+#define TPI_AVI_BYTE_1							(0x0D)
+#define TPI_AVI_BYTE_2							(0x0E)
+#define TPI_AVI_BYTE_3							(0x0F)
+#define TPI_AVI_BYTE_4							(0x10)
+#define TPI_AVI_BYTE_5							(0x11)
+
+#define TPI_INFO_FRM_DBYTE5					(0xC8)
+#define TPI_INFO_FRM_DBYTE6					(0xC9)
+
+#define TPI_END_TOP_BAR_LSB					(0x12)
+#define TPI_END_TOP_BAR_MSB					(0x13)
+
+#define TPI_START_BTM_BAR_LSB					(0x14)
+#define TPI_START_BTM_BAR_MSB					(0x15)
+
+#define TPI_END_LEFT_BAR_LSB					(0x16)
+#define TPI_END_LEFT_BAR_MSB					(0x17)
+
+#define TPI_END_RIGHT_BAR_LSB					(0x18)
+#define TPI_END_RIGHT_BAR_MSB					(0x19)
+
+// Colorimetry
+#define SET_EX_COLORIMETRY						(0x0C)	// Set TPI_AVI_BYTE_2 to extended colorimetry and use 
+													//TPI_AVI_BYTE_3
+
+#define TPI_SYSTEM_CONTROL_DATA_REG			(0x1A)
+
+#define LINK_INTEGRITY_MODE_MASK				(BIT_6)
+#define LINK_INTEGRITY_STATIC					(0x00)
+#define LINK_INTEGRITY_DYNAMIC					(0x40)
+
+#define TMDS_OUTPUT_CONTROL_MASK				(BIT_4)
+#define TMDS_OUTPUT_CONTROL_ACTIVE			(0x00)
+#define TMDS_OUTPUT_CONTROL_POWER_DOWN	(0x10)
+
+#define AV_MUTE_MASK							(BIT_3)
+#define AV_MUTE_NORMAL						(0x00)
+#define AV_MUTE_MUTED							(0x08)
+
+#define DDC_BUS_REQUEST_MASK					(BIT_2)
+#define DDC_BUS_REQUEST_NOT_USING			(0x00)
+#define DDC_BUS_REQUEST_REQUESTED			(0x04)
+
+#define DDC_BUS_GRANT_MASK					(BIT_1)
+#define DDC_BUS_GRANT_NOT_AVAILABLE			(0x00)
+#define DDC_BUS_GRANT_GRANTED				(0x02)
+
+#define OUTPUT_MODE_MASK						(BIT_0)
+#define OUTPUT_MODE_DVI						(0x00)
+#define OUTPUT_MODE_HDMI						(0x01)
+
+// TPI Identification Registers
+#define TPI_DEVICE_ID							(0x1B)
+#define TPI_DEVICE_REV_ID						(0x1C)
+
+#define TPI_RESERVED2							(0x1D)
+
+#define TPI_DEVICE_POWER_STATE_CTRL_REG		(0x1E)
+
+#define CTRL_PIN_CONTROL_MASK					(BIT_4)
+#define CTRL_PIN_TRISTATE						(0x00)
+#define CTRL_PIN_DRIVEN_TX_BRIDGE				(0x10)
+
+#define TX_POWER_STATE_MASK					(BIT_1 | BIT_0)
+#define TX_POWER_STATE_D0						(0x00)
+#define TX_POWER_STATE_D1						(0x01)
+#define TX_POWER_STATE_D2						(0x02)
+#define TX_POWER_STATE_D3						(0x03)
+
+// Configuration of I2S Interface
+#define TPI_I2S_EN								(0x1F)
+#define TPI_I2S_IN_CFG							(0x20)
+#define SCK_SAMPLE_EDGE						(BIT_7)
+
+// Available only when TPI 0x26[7:6]=10 to select I2S input
+#define TPI_I2S_CHST_0							(0x21)
+#define TPI_I2S_CHST_1							(0x22)
+#define TPI_I2S_CHST_2							(0x23)
+#define TPI_I2S_CHST_3							(0x24)
+#define TPI_I2S_CHST_4							(0x25)
+
+#define AUDIO_INPUT_LENGTH					(0x24)
+
+// Available only when 0x26[7:6]=01
+#define TPI_SPDIF_HEADER						(0x24)
+#define TPI_AUDIO_HANDLING						(0x25)
+
+// Audio Configuration Regiaters
+#define TPI_AUDIO_INTERFACE_REG				(0x26)
+#define AUDIO_MUTE_MASK						(BIT_4)
+#define AUDIO_MUTE_NORMAL						(0x00)
+#define AUDIO_MUTE_MUTED						(0x10)
+
+#define AUDIO_SEL_MASK							(BITS_7_6)
+
+
+#define TPI_AUDIO_SAMPLE_CTRL					(0x27)
+#define TPI_SPEAKER_CFG						(0xC7)
+#define TPI_CODING_TYPE_CHANNEL_COUNT		(0xC4)
+
+//--------------------------------------------------------------------
+// HDCP Implementation
+// HDCP link security logic is implemented in certain transmitters; unique
+//   keys are embedded in each chip as part of the solution. The security 
+//   scheme is fully automatic and handled completely by the hardware.
+//--------------------------------------------------------------------
+
+/// HDCP Query Data Register
+#define TPI_HDCP_QUERY_DATA_REG				(0x29)
+
+#define EXTENDED_LINK_PROTECTION_MASK		(BIT_7)
+#define EXTENDED_LINK_PROTECTION_NONE		(0x00)
+#define EXTENDED_LINK_PROTECTION_SECURE		(0x80)
+
+#define LOCAL_LINK_PROTECTION_MASK			(BIT_6)
+#define LOCAL_LINK_PROTECTION_NONE			(0x00)
+#define LOCAL_LINK_PROTECTION_SECURE			(0x40)
+
+#define LINK_STATUS_MASK						(BIT_5 | BIT_4)
+#define LINK_STATUS_NORMAL					(0x00)
+#define LINK_STATUS_LINK_LOST					(0x10)
+#define LINK_STATUS_RENEGOTIATION_REQ		(0x20)
+#define LINK_STATUS_LINK_SUSPENDED			(0x30)
+
+#define HDCP_REPEATER_MASK					(BIT_3)
+#define HDCP_REPEATER_NO						(0x00)
+#define HDCP_REPEATER_YES						(0x08)
+
+#define CONNECTOR_TYPE_MASK					(BIT_2 | BIT_0)
+#define CONNECTOR_TYPE_DVI						(0x00)
+#define CONNECTOR_TYPE_RSVD					(0x01)
+#define CONNECTOR_TYPE_HDMI					(0x04)
+#define CONNECTOR_TYPE_FUTURE					(0x05)
+
+#define PROTECTION_TYPE_MASK					(BIT_1)
+#define PROTECTION_TYPE_NONE					(0x00)
+#define PROTECTION_TYPE_HDCP					(0x02)
+
+/// HDCP Control Data Register
+#define TPI_HDCP_CONTROL_DATA_REG			(0x2A)
+#define PROTECTION_LEVEL_MASK					(BIT_0)
+#define PROTECTION_LEVEL_MIN					(0x00)
+#define PROTECTION_LEVEL_MAX					(0x01)
+
+#define KSV_FORWARD_MASK						(BIT_4)
+#define KSV_FORWARD_ENABLE					(0x10)
+#define KSV_FORWARD_DISABLE					(0x00)
+
+/// HDCP BKSV Registers
+#define TPI_BKSV_1_REG							(0x2B)
+#define TPI_BKSV_2_REG							(0x2C)
+#define TPI_BKSV_3_REG							(0x2D)
+#define TPI_BKSV_4_REG							(0x2E)
+#define TPI_BKSV_5_REG							(0x2F)
+
+/// HDCP Revision Data Register
+#define TPI_HDCP_REVISION_DATA_REG			(0x30)
+
+#define HDCP_MAJOR_REVISION_MASK				(BIT_7 | BIT_6 | BIT_5 | BIT_4)
+#define HDCP_MAJOR_REVISION_VALUE				(0x10)
+
+#define HDCP_MINOR_REVISION_MASK				(BIT_3 | BIT_2 | BIT_1 | BIT_0)
+#define HDCP_MINOR_REVISION_VALUE				(0x02)
+
+/// HDCP KSV and V' Value Data Register
+#define TPI_V_PRIME_SELECTOR_REG				(0x31)
+
+/// V' Value Readback Registers
+#define TPI_V_PRIME_7_0_REG					(0x32)
+#define TPI_V_PRIME_15_9_REG					(0x33)
+#define TPI_V_PRIME_23_16_REG					(0x34)
+#define TPI_V_PRIME_31_24_REG					(0x35)
+
+/// HDCP AKSV Registers
+#define TPI_AKSV_1_REG							(0x36)
+#define TPI_AKSV_2_REG							(0x37)
+#define TPI_AKSV_3_REG							(0x38)
+#define TPI_AKSV_4_REG							(0x39)
+#define TPI_AKSV_5_REG							(0x3A)
+
+#define TPI_DEEP_COLOR_GCP						(0x40)
+
+//--------------------------------------------------------------------
+// Interrupt Service
+// TPI can be configured to generate an interrupt to the host to notify it of
+//   various events. The host can either poll for activity or use an interrupt
+//   handler routine. TPI generates on a single interrupt (INT) to the host.
+//--------------------------------------------------------------------
+
+/// Interrupt Enable Register
+#define TPI_INTERRUPT_ENABLE_REG				(0x3C)
+
+#define HDCP_AUTH_STATUS_CHANGE_EN_MASK	(BIT_7)
+#define HDCP_AUTH_STATUS_CHANGE_DISABLE		(0x00)
+#define HDCP_AUTH_STATUS_CHANGE_ENABLE		(0x80)
+
+#define HDCP_VPRIME_VALUE_READY_EN_MASK		(BIT_6)
+#define HDCP_VPRIME_VALUE_READY_DISABLE		(0x00)
+#define HDCP_VPRIME_VALUE_READY_ENABLE		(0x40)
+
+#define HDCP_SECURITY_CHANGE_EN_MASK		(BIT_5)
+#define HDCP_SECURITY_CHANGE_DISABLE		    	(0x00)
+#define HDCP_SECURITY_CHANGE_ENABLE			(0x20)
+
+#define AUDIO_ERROR_EVENT_EN_MASK			(BIT_4)
+#define AUDIO_ERROR_EVENT_DISABLE				(0x00)
+#define AUDIO_ERROR_EVENT_ENABLE				(0x10)
+
+#define CPI_EVENT_NO_RX_SENSE_MASK			(BIT_3)
+#define CPI_EVENT_NO_RX_SENSE_DISABLE		(0x00)
+#define CPI_EVENT_NO_RX_SENSE_ENABLE			(0x08)
+
+#define RECEIVER_SENSE_EVENT_EN_MASK			(BIT_1)
+#define RECEIVER_SENSE_EVENT_DISABLE			(0x00)
+#define RECEIVER_SENSE_EVENT_ENABLE			(0x02)
+
+#define HOT_PLUG_EVENT_EN_MASK				(BIT_0)
+#define HOT_PLUG_EVENT_DISABLE				(0x00)
+#define HOT_PLUG_EVENT_ENABLE					(0x01)
+
+/// Interrupt Status Register
+#define TPI_INTERRUPT_STATUS_REG				(0x3D)
+
+#define HDCP_AUTH_STATUS_CHANGE_EVENT_MASK	(BIT_7)
+#define HDCP_AUTH_STATUS_CHANGE_EVENT_NO	(0x00)
+#define HDCP_AUTH_STATUS_CHANGE_EVENT_YES	(0x80)
+
+#define HDCP_VPRIME_VALUE_READY_EVENT_MASK	(BIT_6)
+#define HDCP_VPRIME_VALUE_READY_EVENT_NO	(0x00)
+#define HDCP_VPRIME_VALUE_READY_EVENT_YES	(0x40)
+
+#define HDCP_SECURITY_CHANGE_EVENT_MASK		(BIT_5)
+#define HDCP_SECURITY_CHANGE_EVENT_NO		(0x00)
+#define HDCP_SECURITY_CHANGE_EVENT_YES		(0x20)
+
+#define AUDIO_ERROR_EVENT_MASK				(BIT_4)
+#define AUDIO_ERROR_EVENT_NO					(0x00)
+#define AUDIO_ERROR_EVENT_YES					(0x10)
+
+#define CPI_EVENT_MASK							(BIT_3)
+#define CPI_EVENT_NO							(0x00)
+#define CPI_EVENT_YES							(0x08)
+#define RX_SENSE_MASK							(BIT_3)		// This bit is dual purpose depending on the value of 0x3C[3]
+#define RX_SENSE_NOT_ATTACHED					(0x00)
+#define RX_SENSE_ATTACHED						(0x08)
+
+#define HOT_PLUG_PIN_STATE_MASK				(BIT_2)
+#define HOT_PLUG_PIN_STATE_LOW				(0x00)
+#define HOT_PLUG_PIN_STATE_HIGH				(0x04)
+
+#define RECEIVER_SENSE_EVENT_MASK				(BIT_1)
+#define RECEIVER_SENSE_EVENT_NO				(0x00)
+#define RECEIVER_SENSE_EVENT_YES				(0x02)
+
+#define HOT_PLUG_EVENT_MASK					(BIT_0)
+#define HOT_PLUG_EVENT_NO						(0x00)
+#define HOT_PLUG_EVENT_YES					(0x01)
+
+/// KSV FIFO First Status Register
+#define TPI_KSV_FIFO_READY_INT					(0x3E)
+
+#define KSV_FIFO_READY_MASK					(BIT_1)
+#define KSV_FIFO_READY_NO						(0x00)
+#define KSV_FIFO_READY_YES						(0x02)
+
+#define TPI_KSV_FIFO_READY_INT_EN				(0x3F)
+
+#define KSV_FIFO_READY_EN_MASK				(BIT_1)
+#define KSV_FIFO_READY_DISABLE				(0x00)
+#define KSV_FIFO_READY_ENABLE					(0x02)
+
+/// KSV FIFO Last Status Register
+#define TPI_KSV_FIFO_STATUS_REG				(0x41)
+#define TPI_KSV_FIFO_VALUE_REG					(0x42)
+
+#define KSV_FIFO_LAST_MASK						(BIT_7)
+#define KSV_FIFO_LAST_NO						(0x00)
+#define KSV_FIFO_LAST_YES						(0x80)
+
+#define KSV_FIFO_COUNT_MASK					(BIT_4 | BIT_3 | BIT_2 | BIT_1 | BIT_0)
+
+// Sync Register Configuration and Sync Monitoring Registers
+#define TPI_SYNC_GEN_CTRL						(0x60)
+#define TPI_SYNC_POLAR_DETECT					(0x61)
+
+// Explicit Sync DE Generator Registers (TPI 0x60[7]=0)
+#define TPI_DE_DLY								(0x62)
+#define TPI_DE_CTRL								(0x63)
+#define TPI_DE_TOP								(0x64)
+
+#define TPI_RESERVED4							(0x65)
+
+#define TPI_DE_CNT_7_0							(0x66)
+#define TPI_DE_CNT_11_8						(0x67)
+
+#define TPI_DE_LIN_7_0							(0x68)
+#define TPI_DE_LIN_10_8							(0x69)
+
+#define TPI_DE_H_RES_7_0						(0x6A)
+#define TPI_DE_H_RES_10_8						(0x6B)
+
+#define TPI_DE_V_RES_7_0						(0x6C)
+#define TPI_DE_V_RES_10_8						(0x6D)
+
+// Embedded Sync Register Set (TPI 0x60[7]=1)
+#define TPI_HBIT_TO_HSYNC_7_0					(0x62)
+#define TPI_HBIT_TO_HSYNC_9_8					(0x63)
+#define TPI_FIELD_2_OFFSET_7_0					(0x64)
+#define TPI_FIELD_2_OFFSET_11_8				(0x65)
+#define TPI_HWIDTH_7_0							(0x66)
+#define TPI_HWIDTH_8_9							(0x67)
+#define TPI_VBIT_TO_VSYNC						(0x68)
+#define TPI_VWIDTH								(0x69)
+
+// H/W Optimization Control Registers
+#define TPI_HW_OPT_CTRL_1						(0xB9)
+#define TPI_HW_OPT_CTRL_2						(0xBA)
+#define TPI_HW_OPT_CTRL_3						(0xBB)
+
+// H/W Optimization Control Register #3 Set 
+#define DDC_DELAY_BIT9_MASK					(BIT_7)
+#define DDC_DELAY_BIT9_NO						(0x00)
+#define DDC_DELAY_BIT9_YES						(0x80)
+#define RI_CHECK_SKIP_MASK						(BIT_3)
+#define RI_CHECK_SKIP_NO						(0x00)
+#define RI_CHECK_SKIP_YES						(0x08)
+
+// TPI Enable Register
+#define TPI_ENABLE								(0xC7)
+
+// Misc InfoFrames
+#define MISC_INFO_FRAMES_CTRL					(0xBF)
+#define MISC_INFO_FRAMES_TYPE					(0xC0)
+#define MISC_INFO_FRAMES_VER					(0xC1)
+#define MISC_INFO_FRAMES_LEN					(0xC2)
+#define MISC_INFO_FRAMES_CHKSUM				(0xC3)
+//--------------------------------------------------------------------
+void DelayMS (word MS);
+
+byte I2CReadBlock(struct i2c_client *client, byte RegAddr, byte NBytes, byte * Data );
+byte I2CWriteBlock(struct i2c_client *client, byte RegAddr, byte NBytes, byte * Data );
+byte siiReadSegmentBlockEDID(struct i2c_client *client, byte Segment, byte Offset, byte *Buffer, byte Length);
+
+void WriteByteTPI (byte RegOffset, byte Data);
+byte ReadByteTPI (byte RegOffset);
+
+
+void siHdmiTx_PowerStateD2 (void);
+void siHdmiTx_PowerStateD0fromD2 (void);
+
+void siHdmiTx_Init (void);
+
+
+
+byte siHdmiTx_VideoSet (void);
+byte siHdmiTx_AudioSet (void);
+byte siHdmiTx_TPI_Init (void);
+void siHdmiTx_TPI_Poll (void);
+void siHdmiTx_VideoSel (byte vmode);
+void siHdmiTx_AudioSel (byte Afs);
+#endif
diff --git a/drivers/gpu/drm/smi/ddk750/vdif.h b/drivers/gpu/drm/smi/ddk750/vdif.h
new file mode 100644
index 000000000000..36d11d6daa54
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk750/vdif.h
@@ -0,0 +1,63 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2009 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  vdif.h --- SMI DDK 
+*  This file contains the video display information format structure
+* 
+*******************************************************************/
+#ifndef _VDIF_H_
+#define _VDIF_H_
+
+/* Sync polarity */
+typedef enum _vdif_sync_polarity_t
+{
+    VDIF_SYNC_NEGATIVE = 0,
+    VDIF_SYNC_POSITIVE
+} vdif_sync_polarity_t; 
+
+/* Scan type */
+typedef enum _vdif_scan_type_t
+{
+    VDIF_NONINTERLACED = 0,
+    VDIF_INTERLACED
+} vdif_scan_type_t;
+
+/* Monitor Timing Information */
+typedef struct _video_display_information_format_t
+{
+    unsigned long pixelClock;
+    unsigned long characterWidth;
+    vdif_scan_type_t scanType; 
+    
+    unsigned long horizontalFrequency;
+    vdif_sync_polarity_t horizontalSyncPolarity;
+    unsigned long horizontalTotal;
+    unsigned long horizontalActive;
+    unsigned long horizontalBlankStart;
+    unsigned long horizontalBlankTime;
+    unsigned long horizontalSyncStart;
+    unsigned long horizontalRightBorder;
+    unsigned long horizontalFrontPorch;
+    unsigned long horizontalSyncWidth;
+    unsigned long horizontalBackPorch;
+    unsigned long horizontalLeftBorder;
+    
+    unsigned long verticalFrequency;
+    vdif_sync_polarity_t verticalSyncPolarity; 
+    unsigned long verticalTotal;
+    unsigned long verticalActive;
+    unsigned long verticalBlankStart;
+    unsigned long verticalBlankTime;
+    unsigned long verticalSyncStart;
+    unsigned long verticalBottomBorder;
+    unsigned long verticalFrontPorch;
+    unsigned long verticalSyncHeight;
+    unsigned long verticalBackPorch;
+    unsigned long verticalTopBorder;
+} vdif_t;
+
+#endif  /* _VDIF_H_ */
diff --git a/drivers/gpu/drm/smi/ddk768/ddk768.h b/drivers/gpu/drm/smi/ddk768/ddk768.h
new file mode 100644
index 000000000000..8285c868494b
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk768/ddk768.h
@@ -0,0 +1,23 @@
+#ifndef DDK768_H__
+#define DDK768_H__
+/*******************************************************************
+*
+*         Copyright (c) 2007 by Silicon Motion, Inc. (SMI)
+*
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+*
+*  RegSC.h --- SM718 SDK
+*  This file contains the definitions for the System Configuration registers.
+*
+*******************************************************************/
+#include "ddk768_reg.h"
+#include "ddk768_help.h"
+
+
+#include "ddk768_mode.h"
+#include "ddk768_chip.h"
+#include "ddk768_power.h"
+#include "ddk768_display.h"
+#include "ddk768_2d.h"
+#endif
diff --git a/drivers/gpu/drm/smi/ddk768/ddk768_2d.c b/drivers/gpu/drm/smi/ddk768/ddk768_2d.c
new file mode 100644
index 000000000000..8cd66717ef25
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk768/ddk768_2d.c
@@ -0,0 +1,1213 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2007 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  2d.C --- SM750/SM718 DDK 
+*  This file contains the definitions for the 2D functions.
+* 
+*******************************************************************/
+#include "linux/string.h"
+#include "ddk768_reg.h"
+
+#include "ddk768_chip.h"
+#include "ddk768_power.h"
+#include "ddk768_2d.h"
+#include "ddk768_help.h"
+
+/* Blt Direction definitions */
+#define TOP_TO_BOTTOM 0
+#define LEFT_TO_RIGHT 0
+#define BOTTOM_TO_TOP 1
+#define RIGHT_TO_LEFT 1
+
+#if 0 /* Cheok: Block it out to test if it is problem in new chip */
+
+/* Flag to enable the 192 bytes patch to workaround the 2D errata, where the engine
+   will draws incorrectly for BITBLT function that involves READ from memory. 
+   Currently, this definition flag is only used for testing. */
+#define ENABLE_192_BYTES_PATCH
+#endif
+
+/* Static macro */
+#define BYTE_PER_PIXEL(bpp)         (bpp / 8)
+
+/*
+ * 2D Engine Initialization.
+ * This function must be called before other 2D functions.
+ * Assumption: A specific video mode has been properly set up.
+ */
+void ddk768_deInit()
+{
+    ddk768_enable2DEngine(1);
+
+    ddk768_deReset(); /* Just be sure no left-over operations from other applications */
+
+    /* Set up 2D registers that won't change for a specific mode. */
+
+    /* Drawing engine bus and pixel mask, always want to enable. */
+    POKE_32(DE_MASKS, 0xFFFFFFFF);
+
+    /* Pixel format, which can be 8, 16 or 32.
+       Assuming setmode is call before 2D init, then pixel format
+       is available in reg 0x80000 (Panel Display Control)
+    */
+    POKE_32(DE_STRETCH_FORMAT,
+        FIELD_SET  (0, DE_STRETCH_FORMAT, PATTERN_XY,   NORMAL)  |
+        FIELD_VALUE(0, DE_STRETCH_FORMAT, PATTERN_Y,    0)       |
+        FIELD_VALUE(0, DE_STRETCH_FORMAT, PATTERN_X,    0)       |
+        FIELD_SET  (0, DE_STRETCH_FORMAT, ADDRESSING,   XY)      |
+        FIELD_VALUE(0, DE_STRETCH_FORMAT, SOURCE_HEIGHT,3));
+
+    /* Clipping and transparent are disable after INIT */
+    ddk768_deSetClipping(0, 0, 0, 0, 0);
+    ddk768_deSetTransparency(0, 0, 0, 0);
+}
+
+/*
+ * Reset 2D engine by 
+ * 1) Aborting the current 2D operation.
+ * 2) Re-enable 2D engine to normal state.
+ */
+void ddk768_deReset()
+{
+    unsigned long sysCtrl;
+	logical_chip_type_t chipType = ddk768_getChipType();
+
+#if 0 /* Cheok(2/11/2014): Not sure which registers are used for Falcon */
+
+	if (chipType == SM750 || chipType == SM718)
+	{
+    	/* Abort current 2D operation */
+    	sysCtrl = PEEK_32(SYSTEM_CTRL);
+    	sysCtrl = FIELD_SET(sysCtrl, SYSTEM_CTRL, DE_ABORT, ON);
+    	POKE_32(SYSTEM_CTRL, sysCtrl);
+
+    	/* Re-enable 2D engine to normal state */
+    	sysCtrl = PEEK_32(SYSTEM_CTRL);
+    	sysCtrl = FIELD_SET(sysCtrl, SYSTEM_CTRL, DE_ABORT, OFF);
+    	POKE_32(SYSTEM_CTRL, sysCtrl);
+	}
+	else /* For SM750LE and SM750HS series */
+	{
+	    /* Abort current 2D operation */
+		sysCtrl = PEEK_32(DE_STATE1);
+		sysCtrl = FIELD_SET(sysCtrl, DE_STATE1, DE_ABORT, ON);
+		POKE_32(DE_STATE1, sysCtrl);
+
+		/* Re-enable 2D engine to normal state */
+        sysCtrl = PEEK_32(DE_STATE1);
+		sysCtrl = FIELD_SET(sysCtrl, DE_STATE1, DE_ABORT, OFF);
+		POKE_32(DE_STATE1, sysCtrl);
+	}
+#endif
+}
+ 
+/*
+ * Wait until 2D engine is not busy.
+ * All 2D operations are recommand to check 2D engine idle before start.
+ *
+ * Return: 0 = return because engine is idle and normal.
+ *        -1 = return because time out (2D engine may have problem).
+ */
+long ddk768_deWaitForNotBusy(void)
+{
+	unsigned long dwVal;
+    unsigned long i = 0x100000;
+
+    while (i--)
+    {
+        dwVal = PEEK_32(DE_STATE2);
+        if ((FIELD_GET(dwVal, DE_STATE2, DE_STATUS)      == DE_STATE2_DE_STATUS_IDLE) &&
+            (FIELD_GET(dwVal, DE_STATE2, DE_FIFO)        == DE_STATE2_DE_FIFO_EMPTY) &&
+            (FIELD_GET(dwVal, DE_STATE2, DE_MEM_FIFO)    == DE_STATE2_DE_MEM_FIFO_EMPTY))
+        {
+            return 0; /* Return because engine idle */
+        }
+    }
+    return -1; /* Return because of timeout */
+}
+
+/*
+ * This function enable/disable clipping area for the 2d engine.
+ * Note that the clipping area is always rectangular.
+ * 
+ */
+long ddk768_deSetClipping(
+unsigned long enable, /* 0 = disable clipping, 1 = enable clipping */
+unsigned long x1,     /* x1, y1 is the upper left corner of the clipping area */
+unsigned long y1,     /* Note that the region includes x1 and y1 */
+unsigned long x2,     /* x2, y2 is the lower right corner of the clippiing area */
+unsigned long y2)     /* Note that the region will not include x2 and y2 */
+{
+    if (ddk768_deWaitForNotBusy() != 0)
+    {
+        /* The 2D engine is always busy for some unknown reason.
+           Application can choose to return ERROR, or reset it and
+           continue the operation.
+        */
+
+        return -1;
+
+        /* or */
+        /* ddk768_deReset(); */
+    }
+
+    /* Upper left corner and enable/disable bit
+       Note: This module defautls to clip outside region.
+       "Clip inside" is not a useful feature since nothing gets drawn.
+     */
+    POKE_32(DE_CLIP_TL,
+        FIELD_VALUE(0, DE_CLIP_TL, TOP, y1) |
+        ((enable)?
+          FIELD_SET(0, DE_CLIP_TL, STATUS, ENABLE)
+        : FIELD_SET(0, DE_CLIP_TL, STATUS, DISABLE))|
+        FIELD_SET  (0, DE_CLIP_TL, INHIBIT,OUTSIDE) |
+        FIELD_VALUE(0, DE_CLIP_TL, LEFT, x1));
+
+    /* Lower right corner */
+    POKE_32(DE_CLIP_BR,
+        FIELD_VALUE(0, DE_CLIP_BR, BOTTOM,y2) |
+        FIELD_VALUE(0, DE_CLIP_BR, RIGHT, x2));
+
+    return 0;
+}
+
+/* 
+ * Function description:
+ * When transparency is enable, the blt engine compares each pixel value 
+ * (either source or destination) with DE_COLOR_COMPARE register.
+ * If match, the destination pixel will NOT be updated.
+ * If not match, the destination pixel will be updated.
+ */
+long ddk768_deSetTransparency(
+unsigned long enable,     /* 0 = disable, 1 = enable transparency feature */
+unsigned long tSelect,    /* 0 = compare source, 1 = compare destination */
+unsigned long tMatch,     /* 0 = Opaque mode, 1 = transparent mode */
+unsigned long ulColor)    /* Color to compare. */
+{
+    unsigned long de_ctrl;
+
+    if (ddk768_deWaitForNotBusy() != 0)
+    {
+        /* The 2D engine is always busy for some unknown reason.
+           Application can choose to return ERROR, or reset it and
+           continue the operation.
+        */
+
+        return -1;
+
+        /* or */
+        /* ddk768_deReset(); */
+    }
+
+    /* Set mask */
+    if (enable)
+    {
+        POKE_32(DE_COLOR_COMPARE_MASK, 0x00ffffff);
+
+        /* Set compare color */
+        POKE_32(DE_COLOR_COMPARE, ulColor);
+    }
+    else
+    {
+        POKE_32(DE_COLOR_COMPARE_MASK, 0x0);
+        POKE_32(DE_COLOR_COMPARE, 0x0);
+    }
+
+    /* Set up transparency control, without affecting other bits
+       Note: There are two operatiing modes: Transparent and Opague.
+       We only use transparent mode because Opaque mode may have bug.
+    */
+    de_ctrl = PEEK_32(DE_CONTROL)
+              & FIELD_CLEAR(DE_CONTROL, TRANSPARENCY)
+              & FIELD_CLEAR(DE_CONTROL, TRANSPARENCY_MATCH)
+              & FIELD_CLEAR(DE_CONTROL, TRANSPARENCY_SELECT);
+
+    /* For DE_CONTROL_TRANSPARENCY_MATCH bit, always set it
+       to TRANSPARENT mode, OPAQUE mode don't seem working.
+    */
+    de_ctrl |=
+    ((enable)?
+      FIELD_SET(0, DE_CONTROL, TRANSPARENCY, ENABLE)
+    : FIELD_SET(0, DE_CONTROL, TRANSPARENCY, DISABLE))        |
+    ((tMatch)?
+      FIELD_SET(0, DE_CONTROL, TRANSPARENCY_MATCH, TRANSPARENT)
+    : FIELD_SET(0, DE_CONTROL, TRANSPARENCY_MATCH, OPAQUE)) |
+    ((tSelect)?
+      FIELD_SET(0, DE_CONTROL, TRANSPARENCY_SELECT, DESTINATION)
+    : FIELD_SET(0, DE_CONTROL, TRANSPARENCY_SELECT, SOURCE));
+
+    POKE_32(DE_CONTROL, de_ctrl);
+
+    return 0;
+}
+
+/*
+ * This function gets the transparency status from DE_CONTROL register.
+ * It returns a double word with the transparent fields properly set,
+ * while other fields are 0.
+ */
+unsigned long ddk768_deGetTransparency(void)
+{
+    unsigned long de_ctrl;
+
+    de_ctrl = PEEK_32(DE_CONTROL);
+
+    de_ctrl &= 
+        FIELD_MASK(DE_CONTROL_TRANSPARENCY_MATCH) | 
+        FIELD_MASK(DE_CONTROL_TRANSPARENCY_SELECT)| 
+        FIELD_MASK(DE_CONTROL_TRANSPARENCY);
+
+    return de_ctrl;
+}
+
+/*
+ * This function sets the pixel format that will apply to the 2D Engine.
+ */
+void ddk768_deSetPixelFormat(
+    unsigned long bpp
+)
+{
+    unsigned long de_format;
+    
+    de_format = PEEK_32(DE_STRETCH_FORMAT);
+    
+    switch (bpp)
+    {
+        case 8:
+            de_format = FIELD_SET(de_format, DE_STRETCH_FORMAT, PIXEL_FORMAT, 8);
+            break;
+        default:
+        case 16:
+            de_format = FIELD_SET(de_format, DE_STRETCH_FORMAT, PIXEL_FORMAT, 16);
+            break;
+        case 32:
+            de_format = FIELD_SET(de_format, DE_STRETCH_FORMAT, PIXEL_FORMAT, 32);
+            break;
+    }
+    
+    POKE_32(DE_STRETCH_FORMAT, de_format);
+}
+
+/*
+ * This function uses 2D engine to fill a rectangular area with a specific color.
+ * The filled area includes the starting points.
+ */
+long ddk768_deRectFill( /*resolution_t resolution, point_t p0, point_t p1, unsigned long color, unsigned long rop2)*/
+unsigned long dBase,  /* Base address of destination surface counted from beginning of video frame buffer */
+unsigned long dPitch, /* Pitch value of destination surface in BYTES */
+unsigned long bpp,    /* Color depth of destination surface: 8, 16 or 32 */
+unsigned long x,
+unsigned long y,      /* Upper left corner (X, Y) of rectangle in pixel value */
+unsigned long width, 
+unsigned long height, /* width and height of rectange in pixel value */
+unsigned long color,  /* Color to be filled */
+unsigned long rop2)   /* ROP value */
+{
+    unsigned long de_ctrl, bytePerPixel;
+
+    bytePerPixel = bpp/8;
+    
+    if (ddk768_deWaitForNotBusy() != 0)
+    {
+        /* The 2D engine is always busy for some unknown reason.
+           Application can choose to return ERROR, or reset it and
+           continue the operation.
+        */
+
+        return -1;
+
+        /* or */
+        /* ddk768_deReset(); */
+    }
+
+    /* 2D Destination Base.
+       It is an address offset (128 bit aligned) from the beginning of frame buffer.
+    */
+    POKE_32(DE_WINDOW_DESTINATION_BASE, dBase);
+
+    /* Program pitch (distance between the 1st points of two adjacent lines).
+       Note that input pitch is BYTE value, but the 2D Pitch register uses
+       pixel values. Need Byte to pixel convertion.
+    */
+    POKE_32(DE_PITCH,
+        FIELD_VALUE(0, DE_PITCH, DESTINATION, (dPitch/bytePerPixel)) |
+        FIELD_VALUE(0, DE_PITCH, SOURCE,      (dPitch/bytePerPixel)));
+
+    /* Screen Window width in Pixels.
+       2D engine uses this value to calculate the linear address in frame buffer for a given point.
+    */
+    POKE_32(DE_WINDOW_WIDTH,
+        FIELD_VALUE(0, DE_WINDOW_WIDTH, DESTINATION, (dPitch/bytePerPixel)) |
+        FIELD_VALUE(0, DE_WINDOW_WIDTH, SOURCE,      (dPitch/bytePerPixel)));
+
+    POKE_32(DE_FOREGROUND, color);
+
+    /* Set the pixel format of the destination */
+    ddk768_deSetPixelFormat(bpp);
+
+#ifdef ENABLE_192_BYTES_PATCH
+    /* Workaround for 192 byte requirement when ROP is not COPY */
+    if (((rop2 != ROP2_COPY) || (rop2 != ROP2_Sn) || (rop2 != ROP2_Dn) || 
+         (rop2 != ROP2_D) || (rop2 != ROP2_BLACK) || (rop2 != ROP2_WHITE)) && 
+        ((width * bytePerPixel) > 192))
+    {
+        /* Perform the ROP2 operation in chunks of (xWidth * nHeight) */
+        unsigned long xChunk = 192 / bytePerPixel; /* chunk width is in pixels */
+        
+        //DDKDEBUGPRINT((DE_LEVEL, "ROP != ROP_COPY, width * bytePerPixel = %x (> 192 bytes)\n", width * bytePerPixel));
+
+        while (1)
+        {
+            ddk768_deWaitForNotBusy();
+            
+            POKE_32(DE_DESTINATION,
+                FIELD_SET  (0, DE_DESTINATION, WRAP, DISABLE) |
+                FIELD_VALUE(0, DE_DESTINATION, X,    x)  |
+                FIELD_VALUE(0, DE_DESTINATION, Y,    y));
+                
+            POKE_32(DE_DIMENSION,
+                FIELD_VALUE(0, DE_DIMENSION, X,    xChunk) |
+                FIELD_VALUE(0, DE_DIMENSION, Y_ET, height));
+
+            de_ctrl = 
+                FIELD_SET  (0, DE_CONTROL,  STATUS,     START)          |
+                FIELD_SET  (0, DE_CONTROL,  DIRECTION,  LEFT_TO_RIGHT)  |
+                //FIELD_SET  (0, DE_CONTROL,LAST_PIXEL, OFF)            |
+                FIELD_SET  (0, DE_CONTROL,  COMMAND,    RECTANGLE_FILL) |
+                FIELD_SET  (0, DE_CONTROL,  ROP_SELECT, ROP2)           |
+                FIELD_VALUE(0, DE_CONTROL,  ROP,        rop2);
+
+            POKE_32(DE_CONTROL, de_ctrl | ddk768_deGetTransparency());
+
+            if (xChunk == width) break;
+
+            x += xChunk;
+            width -= xChunk;
+
+            if (xChunk > width)
+            {
+                /* This is the last chunk. */
+                xChunk = width;
+            }
+        }
+    }
+    else
+#endif
+    {
+        POKE_32(DE_DESTINATION,
+            FIELD_SET  (0, DE_DESTINATION, WRAP, DISABLE) |
+            FIELD_VALUE(0, DE_DESTINATION, X,    x)       |
+            FIELD_VALUE(0, DE_DESTINATION, Y,    y));
+
+        POKE_32(DE_DIMENSION,
+            FIELD_VALUE(0, DE_DIMENSION, X,    width) |
+            FIELD_VALUE(0, DE_DIMENSION, Y_ET, height));
+
+        de_ctrl = 
+            FIELD_SET  (0, DE_CONTROL,  STATUS,     START)          |
+            FIELD_SET  (0, DE_CONTROL,  DIRECTION,  LEFT_TO_RIGHT)  |
+            //FIELD_SET  (0, DE_CONTROL,LAST_PIXEL, OFF)            |
+            FIELD_SET  (0, DE_CONTROL,  COMMAND,    RECTANGLE_FILL) |
+            FIELD_SET  (0, DE_CONTROL,  ROP_SELECT, ROP2)           |
+            FIELD_VALUE(0, DE_CONTROL,  ROP,        rop2);
+
+        POKE_32(DE_CONTROL, de_ctrl | ddk768_deGetTransparency());
+    }
+    
+    return 0;
+}
+
+/*
+ * This function uses 2D engine to draw a trapezoid with a specific color.
+ * The filled area includes the starting points.
+ */
+long ddk768_deStartTrapezoidFill(
+    unsigned long dBase,  /* Base address of destination surface counted from beginning of video frame buffer */
+    unsigned long dPitch, /* Pitch value of destination surface in BYTES */
+    unsigned long bpp,    /* Color depth of destination surface: 8, 16 or 32 */
+    unsigned long x,
+    unsigned long y,      /* Starting (X, Y) coordinate inside the polygon to be filled */
+    unsigned long length, /* Length of the line */
+    unsigned long color,  /* Color to be filled */
+    unsigned long rop2    /* ROP value */
+)
+{
+    unsigned long dx, dy;
+    unsigned long de_ctrl =
+        FIELD_SET  (0, DE_CONTROL, STATUS,      START)           |
+        FIELD_SET  (0, DE_CONTROL, QUICK_START, ENABLE)          |
+        FIELD_SET  (0, DE_CONTROL, LAST_PIXEL,  OFF)             |
+        FIELD_SET  (0, DE_CONTROL, DIRECTION,   LEFT_TO_RIGHT)   |
+        FIELD_SET  (0, DE_CONTROL, COMMAND,     TRAPEZOID_FILL)  |
+        FIELD_SET  (0, DE_CONTROL, ROP_SELECT,  ROP2)            |
+        FIELD_VALUE(0, DE_CONTROL, ROP,         rop2);
+
+    if (ddk768_deWaitForNotBusy() != 0)
+    {
+        /* The 2D engine is always busy for some unknown reason.
+           Application can choose to return ERROR, or reset it and
+           continue the operation.
+        */
+
+        return -1;
+
+        /* or */
+        /* ddk768_deReset(); */
+    }
+    
+    /* 2D Destination Base.
+       It is an address offset (128 bit aligned) from the beginning of frame buffer.
+    */
+    POKE_32(DE_WINDOW_DESTINATION_BASE, dBase);
+
+    /* Program pitch (distance between the 1st points of two adjacent lines).
+       Note that input pitch is BYTE value, but the 2D Pitch register uses
+       pixel values. Need Byte to pixel convertion.
+    */
+    POKE_32(DE_PITCH,
+        FIELD_VALUE(0, DE_PITCH, DESTINATION, dPitch / BYTE_PER_PIXEL(bpp)) |
+        FIELD_VALUE(0, DE_PITCH, SOURCE, dPitch / BYTE_PER_PIXEL(bpp)));
+
+    /* Screen Window width in Pixels.
+       2D engine uses this value to calculate the linear address in frame buffer for a given point.
+    */
+    POKE_32(DE_WINDOW_WIDTH,
+        FIELD_VALUE(0, DE_WINDOW_WIDTH, DESTINATION, dPitch / BYTE_PER_PIXEL(bpp)) |
+        FIELD_VALUE(0, DE_WINDOW_WIDTH, SOURCE,      dPitch / BYTE_PER_PIXEL(bpp)));
+
+    /* Set the Line Color */
+    POKE_32(DE_FOREGROUND, color);
+    
+    /* Set the destination coordinate */
+    POKE_32(DE_DESTINATION,
+        FIELD_SET  (0, DE_DESTINATION, WRAP, DISABLE) |
+        FIELD_VALUE(0, DE_DESTINATION, X,    x)       |
+        FIELD_VALUE(0, DE_DESTINATION, Y,    y));
+    
+    /* Set the pixel format of the destination */
+    ddk768_deSetPixelFormat(bpp);
+    
+    /* Set the line length and width */
+    POKE_32(DE_DIMENSION,
+        FIELD_VALUE(0, DE_DIMENSION, X,    length) |
+        FIELD_VALUE(0, DE_DIMENSION, Y_ET, 0));
+
+    /* Enable the 2D Engine. */
+    POKE_32(DE_CONTROL, de_ctrl | ddk768_deGetTransparency());
+    
+    return 0;
+}
+
+/* 
+ * Function to continue drawing a line using Trapezoid Fill method.
+ */
+long ddk768_deNextTrapezoidFill(
+    unsigned long x,            /* Starting X location. */
+    unsigned long length        /* Line length */
+)
+{
+    unsigned long de_ctrl;
+    
+    if (ddk768_deWaitForNotBusy() != 0)
+    {
+        /* The 2D engine is always busy for some unknown reason.
+           Application can choose to return ERROR, or reset it and
+           continue the operation.
+        */
+
+        return -1;
+
+        /* or */
+        /* ddk768_deReset(); */
+    }
+    
+    /* Set the X destination coordinate */
+    POKE_32(DE_DESTINATION,
+        FIELD_VALUE(PEEK_32(DE_DESTINATION), DE_DESTINATION, X,    x));
+        
+    /* Set the line length */
+    POKE_32(DE_DIMENSION,
+        FIELD_VALUE(PEEK_32(DE_DIMENSION), DE_DIMENSION, X,    length));
+        
+    return 0;
+}
+
+/* 
+ * Function to stop the Trapezoid Fill drawing.
+ * This function has to be called to end the Trapezoid Fill drawing.
+ * Otherwise, the next 2D function might still use this function.
+ */
+long ddk768_deStopTrapezoidFill()
+{
+    if (ddk768_deWaitForNotBusy() != 0)
+    {
+        /* The 2D engine is always busy for some unknown reason.
+           Application can choose to return ERROR, or reset it and
+           continue the operation.
+        */
+
+        return -1;
+
+        /* or */
+        /* ddk768_deReset(); */
+    }
+    
+    POKE_32(DE_CONTROL, FIELD_SET(PEEK_32(DE_CONTROL), DE_CONTROL, QUICK_START, DISABLE));
+    
+    return 0;
+}
+
+/*
+ * Video Memory to Video Memory data transfer.
+ * Note: 
+ *        It works whether the Video Memroy is off-screeen or on-screen.
+ *        This function is a one to one transfer without stretching or 
+ *        mono expansion.
+ */
+long ddk768_deVideoMem2VideoMemBlt(
+unsigned long sBase,  /* Address of source: offset in frame buffer */
+unsigned long sPitch, /* Pitch value of source surface in BYTE */
+unsigned long sx,
+unsigned long sy,     /* Starting coordinate of source surface */
+unsigned long dBase,  /* Address of destination: offset in frame buffer */
+unsigned long dPitch, /* Pitch value of destination surface in BYTE */
+unsigned long bpp,    /* Color depth of destination surface */
+unsigned long dx,
+unsigned long dy,     /* Starting coordinate of destination surface */
+unsigned long width, 
+unsigned long height, /* width and height of rectangle in pixel value */
+unsigned long rop2)   /* ROP value */
+{
+    unsigned long nDirection, de_ctrl, bytePerPixel;
+    long opSign;
+
+    if (ddk768_deWaitForNotBusy() != 0)
+    {
+        /* The 2D engine is always busy for some unknown reason.
+           Application can choose to return ERROR, or reset it and
+           continue the operation.
+        */
+
+        return -1;
+
+        /* or */
+        /* ddk768_deReset(); */
+    }
+
+    nDirection = LEFT_TO_RIGHT;
+    opSign = 1;    /* Direction of ROP2 operation: 1 = Left to Right, (-1) = Right to Left */
+    bytePerPixel = bpp/8;
+    de_ctrl = 0;
+
+    /* If source and destination are the same surface, need to check for overlay cases */
+    if (sBase == dBase && sPitch == dPitch)
+    {
+        /* Determine direction of operation */
+        if (sy < dy)
+        {
+            /* +----------+
+               |S         |
+               |   +----------+
+               |   |      |   |
+               |   |      |   |
+               +---|------+   |
+                   |         D|
+                   +----------+ */
+    
+            nDirection = BOTTOM_TO_TOP;
+        }
+        else if (sy > dy)
+        {
+            /* +----------+
+               |D         |
+               |   +----------+
+               |   |      |   |
+               |   |      |   |
+               +---|------+   |
+                   |         S|
+                   +----------+ */
+    
+            nDirection = TOP_TO_BOTTOM;
+        }
+        else
+        {
+            /* sy == dy */
+    
+            if (sx <= dx)
+            {
+                /* +------+---+------+
+                   |S     |   |     D|
+                   |      |   |      |
+                   |      |   |      |
+                   |      |   |      |
+                   +------+---+------+ */
+    
+                nDirection = RIGHT_TO_LEFT;
+            }
+            else
+            {
+                /* sx > dx */
+    
+                /* +------+---+------+
+                   |D     |   |     S|
+                   |      |   |      |
+                   |      |   |      |
+                   |      |   |      |
+                   +------+---+------+ */
+    
+                nDirection = LEFT_TO_RIGHT;
+            }
+        }
+    }
+
+    if ((nDirection == BOTTOM_TO_TOP) || (nDirection == RIGHT_TO_LEFT))
+    {
+        sx += width - 1;
+        sy += height - 1;
+        dx += width - 1;
+        dy += height - 1;
+        opSign = (-1);
+    }
+
+    /* Note:
+       DE_FOREGROUND are DE_BACKGROUND are don't care.
+       DE_COLOR_COMPARE and DE_COLOR_COMPARE_MAKS are set by set ddk768_deSetTransparency().
+    */
+
+    /* 2D Source Base.
+       It is an address offset (128 bit aligned) from the beginning of frame buffer.
+    */
+    POKE_32(DE_WINDOW_SOURCE_BASE, sBase);
+
+    /* 2D Destination Base.
+       It is an address offset (128 bit aligned) from the beginning of frame buffer.
+    */
+    POKE_32(DE_WINDOW_DESTINATION_BASE, dBase);
+
+    /* Program pitch (distance between the 1st points of two adjacent lines).
+       Note that input pitch is BYTE value, but the 2D Pitch register uses
+       pixel values. Need Byte to pixel convertion.
+    */
+    POKE_32(DE_PITCH,
+        FIELD_VALUE(0, DE_PITCH, DESTINATION, (dPitch/bytePerPixel)) |
+        FIELD_VALUE(0, DE_PITCH, SOURCE,      (sPitch/bytePerPixel)));
+
+    /* Screen Window width in Pixels.
+       2D engine uses this value to calculate the linear address in frame buffer for a given point.
+    */
+    POKE_32(DE_WINDOW_WIDTH,
+        FIELD_VALUE(0, DE_WINDOW_WIDTH, DESTINATION, (dPitch/bytePerPixel)) |
+        FIELD_VALUE(0, DE_WINDOW_WIDTH, SOURCE,      (sPitch/bytePerPixel)));
+
+    /* Set the pixel format of the destination */
+    ddk768_deSetPixelFormat(bpp);
+    
+#ifdef ENABLE_192_BYTES_PATCH
+    /* This bug is fixed in SM718 for 16 and 32 bpp. However, in 8-bpp, the problem still exists. 
+       The Version AA also have this problem on higher clock with 32-bit memory data bus, 
+       therefore, it needs to be enabled here. 
+       In version AA, the problem happens on the following configurations:
+        1. M2XCLK = 336MHz w/ 32-bit, MCLK = 112MHz, and color depth set to 32bpp
+        2. M2XCLK = 336MHz w/ 32-bit, MCLK = 84MHz, and color depth set to 16bpp or 32bpp.
+       Somehow, the problem does not appears in 64-bit memory setting.
+     */
+
+    /* Workaround for 192 byte requirement when ROP is not COPY */
+    if ((rop2 != ROP2_COPY) && ((width * bytePerPixel) > 192))
+    {
+        /* Perform the ROP2 operation in chunks of (xWidth * nHeight) */
+        unsigned long xChunk = 192 / bytePerPixel; /* chunk width is in pixels */
+        
+        //DDKDEBUGPRINT((DE_LEVEL, "ROP != ROP_COPY, width * bytePerPixel = %x (> 192 bytes)\n", width * bytePerPixel));
+
+        while (1)
+        {
+            ddk768_deWaitForNotBusy();
+            POKE_32(DE_SOURCE,
+                FIELD_SET  (0, DE_SOURCE, WRAP, DISABLE) |
+                FIELD_VALUE(0, DE_SOURCE, X_K1, sx)   |
+                FIELD_VALUE(0, DE_SOURCE, Y_K2, sy));
+            POKE_32(DE_DESTINATION,
+                FIELD_SET  (0, DE_DESTINATION, WRAP, DISABLE) |
+                FIELD_VALUE(0, DE_DESTINATION, X,    dx)  |
+                FIELD_VALUE(0, DE_DESTINATION, Y,    dy));
+            POKE_32(DE_DIMENSION,
+                FIELD_VALUE(0, DE_DIMENSION, X,    xChunk) |
+                FIELD_VALUE(0, DE_DIMENSION, Y_ET, height));
+
+            de_ctrl = 
+                FIELD_VALUE(0, DE_CONTROL, ROP, rop2) |
+                FIELD_SET(0, DE_CONTROL, ROP_SELECT, ROP2) |
+                FIELD_SET(0, DE_CONTROL, COMMAND, BITBLT) |
+                ((nDirection == RIGHT_TO_LEFT) ? 
+                FIELD_SET(0, DE_CONTROL, DIRECTION, RIGHT_TO_LEFT)
+                : FIELD_SET(0, DE_CONTROL, DIRECTION, LEFT_TO_RIGHT)) |
+                FIELD_SET(0, DE_CONTROL, STATUS, START);
+
+            POKE_32(DE_CONTROL, de_ctrl | ddk768_deGetTransparency());
+
+            if (xChunk == width) break;
+
+            sx += (opSign * xChunk);
+            dx += (opSign * xChunk);
+            width -= xChunk;
+
+            if (xChunk > width)
+            {
+                /* This is the last chunk. */
+                xChunk = width;
+            }
+        }
+    }
+    else
+#endif
+    {
+        ddk768_deWaitForNotBusy();
+
+        POKE_32(DE_SOURCE,
+            FIELD_SET  (0, DE_SOURCE, WRAP, DISABLE) |
+            FIELD_VALUE(0, DE_SOURCE, X_K1, sx)   |
+            FIELD_VALUE(0, DE_SOURCE, Y_K2, sy));
+        POKE_32(DE_DESTINATION,
+            FIELD_SET  (0, DE_DESTINATION, WRAP, DISABLE) |
+            FIELD_VALUE(0, DE_DESTINATION, X,    dx)  |
+            FIELD_VALUE(0, DE_DESTINATION, Y,    dy));
+        POKE_32(DE_DIMENSION,
+            FIELD_VALUE(0, DE_DIMENSION, X,    width) |
+            FIELD_VALUE(0, DE_DIMENSION, Y_ET, height));
+
+        de_ctrl = 
+            FIELD_VALUE(0, DE_CONTROL, ROP, rop2) |
+            FIELD_SET(0, DE_CONTROL, ROP_SELECT, ROP2) |
+            FIELD_SET(0, DE_CONTROL, COMMAND, BITBLT) |
+            ((nDirection == RIGHT_TO_LEFT) ? 
+            FIELD_SET(0, DE_CONTROL, DIRECTION, RIGHT_TO_LEFT)
+            : FIELD_SET(0, DE_CONTROL, DIRECTION, LEFT_TO_RIGHT)) |
+            FIELD_SET(0, DE_CONTROL, STATUS, START);
+
+        POKE_32(DE_CONTROL, de_ctrl | ddk768_deGetTransparency());
+    }
+
+    return 0;
+}
+#if 0
+
+/*
+ * System Memory to Video Memory data transfer.
+ * Only works in D, S, ~D, and ~S ROP.
+ */
+long ddk768_deSystemMem2VideoMemBusMasterBlt(
+    unsigned char *pSBase,  /* Address of source in the system memory.
+                               The memory must be a continuous physical address. */
+    unsigned long sPitch,   /* Pitch value of source surface in BYTE */
+    unsigned long sx,
+    unsigned long sy,       /* Starting coordinate of source surface */
+    unsigned long dBase,    /* Address of destination in frame buffer */
+    unsigned long dPitch,   /* Pitch value of destination surface in BYTE */
+    unsigned long bpp,      /* Color depth of destination surface */
+    unsigned long dx,
+    unsigned long dy,       /* Starting coordinate of destination surface */
+    unsigned long width, 
+    unsigned long height,   /* width and height of rectangle in pixel value */
+    unsigned long rop2      /* ROP value */
+)
+{
+    unsigned long de_ctrl, bytePerPixel;
+    unsigned long value, pciMasterBaseAddress;
+    long opSign;
+
+    if (ddk768_deWaitForNotBusy() != 0)
+    {
+        /* The 2D engine is always busy for some unknown reason.
+           Application can choose to return ERROR, or reset it and
+           continue the operation.
+        */
+
+        return -1;
+
+        /* or */
+        /* ddk768_deReset(); */
+    }
+
+    bytePerPixel = bpp/8;
+    de_ctrl = 0;
+
+    /* Note:
+       DE_FOREGROUND are DE_BACKGROUND are don't care.
+       DE_COLOR_COMPARE and DE_COLOR_COMPARE_MAKS are set by set ddk768_deSetTransparency().
+    */
+
+    /* 2D Source Base.
+       It is an address offset (128 bit aligned) from the given PCI Master base address
+    */
+    /* Set 2D Source Base Address */
+    value = FIELD_VALUE(0, DE_WINDOW_SOURCE_BASE, ADDRESS, (unsigned long)pSBase);        
+    pciMasterBaseAddress = ((unsigned long)pSBase & 0xFC000000) >> 24;
+    POKE_32(PCI_MASTER_BASE, FIELD_VALUE(0, PCI_MASTER_BASE, ADDRESS, pciMasterBaseAddress));
+    POKE_32(DE_WINDOW_SOURCE_BASE, value);
+
+    /* 2D Destination Base.
+       It is an address offset (128 bit aligned) from the beginning of frame buffer.
+    */
+    POKE_32(DE_WINDOW_DESTINATION_BASE, dBase);
+
+    /* Program pitch (distance between the 1st points of two adjacent lines).
+       Note that input pitch is BYTE value, but the 2D Pitch register uses
+       pixel values. Need Byte to pixel convertion.
+    */
+    POKE_32(DE_PITCH,
+        FIELD_VALUE(0, DE_PITCH, DESTINATION, (dPitch/bytePerPixel)) |
+        FIELD_VALUE(0, DE_PITCH, SOURCE,      (sPitch/bytePerPixel)));
+
+    /* Screen Window width in Pixels.
+       2D engine uses this value to calculate the linear address in frame buffer for a given point.
+    */
+    POKE_32(DE_WINDOW_WIDTH,
+        FIELD_VALUE(0, DE_WINDOW_WIDTH, DESTINATION, (dPitch/bytePerPixel)) |
+        FIELD_VALUE(0, DE_WINDOW_WIDTH, SOURCE,      (sPitch/bytePerPixel)));
+
+    /* Set the pixel format of the destination */
+    ddk768_deSetPixelFormat(bpp);
+    
+#ifdef ENABLE_192_BYTES_PATCH
+    /* This bug is fixed in SM718 for 16 and 32 bpp. However, in 8-bpp, the problem still exists. 
+       The Version AA also have this problem on higher clock with 32-bit memory data bus, 
+       therefore, it needs to be enabled here. 
+       In version AA, the problem happens on the following configurations:
+        1. M2XCLK = 336MHz w/ 32-bit, MCLK = 112MHz, and color depth set to 32bpp
+        2. M2XCLK = 336MHz w/ 32-bit, MCLK = 84MHz, and color depth set to 16bpp or 32bpp.
+       Somehow, the problem does not appears in 64-bit memory setting.
+     */
+
+    /* Workaround for 192 byte requirement when ROP is not COPY */
+    if ((rop2 != ROP2_COPY) && ((width * bytePerPixel) > 192))
+    {
+        /* Perform the ROP2 operation in chunks of (xWidth * nHeight) */
+        unsigned long xChunk = 192 / bytePerPixel; /* chunk width is in pixels */
+        
+        //DDKDEBUGPRINT((DE_LEVEL, "ROP != ROP_COPY, width * bytePerPixel = %x (> 192 bytes)\n", width * bytePerPixel));
+
+        while (1)
+        {
+            ddk768_deWaitForNotBusy();
+            POKE_32(DE_SOURCE,
+                FIELD_SET  (0, DE_SOURCE, WRAP, DISABLE) |
+                FIELD_VALUE(0, DE_SOURCE, X_K1, sx)   |
+                FIELD_VALUE(0, DE_SOURCE, Y_K2, sy));
+                
+            POKE_32(DE_DESTINATION,
+                FIELD_SET  (0, DE_DESTINATION, WRAP, DISABLE) |
+                FIELD_VALUE(0, DE_DESTINATION, X,    dx)  |
+                FIELD_VALUE(0, DE_DESTINATION, Y,    dy));
+                
+            POKE_32(DE_DIMENSION,
+                FIELD_VALUE(0, DE_DIMENSION, X,    xChunk) |
+                FIELD_VALUE(0, DE_DIMENSION, Y_ET, height));
+
+            de_ctrl = 
+                FIELD_VALUE(0, DE_CONTROL, ROP, rop2) |
+                FIELD_SET(0, DE_CONTROL, ROP_SELECT, ROP2) |
+                FIELD_SET(0, DE_CONTROL, COMMAND, BITBLT) |
+                FIELD_SET(0, DE_CONTROL, DIRECTION, LEFT_TO_RIGHT) |
+                FIELD_SET(0, DE_CONTROL, STATUS, START);
+
+            POKE_32(DE_CONTROL, de_ctrl | ddk768_deGetTransparency());
+
+            if (xChunk == width) break;
+
+            sx += xChunk;
+            dx += xChunk;
+            width -= xChunk;
+
+            if (xChunk > width)
+            {
+                /* This is the last chunk. */
+                xChunk = width;
+            }
+        }
+    }
+    else
+#endif
+    {
+        ddk768_deWaitForNotBusy();
+
+        POKE_32(DE_SOURCE,
+            FIELD_SET  (0, DE_SOURCE, WRAP, DISABLE) |
+            FIELD_VALUE(0, DE_SOURCE, X_K1, sx)   |
+            FIELD_VALUE(0, DE_SOURCE, Y_K2, sy));
+        POKE_32(DE_DESTINATION,
+            FIELD_SET  (0, DE_DESTINATION, WRAP, DISABLE) |
+            FIELD_VALUE(0, DE_DESTINATION, X,    dx)  |
+            FIELD_VALUE(0, DE_DESTINATION, Y,    dy));
+        POKE_32(DE_DIMENSION,
+            FIELD_VALUE(0, DE_DIMENSION, X,    width) |
+            FIELD_VALUE(0, DE_DIMENSION, Y_ET, height));
+
+        de_ctrl = 
+            FIELD_VALUE(0, DE_CONTROL, ROP, rop2) |
+            FIELD_SET(0, DE_CONTROL, ROP_SELECT, ROP2) |
+            FIELD_SET(0, DE_CONTROL, COMMAND, BITBLT) |
+            FIELD_SET(0, DE_CONTROL, DIRECTION, LEFT_TO_RIGHT) |
+            FIELD_SET(0, DE_CONTROL, STATUS, START);
+
+        POKE_32(DE_CONTROL, de_ctrl | ddk768_deGetTransparency());
+    }
+
+    return 0;
+}
+#endif
+/* 
+ * System memory to Video memory data transfer
+ * Note: 
+ *         We also call it HOST Blt.
+ *        This function is a one to one transfer without stretching or 
+ *        mono expansion.
+ */
+long ddk768_deSystemMem2VideoMemBlt(
+    unsigned char *pSrcbuf, /* pointer to source data in system memory */
+    long srcDelta,          /* width (in Bytes) of the source data, +ive means top down and -ive mean button up */
+    unsigned long dBase,    /* Address of destination: offset in frame buffer */
+    unsigned long dPitch,   /* Pitch value of destination surface in BYTE */
+    unsigned long bpp,      /* Color depth of destination surface */
+    unsigned long dx,
+    unsigned long dy,       /* Starting coordinate of destination surface */
+    unsigned long width, 
+    unsigned long height,   /* width and height of rectange in pixel value */
+    unsigned long rop2      /* ROP value */
+)
+{
+    unsigned long bytePerPixel;
+    unsigned long ulBytesPerScan;
+    unsigned long ul8BytesPerScan;
+    unsigned long ulBytesRemain;
+    unsigned long de_ctrl = 0;
+    unsigned char ajRemain[8];
+    long i, j;
+
+    bytePerPixel = bpp/8;
+
+    /* HOST blt data port must take multiple of 8 bytes as input.
+       If the source width does not match that requirement,
+       we need to split it into two portions. The first portion
+       is 8 byte multiple. The 2nd portion is the remaining bytes.
+       The remaining bytes will be buffered to an 8 byte array and
+       and send it to the host blt data port.
+    */
+    //ulBytesPerScan = width * bpp / 8;
+    ulBytesPerScan = width  / 8;
+    ul8BytesPerScan = ulBytesPerScan & ~7;
+    ulBytesRemain = ulBytesPerScan & 7;
+
+    /* Program 2D Drawing Engine */
+    if (ddk768_deWaitForNotBusy() != 0)
+    {
+        /* The 2D engine is always busy for some unknown reason.
+           Application can choose to return ERROR, or reset it and
+           continue the operation.
+        */
+
+        return -1;
+
+        /* or */
+        /* ddk768_deReset(); */
+    }
+
+    /* 2D Source Base.
+       Use 0 for HOST Blt.
+    */
+    POKE_32(DE_WINDOW_SOURCE_BASE, 0);
+
+    /* 2D Destination Base.
+       It is an address offset (128 bit aligned) from the beginning of frame buffer.
+    */
+    POKE_32(DE_WINDOW_DESTINATION_BASE, dBase);
+
+    /* Program pitch (distance between the 1st points of two adjacent lines).
+       Note that input pitch is BYTE value, but the 2D Pitch register uses
+       pixel values. Need Byte to pixel convertion.
+    */
+    POKE_32(DE_PITCH,
+        FIELD_VALUE(0, DE_PITCH, DESTINATION, dPitch/bytePerPixel) |
+        FIELD_VALUE(0, DE_PITCH, SOURCE,      dPitch/bytePerPixel));
+
+    /* Screen Window width in Pixels.
+       2D engine uses this value to calculate the linear address in frame buffer for a given point.
+    */
+    POKE_32(DE_WINDOW_WIDTH,
+        FIELD_VALUE(0, DE_WINDOW_WIDTH, DESTINATION, (dPitch/bytePerPixel)) |
+        FIELD_VALUE(0, DE_WINDOW_WIDTH, SOURCE,      (dPitch/bytePerPixel)));
+
+    /* Note: For 2D Source in Host Write, only X_K1 field is needed, and Y_K2 field is not used.
+             For 1 to 1 bitmap transfer, use 0 for X_K1 means source alignment from byte 0. */
+    POKE_32(DE_SOURCE,
+        FIELD_SET  (0, DE_SOURCE, WRAP, DISABLE) |
+        FIELD_VALUE(0, DE_SOURCE, X_K1, 0)       |
+        FIELD_VALUE(0, DE_SOURCE, Y_K2, 0));
+
+    POKE_32(DE_DESTINATION,
+        FIELD_SET  (0, DE_DESTINATION, WRAP, DISABLE) |
+        FIELD_VALUE(0, DE_DESTINATION, X,    dx)    |
+        FIELD_VALUE(0, DE_DESTINATION, Y,    dy));
+
+    POKE_32(DE_DIMENSION,
+        FIELD_VALUE(0, DE_DIMENSION, X,    width) |
+        FIELD_VALUE(0, DE_DIMENSION, Y_ET, height));
+        
+    /* Set the pixel format of the destination */
+    ddk768_deSetPixelFormat(bpp);
+
+    de_ctrl = 
+        FIELD_VALUE(0, DE_CONTROL, ROP, rop2)         |
+        FIELD_SET(0, DE_CONTROL, ROP_SELECT, ROP2)    |
+        FIELD_SET(0, DE_CONTROL, COMMAND, HOST_WRITE) |
+        FIELD_SET(0, DE_CONTROL, HOST, COLOR)         |
+        FIELD_SET(0, DE_CONTROL, STATUS, START);
+
+    POKE_32(DE_CONTROL, de_ctrl | ddk768_deGetTransparency());
+
+    /* Write bitmap/image data (line by line) to 2D Engine data port */
+    for (i = 0; i < height; i++)
+    {
+        /* For each line, send the data in chunks of 4 bytes. */
+        for (j=0; j < (ul8BytesPerScan/4);  j++)
+            POKE_32(DE_DATA_PORT, *(unsigned long *)(pSrcbuf + (j * 4)));
+
+        if (ulBytesRemain)
+        {
+            memcpy(ajRemain, pSrcbuf+ul8BytesPerScan, ulBytesRemain);
+            POKE_32(DE_DATA_PORT, *(unsigned long *)ajRemain);
+            POKE_32(DE_DATA_PORT, *(unsigned long *)(ajRemain+4));
+        }
+
+        pSrcbuf += srcDelta;
+    }
+
+    return 0;
+}
+
+/*
+ * System memory to Video memory monochrome expansion.
+ * Source is monochrome image in system memory.
+ * This function expands the monochrome data to color image in video memory.
+ */
+long ddk768_deSystemMem2VideoMemMonoBlt(
+unsigned char *pSrcbuf, /* pointer to start of source buffer in system memory */
+long srcDelta,          /* Pitch value (in bytes) of the source buffer, +ive means top down and -ive mean button up */
+unsigned long startBit, /* Mono data can start at any bit in a byte, this value should be 0 to 7 */
+unsigned long dBase,    /* Address of destination: offset in frame buffer */
+unsigned long dPitch,   /* Pitch value of destination surface in BYTE */
+unsigned long bpp,      /* Color depth of destination surface */
+unsigned long dx,
+unsigned long dy,       /* Starting coordinate of destination surface */
+unsigned long width, 
+unsigned long height,   /* width and height of rectange in pixel value */
+unsigned long fColor,   /* Foreground color (corresponding to a 1 in the monochrome data */
+unsigned long bColor,   /* Background color (corresponding to a 0 in the monochrome data */
+unsigned long rop2)     /* ROP value */
+{
+    unsigned long bytePerPixel;
+    unsigned long ulBytesPerScan;
+    unsigned long ul4BytesPerScan;
+    unsigned long ulBytesRemain;
+    unsigned long de_ctrl = 0;
+    unsigned char ajRemain[4];
+    long i, j;
+
+    bytePerPixel = bpp/8;
+
+    startBit &= 7; /* Just make sure the start bit is within legal range */
+    ulBytesPerScan = (width + startBit + 7) / 8;
+    ul4BytesPerScan = ulBytesPerScan & ~3;
+    ulBytesRemain = ulBytesPerScan & 3;
+
+    if (ddk768_deWaitForNotBusy() != 0)
+    {
+        /* The 2D engine is always busy for some unknown reason.
+           Application can choose to return ERROR, or reset it and
+           continue the operation.
+        */
+
+        return -1;
+
+        /* or */
+        /* ddk768_deReset(); */
+    }
+
+    /* 2D Source Base.
+       Use 0 for HOST Blt.
+    */
+    POKE_32(DE_WINDOW_SOURCE_BASE, 0);
+
+    /* 2D Destination Base.
+       It is an address offset (128 bit aligned) from the beginning of frame buffer.
+    */
+    POKE_32(DE_WINDOW_DESTINATION_BASE, dBase);
+
+    /* Program pitch (distance between the 1st points of two adjacent lines).
+       Note that input pitch is BYTE value, but the 2D Pitch register uses
+       pixel values. Need Byte to pixel convertion.
+    */
+    POKE_32(DE_PITCH,
+        FIELD_VALUE(0, DE_PITCH, DESTINATION, dPitch/bytePerPixel) |
+        FIELD_VALUE(0, DE_PITCH, SOURCE,      dPitch/bytePerPixel));
+
+    /* Screen Window width in Pixels.
+       2D engine uses this value to calculate the linear address in frame buffer for a given point.
+    */
+    POKE_32(DE_WINDOW_WIDTH,
+        FIELD_VALUE(0, DE_WINDOW_WIDTH, DESTINATION, (dPitch/bytePerPixel)) |
+        FIELD_VALUE(0, DE_WINDOW_WIDTH, SOURCE,      (dPitch/bytePerPixel)));
+
+    /* Note: For 2D Source in Host Write, only X_K1_MONO field is needed, and Y_K2 field is not used.
+             For mono bitmap, use startBit for X_K1. */
+    POKE_32(DE_SOURCE,
+        FIELD_SET  (0, DE_SOURCE, WRAP, DISABLE)       |
+        FIELD_VALUE(0, DE_SOURCE, X_K1_MONO, startBit));
+
+    POKE_32(DE_DESTINATION,
+        FIELD_SET  (0, DE_DESTINATION, WRAP, DISABLE) |
+        FIELD_VALUE(0, DE_DESTINATION, X,    dx)    |
+        FIELD_VALUE(0, DE_DESTINATION, Y,    dy));
+
+    POKE_32(DE_DIMENSION,
+        FIELD_VALUE(0, DE_DIMENSION, X,    width) |
+        FIELD_VALUE(0, DE_DIMENSION, Y_ET, height));
+
+    POKE_32(DE_FOREGROUND, fColor);
+    POKE_32(DE_BACKGROUND, bColor);
+    
+    /* Set the pixel format of the destination */
+    ddk768_deSetPixelFormat(bpp);
+
+    de_ctrl = FIELD_VALUE(0, DE_CONTROL, ROP, rop2)         |
+              FIELD_SET(0, DE_CONTROL, ROP_SELECT, ROP2)    |
+              FIELD_SET(0, DE_CONTROL, COMMAND, HOST_WRITE) |
+              FIELD_SET(0, DE_CONTROL, HOST, MONO)          |
+              FIELD_SET(0, DE_CONTROL, STATUS, START);
+
+    POKE_32(DE_CONTROL, de_ctrl | ddk768_deGetTransparency());
+
+    /* Write MONO data (line by line) to 2D Engine data port */
+    for (i=0; i<height; i++)
+    {
+        /* For each line, send the data in chunks of 4 bytes */
+        for (j=0; j<(ul4BytesPerScan/4); j++)
+        {
+            POKE_32(DE_DATA_PORT, *(unsigned long *)(pSrcbuf + (j * 4)));
+        }
+
+        if (ulBytesRemain)
+        {
+            memcpy(ajRemain, pSrcbuf+ul4BytesPerScan, ulBytesRemain);
+            POKE_32(DE_DATA_PORT, *(unsigned long *)ajRemain);
+        }
+
+        pSrcbuf += srcDelta;
+    }
+
+    return 0;
+}
diff --git a/drivers/gpu/drm/smi/ddk768/ddk768_2d.h b/drivers/gpu/drm/smi/ddk768/ddk768_2d.h
new file mode 100644
index 000000000000..07241143508b
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk768/ddk768_2d.h
@@ -0,0 +1,503 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2007 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  2d.h --- SM750/SM718 DDK 
+*  This file contains the definitions for the 2D Engine interrupt.
+* 
+*******************************************************************/
+#ifndef _DDK768_2D_H_
+#define _DDK768_2D_H_
+
+#define POKE_8(address, value)          pokeRegisterByte(address, value)
+#define POKE_16(address, value)         pokeRegisterWord(address, value)
+#define POKE_32(address, value)         pokeRegisterDWord(address, value)
+#define PEEK_8(address)                 peekRegisterByte(address)
+#define PEEK_16(address)                peekRegisterWord(address)
+#define PEEK_32(address)                peekRegisterDWord(address)
+
+/* Rotation Direction */
+typedef enum _rotate_dir_t
+{
+    ROTATE_NORMAL = 0,
+    ROTATE_90_DEGREE,
+    ROTATE_180_DEGREE,
+    ROTATE_270_DEGREE
+}
+rotate_dir_t;
+
+/*
+ * 2D Engine Initialization.
+ * This function must be called before other 2D functions.
+ * Assumption: A specific vidoe mode has been properly set up.
+ */
+void ddk768_deInit(void);
+
+/*
+ * Reset 2D engine by 
+ * 1) Aborting the current 2D operation.
+ * 2) Re-enable 2D engine to normal state.
+ */
+void ddk768_deReset(void);
+ 
+/*
+ * Wait until 2D engine is not busy.
+ * All 2D operations are recommand to check 2D engine idle before start.
+ *
+ * Return: 0 = return because engine is idle and normal.
+ *        -1 = return because time out (2D engine may have problem).
+ */
+long ddk768_deWaitForNotBusy(void);
+
+/* deWaitIdle() function.
+ *
+ * This function is same as ddk768_deWaitForNotBusy(), except application can
+ * input the maximum number of times that this function will check 
+ * the idle register.
+ *
+ * Its usage is mainly for debugging purpose.
+ *
+ * Wait until 2D engine is not busy.
+ * All 2D operations are recommand to check 2D engine idle before start.
+ *
+ * Return: 0 = return because engine is idle and normal.
+ *        -1 = return because time out (2D engine may have problem).
+ */
+long deWaitIdle(unsigned long i);
+
+/*
+ * This function enable/disable clipping area for the 2d engine.
+ * Note that the clipping area is always rectangular.
+ * 
+ */
+long ddk768_deSetClipping(
+unsigned long enable, /* 0 = disable clipping, 1 = enable clipping */
+unsigned long x1,     /* x1, y1 is the upper left corner of the clipping area */
+unsigned long y1,     /* Note that the region includes x1 and y1 */
+unsigned long x2,     /* x2, y2 is the lower right corner of the clippiing area */
+unsigned long y2);    /* Note that the region will not include x2 and y2 */
+
+/* 
+ * Function description:
+ * When transparency is enable, the blt engine compares each pixel value 
+ * (either source or destination) with DE_COLOR_COMPARE register.
+ * If match, the destination pixel will NOT be updated.
+ * If not match, the destination pixel will be updated.
+ */
+long ddk768_deSetTransparency(
+unsigned long enable,     /* 0 = disable, 1 = enable transparency feature */
+unsigned long tSelect,    /* 0 = compare source, 1 = compare destination */
+unsigned long tMatch,     /* 0 = Opaque mode, 1 = transparent mode */
+unsigned long ulColor);   /* Color to compare. */
+
+/*
+ * This function uses 2D engine to fill a rectangular area with a specific color.
+ * The filled area includes the starting points.
+ */
+long ddk768_deRectFill( /*resolution_t resolution, point_t p0, point_t p1, unsigned long color, unsigned long rop2)*/
+unsigned long dBase,  /* Base address of destination surface counted from beginning of video frame buffer */
+unsigned long dPitch, /* Pitch value of destination surface in BYTES */
+unsigned long bpp,    /* Color depth of destination surface: 8, 16 or 32 */
+unsigned long x,
+unsigned long y,      /* Upper left corner (X, Y) of rectangle in pixel value */
+unsigned long width, 
+unsigned long height, /* width and height of rectange in pixel value */
+unsigned long color,  /* Color to be filled */
+unsigned long rop2);  /* ROP value */
+
+/*
+ * Video Memory to Video Memory data transfer.
+ * Note: 
+ *        It works whether the Video Memroy is off-screeen or on-screen.
+ *        This function is a one to one transfer without stretching or 
+ *        mono expansion.
+ */
+long ddk768_deVideoMem2VideoMemBlt(
+unsigned long sBase,  /* Address of source: offset in frame buffer */
+unsigned long sPitch, /* Pitch value of source surface in BYTE */
+unsigned long sx,
+unsigned long sy,     /* Starting coordinate of source surface */
+unsigned long dBase,  /* Address of destination: offset in frame buffer */
+unsigned long dPitch, /* Pitch value of destination surface in BYTE */
+unsigned long bpp,    /* Color depth of destination surface */
+unsigned long dx,
+unsigned long dy,     /* Starting coordinate of destination surface */
+unsigned long width, 
+unsigned long height, /* width and height of rectange in pixel value */
+unsigned long rop2);  /* ROP value */
+#if 0
+/*
+ * System Memory to Video Memory data transfer.
+ * Note: 
+ *        It works whether the Video Memroy is off-screeen or on-screen.
+ *        This function is a one to one transfer without stretching or 
+ *        mono expansion.
+ */
+long ddk768_deSystemMem2VideoMemBusMasterBlt(
+    unsigned char *pSBase,  /* Address of source: offset in frame buffer */
+    unsigned long sPitch,   /* Pitch value of source surface in BYTE */
+    unsigned long sx,
+    unsigned long sy,       /* Starting coordinate of source surface */
+    unsigned long dBase,    /* Address of destination: offset in frame buffer */
+    unsigned long dPitch,   /* Pitch value of destination surface in BYTE */
+    unsigned long bpp,      /* Color depth of destination surface */
+    unsigned long dx,
+    unsigned long dy,       /* Starting coordinate of destination surface */
+    unsigned long width, 
+    unsigned long height,   /* width and height of rectangle in pixel value */
+    unsigned long rop2      /* ROP value */
+);
+#endif
+/* 
+ * System memory to Video memory data transfer
+ * Note: 
+ *         We also call it HOST Blt.
+ *        This function is a one to one transfer without stretching or 
+ *        mono expansion.
+ */
+long ddk768_deSystemMem2VideoMemBlt(
+unsigned char *pSrcbuf, /* pointer to source data in system memory */
+long srcDelta,          /* width (in Bytes) of the source data, +ive means top down and -ive mean button up */
+unsigned long dBase,    /* Address of destination: offset in frame buffer */
+unsigned long dPitch,   /* Pitch value of destination surface in BYTE */
+unsigned long bpp,      /* Color depth of destination surface */
+unsigned long dx,
+unsigned long dy,       /* Starting coordinate of destination surface */
+unsigned long width, 
+unsigned long height,   /* width and height of rectange in pixel value */
+unsigned long rop2);    /* ROP value */
+
+/*
+ * System memory to Video memory monochrome expansion.
+ * Source is monochrome image in system memory.
+ * This function expands the monochrome data to color image in video memory.
+ */
+long ddk768_deSystemMem2VideoMemMonoBlt(
+unsigned char *pSrcbuf, /* pointer to start of source buffer in system memory */
+long srcDelta,          /* Pitch value (in bytes) of the source buffer, +ive means top down and -ive mean button up */
+unsigned long startBit, /* Mono data can start at any bit in a byte, this value should be 0 to 7 */
+unsigned long dBase,    /* Address of destination: offset in frame buffer */
+unsigned long dPitch,   /* Pitch value of destination surface in BYTE */
+unsigned long bpp,      /* Color depth of destination surface */
+unsigned long dx,
+unsigned long dy,       /* Starting coordinate of destination surface */
+unsigned long width, 
+unsigned long height,   /* width and height of rectange in pixel value */
+unsigned long fColor,   /* Foreground color (corresponding to a 1 in the monochrome data */
+unsigned long bColor,   /* Background color (corresponding to a 0 in the monochrome data */
+unsigned long rop2);    /* ROP value */
+
+#if 0
+/*
+ * System memory to Video memory monochrome expansion.
+ * Source is the starting location of monochrome image in System memory.
+ * This function expands the monochrome data to color image.
+ *
+ * Note:
+ * This fnnction can be used to diaplay a mono-font charater to the screen.
+ * Input source points to the starting location of the font character.
+ */
+long deSystemMem2VideoMemMonoBusMasterBlt(
+    unsigned char *pSBase,  /* Address of mono-chrome source data in frame buffer */
+    unsigned long sPitch,   /* Pitch value (in bytes) of the source buffer. */
+    unsigned long startBit, /* Mono data can start at any bit in a byte, this value should be 0 to 7 */
+    unsigned long dBase,    /* Base address of destination in frame buffer */
+    unsigned long dPitch,   /* Pitch value of destination surface in BYTE */
+    unsigned long bpp,      /* Color depth of destination surface */
+    unsigned long dx,
+    unsigned long dy,       /* Starting coordinate of destination surface */
+    unsigned long width,    /* width of mono-chrome picture in pixel value */
+    unsigned long height,   /* height of mono-chrome picture in pixel value */
+    unsigned long fColor,   /* Foreground color (corresponding to a 1 in the monochrome data */
+    unsigned long bColor,   /* Background color (corresponding to a 0 in the monochrome data */
+    unsigned long rop2      /* ROP value */
+);
+#endif
+
+/*
+ * This function cache font table into frame buffer.
+ *
+ * Inputs:
+ *      Pointer to font table in system memory.
+ *      Charcter size in byte: How many bytes are used to store the font for one characer.
+ *      As an example: For 8x8 mono font, the size is 8 bytes; 
+ *                     For 8x16 mono font, the size is 16 bytes.
+ *                     For 16x32 mono font, the size is 64 bytes.
+ *      Number of characters in the font table.
+ *      Pointer to location of frame buffer to store the font: This is an offset from the beginning of frame buffer.
+ *  
+ * Rules for storing fonts in off-screen.
+ *     1) Base address of font table must be 16 byte (or 128 bit) aligned.
+ *     2) Each font character must be stored in a 16 byte (128 bit) aligned
+ *        location.
+ *
+ */
+long deCacheFontToFrameBuffer(
+unsigned char *fontTable,   /* Pointer to font table in system memory */
+unsigned long sizeOfChar,   /* How many bytes for one monochrome character */
+unsigned long numberOfChar, /* Number of characters in the font table */
+unsigned long fbAddr);      /* Destination in Video memory to store the font */
+
+/*
+ * Video memory to Video memory monochrome expansion.
+ * Source is the starting location of monochrome image in Video memory.
+ * This function expands the monochrome data to color image.
+ *
+ * Note:
+ * This fnnction can be used to diaplay a mono-font charater to the screen.
+ * Input source points to the starting location of the font character.
+ */
+long deVideoMem2VideoMemMonoBlt(
+unsigned long sBase,  /* Address of mono-chrome source data in frame buffer */
+unsigned long dBase,  /* Base address of destination in frame buffer */
+unsigned long dPitch, /* Pitch value of destination surface in BYTE */
+unsigned long bpp,    /* Color depth of destination surface */
+unsigned long dx,
+unsigned long dy,     /* Starting coordinate of destination surface */
+unsigned long width,  /* width of mono-chrome picture in pixel value */
+unsigned long height, /* height of mono-chrome picture in pixel value */
+unsigned long fColor, /* Foreground color (corresponding to a 1 in the monochrome data */
+unsigned long bColor, /* Background color (corresponding to a 0 in the monochrome data */
+unsigned long rop2);  /* ROP value */
+
+/*
+ * Video memory to Video memory monochrome expansion.
+ * 
+ * Difference between this function and deVideoMem2VideoMemMonoBlt():
+ * 1) Input is base address of the whole font table.
+ * 2) An extra input about which character in the font table to display.
+ * 3) This function demos how to use registers DE_SOURCE and
+ *    DE_WINDOW_WIDTH, where they are set to 0 in deVideoMem2VideoMemMonoBlt().
+ */
+long deFontCacheTblMonoBlt(
+unsigned long fontTblBase,/* Base address of monochrome font table in frame buffer */
+unsigned long fontNumber, /* Which character in the font table, starting from 0 */
+unsigned long dBase,      /* Base address of destination in frame buffer */
+unsigned long dPitch,     /* Pitch value of destination surface in BYTE */
+unsigned long bpp,        /* Color depth of destination surface */
+unsigned long dx,
+unsigned long dy,         /* Starting coordinate of destination surface */
+unsigned long width,      /* width of each monochrome font in pixel value */
+unsigned long height,     /* height of each monochrome font in pixel value */
+unsigned long fColor,     /* Foreground color (corresponding to a 1 in the monochrome data */
+unsigned long bColor,     /* Background color (corresponding to a 0 in the monochrome data */
+unsigned long rop2);      /* ROP value */
+
+/*
+ * Stretch Blt.
+ * 
+ * The stretch blt is done by using the CSC engine.
+ */
+long deStretchBlt(
+    unsigned long sBase,    /* Source Base address */
+    unsigned long sPitch,   /* Source pitch value in bytes */
+    unsigned long sbpp,     /* Source bits per pixel */
+    unsigned long sx,       /* Source x coordinate */            
+    unsigned long sy,       /* Source y coordinate */
+    unsigned long sWidth,   /* Width of source in pixel */
+    unsigned long sHeight,  /* Height of source in lines */
+    unsigned long dBase,    /* Destination base address */
+    unsigned long dPitch,   /* Destination pitch value in bytes */
+    unsigned long dbpp,     /* Destination bits per pixel */
+    unsigned long dx,       /* Destination x coordinate */
+    unsigned long dy,       /* Destination y coordinate */
+    unsigned long dWidth,   /* Width of the destination display */
+    unsigned long dHeight   /* Height of the destination display */
+);
+
+/*
+ * Rotation Blt.
+ * 
+ * This function rotates an image to the screen based on the given rotation direction
+ * (0, 90, 180, or 270 degree).
+ * 
+ */
+long deVideoMem2VideoMemRotateBlt(
+    unsigned long sBase,            /* Source Base Address */
+    unsigned long sPitch,           /* Source pitch */
+    unsigned long sx,               /* X Coordinate of the source */
+    unsigned long sy,               /* Y Coordinate of the source */
+    unsigned long dBase,            /* Destination Base Address */
+    unsigned long dPitch,           /* Destination pitch */
+    unsigned long bpp,              /* Color depth of destination surface */
+    unsigned long dx,               /* X Coordinate of the destination */ 
+    unsigned long dy,               /* Y Coordinate of the destination */
+    unsigned long width,            /* Width  of un-rotated image in pixel value */
+    unsigned long height,           /* Height of un-rotated image in pixel value */
+    rotate_dir_t rotateDirection,   /* Direction of the rotation */
+    unsigned long repeatEnable,     /* Enable repeat rotation control where the
+                                       drawing engine is started again every vsync */
+    unsigned long rop2              /* ROP control */
+);
+
+/* 
+ * Function to draw a vertical line.
+ *
+ * Note:
+ *      This function is using Short Stroke line
+ */
+long deVerticalLine(
+    unsigned long dBase,    /* Base address of destination surface counted from beginning of video frame buffer */
+    unsigned long dPitch,   /* Pitch value of destination surface in BYTES */
+    unsigned long bpp,      /* Color depth of destination surface: 8, 16 or 32 */
+    unsigned long x,        /* Starting X Coordinate */
+    unsigned long y,        /* Starting Y Coordinate */
+    unsigned long length,   /* Length of the line */
+    unsigned long color,    /* Color of the line */
+    unsigned long rop2      /* ROP value */
+);
+
+/* 
+ * Function to draw a horizontal line.
+ *
+ * Note:
+ *      This function is using Short Stroke line
+ */
+long deHorizontalLine(
+    unsigned long dBase,    /* Base address of destination surface counted from beginning of video frame buffer */
+    unsigned long dPitch,   /* Pitch value of destination surface in BYTES */
+    unsigned long bpp,      /* Color depth of destination surface: 8, 16 or 32 */
+    unsigned long x,        /* Starting X Coordinate */
+    unsigned long y,        /* Starting Y Coordinate */
+    unsigned long length,   /* Length of the line */
+    unsigned long color,    /* Color of the line */
+    unsigned long rop2      /* ROP value */
+);
+
+/* 
+ * Function to draw a line.
+ *
+ * Note:
+ *      This function is using Short Stroke Command for Vertical, Horizontal, and 
+ *      Diagonal line. Other line are drawn using the Line Draw Command.
+ */
+long deLine(
+    unsigned long dBase,    /* Base address of destination surface counted from beginning of video frame buffer */
+    unsigned long dPitch,   /* Pitch value of destination surface in BYTES */
+    unsigned long bpp,      /* Color depth of destination surface: 8, 16 or 32 */
+    long x0,                /* Starting X Coordinate */
+    long y0,                /* Starting Y Coordinate */
+    long x1,                /* Ending X Coordinate */
+    long y1,                /* Ending Y Coordinate */
+    unsigned long color,    /* Color of the line */
+    unsigned long rop2      /* ROP value */
+);
+
+/*
+ * Alpha Blend Blt.
+ * 
+ * This function blends the source with the destination image.
+ */
+long deVideoMem2VideoMemAlphaBlendBlt(
+    unsigned long sBase,            /* Source Base Address */
+    unsigned long sPitch,           /* Source pitch */
+    unsigned long sx,               /* X Coordinate of the source */
+    unsigned long sy,               /* Y Coordinate of the source */
+    unsigned long sWidth,           /* Source Width */
+    unsigned long sHeight,          /* Source Height */
+    unsigned long dBase,            /* Destination Base Address */
+    unsigned long dPitch,           /* Destination pitch */
+    unsigned long bpp,              /* Color depth of destination surface */
+    unsigned long dx,               /* X Coordinate of the destination */ 
+    unsigned long dy,               /* Y Coordinate of the destination */
+    unsigned long dHeight,          /* Destination Height (only height stretch is supported) */
+    unsigned long alphaValue,       /* Alpha value for Alpha Blend*/
+    unsigned long rop2              /* ROP control */
+);
+
+#if 0   /* These RLE functions are not working. */
+/* 
+ * Function to draw a line using RLE line strip method.
+ */
+long deStartLineStrip(
+    unsigned long dBase,        /* Base address of destination surface counted from beginning of video frame buffer */
+    unsigned long dPitch,       /* Pitch value of destination surface in BYTES */
+    unsigned long bpp,          /* Color depth of destination surface: 8, 16 or 32 */
+    unsigned long x,            /* X Coordinate */
+    unsigned long y,            /* Y Coordinate */
+    unsigned long length,       /* Length of the line */
+    unsigned long lineCounter,  /* Line Counter */
+    unsigned long direction,    /* Direction:   0 - Left to Right
+                                                1 - Right to Left
+                                                2 - Top to Bottom
+                                                3 - Bottom to Top
+                                */
+    unsigned long color,        /* Color of the line */
+    unsigned long rop2          /* ROP value */
+);
+
+/* 
+ * Function to continue drawing a line using RLE line strip method.
+ */
+long deNextLineStrip(
+    unsigned long length,       /* Line strip length */
+    unsigned long lineCounter   /* Line Counter */
+);
+
+/* 
+ * Function to stop the RLE line strip drawing.
+ * This function has to be called to end the Line Strip drawing.
+ * Otherwise, the next 2D function might still use this function.
+ */
+long deStopLineStrip();
+#endif
+
+
+/*
+ * This function uses 2D engine to draw a trapezoid with a specific color.
+ * The filled area includes the starting points.
+ */
+long ddk768_deStartTrapezoidFill(
+    unsigned long dBase,  /* Base address of destination surface counted from beginning of video frame buffer */
+    unsigned long dPitch, /* Pitch value of destination surface in BYTES */
+    unsigned long bpp,    /* Color depth of destination surface: 8, 16 or 32 */
+    unsigned long x,
+    unsigned long y,      /* Starting (X, Y) coordinate inside the polygon to be filled */
+    unsigned long length, /* Length of the line */
+    unsigned long color,  /* Color to be filled */
+    unsigned long rop2);
+
+/* 
+ * Function to continue drawing a line using Trapezoid Fill method.
+ */
+long ddk768_deNextTrapezoidFill(
+    unsigned long x,            /* Starting X location. */
+    unsigned long length        /* Line length */
+);
+
+/* 
+ * Function to stop the Trapezoid Fill drawing.
+ * This function has to be called to end the Trapezoid Fill drawing.
+ * Otherwise, the next 2D function might still use this function.
+ */
+long ddk768_deStopTrapezoidFill(void);
+
+/*
+ * This function clears the RAW interrupt status of DE.
+ * 
+ * When Drawing Engine completes, the raw interrupt bit will be set.
+ * It has to be cleared, in order to distinguish between different sessions of countdown.
+ * 
+ */
+void deClearRawInt(void);
+
+/* 
+ * This function returns the INT mask for Drawing Engine.
+ *
+ */
+unsigned long deIntMask(void);
+
+/*
+ * This is a reference sample showing how to implement ISR for Drawing Engine.
+ * It provides information on how to use the interrupt registers.
+ * 
+ * Refer to Apps\2d\tst2d.c on how to hook up this function with system
+ * interrupt under WATCOM DOS extender.
+ * 
+ */
+void /*ISR_FUNC*/ deIsrTemplate(void);
+
+#endif /* _2D_H_ */
diff --git a/drivers/gpu/drm/smi/ddk768/ddk768_chip.c b/drivers/gpu/drm/smi/ddk768/ddk768_chip.c
new file mode 100644
index 000000000000..1338a47cb06c
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk768/ddk768_chip.c
@@ -0,0 +1,183 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2007 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  CHIP.C --- SMI DDK 
+*  This file contains the source code for the mode table.
+* 
+*******************************************************************/
+#include "ddk768_reg.h"
+#include "ddk768_chip.h"
+#include "ddk768_power.h"
+#include "ddk768_clock.h"
+
+#include "ddk768_help.h"
+
+
+/* Size of SM768 MMIO and memory */
+#define SMI_MMIO_SIZE_SM768       (2<<20)    /* 2M of MMIO space */
+#define SMI_MEMORY_SIZE_SM768     (128<<20)  
+/*
+ * This function returns frame buffer memory size in Byte units.
+ */
+unsigned long ddk768_getFrameBufSize()
+{
+	return SMI_MEMORY_SIZE_SM768;
+    unsigned long strapPin, ddrController, rValue;
+
+    strapPin = FIELD_GET(peekRegisterDWord(STRAP_PINS), STRAP_PINS, MEM_SIZE);
+    ddrController = peekRegisterDWord(DDR_CONTROL);
+
+    switch(strapPin)
+    {
+        case STRAP_PINS_MEM_SIZE_512M:
+        pokeRegisterDWord(DDR_CONTROL, ddrController | FIELD_SET(0, DDR_CONTROL, SIZE, 512M));
+        rValue = MB(512);
+        break;
+
+        case STRAP_PINS_MEM_SIZE_1024M:
+        pokeRegisterDWord(DDR_CONTROL, ddrController | FIELD_SET(0, DDR_CONTROL, SIZE, 1024M));
+        rValue = MB(1024);
+        break;
+
+        default: /* default size of 256M. Don't need to do anything */
+        rValue = MB(256);
+        break;
+    }
+    return(rValue);
+}
+
+/*
+ * This function returns the logical chip type defined in chip.h
+ * It is one of the following: SM501, SM502, SM107, SM718, SM 750 or
+ * SM_UNKNOWN.
+ */
+logical_chip_type_t ddk768_getChipType()
+{
+
+    logical_chip_type_t chip;
+
+
+    chip = SM768;
+
+
+    return chip;
+}
+
+/*
+ * Return a char string name of the current chip.
+ * It's convenient for application need to display the chip name.
+ */
+char *ddk768_getChipTypeString()
+{
+    char * chipName;
+
+    switch(ddk768_getChipType())
+    {
+        case SM768:
+            chipName = "SM768";
+            break;
+        default:
+            chipName = "Unknown";
+            break;
+    }
+
+    return chipName;
+}
+
+/*
+ * Initialize a single chip and environment according to input parameters.
+ *
+ * Input: initchip_param_t structure.
+ *
+ * Return: 0 (or NO_ERROR) if successful.
+ *        -1 if fail.
+ *
+ */
+long ddk768_initChipParamEx(initchip_param_t * pInitParam)
+{
+    unsigned long ulReg;
+
+    /* Check if we know this chip */
+    if (ddk768_getChipType() == SM_UNKNOWN)
+        return -1;
+
+    if (pInitParam->setAllEngOff == 1)
+    {
+        ulReg = peekRegisterDWord(VIDEO_DISPLAY_CTRL);
+        ulReg = FIELD_SET(ulReg, VIDEO_DISPLAY_CTRL, PLANE, DISABLE); 
+        pokeRegisterDWord(VIDEO_DISPLAY_CTRL, ulReg); /* Channel 0 */
+        pokeRegisterDWord(VIDEO_DISPLAY_CTRL+CHANNEL_OFFSET, ulReg); /* Channel 1 */
+
+        /* Disable alpha plane, if a former application left it on */
+        ulReg = peekRegisterDWord(ALPHA_DISPLAY_CTRL);
+        ulReg = FIELD_SET(ulReg, ALPHA_DISPLAY_CTRL, PLANE, DISABLE); 
+        pokeRegisterDWord(ALPHA_DISPLAY_CTRL, ulReg); /* Channel 0 */
+        pokeRegisterDWord(ALPHA_DISPLAY_CTRL+CHANNEL_OFFSET, ulReg); /* Channel 1 */
+
+        /* Disable hardware cursor, if a former application left it on */
+        ulReg = peekRegisterDWord(HWC_CONTROL);
+        ulReg = FIELD_SET(ulReg, HWC_CONTROL, MODE, DISABLE); 
+        pokeRegisterDWord(HWC_CONTROL, ulReg); /* Channel 0 */
+        pokeRegisterDWord(HWC_CONTROL+CHANNEL_OFFSET, ulReg); /* Channel 1 */
+    }
+
+    /* We can add more initialization as needed. */
+
+        
+    return 0;
+}
+
+/*
+ * Initialize chip with default parameters.
+ *
+ * Input: none.
+ *
+ * Return: 0 (or NO_ERROR) if successful.
+ *        -1 if fail.
+ */
+long ddk768_initChip()
+{
+    initchip_param_t initParam;
+    
+    /* Initialize the chip with some default parameters */
+
+    initParam.setAllEngOff = 1;
+    
+    
+    return(ddk768_initChipParamEx(&initParam));
+}
+
+#if 0
+#define PHY_STATUS(A, B)\
+    peekRegisterDWord(A) & B
+/*
+    Program DDR PHY register PIR to do DDR training.
+    Other parameters for training are assumed well set before calling here.
+*/
+void ddrTraining()
+{
+    unsigned long ulTmp;
+
+    ulTmp = peekRegisterDWord(CLOCK_ENABLE);
+
+    //Shut off all active components, espically ARM
+    pokeRegisterDWord(CLOCK_ENABLE, 0);
+
+    pokeRegisterDWord(PIR, 0);
+    pokeRegisterDWord(PIR, 0x1ff);
+
+    // May take few cycles for PGSR.IDONE = 0 after kick off DDR training.
+    while((PHY_STATUS(PGSR, 0x00000001))){}
+
+    // Wait until DDR training completed
+    while(!(PHY_STATUS(PGSR, 0x00000001))){}
+
+    //Restore clocks
+    pokeRegisterDWord(CLOCK_ENABLE, ulTmp);
+}
+#endif
+
diff --git a/drivers/gpu/drm/smi/ddk768/ddk768_chip.h b/drivers/gpu/drm/smi/ddk768/ddk768_chip.h
new file mode 100644
index 000000000000..385bd6598319
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk768/ddk768_chip.h
@@ -0,0 +1,84 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2008 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  CHIP.H --- SMI DDK 
+*  This file contains the source code for the SM750/SM718 chip.
+* 
+*******************************************************************/
+#ifndef _DDK768_CHIP_H_
+#define _DDK768_CHIP_H_
+
+/* This is all the chips recognized by this library */
+typedef enum _logical_chip_type_t
+{
+    SM_UNKNOWN = 0,
+    SM768 = 1
+}
+logical_chip_type_t;
+
+/* input struct to initChipParam() function */
+typedef struct _initchip_param_t
+{
+
+    unsigned short setAllEngOff; /* 0 = leave all engine state untouched.
+                                    1 = make sure they are off: 2D, Overlay,
+                                    video alpha, alpha, hardware cursors
+                                 */
+
+    /* More initialization parameter can be added if needed */
+}
+initchip_param_t;
+
+
+/*
+ * This function returns frame buffer memory size in Byte units.
+ */
+unsigned long ddk768_getFrameBufSize(void);
+
+
+
+/*
+ * This function returns the logical chip type defined in chip.h
+ * It is one of the following: SM501, SM502, SM107, SM718, SM 750 or
+ * SM_UNKNOWN.
+ */
+logical_chip_type_t ddk768_getChipType(void);
+
+/*
+ * Return a char string name of the current chip.
+ * It's convenient for application need to display the chip name.
+ */
+char * ddk768_getChipTypeString(void);
+
+/*
+ * Initialize a single chip and environment according to input parameters.
+ *
+ * Input: initchip_param_t structure.
+ *
+ * Return: 0 (or NO_ERROR) if successful.
+ *        -1 if fail.
+ *
+ */
+long ddk768_initChipParamEx(initchip_param_t * pInitParam);
+
+/*
+ * Initialize the chip with default parameters.
+ *
+ * Input: none.
+ *
+ * Return: 0 (or NO_ERROR) if successful.
+ *        -1 if fail.
+ */
+long ddk768_initChip(void);
+
+#define MB(x) (x<<20) /* Macro for Mega Bytes */
+
+
+
+
+#endif /* _CHIP_H_ */
+
diff --git a/drivers/gpu/drm/smi/ddk768/ddk768_clock.c b/drivers/gpu/drm/smi/ddk768/ddk768_clock.c
new file mode 100644
index 000000000000..ba575abcd6e3
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk768/ddk768_clock.c
@@ -0,0 +1,182 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2016 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  CLOCK.C --- Falcon  DDK 
+*  This file contains source code for the Falcon  PLL's
+* 
+*******************************************************************/
+#include "ddk768_reg.h"
+
+#include "ddk768_chip.h"
+#include "ddk768_power.h"
+#include "ddk768_clock.h"
+#include "ddk768_mode.h"
+
+
+#include "ddk768_help.h"
+#include "ddk768_helper.h"
+
+/*
+ * A local function to calculate the output frequency of a given PLL structure.
+ *
+ */
+unsigned long ddk768_calcPLL(pll_value_t *pPLL)
+{
+    unsigned long pllClk, vcoPower;
+    unsigned long fifteenPower = ddk768_twoToPowerOfx(15); /* 2^15 */
+
+    /* Convert everything in Khz range in order to avoid calculation overflow */
+    pPLL->inputFreq /= 1000;
+    
+    /* Work out 2 to the power of (VCO + 1) */
+    vcoPower = ddk768_twoToPowerOfx(pPLL->VCO + 1);
+    
+    pllClk = (pPLL->inputFreq * pPLL->INT + pPLL->inputFreq * pPLL->FRAC / fifteenPower) / vcoPower;
+    
+    /* Restore input frequency from Khz to hz unit */
+    pPLL->inputFreq *= 1000;
+    pllClk *= 1000;
+
+    return pllClk;
+}
+
+/*
+ * Given a requested clock frequency, this function calculates the 
+ * best INT, FRAC, VCO and BS values for the PLL.
+ * 
+ * Input: Requested pixel clock in Hz unit.
+ *        The followiing fields of PLL has to be set up properly:
+ *        pPLL->inputFreq.
+ *
+ * Output: Update the PLL structure with the proper values
+ * Return: The actual clock in Hz that the PLL is able to set up.
+ *
+ */
+unsigned long ddk768_calcPllValue(
+unsigned long ulRequestClk, /* Required pixel clock in Hz unit */
+pll_value_t *pPLL           /* Structure to hold the value to be set in PLL */
+)
+{
+
+		unsigned long INTEGER, FRAC, VCO,  diff, pllClk, vcoPower, tempRequestClk;
+		unsigned long bestDiff = 0xffffffff; /* biggest 32 bit unsigned number */
+		unsigned long fifteenPower = ddk768_twoToPowerOfx(15); /* 2^15 */
+	
+		/* Init PLL structure to known states */
+		pPLL->INT = 0;
+		pPLL->FRAC = 0;
+		pPLL->VCO = 0;
+		pPLL->BS = 0;
+	
+		/* Convert everything in Khz range in order to avoid calculation overflow */
+		pPLL->inputFreq /= 1000;
+		tempRequestClk = ulRequestClk / 1000;
+	
+		/* If the requested clock is higher than 1 GHz, then set it to the maximum, which is
+		   1 GHz. */
+		if (tempRequestClk > MHz(1))
+			tempRequestClk = MHz(1);
+	
+		/* The maximum of VCO is 5. */
+		for (VCO=0; VCO<=5; VCO++)
+		{
+			/* Work out 2 to the power of (VCO + 1) */
+			vcoPower = ddk768_twoToPowerOfx(VCO + 1);
+	
+			INTEGER = tempRequestClk * vcoPower / pPLL->inputFreq;
+	
+			/* 28 <= INT <= 56 */
+			if ((INTEGER >= 28) && (INTEGER <=56))
+			{
+				/* FRAC = (requestClk * vcoPower / inputFreq - INT ) * (2^15)
+				  Use formula as following to avoid decimal calculation:
+				  FRAC = (requestClk * vcoPower - INT * inputFreq) * (2^15) / inputFreq
+				*/
+				FRAC = ((tempRequestClk * vcoPower) - (INTEGER * pPLL->inputFreq)) * fifteenPower / pPLL->inputFreq;
+	
+				/* FRAC field has 15 bits, reject value bigger than 15 bits */
+				if (FRAC < FRAC_MAX)
+				{
+					/* Calculate the actual clock for a given INT & FRAC */
+					pllClk = (pPLL->inputFreq * INTEGER + pPLL->inputFreq * FRAC / fifteenPower) / vcoPower;
+					
+					/* How much are we different from the requirement */
+					diff = ddk768_absDiff(pllClk, tempRequestClk);
+	
+					if (diff < bestDiff)
+					{
+						bestDiff = diff;
+	
+						/* Store INT and FRAC values */
+						pPLL->INT  = INTEGER;
+						pPLL->FRAC = FRAC;
+						pPLL->VCO = VCO;
+					}
+				}
+			}
+		}
+	
+		/* Calculate BS value */
+		if ((pPLL->INT >= 28) && (pPLL->INT < 35))
+		{
+			pPLL->BS = 0;
+		}
+		else if ((pPLL->INT >=35) && (pPLL->INT < 42))
+		{
+			pPLL->BS = 1;
+		}
+		else if ((pPLL->INT >= 42) && (pPLL->INT < 49))
+		{
+			pPLL->BS = 2;
+		}
+		else if ((pPLL->INT >= 49) && (pPLL->INT <= 56))
+		{
+			pPLL->BS = 3;
+		}
+		
+		/* Restore input frequency from Khz to hz unit */
+		pPLL->inputFreq *= 1000;
+#if 0	
+		/* Output debug information */
+		DDKDEBUGPRINT((DISPLAY_LEVEL, "calcPllValue: Requested Frequency = %d\n", ulRequestClk));
+		DDKDEBUGPRINT((DISPLAY_LEVEL, "calcPllValue: Input CLK = %dHz, INT=%d, FRAC=%d, VCO=%d, BS=%d\n", 
+							pPLL->inputFreq, pPLL->INT, pPLL->FRAC, pPLL->VCO, pPLL->BS));
+#endif	
+		/* Return actual frequency that the PLL can set */
+		return ddk768_calcPLL(pPLL);
+
+    
+}
+
+/*
+ * Set up the corresponding bit field of the programmable PLL register.
+ *
+ * Input: Pointer to PLL structure with all values set up properly.
+ *
+ */
+unsigned long ddk768_formatPllReg(pll_value_t *pPLL)
+{
+
+     unsigned long ulPllReg = 0;
+
+    /* Note that all PLL's have the same format. Here, we just use Panel PLL parameter
+       to work out the bit fields in the register.
+       On returning a 32 bit number, the value can be applied to any PLL in the calling function.
+    */
+    ulPllReg =
+        FIELD_SET(0, VCLK_PLL, FN, FRAC_MODE)
+      | FIELD_VALUE(0, VCLK_PLL, BS, pPLL->BS)      
+      | FIELD_VALUE(0, VCLK_PLL, VCO, pPLL->VCO)
+      | FIELD_VALUE(0, VCLK_PLL, INT, pPLL->INT)
+      | FIELD_VALUE(0, VCLK_PLL, FRAC, pPLL->FRAC);
+
+    return(ulPllReg);
+
+}
+
+
+
diff --git a/drivers/gpu/drm/smi/ddk768/ddk768_clock.h b/drivers/gpu/drm/smi/ddk768/ddk768_clock.h
new file mode 100644
index 000000000000..5edb6eb2b4a0
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk768/ddk768_clock.h
@@ -0,0 +1,68 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2016 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  CLOCK.H --- Falcon DDK 
+* 
+*******************************************************************/
+#ifndef _DDK768_CLOCK_H_
+#define _DDK768_CLOCK_H_
+
+#define DEFAULT_INPUT_CLOCK 12000000 /* Default reference clock */
+#define MHz(x) (x*1000000) /* Don't use this macro if x is fraction number */
+
+#define DEFAULT_INPUT_CLOCK MHz(12) /* Default reference clock */
+
+#define GHz(x) (x*1000000000)   //1000000000HZ  = 1(Ghz)
+#define FRAC_MAX    32768
+
+typedef struct pll_value_t
+{
+    unsigned long inputFreq; /* Input clock frequency to the PLL */
+    unsigned long INT;
+    unsigned long FRAC;
+    unsigned long VCO;
+    unsigned long BS;
+}
+pll_value_t;
+
+/*
+ * Given a requested clock frequency, this function calculates the 
+ * best INT, FRAC, VCO and BS values for the PLL.
+ * 
+ * Input: Requested pixel clock in Hz unit.
+ *        The followiing fields of PLL has to be set up properly:
+ *        pPLL->inputFreq.
+ *
+ * Output: Update the PLL structure with the proper values
+ * Return: The actual clock in Hz that the PLL is able to set up.
+ *
+ */
+unsigned long ddk768_calcPllValue(
+unsigned long ulRequestClk, /* Required pixel clock in Hz unit */
+pll_value_t *pPLL           /* Structure to hold the value to be set in PLL */
+);
+
+/*
+ * Set up the corresponding bit field of the programmable PLL register.
+ *
+ * Input: Pointer to PLL structure with all values set up properly.
+ *
+ */
+unsigned long ddk768_formatPllReg(pll_value_t *pPLL);
+
+/*
+    This funtion sets up pixel clock for Falcon FPGA.
+    Final product will have another PLL clock.
+*/
+
+long ddk768_setVclock(unsigned dispCtrl, unsigned long pixelClock);
+
+
+
+
+
+#endif /*_CLOCK_H_*/
diff --git a/drivers/gpu/drm/smi/ddk768/ddk768_cursor.c b/drivers/gpu/drm/smi/ddk768/ddk768_cursor.c
new file mode 100644
index 000000000000..30a08028e1e7
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk768/ddk768_cursor.c
@@ -0,0 +1,100 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2007 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  CURSOR.C --- Voyager GX SDK 
+*  This file contains the definitions for the Panel cursor functions.
+* 
+*******************************************************************/
+#include "ddk768.h"
+
+#include "ddk768_cursor.h"
+
+/*
+ * This function initializes the cursor attributes.
+ */
+void ddk768_initCursor(
+    disp_control_t dispControl,     /* Display control (CHANNEL0_CTRL or CHANNEL1_CTRL) */
+    unsigned long base,             /* Base Address */ 
+    unsigned long color1,           /* Cursor color 1 in RGB 5:6:5 format */
+    unsigned long color2,           /* Cursor color 2 in RGB 5:6:5 format */
+    unsigned long color3            /* Cursor color 3 in RGB 5:6:5 format */
+)
+{
+    /*
+     * 1. Set the cursor source address 
+     */
+    pokeRegisterDWord(
+        (dispControl == CHANNEL0_CTRL) ? CHANNEL0_HWC_ADDRESS : CHANNEL1_HWC_ADDRESS,
+        FIELD_VALUE(0, CHANNEL0_HWC_ADDRESS, ADDRESS, base));
+        
+    /*
+     * 2. Set the cursor color composition 
+     */
+    pokeRegisterDWord(
+        (dispControl == CHANNEL0_CTRL) ? CHANNEL0_HWC_COLOR_0 : CHANNEL1_HWC_COLOR_0, 
+        FIELD_VALUE(0, CHANNEL0_HWC_COLOR_0, RGB888, color1));
+
+    pokeRegisterDWord(
+        (dispControl == CHANNEL0_CTRL) ? CHANNEL0_HWC_COLOR_1 : CHANNEL1_HWC_COLOR_1, 
+        FIELD_VALUE(0, CHANNEL0_HWC_COLOR_1, RGB888, color2));
+
+}
+
+/*
+ * This function sets the cursor position.
+ */
+void ddk768_setCursorPosition(
+    disp_control_t dispControl,     /* Display control (CHANNEL0_CTRL or CHANNEL1_CTRL) */
+    unsigned long dx,               /* X Coordinate of the cursor */
+    unsigned long dy,               /* Y Coordinate of the cursor */
+    unsigned char topOutside,       /* Top Boundary Select: either partially outside (= 1) 
+                                       or within the screen top boundary (= 0) */
+    unsigned char leftOutside       /* Left Boundary Select: either partially outside (= 1) 
+                                       or within the screen left boundary (= 0) */
+)
+{  
+    unsigned long value;
+
+    /* Set the XY coordinate */
+    value = FIELD_VALUE(0, HWC_LOCATION, X, dx) |
+            FIELD_VALUE(0, HWC_LOCATION, Y, dy);
+    
+    /* Set the top boundary select either partially outside the top boundary
+       screen or inside */
+    if (topOutside)
+        value = FIELD_SET(value, HWC_LOCATION, TOP, OUTSIDE);
+    else         
+        value = FIELD_SET(value, HWC_LOCATION, TOP, INSIDE);
+
+    /* Set the left boundary select either partially outside the left boundary
+       screen or inside */
+    if (leftOutside)
+        value = FIELD_SET(value, HWC_LOCATION, LEFT, OUTSIDE);
+    else        
+        value = FIELD_SET(value, HWC_LOCATION, LEFT, INSIDE);
+
+    /* Set the register accordingly, either Panel cursor or CRT cursor */
+    pokeRegisterDWord((dispControl == CHANNEL0_CTRL) ? HWC_LOCATION : (HWC_LOCATION+CHANNEL_OFFSET), value);
+}
+
+/*
+ * This function enables/disables the cursor.
+ */
+void ddk768_enableCursor(
+    disp_control_t dispControl, /* Display control (CHANNEL0_CTRL or CHANNEL1_CTRL) */
+    unsigned long mode			/* Cursor type - 00 disable, 0x01 mask cursor, 0x02 mono, 0x03 alpha cursor */
+)
+{
+    unsigned long cursorRegister, value;
+
+    cursorRegister = (dispControl == CHANNEL0_CTRL) ? HWC_CONTROL : (HWC_CONTROL+CHANNEL_OFFSET);
+    
+	value = peekRegisterDWord(cursorRegister);
+    value = FIELD_VALUE(value, HWC_CONTROL, MODE, mode);
+    
+    pokeRegisterDWord(cursorRegister, value);
+}
diff --git a/drivers/gpu/drm/smi/ddk768/ddk768_cursor.h b/drivers/gpu/drm/smi/ddk768/ddk768_cursor.h
new file mode 100644
index 000000000000..59afd2990675
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk768/ddk768_cursor.h
@@ -0,0 +1,54 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2007 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  cursor.h --- SMI DDK 
+*  This file contains the definitions for the cursor functions.
+* 
+*******************************************************************/
+#ifndef _DDK768_CURSOR_H_
+#define _DDK768_CURSOR_H_
+
+#include "ddk768_mode.h"
+
+#define CURSOR_DISABLE	0x00
+#define CURSOR_ALPHA	0x01
+#define CURSOR_MONO		0x02
+#define CURSOR_MASK		0x03
+
+/*
+ * This function initializes the cursor attributes.
+ */
+void ddk768_initCursor(
+    disp_control_t dispControl,     /* Display control (CHANNEL0_CTRL or CHANNEL1_CTRL) */
+    unsigned long base,             /* Base Address */ 
+    unsigned long color1,           /* Cursor color 1 in RGB 5:6:5 format */
+    unsigned long color2,           /* Cursor color 2 in RGB 5:6:5 format */
+    unsigned long color3            /* Cursor color 3 in RGB 5:6:5 format */
+);
+
+/*
+ * This function sets the cursor position.
+ */
+void ddk768_setCursorPosition(
+    disp_control_t dispControl,     /* Display control (CHANNEL0_CTRL or CHANNEL1_CTRL) */
+    unsigned long dx,               /* X Coordinate of the cursor */
+    unsigned long dy,               /* Y Coordinate of the cursor */
+    unsigned char topOutside,       /* Top Boundary Select: either partially outside (= 1) 
+                                       or within the screen top boundary (= 0) */
+    unsigned char leftOutside       /* Left Boundary Select: either partially outside (= 1) 
+                                       or within the screen left boundary (= 0) */
+);
+
+/*
+ * This function enables/disables the cursor.
+ */
+void ddk768_enableCursor(
+    disp_control_t dispControl,     /* Display control (CHANNEL0_CTRL or CHANNEL1_CTRL) */
+    unsigned long enable
+);
+
+#endif /* _CURSOR_H_ */
diff --git a/drivers/gpu/drm/smi/ddk768/ddk768_display.c b/drivers/gpu/drm/smi/ddk768/ddk768_display.c
new file mode 100644
index 000000000000..946bbe873983
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk768/ddk768_display.c
@@ -0,0 +1,628 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2007 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  DISPLAY.C --- Voyager GX SDK 
+*  This file contains the source code for the panel and CRT functions.
+* 
+*******************************************************************/
+#include "ddk768_reg.h"
+
+
+#include "ddk768_chip.h"
+#include "ddk768_power.h"
+#include "ddk768_display.h"
+#include "ddk768_timer.h"
+
+#include "ddk768_help.h"
+
+
+/* Monitor Detection RGB Default Threshold values */
+#define DEFAULT_MON_DETECTION_THRESHOLD         0x64
+
+/*
+ * This function initializes the display.
+ *
+ * Output:
+ *      0   - Success
+ *      1   - Fail 
+ */
+long initDisplay()
+{
+#if 0
+    /* set 80024[30:28] and 88024[30:28] to 0x3 in order for the DAC to output stronger signal. */
+    unsigned long value;
+    value = peekRegisterDWord(MONITOR_DETECT);
+    value &= 0xCFFFFFFF;
+    value |= 0x30000000;
+    pokeRegisterDWord(MONITOR_DETECT, value);
+    value = peekRegisterDWord(MONITOR_DETECT + CHANNEL_OFFSET);
+    value &= 0xCFFFFFFF;
+    value |= 0x30000000;
+    pokeRegisterDWord(MONITOR_DETECT + CHANNEL_OFFSET, value);
+#endif
+    return 0;
+
+}
+
+/* New for Falcon: DPMS control is moved to display controller.
+ * This function sets the display DPMS state 
+ * It is used to set CRT monitor to On, off, or suspend states, 
+ * while display channel are still active.
+ */
+void setDisplayDPMS(
+   disp_control_t dispControl, /* Channel 0 or Channel 1) */
+   DISP_DPMS_t state /* DPMS state */
+   )
+{
+    unsigned long ulDispCtrlAddr;
+    unsigned long ulDispCtrlReg;
+
+	/* Get the control register for channel 0 or 1. */
+    ulDispCtrlAddr = (dispControl == CHANNEL0_CTRL)? DISPLAY_CTRL : (DISPLAY_CTRL+CHANNEL_OFFSET);
+    ulDispCtrlReg = peekRegisterDWord(ulDispCtrlAddr);
+
+    switch (state)
+    {
+       case DISP_DPMS_ON:
+        ulDispCtrlReg = FIELD_SET(ulDispCtrlReg, DISPLAY_CTRL, DPMS, VPHP);
+        break;
+
+       case DISP_DPMS_STANDBY:
+        ulDispCtrlReg = FIELD_SET(ulDispCtrlReg, DISPLAY_CTRL, DPMS, VPHN);
+        break;
+
+       case DISP_DPMS_SUSPEND:
+        ulDispCtrlReg = FIELD_SET(ulDispCtrlReg, DISPLAY_CTRL, DPMS, VNHP);
+        break;
+
+       case DISP_DPMS_OFF:
+        ulDispCtrlReg = FIELD_SET(ulDispCtrlReg, DISPLAY_CTRL, DPMS, VNHN);
+        break;
+    }
+
+    pokeRegisterDWord(ulDispCtrlAddr, ulDispCtrlReg);
+}
+
+/* 
+ * New for Falcon.
+ * This funciton configures:
+ * 1. Output from channel 0 or channel 1 is 24 single or 48 double pixel.
+ * 2. Output data comes from data path of channel 0 or channel 1.
+ *
+ * Input: See the commnet in the input parameter below.
+ *
+ * Return: 0 is OK, -1 is error.
+ */
+long setDisplayFormat(
+   disp_control_t outputInterface, /* Use the output of channel 0 or 1 */
+   disp_control_t dataPath,        /* Use the data path from channel 0 or 1 */
+   disp_format_t dispFormat         /* 24 bit single or 48 bit double pixel */
+   )
+{
+   unsigned long ulDispCtrlAddr, ulDispCtrlReg;
+
+   ulDispCtrlAddr = (outputInterface == CHANNEL0_CTRL)? DISPLAY_CTRL : (DISPLAY_CTRL+CHANNEL_OFFSET);
+   ulDispCtrlReg = peekRegisterDWord(ulDispCtrlAddr);
+
+   if (dispFormat == DOUBLE_PIXEL_48BIT)
+   {
+      if (dataPath == CHANNEL0_CTRL)
+           ulDispCtrlReg = FIELD_SET(ulDispCtrlReg, DISPLAY_CTRL, CHANNEL_OUTPUT_FORMAT, CHANNEL0_48BIT);
+      else
+           ulDispCtrlReg = FIELD_SET(ulDispCtrlReg, DISPLAY_CTRL, CHANNEL_OUTPUT_FORMAT, CHANNEL1_48BIT);
+
+        // When in 48 bit mode, enable double pixel clock
+        ulDispCtrlReg = FIELD_SET(ulDispCtrlReg, DISPLAY_CTRL, DOUBLE_PIXEL_CLOCK, ENABLE);
+   }
+   else
+   {
+      if (dataPath == CHANNEL0_CTRL)
+           ulDispCtrlReg = FIELD_SET(ulDispCtrlReg, DISPLAY_CTRL, CHANNEL_OUTPUT_FORMAT, CHANNEL0_24BIT);
+      else
+           ulDispCtrlReg = FIELD_SET(ulDispCtrlReg, DISPLAY_CTRL, CHANNEL_OUTPUT_FORMAT, CHANNEL1_24BIT);
+
+        // When in 24 bit mode, disable double pixel.
+        ulDispCtrlReg = FIELD_SET(ulDispCtrlReg, DISPLAY_CTRL, DOUBLE_PIXEL_CLOCK, DISABLE);
+   }
+
+   pokeRegisterDWord(ulDispCtrlAddr, ulDispCtrlReg);
+
+   return 0;
+}
+
+/*
+ * Wait number of Vertical Vsync
+ *
+ * Input:
+ *          dispControl - Display Control (either channel 0 or 1)
+ *          vSyncCount  - Number of vertical sync to wait.
+ *
+ * Note:
+ *      This function is waiting for the next vertical sync.         
+ */
+void waitDispVerticalSync(disp_control_t dispControl, unsigned long vSyncCount)
+{
+    unsigned long ulDispCtrlAddr;
+    unsigned long status;
+    unsigned long ulLoopCount = 0;
+    static unsigned long ulDeadLoopCount = 10;
+    
+    if (dispControl == CHANNEL0_CTRL)
+    {
+        // There is no Vsync when PLL is off
+        if ((FIELD_GET(peekRegisterDWord(CLOCK_ENABLE), CLOCK_ENABLE, DC0) == CLOCK_ENABLE_DC0_OFF))
+            return;
+
+        ulDispCtrlAddr = DISPLAY_CTRL;
+    }
+    else
+    {
+        // There is no Vsync when PLL is off
+        if ((FIELD_GET(peekRegisterDWord(CLOCK_ENABLE), CLOCK_ENABLE, DC1) == CLOCK_ENABLE_DC1_OFF))
+            return;
+
+        ulDispCtrlAddr = DISPLAY_CTRL+CHANNEL_OFFSET;
+    }
+
+    //There is no Vsync when display timing is off. 
+    if ((FIELD_GET(peekRegisterDWord(ulDispCtrlAddr), DISPLAY_CTRL, TIMING) ==
+         DISPLAY_CTRL_TIMING_DISABLE))
+    {
+            return;
+    }
+
+    /* Count number of Vsync. */
+    while (vSyncCount-- > 0)
+    {
+        /* If VSync is active when entering this function. Ignore it and
+           wait for the next.
+        */
+        ulLoopCount = 0;
+        do
+        {
+            status = FIELD_GET(peekRegisterDWord(ulDispCtrlAddr), DISPLAY_CTRL, VSYNC);
+            //Insert delay to reduce number of Vsync checks
+            timerWaitTicks(3, 0xffff);
+            if(ulLoopCount++ > ulDeadLoopCount) break;
+        }
+        while (status == DISPLAY_CTRL_VSYNC_ACTIVE);
+
+        /* Wait for end of vsync or timeout */
+        ulLoopCount = 0;
+        do
+        {
+            status = FIELD_GET(peekRegisterDWord(ulDispCtrlAddr), DISPLAY_CTRL, VSYNC);
+            timerWaitTicks(3, 0xffff);
+            if(ulLoopCount++ > ulDeadLoopCount) break;
+        }
+        while (status == DISPLAY_CTRL_VSYNC_INACTIVE);
+    }
+}
+
+/*
+ * Use panel vertical sync line as time delay function.
+ * This function does not wait for the next VSync. Instead, it will wait
+ * until the current line reaches the Vertical Sync line.
+ * This function is really useful when flipping display to prevent tearing.
+ *
+ * Input: display control (CHANNEL0_CTRL or CHANNEL1_CTRL)
+ */
+void ddk768_waitVSyncLine(disp_control_t dispControl)
+{
+    unsigned long ulDispCtrlAddr;
+    unsigned long value;
+    mode_parameter_t modeParam;
+    
+    ulDispCtrlAddr = (dispControl == CHANNEL0_CTRL)? CURRENT_LINE : (CURRENT_LINE+CHANNEL_OFFSET);
+
+    /* Get the current mode parameter of the specific display control */
+    modeParam = ddk768_getCurrentModeParam(dispControl);
+    
+    do
+    {
+    	value = FIELD_GET(peekRegisterDWord(ulDispCtrlAddr), CURRENT_LINE, LINE);
+    }
+    while (value < modeParam.vertical_sync_start);
+}
+
+/*
+ * Get current display line number
+ */
+unsigned long getDisplayLine(disp_control_t dispControl)
+{
+    unsigned long ulRegAddr;
+    unsigned long ulRegValue;
+    
+    ulRegAddr = (dispControl == CHANNEL0_CTRL)? CURRENT_LINE : (CURRENT_LINE+DC_OFFSET);
+    ulRegValue = FIELD_GET(peekRegisterDWord(ulRegAddr), CURRENT_LINE, LINE);
+
+    return(ulRegValue);
+}
+
+/*
+ * This functions uses software sequence to turn on/off the panel of the digital interface.
+ */
+void ddk768_swPanelPowerSequence(disp_control_t dispControl, disp_state_t dispState, unsigned long vSyncDelay)
+{
+    unsigned long ulDispCtrlAddr;
+    unsigned long ulDispCtrlReg;
+
+
+    ulDispCtrlAddr = (dispControl == CHANNEL0_CTRL)? DISPLAY_CTRL : (DISPLAY_CTRL+CHANNEL_OFFSET);
+    ulDispCtrlReg = peekRegisterDWord(ulDispCtrlAddr);
+
+    if (dispState == DISP_ON)
+    {
+        //If bit 27:24 are already ON. Don't need to set them again 
+        //because setting panel seq is time consuming.
+        if ((ulDispCtrlReg & 0x0f000000) == 0x0f000000) return;
+
+        /* Turn on FPVDDEN. */
+        ulDispCtrlReg = FIELD_SET(ulDispCtrlReg, DISPLAY_CTRL, FPVDDEN, HIGH);
+        pokeRegisterDWord(ulDispCtrlAddr, ulDispCtrlReg);
+		waitDispVerticalSync(dispControl, vSyncDelay);
+
+        /* Turn on FPDATA. */
+        ulDispCtrlReg = FIELD_SET(ulDispCtrlReg, DISPLAY_CTRL, DATA, ENABLE);
+        pokeRegisterDWord(ulDispCtrlAddr, ulDispCtrlReg);
+		waitDispVerticalSync(dispControl, vSyncDelay);
+
+        /* Turn on FPVBIAS. */
+        ulDispCtrlReg = FIELD_SET(ulDispCtrlReg, DISPLAY_CTRL, VBIASEN, HIGH);
+        pokeRegisterDWord(ulDispCtrlAddr, ulDispCtrlReg);
+		waitDispVerticalSync(dispControl, vSyncDelay);
+
+        /* Turn on FPEN. */
+        ulDispCtrlReg = FIELD_SET(ulDispCtrlReg, DISPLAY_CTRL, FPEN, HIGH);
+        pokeRegisterDWord(ulDispCtrlAddr, ulDispCtrlReg);
+    }
+    else
+    {
+        //If bit 27:24 are already OFF. Don't need to clear them again.
+        if ((ulDispCtrlReg & 0x0f000000) == 0x00000000) return;
+
+        /* Turn off FPEN. */
+        ulDispCtrlReg = FIELD_SET(ulDispCtrlReg, DISPLAY_CTRL, FPEN, LOW);
+        pokeRegisterDWord(ulDispCtrlAddr, ulDispCtrlReg);
+		waitDispVerticalSync(dispControl, vSyncDelay);
+
+
+        /* Turn off FPVBIASEN. */
+        ulDispCtrlReg = FIELD_SET(ulDispCtrlReg, DISPLAY_CTRL, VBIASEN, LOW);
+        pokeRegisterDWord(ulDispCtrlAddr, ulDispCtrlReg);
+		waitDispVerticalSync(dispControl, vSyncDelay);
+
+        /* Turn off FPDATA. */
+        ulDispCtrlReg = FIELD_SET(ulDispCtrlReg, DISPLAY_CTRL, DATA, DISABLE);
+        pokeRegisterDWord(ulDispCtrlAddr, ulDispCtrlReg);
+		waitDispVerticalSync(dispControl, vSyncDelay);
+
+        /* Turn off FPVDDEN. */
+        ulDispCtrlReg = FIELD_SET(ulDispCtrlReg, DISPLAY_CTRL, FPVDDEN, LOW);
+        pokeRegisterDWord(ulDispCtrlAddr, ulDispCtrlReg);
+    }
+
+}
+
+/* 
+ * This function turns on/off the DAC for CRT display control.
+ * Input: On or off
+ */
+void ddk768_setDAC(disp_state_t state)
+{
+
+#if 1
+	/* Cheok(10/16/2013): For Falcon, DAC definition not exist yet.*/
+
+#else
+    if (state == DISP_ON)
+    {
+        pokeRegisterDWord(MISC_CTRL, FIELD_SET(peekRegisterDWord(MISC_CTRL),
+                                               MISC_CTRL,
+                                               DAC_POWER,
+                                               ON));
+    }
+    else
+    {
+        pokeRegisterDWord(MISC_CTRL, FIELD_SET(peekRegisterDWord(MISC_CTRL),
+                                               MISC_CTRL,
+                                               DAC_POWER,
+                                               OFF));
+    }
+#endif
+}
+
+/*
+ * This function turns on/off the display control of Channel 0 or channel 1.
+ *
+ * Note:
+ *      Turning on/off the timing and the plane requires programming sequence.
+ *      The plane can not be changed without turning on the timing. However,
+ *      changing the plane has no effect when the timing (clock) is off. Below,
+ *      is the description of the timing and plane combination setting.
+ */
+//Cheok(10/18/2013): New function similar to setDisplayControl()
+void ddk768_setDisplayEnable(
+   disp_control_t dispControl, /* Channel 0 or Channel 1) */
+   disp_state_t dispState      /* ON or OFF */
+)
+{
+    unsigned long ulDispCtrlAddr;
+    unsigned long ulDispCtrlReg;
+
+    ulDispCtrlAddr = (dispControl == CHANNEL0_CTRL)? DISPLAY_CTRL : (DISPLAY_CTRL+CHANNEL_OFFSET);
+    ulDispCtrlReg = peekRegisterDWord(ulDispCtrlAddr);
+
+
+
+    /* Turn on/off the Panel display control */
+    if (dispState == DISP_ON)
+    {
+         /* Timing should be enabled first before enabling the plane because changing at the
+            same time does not guarantee that the plane will also enabled or disabled. 
+          */
+         ulDispCtrlReg = FIELD_SET(ulDispCtrlReg, DISPLAY_CTRL, TIMING, ENABLE);
+         ulDispCtrlReg = FIELD_SET(ulDispCtrlReg, DISPLAY_CTRL, DIRECTION, INPUT); 
+         pokeRegisterDWord(ulDispCtrlAddr, ulDispCtrlReg);
+
+         ulDispCtrlReg = FIELD_SET(ulDispCtrlReg, DISPLAY_CTRL, PLANE, ENABLE)|        
+                            FIELD_SET(0, DISPLAY_CTRL, DATA_PATH, EXTENDED); 
+         pokeRegisterDWord(ulDispCtrlAddr, ulDispCtrlReg);
+    }
+    else
+    {
+         /* When turning off, there is no rule on the programming sequence since whenever the
+            clock is off, then it does not matter whether the plane is enabled or disabled.
+            Note: Modifying the plane bit will take effect on the next vertical sync. Need to
+                  find out if it is necessary to wait for 1 vsync before modifying the timing
+                  enable bit. 
+          */
+         ulDispCtrlReg = FIELD_SET(ulDispCtrlReg, DISPLAY_CTRL, PLANE, DISABLE);
+         pokeRegisterDWord(ulDispCtrlAddr, ulDispCtrlReg);
+
+         ulDispCtrlReg = FIELD_SET(ulDispCtrlReg, DISPLAY_CTRL, TIMING, DISABLE);
+         pokeRegisterDWord(ulDispCtrlAddr, ulDispCtrlReg);
+
+    }
+
+
+}
+
+
+/*
+ * This function set display channel data direction.
+ *
+ */
+
+void setDataDirection(
+   disp_control_t dispControl, /* Channel 0 or Channel 1) */
+   disp_state_t dispState      /* ON or OFF */
+)
+{
+    unsigned long ulDispCtrlAddr;
+    unsigned long ulDispCtrlReg;
+    if (dispState == DISP_ON)
+    {
+         ulDispCtrlAddr = (dispControl == CHANNEL0_CTRL)? DISPLAY_CTRL : (DISPLAY_CTRL+CHANNEL_OFFSET);
+         ulDispCtrlReg = peekRegisterDWord(ulDispCtrlAddr);
+
+         /*set data direction */ 
+         ulDispCtrlReg = FIELD_SET(ulDispCtrlReg, DISPLAY_CTRL, DIRECTION, INPUT); 
+         pokeRegisterDWord(ulDispCtrlAddr, ulDispCtrlReg);
+
+
+     }
+}
+
+
+
+
+/*
+ * This function detects if the CRT monitor is attached.
+ *
+ * Input:
+ *      redValue    - Threshold value to be detected on the red color.
+ *      greenValue  - Threshold value to be detected on the green color.
+ *      blueValue   - Threshold value to be detected on the blue color.
+ *
+ * Output:
+ *      0   - Success
+ *     -1   - Fail 
+ */
+long ddk768_detectCRTMonitor(
+    disp_control_t dispControl, 
+    unsigned char redValue,
+    unsigned char greenValue,
+    unsigned char blueValue
+)
+{
+    unsigned long ulMonitorDetectAddr;
+    unsigned long value, red, green, blue;
+    long result = (-1);
+
+    ulMonitorDetectAddr = (dispControl == CHANNEL0_CTRL)? CRT_DETECT : (CRT_DETECT+DC_OFFSET);
+    
+    /* Use the given red, green, and blue threshold value to detect the monitor or
+       default. */
+    if (redValue != 0)
+        red = redValue;
+    else
+        red = DEFAULT_MON_DETECTION_THRESHOLD;
+        
+    if (greenValue != 0)
+        green = greenValue;
+    else
+        green = DEFAULT_MON_DETECTION_THRESHOLD;
+        
+    if (blueValue != 0)
+        blue = blueValue;
+    else
+        blue = DEFAULT_MON_DETECTION_THRESHOLD;
+        
+    /* Set the RGB Threshold value and enable the monitor detection. */
+    value = FIELD_VALUE(0, CRT_DETECT, DATA_RED, red) |
+            FIELD_VALUE(0, CRT_DETECT, DATA_GREEN, green) |
+            FIELD_VALUE(0, CRT_DETECT, DATA_BLUE, blue) |
+            FIELD_SET(value, CRT_DETECT, ENABLE, ENABLE);
+    pokeRegisterDWord(ulMonitorDetectAddr, value);
+    
+    /* Add some delay here. Otherwise, the detection is not stable.
+       SM768 has internal timer. It's better than SW countdown loop.
+    */
+    timerWaitTicks(3, 0x7ffff);
+    
+    /* Check if the monitor is detected. */
+    if (FIELD_GET(peekRegisterDWord(ulMonitorDetectAddr), CRT_DETECT, CRT) ==
+        CRT_DETECT_CRT_PRESENT)
+    {
+        result = 0;
+    }
+    
+    /* Disable the Monitor Detect Enable bit. Somehow, enabling this bit will 
+       cause the CRT to lose display. */
+    value = peekRegisterDWord(ulMonitorDetectAddr);
+    value = FIELD_SET(value, CRT_DETECT, ENABLE, DISABLE);
+    pokeRegisterDWord(ulMonitorDetectAddr, value);
+
+    return result;
+}
+
+
+/*
+ * This function controls monitor on/off and data path.
+ * It can be used to set up any veiws: single view, clone view, dual view, output with channel swap, etc.
+ * However, it needs too many input parameter.
+ * There are other set view functions with less parameters, but not as flexible as this one.
+ *
+ */
+long setDisplayView(
+	disp_control_t dispOutput, 		/* Monitor 0 or 1 */
+	disp_state_t dispState,				/* On or off */
+	disp_control_t dataPath,			/* Use the data path of channel 0 or channel 1 (optional when OFF) */
+	disp_format_t dispFormat)			/* 24 or 48 bit digital interface (optional when OFF */
+{
+
+	ddk768_setDisplayEnable(dispOutput, dispState);         /* Enable or disable Channel output timing */
+	ddk768_swPanelPowerSequence(dispOutput, dispState, 4);  /* Turn on or off output power */
+	setDisplayFormat(dispOutput, dataPath, dispFormat); /* Set dataPath and output pixel format */
+
+#if 0
+	if (dispState == DISP_ON)
+    	setDisplayDPMS(dispOutput, DISP_DPMS_ON);          /* DPMS on */
+#endif
+	return 0;
+}
+
+/*
+ * Convenient function to trun on single view 
+ */
+long setSingleViewOn(disp_control_t dispOutput)
+{
+	setDisplayView(
+		dispOutput, 			/* Output monitor */
+		DISP_ON, 				/* Turn On */
+		dispOutput,				/* Assume monitor 0 is using data path 0, and monitor 1 is using data path 1 */
+		SINGLE_PIXEL_24BIT);	/* Default to 24 bit single pixel, the most used case */
+
+	return 0;
+}
+
+/*
+ * Convenient function to trun off single view 
+ */
+long setSingleViewOff(disp_control_t dispOutput)
+{
+	setDisplayView(
+		dispOutput, 	      /* Output monitor */
+		DISP_OFF, 		      /* Turn Off */
+		dispOutput,				/* Assume monitor 0 is using data path 0, and monitor 1 is using data path 1 */
+		SINGLE_PIXEL_24BIT);	/* Default to 24 bit single pixel, the most used case */
+
+	return 0;
+}
+
+/*
+ * Convenient function to trun on clone view 
+ */
+long setCloneViewOn(disp_control_t dataPath)
+{
+	setDisplayView(
+		CHANNEL0_CTRL,			/* For Clone view, monitor 0 has to be ON */
+		DISP_ON, 
+		dataPath,				/* Use this data path for monitor 0 */
+		SINGLE_PIXEL_24BIT);	/* Default to 24 bit single pixel, the most used case */
+
+	setDisplayView(
+		CHANNEL1_CTRL,			/* For Clone view, monitor 1 has to be ON */
+		DISP_ON, 
+		dataPath,				/* Use this data path for monitor 1 */
+		SINGLE_PIXEL_24BIT);	/* Default to 24 bit single pixel, the most used case */
+
+	return 0;
+}
+
+/*
+ * Convenient function to trun on dual view 
+ */
+long setDualViewOn()
+{
+	setSingleViewOn(CHANNEL0_CTRL);
+	setSingleViewOn(CHANNEL1_CTRL);
+
+	return 0;
+}
+
+/*
+ * Convenient function to trun off all views
+ */
+long setAllViewOff()
+{
+	setSingleViewOff(CHANNEL0_CTRL);	/* Turn Off monitor 0 */
+	setSingleViewOff(CHANNEL1_CTRL);	/* Turn Off monitor 1 */
+
+	return 0;
+}
+
+/*
+ * Disable double pixel clock. 
+ * This is a temporary function, used to patch for the random fuzzy font problem. 
+ */
+void DisableDoublePixel(disp_control_t dispControl)
+{
+	unsigned long ulDispCtrlAddr;
+	unsigned long ulDispCtrlReg;
+
+	if(dispControl == CHANNEL0_CTRL) {
+	    ulDispCtrlAddr = DISPLAY_CTRL;
+	    ulDispCtrlReg = peekRegisterDWord(ulDispCtrlAddr);
+	    ulDispCtrlReg = FIELD_SET(ulDispCtrlReg, DISPLAY_CTRL, DOUBLE_PIXEL_CLOCK, DISABLE);
+	    pokeRegisterDWord(ulDispCtrlAddr, ulDispCtrlReg);
+	}else{
+	    ulDispCtrlAddr = DISPLAY_CTRL+CHANNEL_OFFSET;
+	    ulDispCtrlReg = peekRegisterDWord(ulDispCtrlAddr);
+	    ulDispCtrlReg = FIELD_SET(ulDispCtrlReg, DISPLAY_CTRL, DOUBLE_PIXEL_CLOCK, DISABLE);
+	    pokeRegisterDWord(ulDispCtrlAddr, ulDispCtrlReg);
+	}
+}
+
+void EnableDoublePixel(disp_control_t dispControl)
+{
+	unsigned long ulDispCtrlAddr;
+	unsigned long ulDispCtrlReg;
+
+	if(dispControl == CHANNEL0_CTRL) {
+	    ulDispCtrlAddr = DISPLAY_CTRL;
+	    ulDispCtrlReg = peekRegisterDWord(ulDispCtrlAddr);
+	    ulDispCtrlReg = FIELD_SET(ulDispCtrlReg, DISPLAY_CTRL, DOUBLE_PIXEL_CLOCK, ENABLE);
+	    pokeRegisterDWord(ulDispCtrlAddr, ulDispCtrlReg);
+	}else{
+	    ulDispCtrlAddr = DISPLAY_CTRL+CHANNEL_OFFSET;
+	    ulDispCtrlReg = peekRegisterDWord(ulDispCtrlAddr);
+	    ulDispCtrlReg = FIELD_SET(ulDispCtrlReg, DISPLAY_CTRL, DOUBLE_PIXEL_CLOCK, ENABLE);
+	    pokeRegisterDWord(ulDispCtrlAddr, ulDispCtrlReg);
+	}
+}
diff --git a/drivers/gpu/drm/smi/ddk768/ddk768_display.h b/drivers/gpu/drm/smi/ddk768/ddk768_display.h
new file mode 100644
index 000000000000..628d3b178d0a
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk768/ddk768_display.h
@@ -0,0 +1,234 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2007 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  display.h --- SM750/SM718 DDK
+*  This file contains the function prototypes for the display.
+* 
+*******************************************************************/
+#ifndef _DDK768_DISPLAY_H_
+#define _DDK768_DISPLAY_H_
+#include "ddk768_mode.h"
+typedef enum _disp_path_t
+{
+    CHANNEL0_PATH = 0,
+    CHANNEL1_PATH = 1,
+}
+disp_path_t;
+
+typedef enum _disp_state_t
+{
+    DISP_OFF = 0,
+    DISP_ON  = 1,
+}
+disp_state_t;
+
+//Cheok: obsolete for Falcon, delete after old code cleans up.
+typedef enum _disp_output_t
+{
+    NO_DISPLAY,             /* All display off. */
+    LCD1_ONLY,              /* LCD1 only */
+    LCD2_ONLY,              /* LCD2 only */
+    CRT2_ONLY,              /* CRT2 only */
+    LCD1_CRT2_SIMUL,        /* Both LCD1 and CRT2 displaying the same content. */
+    LCD1_LCD2_SIMUL,        /* Both LCD1 and LCD2 displaying the same content. */
+    CRT2_LCD2_SIMUL,        /* CRT2 and LCD2 displaying the same content. */
+    LCD1_LCD2_CRT2_SIMUL,   /* LCD1, LCD2, and CRT2 displaying the same content. */
+    LCD1_CRT2_DUAL,         /* LCD1 and CRT2 displaying different contents. */
+    LCD1_LCD2_DUAL,         /* LCD1 and LCD2 displaying different contents. */
+    LCD1_LCD2_CRT2_DUAL     /* LCD2 and CRT2 displaying the same content while
+                               the Panel displaying different content. */
+}
+disp_output_t;
+
+//Cheok(10/172013): New interface for Falcon.
+typedef enum _disp_interface_t
+{
+    DIGITAL_24BIT = 0,
+    DIGITAL_48BIT,
+    CRT,
+	LVDS,
+    HDMI
+}
+disp_interface_t;
+
+typedef enum _disp_format_t
+{
+    SINGLE_PIXEL_24BIT = 0,
+    DOUBLE_PIXEL_48BIT
+}
+disp_format_t;
+
+typedef enum _DISP_DPMS_t
+{
+    DISP_DPMS_ON,
+    DISP_DPMS_STANDBY,
+    DISP_DPMS_SUSPEND,
+    DISP_DPMS_OFF
+}
+DISP_DPMS_t;
+
+
+
+/*
+ * This function initializes the display.
+ *
+ * Output:
+ *      0   - Success
+ *      1   - Fail 
+ */
+long initDisplay(void);
+
+/*
+ * This function sets the display DPMS state 
+ * It is used to set CRT monitor to On, off, or suspend states, 
+ * while display channel are still active.
+ */
+void setDisplayDPMS(
+   disp_control_t dispControl, /* Channel 0 or Channel 1) */
+   DISP_DPMS_t state /* DPMS state */
+   );
+
+/*
+ * This funciton sets:
+ * 1. Output from channel 0 or channel 1 is 24 single or 48 double pixel.
+ * 2. Output data comes from path of channel 0 or 1.
+ *
+ * Input: See the commnet in the input parameter below.
+ *
+ * Return: 0 is OK, -1 is error.
+ */
+long setDisplayFormat(
+   disp_control_t outputInterface, /* Use the output of channel 0 or 1 */
+   disp_control_t dataPath,        /* Use the data path from channel 0 or 1 */
+   disp_format_t dispFormat         /* 24 bit single or 48 bit double pixel */
+   );
+
+/*
+ * This functions sets the CRT Path.
+ */
+void setCRTPath(disp_control_t dispControl);
+
+/*
+ * This functions uses software sequence to turn on/off the panel.
+ */
+void ddk768_swPanelPowerSequence(disp_control_t dispControl, disp_state_t dispState, unsigned long vsync_delay);
+
+/*
+ * This functions uses software sequence to turn on/off the digital interface.
+ */
+void swDispPowerSequence(disp_control_t dispControl, disp_state_t dispState, unsigned long vSyncDelay);
+
+/* 
+ * This function turns on/off the DAC for CRT display control.
+ * Input: On or off
+ */
+void ddk768_setDAC(disp_state_t state);
+
+/*
+ * Wait number of Vertical Vsync
+ *
+ * Input:
+ *          dispControl - Display Control (either channel 0 or 1)
+ *          vSyncCount  - Number of vertical sync to wait.
+ *
+ * Note:
+ *      This function is waiting for the next vertical sync.         
+ */
+void waitDispVerticalSync(disp_control_t dispControl, unsigned long vSyncCount);
+
+/*
+ * Use panel vertical sync line as time delay function.
+ * This function does not wait for the next VSync. Instead, it will wait
+ * until the current line reaches the Vertical Sync line.
+ * This function is really useful when flipping display to prevent tearing.
+ *
+ * Input: display control (CHANNEL0_CTRL or CHANNEL1_CTRL)
+ */
+void ddk768_waitVSyncLine(disp_control_t dispControl);
+
+/*
+ * This function detects if the CRT monitor is attached.
+ *
+ * Input:
+ *      redValue    - Threshold value to be detected on the red color.
+ *      greenValue  - Threshold value to be detected on the green color.
+ *      blueValue   - Threshold value to be detected on the blue color.
+ *
+ * Output:
+ *      0   - Success
+ *     -1   - Fail 
+ */
+long ddk768_detectCRTMonitor(
+    disp_control_t dispControl, 
+    unsigned char redValue,
+    unsigned char greenValue,
+    unsigned char blueValue
+);
+
+
+
+/*
+ * This function turns on/off the display control of Channel 0 or channel 1.
+ *
+ * Note:
+ *      Turning on/off the timing and the plane requires programming sequence.
+ *      The plane can not be changed without turning on the timing. However,
+ *      changing the plane has no effect when the timing (clock) is off. Below,
+ *      is the description of the timing and plane combination setting.
+ */
+void ddk768_setDisplayEnable(
+disp_control_t dispControl, /* Channel 0 or Channel 1) */
+disp_state_t dispState /* ON or OFF */
+);
+
+/*
+ * This function controls monitor on/off and data path.
+ * It can be used to set up any veiws: single view, clone view, dual view, output with channel swap, etc.
+ * However, it needs too many input parameter.
+ * There are other set view functions with less parameters, but not as flexible as this one.
+ *
+ */
+long setDisplayView(
+	disp_control_t dispOutput, 			/* Monitor 0 or 1 */
+	disp_state_t dispState,				/* On or off */
+	disp_control_t dataPath,			/* Use the data path of channel 0 or channel 1 (optional when OFF) */
+	disp_format_t dispFormat);			/* 24 or 48 bit digital interface (optional when OFF */
+
+/*
+ * Convenient function to trun on single view 
+ */
+long setSingleViewOn(disp_control_t dispOutput);
+
+/*
+ * Convenient function to trun off single view 
+ */
+long setSingleViewOff(disp_control_t dispOutput);
+
+/*
+ * Convenient function to trun on clone view 
+ */
+long setCloneViewOn(disp_control_t dataPath);
+
+/*
+ * Convenient function to trun on dual view 
+ */
+long setDualViewOn(void);
+
+/*
+ * Convenient function to trun off all views
+ */
+long setAllViewOff(void);
+
+
+/*
+ * Disable double pixel clock. 
+ * This is a teporary function, used to patch for the random fuzzy font problem. 
+ */
+void EnableDoublePixel(disp_control_t dispControl);
+void DisableDoublePixel(disp_control_t dispControl);
+
+#endif /* _DISPLAY_H_ */
diff --git a/drivers/gpu/drm/smi/ddk768/ddk768_edid.c b/drivers/gpu/drm/smi/ddk768/ddk768_edid.c
new file mode 100644
index 000000000000..fccc23a3939f
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk768/ddk768_edid.c
@@ -0,0 +1,2116 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2009 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  edid.c --- SM750/SM718 DDK 
+*  This file contains functions to interpret the EDID structure.
+* 
+*******************************************************************/
+
+#include "ddk768_help.h"
+#include "ddk768_helper.h"
+#include "ddk768_hwi2c.h"
+#include "ddk768_swi2c.h"
+#include "ddk768_edid.h"
+
+#include "ddkdebug.h"
+
+
+/* Enable this one to print the VDIF timing when debug is enabled. */
+//#define ENABLE_DEBUG_PRINT_VDIF
+
+
+#define HEADER_EDID_REGISTERS               8
+
+typedef struct _est_timing_mode_t
+{
+    unsigned long x;        /* Mode Width */
+    unsigned long y;        /* Mode Height */
+    unsigned long hz;       /* Refresh Rate */
+    unsigned char source;   /* Source:  0 - VESA
+                                        1 - IBM
+                                        2 - Apple
+                             */
+}
+est_timing_mode_t;
+
+/* These values only applies to EDID Version 1 */
+static est_timing_mode_t establishTiming[3][8] =
+{
+    /* Established Timing 1 */
+    {   
+        { 800,  600, 60, 0},
+        { 800,  600, 56, 0},
+        { 640,  480, 75, 0},
+        { 640,  480, 72, 0},
+        { 640,  480, 67, 2},
+        { 640,  480, 60, 1},
+        { 720,  400, 88, 1},
+        { 720,  400, 70, 1},
+    },
+    {
+        {1280, 1024, 75, 0},
+        {1024,  768, 75, 0},
+        {1024,  768, 70, 0},
+        {1024,  768, 60, 0},
+        {1024,  768, 87, 1},
+        { 832,  624, 75, 0},
+        { 800,  600, 75, 0},
+        { 800,  600, 72, 0},
+    },
+    {
+        {   0,    0,  0, 0},
+        {   0,    0,  0, 0},
+        {   0,    0,  0, 0},
+        {   0,    0,  0, 0},
+        {   0,    0,  0, 0},
+        {   0,    0,  0, 0},
+        {   0,    0,  0, 0},
+        {1152,  870, 75, 2},
+    }
+};
+
+static void printVdif(
+    vdif_t *pVDIF
+)
+{
+#ifdef DDKDEBUG
+
+#ifndef ENABLE_DEBUG_PRINT_VDIF
+    DDKDEBUGENABLE(0);
+#endif
+    
+    DDKDEBUGPRINT((DISPLAY_LEVEL, "pixelClock = %d\n", pVDIF->pixelClock));
+    DDKDEBUGPRINT((DISPLAY_LEVEL, "characterWidth = %d\n", pVDIF->characterWidth));
+    DDKDEBUGPRINT((DISPLAY_LEVEL, "scanType = %s\n", (pVDIF->scanType == VDIF_INTERLACED) ? "Interlaced" : "Progressive"));
+    
+    DDKDEBUGPRINT((DISPLAY_LEVEL, "horizontalFrequency = %d\n", pVDIF->horizontalFrequency));
+    DDKDEBUGPRINT((DISPLAY_LEVEL, "horizontalTotal = %d\n", pVDIF->horizontalTotal));
+    DDKDEBUGPRINT((DISPLAY_LEVEL, "horizontalActive = %d\n", pVDIF->horizontalActive));
+    DDKDEBUGPRINT((DISPLAY_LEVEL, "horizontalBlankStart = %d\n", pVDIF->horizontalBlankStart));
+    DDKDEBUGPRINT((DISPLAY_LEVEL, "horizontalBlankTime = %d\n", pVDIF->horizontalBlankTime));
+    DDKDEBUGPRINT((DISPLAY_LEVEL, "horizontalSyncStart = %d\n", pVDIF->horizontalSyncStart));
+    DDKDEBUGPRINT((DISPLAY_LEVEL, "horizontalRightBorder = %d\n", pVDIF->horizontalRightBorder));
+    DDKDEBUGPRINT((DISPLAY_LEVEL, "horizontalFrontPorch = %d\n", pVDIF->horizontalFrontPorch));
+    DDKDEBUGPRINT((DISPLAY_LEVEL, "horizontalSyncWidth = %d\n", pVDIF->horizontalSyncWidth));
+    DDKDEBUGPRINT((DISPLAY_LEVEL, "horizontalBackPorch = %d\n", pVDIF->horizontalBackPorch));
+    DDKDEBUGPRINT((DISPLAY_LEVEL, "horizontalLeftBorder = %d\n", pVDIF->horizontalLeftBorder));
+    DDKDEBUGPRINT((DISPLAY_LEVEL, "horizontalSyncPolarity = %s\n", 
+        (pVDIF->horizontalSyncPolarity == VDIF_SYNC_NEGATIVE) ? "Negative" : "Positive"));
+    
+    DDKDEBUGPRINT((DISPLAY_LEVEL, "verticalFrequency = %d\n", pVDIF->verticalFrequency));
+    DDKDEBUGPRINT((DISPLAY_LEVEL, "verticalTotal = %d\n", pVDIF->verticalTotal));
+    DDKDEBUGPRINT((DISPLAY_LEVEL, "verticalActive = %d\n", pVDIF->verticalActive));
+    DDKDEBUGPRINT((DISPLAY_LEVEL, "verticalBlankStart = %d\n", pVDIF->verticalBlankStart));
+    DDKDEBUGPRINT((DISPLAY_LEVEL, "verticalBlankTime = %d\n", pVDIF->verticalBlankTime));
+    DDKDEBUGPRINT((DISPLAY_LEVEL, "verticalSyncStart = %d\n", pVDIF->verticalSyncStart));
+    DDKDEBUGPRINT((DISPLAY_LEVEL, "verticalBottomBorder = %d\n", pVDIF->verticalBottomBorder));
+    DDKDEBUGPRINT((DISPLAY_LEVEL, "verticalFrontPorch = %d\n", pVDIF->verticalFrontPorch));
+    DDKDEBUGPRINT((DISPLAY_LEVEL, "verticalSyncHeight = %d\n", pVDIF->verticalSyncHeight));
+    DDKDEBUGPRINT((DISPLAY_LEVEL, "verticalBackPorch = %d\n", pVDIF->verticalBackPorch));
+    DDKDEBUGPRINT((DISPLAY_LEVEL, "verticalTopBorder = %d\n", pVDIF->verticalTopBorder));
+    DDKDEBUGPRINT((DISPLAY_LEVEL, "verticalSyncPolarity = %s\n", 
+        (pVDIF->verticalSyncPolarity == VDIF_SYNC_NEGATIVE) ? "Negative" : "Positive"));
+
+#ifndef ENABLE_DEBUG_PRINT_VDIF
+    DDKDEBUGENABLE(1);
+#endif
+#endif
+}
+
+/*
+ *  edidGetHeader
+ *      This function gets the EDID Header
+ *
+ *  Input:
+ *      pEDIDBuffer - Buffer that contains the EDID structure of the monitor
+ *
+ *  Output:
+ *      0 get header success; -1 fail.
+ */
+unsigned char edidGetHeader(
+    unsigned char *pEDIDBuffer
+)
+{
+    if (pEDIDBuffer != (unsigned char *)0)
+    {
+        /* Check the header */
+        if ((pEDIDBuffer[0] == 0x00) && (pEDIDBuffer[1] == 0xFF) && (pEDIDBuffer[2] == 0xFF) &&
+            (pEDIDBuffer[3] == 0xFF) && (pEDIDBuffer[4] == 0xFF) && (pEDIDBuffer[5] == 0xFF) &&
+            (pEDIDBuffer[6] == 0xFF) && (pEDIDBuffer[7] == 0x00))
+        {
+            return 0;
+        }
+        else
+            return -1;
+    }
+
+   // DDKDEBUGPRINT((DISPLAY_LEVEL, "Invalid EDID bufffer\n"));
+    return -1;
+}
+
+/*
+ *  edidGetVersion
+ *      This function gets the EDID version
+ *
+ *  Input:
+ *      pEDIDBuffer - Buffer that contains the EDID structure of the monitor
+ *      pRevision   - Revision of the EDIE (if exist)
+ *
+ *  Output:
+ *      Revision number of the given EDID buffer.
+ */
+unsigned char ddk768_edidGetVersion(
+    unsigned char *pEDIDBuffer,
+    unsigned char *pRevision
+)
+{
+    unsigned char version;
+    
+    if (pEDIDBuffer != (unsigned char *)0)
+    {
+        /* Check the header */
+        if ((pEDIDBuffer[0] == 0x00) && (pEDIDBuffer[1] == 0xFF) && (pEDIDBuffer[2] == 0xFF) &&
+            (pEDIDBuffer[3] == 0xFF) && (pEDIDBuffer[4] == 0xFF) && (pEDIDBuffer[5] == 0xFF) &&
+            (pEDIDBuffer[6] == 0xFF) && (pEDIDBuffer[7] == 0x00))
+        {
+            /* 
+             * EDID Structure Version 1.
+             */
+        
+            /* Read the version field from the buffer. It should be 1 */
+            version  = pEDIDBuffer[18];
+        
+            if (version == 1)
+            {
+                /* Copy the revision first */
+                if (pRevision != (unsigned char *)0)
+                    *pRevision = pEDIDBuffer[19];
+                    
+                return version;
+            }
+        }
+        else
+        {
+            /* 
+             * EDID Structure Version 2 
+             */
+             
+            /* Read the version and revision field from the buffer. */
+            version = pEDIDBuffer[0];
+        
+            if ((version >> 4) == 2)
+            {
+                /* Copy the revision */
+                if (pRevision != (unsigned char *)0)
+                    *pRevision = version & 0x0F;
+                
+                return (version >> 4);
+            }
+        }
+    }
+    
+    DDKDEBUGPRINT((DISPLAY_LEVEL, "Invalid EDID Structure\n"));    
+    return 0;    
+}
+
+/*
+ *  ddk768_edidGetProductInfo
+ *      This function gets the vendor and product information.
+ *
+ *  Input:
+ *      pEDIDBuffer         - Buffer that contains the EDID structure of the monitor [in]
+ *      pManufacturerName   - Pointer to a 3 byte length variable to store the manufacturer name [out]
+ *      pProductCode        - Pointer to a variable to store the product code [out]
+ *      pSerialNumber       - Pointer to a variable to store the serial number [out]
+ *      pWeekOfManufacture  - Pointer to a variable to store the week of manufacture [out]
+ *      pYearOfManufacture  - Pointer to a variable to store the year of manufacture 
+ *                            or model year (if WeekOfManufacture is 0xff) [out]
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long ddk768_edidGetProductInfo(
+    unsigned char *pEDIDBuffer,
+    char *pManufacturerName,
+    unsigned short *pProductCode,
+    unsigned long *pSerialNumber,
+    unsigned char *pWeekOfManufacture,
+    unsigned short *pYearOfManufacture
+)
+{
+    unsigned char version, revision;
+    unsigned short manufactureID;
+    
+    /* Get EDID Version and revision */
+    version = ddk768_edidGetVersion(pEDIDBuffer, &revision);
+    
+    if (version == 1)
+    {
+        edid_version_1_t *pEDIDStructure;
+        
+        /* EDID Structure Version 1. */
+        pEDIDStructure = (edid_version_1_t *)pEDIDBuffer;
+        
+        if (pManufacturerName != (char *)0)
+        {
+            /* Swap the byte */
+            manufactureID = (pEDIDStructure->manufacturerID >> 8) + (pEDIDStructure->manufacturerID << 8);
+            pManufacturerName[0] = ((manufactureID >> 10) & 0x001F) + 'A' - 1;
+            pManufacturerName[1] = ((manufactureID >> 5) & 0x001F) + 'A' - 1;
+            pManufacturerName[2] = (manufactureID & 0x001F) + 'A' - 1;
+            pManufacturerName[3] = '\0';
+        }
+        
+        if (pProductCode != (unsigned short *)0)
+            *pProductCode = pEDIDStructure->productCode;
+            
+        /* Only EDID structure version 1.1 and 1.2 supports this. EDID 1.3 uses
+           detail timing descriptor to store the serial number in ASCII. */
+        if (pSerialNumber != (unsigned long *)0)
+            *pSerialNumber = pEDIDStructure->serialNumber;
+        
+        /*
+         * Rev 1.3: - A value of 0 means that week of manufacture is not specified
+         *          - A value in the range of 1 to 54 (0x01 - 0x36) means the week of manufacture
+         *          - Any values greater than 54 is invalid.
+         *
+         * Rev 1.4: - A value of 0 means that week of manufacture is not specified
+         *          - A value in the range of 1 to 54 (0x01 - 0x36) means the week of manufacture
+         *          - A value of 0xFF means that Year of Manufacture contains the model year
+         *            instead of year of Manufacture.
+         *          - Other values means invalid
+         */
+        if (pWeekOfManufacture != (unsigned char *)0)
+            *pWeekOfManufacture = pEDIDStructure->weekOfManufacture;
+            
+        /* The value must be greater than 3 and less than or equal to the current
+           year minus 1990.
+           A value of 3 or less would indicated that the display was manufactured 
+           before the EDID standard was defined.
+           A value greater than (current year - 1990) would indicate that the display
+           has not yet been manufactured.
+         */
+        if (pYearOfManufacture != (unsigned short *)0)
+            *pYearOfManufacture = (unsigned short) pEDIDStructure->yearOfManufacture + 1990;
+        
+        return 0;
+    }
+
+    return (-1);
+}
+
+/*
+ *  ddk768_edidCheckMonitorInputSignal
+ *      This function checks whether the monitor is expected analog/digital 
+ *      input signal.
+ *
+ *  Input:
+ *      pEDIDBuffer     - Buffer that contains the EDID structure of the monitor
+ *
+ *  Output:
+ *      0   - Analog
+ *      1   - Digital
+ */
+unsigned char ddk768_edidCheckMonitorInputSignal(
+    unsigned char *pEDIDBuffer
+)
+{
+    unsigned char version;
+
+    
+    /* Get EDID Version and revision */
+    version = ddk768_edidGetVersion(pEDIDBuffer, (unsigned char *)0);
+    
+    if (version == 1)
+        return (unsigned char)((edid_version_1_t *)pEDIDBuffer)->videoInputDefinition.analogSignal.inputSignal;
+    
+    return 0;
+}
+
+/*
+ *  ddk768_edidGetAnalogSignalInfo
+ *      This function gets the analog video input signal information
+ *
+ *  Input:
+ *      pEDIDBuffer             - Buffer that contains the EDID structure of the monitor
+ *      pRefWhiteAboveBlank     - Pointer to a variable to store the reference white above blank
+ *                                value. The value is in milliVolt.
+ *      pSyncLevelBelowBlank    - Pointer to a variable to store the Sync tip level below blank
+ *                                The value is also in milliVolt
+ *      pBlank2BlackSetup       - Pointer to a variable to store the Blank to black setup or
+ *                                pedestal per appropriate Signal Level Standard flag. 
+ *                                1 means that the display expect the setup.
+ *      pSeparateSyncSupport    - Pointer to a variable to store the flag to indicate that the
+ *                                monitor supports separate sync.
+ *      pCompositeSyncSupport   - Pointer to a variable to store a flag to indicate that the
+ *                                monitor supports composite sync.
+ *      pSyncOnGreenSupport     - Pointer to a variable to store a flag to indicate that
+ *                                the monitor supports sync on green video.
+ *      pVSyncSerrationRequired - Pointer to a variable to store a flag to indicate that serration
+ *                                of the VSync pulse is required when composite sync or
+ *                                sync-on-green video is used.
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long ddk768_edidGetAnalogSignalInfo(
+    unsigned char *pEDIDBuffer,
+    unsigned short *pRefWhiteAboveBlank,
+    unsigned short *pSyncLevelBelowBlank,
+    unsigned char *pBlank2BlackSetup,
+    unsigned char *pSeparateSyncSupport,
+    unsigned char *pCompositeSyncSupport,
+    unsigned char *pSyncOnGreenSupport,
+    unsigned char *pVSyncSerrationRequired
+)
+{
+    unsigned char version, revision;
+    unsigned short whiteReference, syncLevel;
+    
+    /* Get EDID Version and revision */
+    version = ddk768_edidGetVersion(pEDIDBuffer, &revision);
+    
+    if (version == 1)
+    {
+        edid_version_1_t *pEDIDStructure;
+        
+        /* EDID Structure Version 1. */
+        pEDIDStructure = (edid_version_1_t *)pEDIDBuffer;
+        
+        /* Check if the input signal is analog */
+        if (pEDIDStructure->videoInputDefinition.analogSignal.inputSignal != 0)
+            return (-1);
+        
+        switch (pEDIDStructure->videoInputDefinition.analogSignal.signalLevelStd)
+        {
+            case 0:
+                whiteReference = 700;
+                syncLevel = 300;
+                break;
+            case 1:
+                whiteReference = 714;
+                syncLevel = 286;
+                break;
+            case 2:
+                whiteReference = 1000;
+                syncLevel = 400;
+                break;
+            case 3:
+                whiteReference = 700;
+                syncLevel = 0;
+                break;
+        }
+        
+        if (pRefWhiteAboveBlank != (unsigned short *)0)
+            *pRefWhiteAboveBlank = whiteReference; 
+        
+        if (pSyncLevelBelowBlank != (unsigned short *)0)
+            *pSyncLevelBelowBlank = syncLevel;
+        
+        if (pBlank2BlackSetup != (unsigned char *)0)
+            *pBlank2BlackSetup = (unsigned char)
+                                  pEDIDStructure->videoInputDefinition.analogSignal.blank2Black;
+        
+        if (pSeparateSyncSupport != (unsigned char *)0)
+            *pSeparateSyncSupport = (unsigned char)
+                                     pEDIDStructure->videoInputDefinition.analogSignal.separateSyncSupport;
+        
+        if (pCompositeSyncSupport != (unsigned char *)0)
+            *pCompositeSyncSupport = (unsigned char)
+                                      pEDIDStructure->videoInputDefinition.analogSignal.compositeSyncSupport;
+        
+        if (pSyncOnGreenSupport != (unsigned char *)0)
+            *pSyncOnGreenSupport = (unsigned char)
+                                    pEDIDStructure->videoInputDefinition.analogSignal.syncOnGreenSupport;
+        
+        if (pVSyncSerrationRequired != (unsigned char *)0)
+            *pVSyncSerrationRequired = (unsigned char)
+                                        pEDIDStructure->videoInputDefinition.analogSignal.vsyncSerration;
+                                        
+        return 0;
+    }
+    else
+    {
+        /* EDID Structure 2 */
+    }
+    
+    return (-1);
+}
+
+/*
+ *  ddk768_edidGetDigitalSignalInfo
+ *      This function gets the digital video input signal information.
+ *      Only applies to EDID 1.3 and above.
+ *
+ *  Input:
+ *      pEDIDBuffer     - Buffer that contains the EDID structure of the monitor
+ *      pDFP1xSupport   - Pointer to a variable to store the flag to indicate that
+ *                        the mointor interface is signal compatible with VESA
+ *                        DFP 1.x TMDS CRGB, 1 pixel/clock, up to 8 bits / color
+ *                        MSB aligned, DE active high
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long ddk768_edidGetDigitalSignalInfo(
+    unsigned char *pEDIDBuffer,
+    unsigned char *pDFP1xSupport
+)
+{
+    unsigned char version, revision;
+    
+    /* Get EDID Version and revision */
+    version = ddk768_edidGetVersion(pEDIDBuffer, &revision);
+    
+    if ((version == 1) && (revision == 3))
+    {
+        edid_version_1_t *pEDIDStructure;
+        
+        /* EDID Structure Version 1. */
+        pEDIDStructure = (edid_version_1_t *)pEDIDBuffer;
+        
+        /* Check if the input signal is digital */
+        if (pEDIDStructure->videoInputDefinition.digitalSignal.inputSignal != 1)
+            return (-1);
+            
+        if (pDFP1xSupport != (unsigned char *)0)
+            *pDFP1xSupport = pEDIDStructure->videoInputDefinition.digitalSignal.dfp1Support;
+        
+        return 0;
+    }
+    
+    return (-1);
+}
+
+/*
+ *  ddk768_edidGetDisplaySize
+ *      This function gets the display sizes in cm.
+ *
+ *  Input:
+ *      pEDIDBuffer         - Buffer that contains the EDID structure of the monitor
+ *      pMaxHorzImageSize   - Pointer to a variable to store the maximum horizontal 
+ *                            image size to the nearest centimeter. A value of 0
+ *                            indicates that the size is indeterminate size.
+ *      pMaxVertImageSize   - Pointer to a variable to store the maximum vertical
+ *                            image size to the nearest centimeter. A value of 0
+ *                            indicates that the size is indeterminate size.
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long ddk768_edidGetDisplaySize(
+    unsigned char *pEDIDBuffer,
+    unsigned char *pMaxHorzImageSize,
+    unsigned char *pMaxVertImageSize
+)
+{
+    unsigned char version, revision;
+    
+    /* Get EDID Version and revision */
+    version = ddk768_edidGetVersion(pEDIDBuffer, &revision);
+    
+    if (version == 1)
+    {
+        edid_version_1_t *pEDIDStructure;
+        
+        /* EDID Structure Version 1. */
+        pEDIDStructure = (edid_version_1_t *)pEDIDBuffer;
+        
+        if (pMaxHorzImageSize != (unsigned char *)0)
+            *pMaxHorzImageSize = pEDIDStructure->maxHorzImageSize;
+        
+        if (pMaxVertImageSize != (unsigned char *)0)
+            *pMaxVertImageSize = pEDIDStructure->maxVertImageSize;
+        
+        return 0;
+    }
+    
+    return (-1);
+}
+
+#if 0   /* Use the ddk768_edidGetWhitePoint to get the Gamma */
+/*
+ *  edidGetGamma
+ *      This function gets the Display Transfer Characteristic (Gamma).
+ *
+ *  Input:
+ *      pEDIDBuffer         - Buffer that contains the EDID structure of the monitor
+ *
+ *  Output:
+ *      Gamma value multiplied by 100. A value of 0xFFFF (-1) indicates that
+ *      the gamma value is not defined.
+ */
+unsigned short edidGetGamma(
+    unsigned char *pEDIDBuffer
+)
+{
+    unsigned char version;
+    
+    /* Get EDID Version and revision */
+    version = ddk768_edidGetVersion(pEDIDBuffer, (unsigned char *)0);
+    
+    if (version == 1)
+        return (unsigned short)(((edid_version_1_t *)pEDIDBuffer)->displayTransferChar + 100);
+    
+    return (-1);
+}
+#endif
+
+/*
+ *  ddk768_edidGetPowerManagementSupport
+ *      This function gets the monitor's power management support.
+ *
+ *  Input:
+ *      pEDIDBuffer     - Buffer that contains the EDID structure of the monitor
+ *      pStandBy        - Pointer to a variable to store the flag to indicate that
+ *                        standby power mode is supported.
+ *      pSuspend        - Pointer to a variable to store the flag to indicate that
+ *                        suspend power mode is supported.
+ *      pLowPower       - Pointer to a variable to store the flag to indicate that
+ *                        the display consumes low power when it receives a timing
+ *                        signal that is outside its declared active operating range.
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long ddk768_edidGetPowerManagementSupport(
+    unsigned char *pEDIDBuffer,
+    unsigned char *pStandBy,
+    unsigned char *pSuspend,
+    unsigned char *pLowPower
+)
+{
+    unsigned char version;
+    
+    /* Get EDID Version and revision */
+    version = ddk768_edidGetVersion(pEDIDBuffer, (unsigned char *)0);
+    
+    if (version == 1)
+    {
+        edid_version_1_t *pEDIDStructure;
+        
+        /* EDID Structure Version 1. */
+        pEDIDStructure = (edid_version_1_t *)pEDIDBuffer;
+        
+        if (pStandBy != (unsigned char *)0)
+            *pStandBy = (unsigned char) pEDIDStructure->featureSupport.standbySupport;
+            
+        if (pSuspend != (unsigned char *)0)
+            *pSuspend = (unsigned char) pEDIDStructure->featureSupport.suspendSupport;
+            
+        if (pLowPower != (unsigned char *)0)
+            *pLowPower = (unsigned char) pEDIDStructure->featureSupport.lowPowerSupport;
+        
+        return 0;
+    }
+    
+    return (-1);
+}
+
+/*
+ *  ddk768_edidGetDisplayType
+ *      This function gets the display type.
+ *
+ *  Input:
+ *      pEDIDBuffer     - Buffer that contains the EDID structure of the monitor
+ *
+ *  Output:
+ *      0   - Monochrome / grayscale display
+ *      1   - RGB Color Display
+ *      2   - Non-RGB multicolor display, e.g. R/G/Y
+ *      3   - Undefined
+ */
+unsigned char ddk768_edidGetDisplayType(
+    unsigned char *pEDIDBuffer
+)
+{
+    unsigned char version;
+    
+    /* Get EDID Version and revision */
+    version = ddk768_edidGetVersion(pEDIDBuffer, (unsigned char *)0);
+    
+    if (version == 1)
+        return (unsigned char)((edid_version_1_t *)pEDIDBuffer)->featureSupport.displayType;
+    
+    return (3);
+}
+
+/*
+ *  ddk768_edidChecksRGBUsage
+ *      This function checks if the display is using the sRGB standard default
+ *      color space as its primary color space. 
+ *
+ *  Input:
+ *      pEDIDBuffer     - Buffer that contains the EDID structure of the monitor
+ *
+ *  Output:
+ *      0   - Does not use sRGB as its primary color space
+ *      1   - Use sRGB as its primary color space
+ */
+unsigned char ddk768_edidChecksRGBUsage(
+    unsigned char *pEDIDBuffer
+)
+{
+    unsigned char version;
+    
+    /* Get EDID Version and revision */
+    version = ddk768_edidGetVersion(pEDIDBuffer, (unsigned char *)0);
+    
+    if (version == 1)
+        return (unsigned char)((edid_version_1_t *)pEDIDBuffer)->featureSupport.sRGBSupport;
+    
+    return (0);
+}
+
+/*
+ *  ddk768_edidIsPreferredTimingAvailable
+ *      This function checks whether the preffered timing mode is available.
+ *      Use of preferred timing mode is required by EDID structure version 1
+ *      Revision 3 and higher. 
+ *
+ *  Input:
+ *      pEDIDBuffer     - Buffer that contains the EDID structure of the monitor
+ *
+ *  Output:
+ *      0   - Preferred Timing is not available
+ *      1   - Preferred Timing is available
+ */
+unsigned char ddk768_edidIsPreferredTimingAvailable(
+    unsigned char *pEDIDBuffer
+)
+{
+    unsigned char version;
+    
+    if (pEDIDBuffer != (unsigned char *)0)
+    {
+        /* Get EDID Version and revision */
+        version = ddk768_edidGetVersion(pEDIDBuffer, (unsigned char *)0);
+    
+        if (version == 1)
+            return (unsigned char)((edid_version_1_t *)pEDIDBuffer)->featureSupport.preferredTiming;
+    }
+        
+    return (0);
+}
+
+/*
+ *  ddk768_edidIsDefaultGTFSupported
+ *      This function checks whether the display supports timings based on the
+ *      GTF standard using default GTF parameter values. 
+ *
+ *  Input:
+ *      pEDIDBuffer     - Buffer that contains the EDID structure of the monitor
+ *
+ *  Output:
+ *      0   - Default GTF is not supported
+ *      1   - Default GTF is supported
+ */
+unsigned char ddk768_edidIsDefaultGTFSupported(
+    unsigned char *pEDIDBuffer
+)
+{
+    unsigned char version, revision;
+    
+    /* Get EDID Version and revision */
+    version = ddk768_edidGetVersion(pEDIDBuffer, (unsigned char *)0);
+    
+    if (version == 1)
+        return (unsigned char)((edid_version_1_t *)pEDIDBuffer)->featureSupport.defaultGTFSupport;
+    
+    return (0);
+}
+
+/*
+ *  edidCalculateChromaticValue
+ *      This function calculates the chromatic value. 
+ *
+ *  Input:
+ *      colorBinaryValue    - Color Characteristic Binary Representation Value 
+ *                            to be computed
+ *
+ *  Output:
+ *      The chromatic value times a 1000.
+ */
+static unsigned short edidCalculateChromaticValue(
+    unsigned short colorBinaryValue
+)
+{
+    unsigned long index;
+    unsigned long result;
+    
+    result = 0;
+    for (index = 10; index > 0; index--)
+    {
+        /* Times 1000000 to make it accurate to the micro value. */
+        result += ddk768_roundedDiv((colorBinaryValue & 0x0001) * 1000000, ddk768_twoToPowerOfx(index));
+        colorBinaryValue >>= 1;
+    }
+    
+    /* Make it accurate to 1000 place */
+    return ((unsigned short)ddk768_roundedDiv(result, 1000));
+}
+
+/*
+ *  ddk768_edidGetColorCharacteristic
+ *      This function gets the chromaticity and white point values expressed as
+ *      an integer value which represents the actual value times 1000.
+ *
+ *  Input:
+ *      pEDIDBuffer - Buffer that contains the EDID structure of the monitor
+ *      pRedX   - Pointer to a variable to store the Red X values
+ *      pRedY   - Pointer to a variable to store the Red Y values
+ *      pGreenX - Pointer to a variable to store the Green X values
+ *      pGreenY - Pointer to a variable to store the Green Y values
+ *      pBlueX  - Pointer to a variable to store the Blue X values
+ *      pBlueY  - Pointer to a variable to store the Blue Y values
+ *
+ *  Note:
+ *      To get the White color characteristic, use the ddk768_edidGetWhitePoint
+ */
+void ddk768_edidGetColorCharacteristic(
+    unsigned char *pEDIDBuffer,
+    unsigned short *pRedX,
+    unsigned short *pRedY,
+    unsigned short *pGreenX,
+    unsigned short *pGreenY,
+    unsigned short *pBlueX,
+    unsigned short *pBlueY
+)
+{
+    unsigned char version, revision;
+    
+    /* Get EDID Version and revision */
+    version = ddk768_edidGetVersion(pEDIDBuffer, (unsigned char *)0);
+    
+    if (version == 1)
+    {
+        edid_version_1_t *pEDIDStructure;
+        
+        /* EDID Structure Version 1. */
+        pEDIDStructure = (edid_version_1_t *)pEDIDBuffer;
+        
+        if (pRedX != (unsigned short *)0)
+        {
+            *pRedX = edidCalculateChromaticValue(((unsigned short)pEDIDStructure->redX << 2) + 
+                                                  (unsigned short)pEDIDStructure->redGreenLowBits.redXLowBits);
+        }
+            
+        if (pRedY != (unsigned short *)0)
+        {
+            *pRedY = edidCalculateChromaticValue(((unsigned short)pEDIDStructure->redY << 2) + 
+                                                  (unsigned short)pEDIDStructure->redGreenLowBits.redYLowBits);
+        }
+            
+        if (pGreenX != (unsigned short *)0)
+        {
+            *pGreenX = edidCalculateChromaticValue(((unsigned short)pEDIDStructure->greenX << 2) + 
+                                                    (unsigned short)pEDIDStructure->redGreenLowBits.greenXLowBits);
+        }
+            
+        if (pGreenY != (unsigned short *)0)
+        {
+            *pGreenY = edidCalculateChromaticValue(((unsigned short)pEDIDStructure->greenY << 2) + 
+                                                    (unsigned short)pEDIDStructure->redGreenLowBits.greenYLowBits);
+        }
+            
+        if (pBlueX != (unsigned short *)0)
+        {
+            *pBlueX = edidCalculateChromaticValue(((unsigned short)pEDIDStructure->blueX << 2) +
+                                                   (unsigned short)pEDIDStructure->blueWhiteLowBits.blueXLowBits);
+        }
+            
+        if (pBlueY != (unsigned short *)0)
+        {
+            *pBlueY = edidCalculateChromaticValue(((unsigned short)pEDIDStructure->blueY << 2) +
+                                                   (unsigned short)pEDIDStructure->blueWhiteLowBits.blueYLowBits);
+        }
+    }
+}
+
+/*
+ *  ddk768_edidGetWhitePoint
+ *      This function gets the white point.
+ *      To get the default white point, set the index to 0. For multiple white point,
+ *      call this function multiple times to check if more than 1 white point is supported.
+ *
+ *  Input:
+ *      pEDIDBuffer - Buffer that contains the EDID structure of the monitor
+ *      pWhitePointIndex    - Pointer to a variable that contains the white point index 
+ *                            to be retrieved.
+ *      pWhiteX             - Pointer to a variable to store the White X value
+ *      pWhiteY             - Pointer to a variable to store the White Y value
+ *      pWhiteGamma         - Pointer to a variable to store the White Gamma value
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long ddk768_edidGetWhitePoint(
+    unsigned char *pEDIDBuffer,
+    unsigned char *pWhitePointIndex,
+    unsigned short *pWhiteX,
+    unsigned short *pWhiteY,
+    unsigned short *pWhiteGamma
+)
+{
+    unsigned char version, revision, index, tableIndex;
+    
+    if (pWhitePointIndex == (unsigned char *)0)
+        return (-1);
+    
+    /* Get EDID Version and revision */
+    version = ddk768_edidGetVersion(pEDIDBuffer, (unsigned char *)0);
+    
+    if (version == 1)
+    {
+        edid_version_1_t *pEDIDStructure;
+        monitor_desc_t *pMonitorDescriptor;
+        
+        /* EDID Structure Version 1. */
+        pEDIDStructure = (edid_version_1_t *)pEDIDBuffer;
+        
+        /* Get the index to a temporary variable and increment the index for the
+           next loop. */
+        index = *pWhitePointIndex;
+        (*pWhitePointIndex)++;
+        
+        if (index == 0)
+        {
+            if (pWhiteX != (unsigned short *)0)
+            {
+                *pWhiteX = edidCalculateChromaticValue(((unsigned short)pEDIDStructure->whiteX << 2) +
+                                                        (unsigned short)pEDIDStructure->blueWhiteLowBits.whiteXLowBits);
+            }
+            
+            if (pWhiteY != (unsigned short *)0)
+            {
+                *pWhiteY = edidCalculateChromaticValue(((unsigned short)pEDIDStructure->whiteY << 2) +
+                                                        (unsigned short)pEDIDStructure->blueWhiteLowBits.whiteYLowBits);
+            }
+            
+            if (pWhiteGamma != (unsigned short *)0)
+                *pWhiteGamma = pEDIDStructure->displayTransferChar + 100;
+                
+            return 0;
+        }
+        else
+        {
+            for (tableIndex = 0; tableIndex < 4; tableIndex++)
+            {
+                pMonitorDescriptor = &pEDIDStructure->miscInformation.monitorDesc[tableIndex];
+                if ((pMonitorDescriptor->flag1 == 0) && (pMonitorDescriptor->flag2 == 0) &&
+                    (pMonitorDescriptor->dataTypeTag == 0xFB) && 
+                    (pMonitorDescriptor->descriptor.colorPoint.white[index-1].whitePointIndex != 0))
+                {
+                    if (pWhiteX != (unsigned short *)0)
+                    {
+                        *pWhiteX = edidCalculateChromaticValue(((unsigned short)pMonitorDescriptor->descriptor.colorPoint.white[index-1].whiteX << 2) +
+                                                                (unsigned short)pMonitorDescriptor->descriptor.colorPoint.white[index-1].whiteLowBits.whiteXLowBits);
+                    }
+                    
+                    if (pWhiteY != (unsigned short *)0)
+                    {
+                        *pWhiteY = edidCalculateChromaticValue(((unsigned short)pMonitorDescriptor->descriptor.colorPoint.white[index-1].whiteY << 2) +
+                                                                (unsigned short)pMonitorDescriptor->descriptor.colorPoint.white[index-1].whiteLowBits.whiteYLowBits);
+                    }
+                    
+                    if (pWhiteGamma != (unsigned short *)0)
+                        *pWhiteGamma = pMonitorDescriptor->descriptor.colorPoint.white[index-1].gamma + 100;
+                    
+                    return 0;
+                }
+            }
+        }
+    }
+    
+    return (-1);
+}
+
+/*
+ *  edidCalculateChecksum
+ *      This function adds all one-byte value of the EDID buffer. 
+ *      The total should be equal to 0x00
+ *
+ *  Input:
+ *      pEDIDBuffer     - Buffer that contains the EDID structure of the monitor
+ *
+ *  Output:
+ *      Total of one-byte values. It should equal to 0x00. A value other than
+ *      0x00 indicates the EDID buffer is not valid.
+ */
+static unsigned char edidCalculateChecksum(
+    unsigned char *pEDIDBuffer
+)
+{
+    unsigned char version, revision, checksum;
+    unsigned short index;
+    
+    /* Get EDID Version and revision */
+    version = ddk768_edidGetVersion(pEDIDBuffer, &revision);
+    
+    checksum = 0;
+    if (version == 1)
+    {
+        for (index = 0; index < 128; index++)
+            checksum += pEDIDBuffer[index];
+    }
+    
+    return checksum;
+}
+
+/*
+ *  ddk768_edidGetExtension
+ *      This function gets the number of (optional) EDID extension blocks to follow
+ *      the given EDID buffer.
+ *
+ *  Input:
+ *      pEDIDBuffer     - Buffer that contains the EDID structure of the monitor
+ *
+ *  Output:
+ *      Total number of EDID Extension to follow the given EDID buffer.
+ */
+unsigned char ddk768_edidGetExtension(
+    unsigned char *pEDIDBuffer
+)
+{
+    unsigned char version, revision;
+    
+    /* Get EDID Version and revision */
+    version = ddk768_edidGetVersion(pEDIDBuffer, &revision);
+    
+    if (version == 1)
+        return ((edid_version_1_t *)pEDIDBuffer)->extFlag;
+    
+    return 0;
+}
+
+#define EDID_TOTAL_RETRY_COUNTER            4
+/*
+ *  ddk768_edidReadMonitor
+ *      This function reads the EDID structure from the attached monitor
+ *
+ *  Input:
+ *      displayPath - Display device which EDID to be read from.
+ *      pEDIDBuffer - Buffer that contains the EDID structure of the monitor
+ *      bufferSize  - The EDID Buffer size index (usually 128-bytes)
+ *      edidExtNo   - Extension Index of the EDID Structure to be read
+ *      sclGpio     - GPIO pin used as the I2C Clock (SCL)
+ *      sdaGpio     - GPIO pin used as the I2C Data (SDA)
+ *
+ *  Output:
+ *      0   - Fail
+ *      edidSize   - Success and return the edid's size
+ */
+long ddk768_edidReadMonitorEx(
+    unsigned char *pEDIDBuffer,
+    unsigned long bufferSize,
+    unsigned char edidExtNo,
+    unsigned char sclGpio,
+    unsigned char sdaGpio
+)
+{
+    unsigned char value, retry, edidVersion, edidRevision;
+    unsigned char edidBuffer[TOTAL_EDID_REGISTERS_256];
+    unsigned long offset;
+    long edidSize = TOTAL_EDID_REGISTERS_128;
+
+    /* Initialize the i2c bus */
+    ddk768_swI2CInit(sclGpio, sdaGpio);
+
+    for (retry = 0; retry < EDID_TOTAL_RETRY_COUNTER; retry++)
+    {
+       // DDKDEBUGPRINT((DISPLAY_LEVEL, "retry: %d\n", retry));
+            
+        /* Read the EDID from the monitor. */
+        for (offset = 0; offset < TOTAL_EDID_REGISTERS_128; offset++)
+            edidBuffer[offset] = ddk768_swI2CReadReg(EDID_DEVICE_I2C_ADDRESS, (unsigned char)offset);
+         	if(edidBuffer[EDID_EXTEND_BLOCK])
+       	 	{
+            	for (offset = TOTAL_EDID_REGISTERS_128; offset < TOTAL_EDID_REGISTERS_256; offset++)
+                edidBuffer[offset] = ddk768_swI2CReadReg(EDID_DEVICE_I2C_ADDRESS, (unsigned char)offset);
+            	edidSize = TOTAL_EDID_REGISTERS_256;
+         	}	
+
+        /* Check if the EDID is valid. */
+        edidVersion = ddk768_edidGetVersion((unsigned char *)&edidBuffer, (unsigned char *)&edidRevision);
+        //DDKDEBUGPRINT((DISPLAY_LEVEL, "EDID Structure Version: %d.%d\n", edidVersion, edidRevision)); 
+        if (edidVersion != 0)
+            break;
+    }
+    
+    /* 
+     *  The monitor might not be DDC2B compliance. Therefore, need to use DDC1 protocol,
+     *  which uses the Vertical Sync to clock in the EDID data.
+     *  Currently this function return error. DDC1 protocol can be added later.
+     */
+    if (retry == EDID_TOTAL_RETRY_COUNTER)
+    {
+        /* DDC1 uses the SDA line to transmit 9 bit data per byte. The last bit is
+         * only an acknowledge flag, which could be high or low. However, SCL line
+         * is not used. Instead the data is clock-in using vertical sync.
+         */
+        return 0;
+    }
+
+    /* Copy the data to the given buffer */
+    if (pEDIDBuffer != (unsigned char *)0)
+    {
+        for (offset = 0; offset < edidSize; offset++)
+            pEDIDBuffer[offset] = edidBuffer[offset];
+    }
+
+    return edidSize;
+}
+
+/*
+ *  This function is same as editReadMonitorEx(), but using HW I2C.
+ *
+ *  Input:
+ *      pEDIDBuffer - Buffer that contains the EDID structure of the monitor
+ *      bufferSize  - The EDID Buffer size index (usually 128-bytes)
+ *      edidExtNo   - Extension Index of the EDID Structure to be read
+ *      i2cNumber   - 0 = I2C0 and 1 = I2C1
+ *
+ *  Output:
+ *      0   - Fail
+ *     edidSize   - Success and return the edid's size.
+ */
+long ddk768_edidReadMonitorExHwI2C(
+    unsigned char *pEDIDBuffer,
+    unsigned long bufferSize,
+    unsigned char edidExtNo,
+    unsigned char i2cNumber
+)
+{
+    unsigned char  retry, edidVersion, edidRevision;
+    unsigned long value;
+    unsigned char edidBuffer[TOTAL_EDID_REGISTERS_256];
+    unsigned long offset;
+    long edidSize = 0;
+    
+    /* Initialize the i2c bus */
+    ddk768_hwI2CInit(i2cNumber);
+#if 0
+    for (retry = 0; retry < EDID_TOTAL_RETRY_COUNTER; retry++)
+    {
+       // DDKDEBUGPRINT((DISPLAY_LEVEL, "retry: %d\n", retry));
+            
+        /* Read the EDID from the monitor. */
+        for (offset = 0; offset < TOTAL_EDID_REGISTERS; offset++)
+            edidBuffer[offset] = ddk768_hwI2CReadReg(i2cNumber, EDID_DEVICE_I2C_ADDRESS, (unsigned char)offset);
+            
+        /* Check if the EDID is valid. */
+        edidVersion = ddk768_edidGetVersion((unsigned char *)&edidBuffer, (unsigned char *)&edidRevision);
+      //  DDKDEBUGPRINT((DISPLAY_LEVEL, "EDID Structure Version: %d.%d\n", edidVersion, edidRevision)); 
+        if (edidVersion != 0)
+            break;
+    }
+#else
+	
+    for (retry = 0; retry < EDID_TOTAL_RETRY_COUNTER; retry++)
+    {
+        //DDKDEBUGPRINT((DISPLAY_LEVEL, "retry: %d\n", retry));
+		edidSize = 0;
+        /* Read the EDID from the monitor. */
+        for (offset = 0; offset < TOTAL_EDID_REGISTERS_128; offset++)
+        {
+            value = ddk768_hwI2CReadReg(i2cNumber,EDID_DEVICE_I2C_ADDRESS, (unsigned char)offset);
+            if(0xFFFFFFFF == value)
+                break;
+            edidBuffer[offset] = (0xFF & value);
+        }
+        if(0xFFFFFFFF != value)
+        {
+          	edidSize = TOTAL_EDID_REGISTERS_128;
+            if(edidBuffer[EDID_EXTEND_BLOCK])
+            {
+                for (offset = TOTAL_EDID_REGISTERS_128; offset < TOTAL_EDID_REGISTERS_256; offset++)
+                {
+                    value = ddk768_hwI2CReadReg(i2cNumber,EDID_DEVICE_I2C_ADDRESS, (unsigned char)offset);
+
+                    if(0xFFFFFFFF == value)
+                        break;
+                    edidBuffer[offset] = (0xFF & value);
+                }
+
+                if(0xFFFFFFFF != value)
+                	edidSize = TOTAL_EDID_REGISTERS_256;
+            }
+            if(0xFFFFFFFF != value)
+            {
+                /* Check if the EDID is valid. */
+                edidVersion = ddk768_edidGetVersion((unsigned char *)&edidBuffer, (unsigned char *)&edidRevision);
+           //     DDKDEBUGPRINT((DISPLAY_LEVEL, "EDID Structure Version: %d.%d\n", edidVersion, edidRevision));
+                if (edidVersion != 0)
+                    break;
+            }
+        }
+    }
+#endif
+
+    /* Finish using HW I2C, we can close the device. */
+    ddk768_hwI2CClose(i2cNumber);
+    
+     /*
+     *  The monitor might not be DDC2B compliance. Therefore, need to use DDC1 protocol,
+     *  which uses the Vertical Sync to clock in the EDID data.
+     *  Currently this function return error. DDC1 protocol can be added later.
+     */
+    if (retry == EDID_TOTAL_RETRY_COUNTER)
+    {
+        /* DDC1 uses the SDA line to transmit 9 bit data per byte. The last bit is
+         * only an acknowledge flag, which could be high or low. However, SCL line
+         * is not used. Instead the data is clock-in using vertical sync.
+         */
+        return 0;
+    }
+
+    /* Copy the data to the given buffer */
+    if (pEDIDBuffer != (unsigned char *)0)
+    {
+        for (offset = 0; offset < edidSize; offset++)
+            pEDIDBuffer[offset] = edidBuffer[offset];
+    }
+
+    return edidSize;
+}
+
+
+
+/*
+ *  ddk768_edidReadMonitor
+ *      This function reads the EDID structure from the attached monitor
+ *
+ *  Input:
+ *      pEDIDBuffer - Buffer that contains the EDID structure of the monitor
+ *      bufferSize  - The EDID Buffer size index (usually 128-bytes)
+ *      edidExtNo   - Extension Index of the EDID Structure to be read
+ *      i2cNumber   - 0 = I2c0 and 1 = 12c1
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long ddk768_edidReadMonitor(
+    unsigned char *pEDIDBuffer,
+    unsigned long bufferSize,
+    unsigned char edidExtNo,
+    unsigned char i2cNumber
+)
+{
+
+	unsigned char i2cSCL, i2cSDA;
+
+    if (i2cNumber == 0)
+    {
+        i2cSCL = DEFAULT_I2C0_SCL;
+        i2cSDA = DEFAULT_I2C0_SDA;
+    }
+    else
+    {
+        i2cSCL = DEFAULT_I2C1_SCL;
+        i2cSDA = DEFAULT_I2C1_SDA;
+    }
+
+    return ddk768_edidReadMonitorEx(pEDIDBuffer, bufferSize, edidExtNo, i2cSCL, i2cSDA);
+}
+
+
+/*
+ *  edidHeaderReadMonitor
+ *      This function reads the EDID header from the attached monitor
+ *
+ *  Input:
+ *      sclGpio     - GPIO pin used as the I2C Clock (SCL)
+ *      sdaGpio     - GPIO pin used as the I2C Data (SDA)
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long ddk768_edidHeaderReadMonitorEx(
+    unsigned char sclGpio,
+    unsigned char sdaGpio
+)
+{
+    unsigned char retry;//value,
+    unsigned char edidBuffer[10];
+    unsigned long offset;
+
+    /* Initialize the i2c bus */
+    ddk768_swI2CInit(sclGpio, sdaGpio);
+
+    for (retry = 0; retry < EDID_TOTAL_RETRY_COUNTER; retry++)
+    {
+        DDKDEBUGPRINT((DISPLAY_LEVEL, "retry: %d\n", retry));
+
+        /* Read the EDID from the monitor. */
+        for (offset = 0; offset < HEADER_EDID_REGISTERS; offset++)
+            edidBuffer[offset] = ddk768_swI2CReadReg(EDID_DEVICE_I2C_ADDRESS, (unsigned char)offset);
+
+        /* Check if the EDID header is valid. */
+        if (!edidGetHeader((unsigned char *)&edidBuffer))
+            break;
+    }
+
+    /*
+     *  The monitor might not be DDC2B compliance. Therefore, need to use DDC1 protocol,
+     *  which uses the Vertical Sync to clock in the EDID data.
+     *  Currently this function return error. DDC1 protocol can be added later.
+     */
+    if (retry == EDID_TOTAL_RETRY_COUNTER)
+    {
+        /* DDC1 uses the SDA line to transmit 9 bit data per byte. The last bit is
+         * only an acknowledge flag, which could be high or low. However, SCL line
+         * is not used. Instead the data is clock-in using vertical sync.
+         */
+        return (-1);
+    }
+
+    return 0;
+}
+
+long ddk768_edidHeaderReadMonitorExHwI2C(
+    unsigned char i2cNumber
+)
+{
+    unsigned char retry;//value,
+    unsigned char edidBuffer[10];
+    unsigned long offset;
+
+    /* Initialize the i2c bus */
+    ddk768_hwI2CInit(i2cNumber);
+
+    for (retry = 0; retry < EDID_TOTAL_RETRY_COUNTER; retry++)
+    {
+        DDKDEBUGPRINT((DISPLAY_LEVEL, "retry: %d\n", retry));
+
+        /* Read the EDID from the monitor. */
+        for (offset = 0; offset < HEADER_EDID_REGISTERS; offset++)
+            edidBuffer[offset] = ddk768_hwI2CReadReg(i2cNumber,EDID_DEVICE_I2C_ADDRESS, (unsigned char)offset);
+
+        /* Check if the EDID header is valid. */
+        if (!edidGetHeader((unsigned char *)&edidBuffer))
+            break;
+    }
+
+	/* Finish using HW I2C, we can close the device. */
+    ddk768_hwI2CClose(i2cNumber);
+
+    /*
+     *  The monitor might not be DDC2B compliance. Therefore, need to use DDC1 protocol,
+     *  which uses the Vertical Sync to clock in the EDID data.
+     *  Currently this function return error. DDC1 protocol can be added later.
+     */
+    if (retry == EDID_TOTAL_RETRY_COUNTER)
+    {
+        /* DDC1 uses the SDA line to transmit 9 bit data per byte. The last bit is
+         * only an acknowledge flag, which could be high or low. However, SCL line
+         * is not used. Instead the data is clock-in using vertical sync.
+         */
+        return (-1);
+    }
+
+    return 0;
+}
+
+
+
+/*
+ *  ddk768_edidGetEstablishedTiming
+ *      This function gets the established timing list from the given EDID buffer,
+ *      table, and timing index.
+ *
+ *  Input:
+ *      pEDIDBuffer     - Buffer that contains the EDID structure of the monitor (In)
+ *      pEstTableIndex  - Pointer to the Established Timing Table index  (In/Out)
+ *      pIndex          - Pointer to the Establihsed Timing Index (In/Out)
+ *      pWidth          - Pointer to a variable that to store the horizontal active / width
+ *                        value of the retrieved timing (Out)
+ *      pHeight         - Pointer to a variable to store the vertical active / height
+ *                        value of the retrieved timing (Out)
+ *      pRefreshRate    - Pointer to a variable to store the vertical frequency value
+ *                        of the retrieved timing (out)
+ *      pSource         - Pointer to a variable to store the standard timing source:
+ *                          0 - VESA
+ *                          1 - IBM
+ *                          2 - Apple
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long ddk768_edidGetEstablishedTiming(
+    unsigned char *pEDIDBuffer,
+    /*unsigned char *pEstTableIndex,*/
+    unsigned char *pIndex,
+    unsigned long *pWidth,
+    unsigned long *pHeight,
+    unsigned long *pRefreshRate,
+    unsigned char *pSource
+)
+{
+    unsigned char version, revision;
+    unsigned char tableIndex, index;
+    
+    /* Get EDID Version and revision */
+    version = ddk768_edidGetVersion(pEDIDBuffer, &revision);
+    
+    if (version == 1)
+    {
+        edid_version_1_t *pEDIDStructure;
+        
+        /* EDID Structure Version 1. */
+        pEDIDStructure = (edid_version_1_t *)pEDIDBuffer;
+        
+        while (1)
+        {
+            /* Get index */
+            index = *pIndex;
+            
+            if (index > 16)
+                break;
+            
+            /* Search Established Table index 0 when the index is less than 8 */
+            tableIndex = index / 8;
+            
+            /* Exit the function when it has reached the last table. */
+            if (tableIndex > 2)
+                break;
+            
+            /* Increment the index value and update the index accordingly */
+            (*pIndex)++;
+            index %= 8;
+            
+            /* Check */
+            if ((pEDIDStructure->estTiming[tableIndex] & (1 << index)) != 0)
+            {
+                if (pWidth != (unsigned long *)0)
+                    *pWidth = establishTiming[tableIndex][index].x;
+        
+                if (pHeight != (unsigned long *)0)
+                    *pHeight = establishTiming[tableIndex][index].y;
+    
+                if (pRefreshRate != (unsigned long *)0)
+                    *pRefreshRate = establishTiming[tableIndex][index].hz;
+    
+                if (pSource != (unsigned char *)0)
+                    *pSource = establishTiming[tableIndex][index].source;
+                    
+                /* Return success */
+                return 0;
+            }
+        }
+    }
+    else
+    {
+        /* EDID Structure Version 2.0. */
+    }
+    
+    return (-1);
+}
+
+/*
+ *  edidCalculateStdTiming
+ *      This function calculates the width, height, and vertical frequency values
+ *      from the given Standard Timing structure. This function only applies to
+ *      EDID structure version 1. It will give the wrong result when used with
+ *      EDID version 2.
+ *
+ *  Input:
+ *      pStdTiming      - Pointer to a standard timing structure that contains the
+ *                        standard timing value to be calculated (In)
+ *      edid1Revision   - Revision of the EDID 1 (In)
+ *      pWidth          - Pointer to a variable that to store the horizontal active / width
+ *                        value of the retrieved timing (Out)
+ *      pHeight         - Pointer to a variable to store the vertical active / height
+ *                        value of the retrieved timing (Out)
+ *      pRefreshRate    - Pointer to a variable to store the vertical frequency value
+ *                        of the retrieved timing (out)
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+static long edidCalculateStdTiming(
+    standard_timing_t *pStdTiming,
+    unsigned char edid1Revision,
+    unsigned long *pWidth,
+    unsigned long *pHeight,
+    unsigned long *pRefreshRate
+)
+{
+    unsigned long x, y;
+     
+    /* Calculate the standard timing into x and y mode dimension */
+    if (pStdTiming->horzActive != 0x01)
+    {
+        /* Calculate the X and Y */
+        x = (pStdTiming->horzActive + 31) * 8;
+        switch (pStdTiming->stdTimingInfo.aspectRatio)
+        {
+            case 0:
+                if (edid1Revision != 3)
+                    y = x;                  /* 1:1 aspect ratio (prior revision 1.3) */
+                else
+                    y = x * 10 / 16;        /* 16:10 aspect ratio (revision 1.3) */
+                break;
+            case 1:
+                y = x * 3 / 4;              /* 4:3 aspect ratio */
+                break;
+            case 2:
+                y = x * 4 / 5;              /* 5:4 aspect ratio */
+                break;
+            case 3:
+                y = x * 9 / 16;             /* 16:9 aspect ratio */
+                break;
+        }
+
+        if (pWidth != (unsigned long *)0)
+            *pWidth = x;
+
+        if (pHeight != (unsigned long *)0)
+            *pHeight = y;
+
+        if (pRefreshRate != (unsigned long *)0)
+            *pRefreshRate = pStdTiming->stdTimingInfo.refreshRate + 60;
+    
+        return 0;
+    }
+    
+    return (-1);
+}
+
+/*
+ *  ddk768_edidGetStandardTiming
+ *      This function gets the standard timing from the given EDID buffer and
+ *      calculates the width, height, and vertical frequency from that timing.
+ *
+ *  Input:
+ *      pEDIDBuffer     - Buffer that contains the EDID structure of the monitor
+ *      pStdTimingIndex - Pointer to a standard timing index to be retrieved
+ *      pWidth          - Pointer to a variable that to store the horizontal active / width
+ *                        value of the retrieved timing (Out)
+ *      pHeight         - Pointer to a variable to store the vertical active / height
+ *                        value of the retrieved timing (Out)
+ *      pRefreshRate    - Pointer to a variable to store the vertical frequency value
+ *                        of the retrieved timing (out)
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long ddk768_edidGetStandardTiming(
+    unsigned char *pEDIDBuffer,
+    unsigned char *pStdTimingIndex,
+    unsigned long *pWidth,
+    unsigned long *pHeight,
+    unsigned long *pRefreshRate
+)
+{
+    unsigned char version, revision, timingIndex, tableIndex;
+  
+    
+    /* Get EDID Version and revision */
+    version = ddk768_edidGetVersion(pEDIDBuffer, &revision);
+    
+    if (version == 1)
+    {
+        edid_version_1_t *pEDIDStructure;
+        monitor_desc_t *pMonitorDescriptor;
+        
+        /* EDID Structure Version 1. */
+        pEDIDStructure = (edid_version_1_t *)pEDIDBuffer;
+        
+        while (1)
+        {
+            /* There are only 8 standard timing entries */
+            if (*pStdTimingIndex > 7)
+                break;
+            
+            /* Get the table index first before incrementing the index. */
+            timingIndex = *pStdTimingIndex;
+            
+            /* Increment the standard timing index */
+            (*pStdTimingIndex)++;
+            
+            if (timingIndex < 8)
+            {
+                /*
+                 *  Search the first Standard Timing Identifier table
+                 */
+                 
+                /* Calculate the standard timing into x and y mode dimension */
+                if (edidCalculateStdTiming(&pEDIDStructure->stdTiming[timingIndex], 
+                                       revision, pWidth, pHeight, pRefreshRate) == 0)
+                {
+                    return 0;
+                }
+            }
+            else
+            {
+                /*
+                 *  Search Standard Timing Identifier Table in the detailed Timing block. 
+                 */
+                
+                /* 
+                 * Each Detailed Timing Identifier can contains 6 entries of Standard Timing
+                 * Identifier. Based on this value, we can get the Detailed Timing Table Index
+                 * that contains the requested standard timing.
+                 */
+                timingIndex = timingIndex - 8;
+                for (tableIndex = 0; tableIndex < 4; tableIndex++)
+                {
+                    /* Get detailed info */
+                    pMonitorDescriptor = &pEDIDStructure->miscInformation.monitorDesc[tableIndex];
+                    if ((pMonitorDescriptor->flag1 == 0) && (pMonitorDescriptor->flag2 == 0) &&
+                        (pMonitorDescriptor->dataTypeTag == 0xFA))
+                    {
+                        if (timingIndex >= 6)
+                        {
+                            timingIndex-=6;
+                            continue;
+                        }
+                        else
+                        {
+                            if (edidCalculateStdTiming(&pMonitorDescriptor->descriptor.stdTimingExt.stdTiming[timingIndex], 
+                                                   revision, pWidth, pHeight, pRefreshRate) == 0)
+                            {
+                                return 0;
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+    else
+    {
+        /* EDID Structure version 2 */
+    }
+    
+    return (-1);
+}
+
+/*
+ *  ddk768_edidGetDetailedTiming
+ *      This function gets the detailed timing from the given EDID buffer.
+ *
+ *  Input:
+ *      pEDIDBuffer             - Buffer that contains the EDID structure of the monitor
+ *      pDetailedTimingIndex    - Pointer to a detailed timing index to be retrieved
+ *      pModeParameter          - Pointer to a mode_parameter_t structure that will be
+ *                                filled with the detailed timing.
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long ddk768_edidGetDetailedTiming(
+    unsigned char *pEDIDBuffer,
+    unsigned char *pDetailedTimingIndex,
+    vdif_t *pVDIF
+)
+{
+    unsigned char version, revision, tableIndex;
+    unsigned long x, y, aspectRatio;
+    
+    /* Get EDID Version and revision */
+    version = ddk768_edidGetVersion(pEDIDBuffer, &revision);
+    
+    if (version == 1)
+    {
+        edid_version_1_t *pEDIDStructure;
+        detailed_timing_t *pDetailedTiming;
+        
+        /* EDID Structure Version 1. */
+        pEDIDStructure = (edid_version_1_t *)pEDIDBuffer;
+        
+        while (1)
+        {
+            if (*pDetailedTimingIndex > 3)
+                break;
+            
+            /* Get the Detail Timing entry index */
+            tableIndex = *pDetailedTimingIndex;
+            
+            /* Increment the index */
+            (*pDetailedTimingIndex)++;
+                
+            /* Get detailed info */
+            pDetailedTiming = &pEDIDStructure->miscInformation.detailTiming[tableIndex];
+            if ((pDetailedTiming->pixelClock != 0) && (pVDIF != (vdif_t *)0))
+            {
+                /* Translate the Detail timing to VDIF format. */
+                pVDIF->pixelClock = (unsigned long)pDetailedTiming->pixelClock * 10000;
+                pVDIF->characterWidth = 8;
+                pVDIF->scanType = (pDetailedTiming->flags.interlaced == 0) ? VDIF_NONINTERLACED : VDIF_INTERLACED;
+
+                pVDIF->horizontalActive = 
+                    ((unsigned long)pDetailedTiming->horzActiveBlanking.horzActiveMSB << 8) +
+                     (unsigned long)pDetailedTiming->horzActive;
+                pVDIF->horizontalBlankStart = pVDIF->horizontalActive;
+                pVDIF->horizontalBlankTime = 
+                    ((unsigned long)pDetailedTiming->horzActiveBlanking.horzBlankingMSB << 8) +
+                     (unsigned long)pDetailedTiming->horzBlanking;
+                pVDIF->horizontalTotal = pVDIF->horizontalActive + pVDIF->horizontalBlankTime;
+                pVDIF->horizontalFrontPorch = 
+                    ((unsigned long)pDetailedTiming->syncAuxInfo.horzSyncOffset << 8) + 
+                     (unsigned long)pDetailedTiming->horzSyncOffset;
+                pVDIF->horizontalSyncStart = pVDIF->horizontalBlankStart + pVDIF->horizontalFrontPorch;
+                pVDIF->horizontalSyncWidth = 
+                    ((unsigned long)pDetailedTiming->syncAuxInfo.horzSyncWidth << 8) +
+                     (unsigned long)pDetailedTiming->horzSyncPulseWidth;                     
+                pVDIF->horizontalBackPorch = 
+                    pVDIF->horizontalBlankTime - (pVDIF->horizontalFrontPorch + pVDIF->horizontalSyncWidth);
+                pVDIF->horizontalFrequency = ddk768_roundedDiv(pVDIF->pixelClock, pVDIF->horizontalTotal);
+                pVDIF->horizontalLeftBorder = 0;
+                pVDIF->horizontalRightBorder = 0;
+        
+                pVDIF->verticalActive = 
+                    ((unsigned long)pDetailedTiming->vertActiveBlanking.vertActiveMSB << 8) +
+                     (unsigned long)pDetailedTiming->vertActive;
+                pVDIF->verticalBlankStart = pVDIF->verticalActive;
+                pVDIF->verticalBlankTime =
+                    ((unsigned long)pDetailedTiming->vertActiveBlanking.vertBlankingMSB << 8) +
+                     (unsigned long)pDetailedTiming->vertBlanking;
+                pVDIF->verticalTotal = pVDIF->verticalActive + pVDIF->verticalBlankTime;
+                pVDIF->verticalFrontPorch = 
+                    ((unsigned long)pDetailedTiming->syncAuxInfo.vertSyncOffset << 8) +
+                     (unsigned long)pDetailedTiming->verticalSyncInfo.syncOffset;
+                pVDIF->verticalSyncStart = pVDIF->verticalBlankStart + pVDIF->verticalFrontPorch;
+                pVDIF->verticalSyncHeight =
+                    ((unsigned long)pDetailedTiming->syncAuxInfo.vertSyncWidth  << 8) +
+                     (unsigned long)pDetailedTiming->verticalSyncInfo.syncWidth;
+                pVDIF->verticalBackPorch =
+                    pVDIF->verticalBlankTime - (pVDIF->verticalFrontPorch + pVDIF->verticalSyncHeight);
+                pVDIF->verticalFrequency =
+                    ddk768_roundedDiv(pVDIF->pixelClock, (pVDIF->horizontalTotal * pVDIF->verticalTotal));
+                pVDIF->verticalTopBorder = 0;
+                pVDIF->verticalBottomBorder = 0;
+                
+                if (pDetailedTiming->flags.connectionType == 3)
+                {
+                    pVDIF->verticalSyncPolarity = 
+                        (pDetailedTiming->flags.vertSyncFlag == 1) ? VDIF_SYNC_POSITIVE : VDIF_SYNC_NEGATIVE;
+                    pVDIF->horizontalSyncPolarity = 
+                        (pDetailedTiming->flags.horzSyncFlag == 1) ? VDIF_SYNC_POSITIVE : VDIF_SYNC_NEGATIVE;
+                }
+                else
+                {
+                    pVDIF->verticalSyncPolarity = VDIF_SYNC_NEGATIVE;
+                    pVDIF->horizontalSyncPolarity = VDIF_SYNC_NEGATIVE;
+                }
+                
+                /* For debugging purpose. */
+                printVdif(pVDIF);
+                
+                return 0;
+            }
+        }
+    }
+    
+    return (-1);
+}
+
+/*
+ *  ddk768_edidGetMonitorSerialNumber
+ *      This function gets the monitor serial number from the EDID structure.
+ *      Only EDID version 1 and revision 1 or above supports this feature.
+ *
+ *  Input:
+ *      pEDIDBuffer             - Buffer that contains the EDID structure of the monitor
+ *      pMonitorSerialNumber    - Pointer to a buffer to store the serial number 
+ *                                retrieved from the EDID
+ *      bufferSize              - The size of the buffer to store the serial number.
+ *                                The maximum size required is 13 bytes.
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long ddk768_edidGetMonitorSerialNumber(
+    unsigned char *pEDIDBuffer,
+    char *pMonitorSerialNumber,
+    unsigned char bufferSize
+)
+{
+    unsigned char version, revision, tableIndex, charIndex;
+    
+    /* If no pointer is given or the buffer size is set to 0, then return fail. */
+    if ((pMonitorSerialNumber == (char *)0) || (bufferSize == 0))
+        return (-1);
+    
+    /* Get EDID Version and revision */
+    version = ddk768_edidGetVersion(pEDIDBuffer, &revision);
+    
+    if ((version == 1) && (revision > 0))
+    {
+        edid_version_1_t *pEDIDStructure;
+        monitor_desc_t *pMonitorDescriptor;
+        
+        /* EDID Structure Version 1. */
+        pEDIDStructure = (edid_version_1_t *)pEDIDBuffer;
+        for (tableIndex = 0; tableIndex < 4; tableIndex++)
+        {
+            pMonitorDescriptor = &pEDIDStructure->miscInformation.monitorDesc[tableIndex];
+            if ((pMonitorDescriptor->flag1 == 0) && (pMonitorDescriptor->flag2 == 0) &&
+                (pMonitorDescriptor->dataTypeTag == 0xFF))
+            {
+                bufferSize = (bufferSize > 13) ? 13 : bufferSize;
+                for (charIndex = 0; charIndex < 13; charIndex++)
+                {
+                    if (pMonitorDescriptor->descriptor.serialNo[charIndex] == 0x0A)
+                    {
+                        pMonitorSerialNumber[charIndex] = '\0';
+                        break;
+                    }
+                        
+                    pMonitorSerialNumber[charIndex] = pMonitorDescriptor->descriptor.serialNo[charIndex];
+                }
+                
+                return 0;
+            }
+        }
+    }
+    
+    /* Serial Number is not found. */
+    return (-1);
+}
+
+/*
+ *  ddk768_edidGetDataString
+ *      This function gets the data string from the EDID 
+ *      Only EDID version 1 and revision 1 or above supports this feature.
+ *
+ *  Input:
+ *      pEDIDBuffer             - Buffer that contains the EDID structure of the monitor
+ *      pMonitorSerialNumber    - Pointer to a buffer to store the data string 
+ *                                retrieved from the EDID
+ *      bufferSize              - The size of the buffer to store the data string
+ *                                The maximum size required is 13 bytes.
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long ddk768_edidGetDataString(
+    unsigned char *pEDIDBuffer,
+    char *pDataString,
+    unsigned char bufferSize
+)
+{
+    unsigned char version, revision, tableIndex, charIndex;
+    
+    /* If no pointer is given or the buffer size is set to 0, then return fail. */
+    if ((pDataString == (char *)0) || (bufferSize == 0))
+        return (-1);
+    
+    /* Get EDID Version and revision */
+    version = ddk768_edidGetVersion(pEDIDBuffer, &revision);
+    
+    if ((version == 1) && (revision > 0))
+    {
+        edid_version_1_t *pEDIDStructure;
+        monitor_desc_t *pMonitorDescriptor;
+        
+        /* EDID Structure Version 1. */
+        pEDIDStructure = (edid_version_1_t *)pEDIDBuffer;
+        for (tableIndex = 0; tableIndex < 4; tableIndex++)
+        {
+            pMonitorDescriptor = &pEDIDStructure->miscInformation.monitorDesc[tableIndex];
+            if ((pMonitorDescriptor->flag1 == 0) && (pMonitorDescriptor->flag2 == 0) &&
+                (pMonitorDescriptor->dataTypeTag == 0xFE))
+            {
+                bufferSize = (bufferSize > 13) ? 13 : bufferSize;
+                for (charIndex = 0; charIndex < 13; charIndex++)
+                {
+                    if (pMonitorDescriptor->descriptor.dataString[charIndex] == 0x0A)
+                    {
+                        pDataString[charIndex] = '\0';
+                        break;
+                    }
+                        
+                    pDataString[charIndex] = pMonitorDescriptor->descriptor.dataString[charIndex];
+                }
+                
+                return 0;
+            }
+        }
+    }
+    
+    /* Data String is not found. */
+    return (-1);
+}
+
+/*
+ *  ddk768_edidGetMonitorRangeLimit
+ *      This function gets the monitor range limits from the EDID structure.
+ *      Only EDID version 1 revision 1 or above supports this feature.
+ *      This is a required field in EDID Version 1.3
+ *
+ *  Input:
+ *      pEDIDBuffer         - Buffer that contains the EDID structure of the monitor
+ *      pMinVerticalRate    - Pointer to a variable to store the Minimum Vertical Rate (Hz)
+ *      pMaxVerticalRate    - Pointer to a variable to store the Maximum Vertical Rate (Hz)
+ *      pMinHorzFreq        - Pointer to a variable to store the Minimum Horz. Freq (kHz)
+ *      pMaxHorzFreq        - Pointer to a variable to store the Maximum Horz. Freq (kHz)
+ *      pMaxPixelClock      - Pointer to a variable to store the Maximum Pixel Clock (Hz)
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long ddk768_edidGetMonitorRangeLimit(
+    unsigned char *pEDIDBuffer,
+    unsigned char *pMinVerticalRate,
+    unsigned char *pMaxVerticalRate,
+    unsigned char *pMinHorzFreq,
+    unsigned char *pMaxHorzFreq,
+    unsigned long *pMaxPixelClock
+)
+{
+    unsigned char version, revision, tableIndex, charIndex;
+    
+    if (pEDIDBuffer == (unsigned char *)0)
+        return (-1);
+            
+    /* Get EDID Version and revision */
+    version = ddk768_edidGetVersion(pEDIDBuffer, &revision);
+    
+    if ((version == 1) && (revision > 0))
+    {
+        edid_version_1_t *pEDIDStructure;
+        monitor_desc_t *pMonitorDescriptor;
+        
+        /* EDID Structure Version 1. */
+        pEDIDStructure = (edid_version_1_t *)pEDIDBuffer;
+        
+        for (tableIndex = 0; tableIndex < 4; tableIndex++)
+        {
+            pMonitorDescriptor = &pEDIDStructure->miscInformation.monitorDesc[tableIndex];
+            if ((pMonitorDescriptor->flag1 == 0) && (pMonitorDescriptor->flag2 == 0) &&
+                (pMonitorDescriptor->dataTypeTag == 0xFD) && (pMonitorDescriptor->flag3 == 0))
+            {
+                if (pMinVerticalRate != (unsigned char *)0)
+                    *pMinVerticalRate = pMonitorDescriptor->descriptor.monitorRange.minVertRate;
+
+                if (pMaxVerticalRate != (unsigned char *)0)
+                    *pMaxVerticalRate = pMonitorDescriptor->descriptor.monitorRange.maxVertRate;
+                    
+                if (pMinHorzFreq != (unsigned char *)0)
+                    *pMinHorzFreq = pMonitorDescriptor->descriptor.monitorRange.minHorzFrequency;
+                    
+                if (pMaxHorzFreq != (unsigned char *)0)
+                    *pMaxHorzFreq = pMonitorDescriptor->descriptor.monitorRange.maxHorzFrequency;
+                    
+                if (pMaxPixelClock != (unsigned long *)0)
+                    *pMaxPixelClock = (unsigned long) pMonitorDescriptor->descriptor.monitorRange.maxPixelClock * 10 * 1000000;
+                    
+                return 0;
+            }
+        }
+    }
+    
+    /* Data String is not found. */
+    return (-1);
+}
+
+/*
+ *  edidGetChannel1TimingSupport
+ *      This function gets the secondary GTF timing support.
+ *      Only EDID version 1 and revision 1 or above supports this feature.
+ *
+ *  Input:
+ *      pEDIDBuffer             - Buffer that contains the EDID structure of the monitor
+ *      pStartFrequency         - Pointer to a variable to store the start frequency of 
+ *                                the secondary GTF
+ *      pOffset                 - Pointer to a variable to store the Offset (C) value of
+ *                                the secondary GTF
+ *      pGradient               - Pointer to a variable to store the Gradient (M) value of
+ *                                the secondary GTF
+ *      pScalingFactor          - Pointer to a variable to store the Scaling Factor (K)
+ *                                value of the secondary GTF
+ *      pScalingFactorWeight    - Pointer to a variable to store the Scaling Factore Weight (J)
+ *                                value of the secondary GTF
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long edidGetChannel1TimingSupport(
+    unsigned char *pEDIDBuffer,
+    unsigned short *pStartFrequency,
+    unsigned char *pOffset,
+    unsigned short *pGradient,
+    unsigned char *pScalingFactor,
+    unsigned char *pScalingFactorWeight
+)
+{
+    unsigned char version, revision, tableIndex, charIndex;
+            
+    /* Get EDID Version and revision */
+    version = ddk768_edidGetVersion(pEDIDBuffer, &revision);
+    
+    if ((version == 1) && (revision > 0) && (pEDIDBuffer != (unsigned char *)0))
+    {
+        edid_version_1_t *pEDIDStructure;
+        monitor_desc_t *pMonitorDescriptor;
+        
+        /* EDID Structure Version 1. */
+        pEDIDStructure = (edid_version_1_t *)pEDIDBuffer;
+        for (tableIndex = 0; tableIndex < 4; tableIndex++)
+        {
+            pMonitorDescriptor = &pEDIDStructure->miscInformation.monitorDesc[tableIndex];
+            if ((pMonitorDescriptor->flag1 == 0) && (pMonitorDescriptor->flag2 == 0) &&
+                (pMonitorDescriptor->dataTypeTag == 0xFD) && 
+                (pMonitorDescriptor->descriptor.monitorRange.secondaryTimingFlag == 0x02))
+            {
+                if (pStartFrequency != (unsigned short *)0)
+                    *pStartFrequency = (unsigned short)
+                        pMonitorDescriptor->descriptor.monitorRange.secondaryTimingInfo.cmkjParam.startFrequency * 2 * 1000;
+
+                if (pOffset != (unsigned char *)0)
+                    *pOffset = pMonitorDescriptor->descriptor.monitorRange.secondaryTimingInfo.cmkjParam.cParam/2;
+                    
+                if (pGradient != (unsigned short *)0)
+                    *pGradient = pMonitorDescriptor->descriptor.monitorRange.secondaryTimingInfo.cmkjParam.mParam;
+                    
+                if (pScalingFactor != (unsigned char *)0)
+                    *pScalingFactor = pMonitorDescriptor->descriptor.monitorRange.secondaryTimingInfo.cmkjParam.kParam;
+                    
+                if (pScalingFactorWeight != (unsigned char *)0)
+                    *pScalingFactorWeight = pMonitorDescriptor->descriptor.monitorRange.secondaryTimingInfo.cmkjParam.jParam / 2;
+                    
+                return 0;
+            }
+        }
+    }
+    
+    /* Data String is not found. */
+    return (-1);
+}
+
+/*
+ *  ddk768_edidGetMonitorName
+ *      This function gets the monitor name from the EDID structure.
+ *      This is a required field in EDID Version 1.3
+ *
+ *  Input:
+ *      pEDIDBuffer             - Buffer that contains the EDID structure of the monitor
+ *      pMonitorName            - Pointer to a buffer to store the monitor name 
+ *                                retrieved from the EDID
+ *      bufferSize              - The size of the buffer to store the monitor name
+ *                                The maximum size required is 13 bytes.
+ * 
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long ddk768_edidGetMonitorName(
+    unsigned char *pEDIDBuffer,
+    char *pMonitorName,
+    unsigned char bufferSize
+)
+{
+    unsigned char version, revision, tableIndex, charIndex;
+    
+    /* If no pointer is given or the buffer size is set to 0, then return fail. */
+    if ((pMonitorName == (char *)0) || (bufferSize == 0))
+        return (-1);
+        
+    /* Get EDID Version and revision */
+    version = ddk768_edidGetVersion(pEDIDBuffer, &revision);
+    
+    if (version == 1)
+    {
+        edid_version_1_t *pEDIDStructure;
+        monitor_desc_t *pMonitorDescriptor;
+        
+        /* EDID Structure Version 1. */
+        pEDIDStructure = (edid_version_1_t *)pEDIDBuffer;
+        for (tableIndex = 0; tableIndex < 4; tableIndex++)
+        {
+            pMonitorDescriptor = &pEDIDStructure->miscInformation.monitorDesc[tableIndex];
+            if ((pMonitorDescriptor->flag1 == 0) && (pMonitorDescriptor->flag2 == 0) &&
+                (pMonitorDescriptor->dataTypeTag == 0xFC) && (pMonitorDescriptor->flag3 == 0))
+            {
+                bufferSize = (bufferSize > 13) ? 13 : bufferSize;
+                for (charIndex = 0; charIndex < 13; charIndex++)
+                {
+                    if (pMonitorDescriptor->descriptor.monitorName[charIndex] == 0x0A)
+                    {
+                        pMonitorName[charIndex] = '\0';
+                        break;
+                    }
+                        
+                    pMonitorName[charIndex] = pMonitorDescriptor->descriptor.monitorName[charIndex];
+                }
+                
+                return 0;
+            }
+        }
+    }
+    
+    /* Data String is not found. */
+    return (-1);
+}
+
+/*
+ *  ddk768_edidGetPreferredTiming
+ *      This function gets the preferred/native timing of the monitor
+ *
+ *  Input:
+ *      pEDIDBuffer         - Buffer that contains the EDID structure of the monitor
+ *      pWidth              - Pointer to an unsigned long buffer to store the width 
+ *                            of the preferred (native) timing.
+ *      pHeight             - Pointer to an unsigned long buffer to store the height
+ *                            of the preferred (native) timing.
+ *      pVerticalFrequency  - Pointer to an unsigned long buffer to store the refresh
+ *                            rate of the preferred (native) timing.
+ * 
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long ddk768_edidGetPreferredTiming(
+    unsigned char *pEDIDBuffer,
+    unsigned long *pWidth,
+    unsigned long *pHeight,
+    unsigned long *pVerticalFrequency
+)
+{
+    unsigned char index = 0;
+    vdif_t vdifBuffer;
+
+
+    {
+        /* The preferred (native) timing is available, so get the timing. It is located
+           at the first index of detailed timing.
+         */
+        if (ddk768_edidGetDetailedTiming(pEDIDBuffer, &index, &vdifBuffer) == 0)
+        {
+            if (pWidth != (unsigned long *)0)
+                *pWidth = vdifBuffer.horizontalActive;
+                
+            if (pHeight != (unsigned long *)0)
+                *pHeight = vdifBuffer.verticalActive;
+                
+            if (pVerticalFrequency != (unsigned long *)0)
+                *pVerticalFrequency = vdifBuffer.verticalFrequency;
+                
+            return 0;
+        }
+    }
+    
+    return (-1);
+}
diff --git a/drivers/gpu/drm/smi/ddk768/ddk768_edid.h b/drivers/gpu/drm/smi/ddk768/ddk768_edid.h
new file mode 100644
index 000000000000..c9718fe9f8cf
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk768/ddk768_edid.h
@@ -0,0 +1,1049 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2009 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  edid.h --- SMI DDK 
+*  This file contains the EDID structure and function API to
+*  interpret the EDID
+* 
+*******************************************************************/
+#ifndef _EDID_H_
+#define _EDID_H_
+
+#include "ddk768_display.h"
+#include "vdif.h"
+
+#define EDID_DEVICE_I2C_ADDRESS             0xA0
+#define TOTAL_EDID_REGISTERS                128
+
+/* Set the alignment to 1-bit aligned. Otherwise, it can't get the EDID correctly. */
+#pragma pack(1)
+
+#define TOTAL_EDID_REGISTERS_128                128
+#define TOTAL_EDID_REGISTERS_256                256
+#define EDID_EXTEND_BLOCK         126
+
+/* Standard Timing Structure */
+typedef struct _standard_timing_t
+{
+    unsigned char horzActive;       /* (Horizontal active pixels / 8 ) - 31 */
+    struct
+    {
+        unsigned char refreshRate:6;    /* Refresh Rate (Hz) - 60; Range 60 --> 123 */
+        unsigned char aspectRatio:2;    /* Aspect Ratio:
+                                            Bit 7   Bit 6   Operation
+                                              0       0        1:1      (prior Version 1.3)
+                                              0       0       16:10     (Version 1.3)
+                                              0       1        4:3
+                                              1       0        5:4
+                                              1       1       16:9
+                                         */
+    } stdTimingInfo;
+} standard_timing_t;
+
+/* Detailed Timing Description Structure */
+typedef struct _detailed_timing_t
+{
+    unsigned short pixelClock;
+    unsigned char horzActive;
+    unsigned char horzBlanking;
+    struct 
+    {
+        unsigned char horzBlankingMSB:4;
+        unsigned char horzActiveMSB:4;
+    } horzActiveBlanking;
+    unsigned char vertActive;
+    unsigned char vertBlanking;
+    struct 
+    {
+        unsigned char vertBlankingMSB:4;
+        unsigned char vertActiveMSB:4;
+    } vertActiveBlanking;
+    unsigned char horzSyncOffset;
+    unsigned char horzSyncPulseWidth;
+    struct
+    {
+        unsigned char syncWidth:4;
+        unsigned char syncOffset:4;
+    } verticalSyncInfo;
+    struct
+    {
+        unsigned char vertSyncWidth:2;
+        unsigned char vertSyncOffset:2;
+        unsigned char horzSyncWidth:2;
+        unsigned char horzSyncOffset:2;
+    } syncAuxInfo;
+    unsigned char horzImageSize;
+    unsigned char vertImageSize;
+    struct
+    {
+        unsigned char vertImageSizeMSB:4;
+        unsigned char horzImageSizeMSB:4;
+    } horzVertImageSize;
+    unsigned char horzBorder;
+    unsigned char vertBorder;
+    struct
+    {
+        unsigned char interleaved:1;
+        unsigned char horzSyncFlag:1;
+        unsigned char vertSyncFlag:1;
+        unsigned char connectionType:2;
+        unsigned char stereo:2;
+        unsigned char interlaced:1;
+    } flags;
+} detailed_timing_t;
+
+typedef struct _color_point_t
+{
+    unsigned char whitePointIndex;
+    struct
+    {
+        unsigned char whiteYLowBits:2;
+        unsigned char whiteXLowBits:2;
+        unsigned char reserved:4;
+    } whiteLowBits;
+    unsigned char whiteX;
+    unsigned char whiteY;
+    unsigned char gamma;
+} color_point_t;
+
+typedef struct _monitor_desc_t
+{
+    unsigned short flag1;               /* Flag = 0000h when block used as descriptor */
+    unsigned char flag2;                /* Flag = 00h when block used as descriptor */
+    unsigned char dataTypeTag;          /* Data type tag:
+                                                FFh: Monitor Serial Number - Stored as ASCII, 
+                                                     code page #437, <= 13bytes
+                                                FEh: ASCII String - Stored as ASCII, code 
+                                                     page #437, <= 13 bytes
+                                                FDh: Monitor range limits, binary coded
+                                                FCh: Monitor name, stored as ASCII, code page #437
+                                                FBh: Descriptor contains additional color point data
+                                                FAh: Descriptor contains additional Standard Timing
+                                                     Identifications
+                                                F9h-11h: Currently undefined
+                                                10h: Dummy descriptor, used to indicate 
+                                                     that the descriptor space is unused
+                                                0Fh-00h: Descriptor defined by manufacturer.
+                                         */
+    unsigned char flag3;                /* Flag = 00h when block used as descriptor */
+    union
+    {
+        unsigned char serialNo[13];
+        unsigned char dataString[13];
+        struct
+        {
+            unsigned char minVertRate;
+            unsigned char maxVertRate;
+            unsigned char minHorzFrequency;
+            unsigned char maxHorzFrequency;
+            unsigned char maxPixelClock;        /* Binary coded clock rate in MHz / 10 
+                                                   Max Pixel Clock those are not a multiple of 10MHz
+                                                   is rounded up to a multiple of 10MHz
+                                                 */
+            unsigned char secondaryTimingFlag;  /* 00h = No secondary timing formula supported
+                                                   (Support for default GTF indicated in feature byte)
+                                                   02h = Channel1 GTF curve supported
+                                                   All other = Reserved for future timing formula
+                                                               definitions.
+                                                 */
+            union
+            {
+                unsigned char constantStr[7];
+                struct
+                {
+                    unsigned char reserved;
+                    unsigned char startFrequency;
+                    unsigned char cParam;
+                    unsigned short mParam;
+                    unsigned char kParam;
+                    unsigned char jParam;
+                } cmkjParam;
+            } secondaryTimingInfo;
+        } monitorRange;
+        
+        unsigned char monitorName[13];
+        struct
+        {
+            color_point_t white[2];
+            unsigned char reserved[3];          /* Set to (0Ah, 20h, 20h)*/
+        } colorPoint;
+        
+        struct
+        {
+            standard_timing_t stdTiming[6];
+            unsigned char reserved;             /* Set to 0Ah */
+        } stdTimingExt;
+        
+        unsigned char manufactureSpecifics[13];
+    } descriptor; 
+}
+monitor_desc_t;
+
+/* EDID Structuve Version 1. Within version 1 itself, there are 4 revisions mentioned
+   below: 
+    - EDID 1.0: The original 128-byte data format
+    - EDID 1.1: Added definitions for monitor descriptors as an alternate use of the space 
+                originally reserved for detailed timings, as well as definitions for 
+                previously unused fields.
+    - EDID 1.2: Added definitions to existing data fields.
+    - EDID 1.3: Added definitions for secondary GTF curve coefficients. This is the new
+                baseline for EDID data structures, which is recommended for all new monitor
+                designs.
+ */
+typedef struct _edid_version_1_t
+{
+    /* Header (8 bytes) */
+    unsigned char header[8];            /* Header */
+    
+    /* Vendor / Product ID (10 bytes) */
+    unsigned short manufacturerID;      /* Manufacture Identification */
+    unsigned short productCode;         /* Product code Identification */ 
+    unsigned long serialNumber;         /* Serial Number */
+    unsigned char weekOfManufacture;    /* Week of Manufacture */
+    unsigned char yearOfManufacture;    /* Year of Manufacture */
+    
+    /* EDID Structure version / revision (2 bytes) */
+    unsigned char version;              /* EDID Structure Version no. */
+    unsigned char revision;             /* Revision Version no. */
+    
+    /* Basic Display Parameters / Features (5 bytes) */
+    union
+    {
+        struct
+        {
+            unsigned char vsyncSerration:1;
+            unsigned char syncOnGreenSupport:1;
+            unsigned char compositeSyncSupport:1;
+            unsigned char separateSyncSupport:1;
+            unsigned char blank2Black:1;
+            unsigned char signalLevelStd:2;
+            unsigned char inputSignal:1;    /* Input Signal: Analog = 0, Digital = 1 */
+        } analogSignal;
+        struct
+        {
+            unsigned char dfp1Support:1;
+            unsigned char reserved:6;
+            unsigned char inputSignal:1;    /* Input Signal: Analog = 0, Digital = 1 */
+        } digitalSignal;
+    } videoInputDefinition;             /* Video Input Definition */
+
+    unsigned char maxHorzImageSize;     /* Maximum Horizontal Image Size */
+    unsigned char maxVertImageSize;     /* Maximum Vertical Image Size */
+    unsigned char displayTransferChar;  /* Display Transfer Characteristic (Gamma) */
+    struct
+    {
+        unsigned char defaultGTFSupport:1;  /* Support timings based on the GTF standard using
+                                               default GTF parameters 
+                                             */ 
+        unsigned char preferredTiming:1;    /* If set, the display's preferred timing mode is
+                                               indicated in the first detailed timing block.
+                                             */
+        unsigned char sRGBSupport:1;        /* If set, the display uses the sRGB standard
+                                               default color space as its primary color space
+                                             */
+        unsigned char displayType:2;        /* Display Type:
+                                                    00  - Monochrome / Grayscale display
+                                                    01  - RGB Color Display
+                                                    10  - Non-RGB multicolor display, e.g. R/G/Y
+                                                    11  - Undefined
+                                             */
+        unsigned char lowPowerSupport:1;    /* If set, the display consumes much less power when
+                                               it receives a timing signal outside its active
+                                               operating range. It will revert to normal if the
+                                               timing returns to the normal operating range.
+                                             */
+        unsigned char suspendSupport:1;     /* Support Suspend as defined in VESA DPMS spec. */
+        unsigned char standbySupport:1;     /* Support Standby as defined in VESA DPMS spec. */
+    } featureSupport;                   /* Feature Support */
+    
+    /* Color Characteristics (10 bytes) */
+    struct
+    {
+        unsigned char greenYLowBits:2;
+        unsigned char greenXLowBits:2;
+        unsigned char redYLowBits:2;
+        unsigned char redXLowBits:2;
+    } redGreenLowBits;                  /* Red/Green Low Bits */
+    struct
+    {
+        unsigned char whiteYLowBits:2;
+        unsigned char whiteXLowBits:2;
+        unsigned char blueYLowBits:2;
+        unsigned char blueXLowBits:2;
+    } blueWhiteLowBits;                 /* Blue/White Low Bits */
+    unsigned char redX;                 /* Red-x bits 9-2 */
+    unsigned char redY;                 /* Red-y bits 9-2 */
+    unsigned char greenX;               /* Green-x bits 9-2 */
+    unsigned char greenY;               /* Green-y bits 9-2 */
+    unsigned char blueX;                /* Blue-x bits 9-2 */
+    unsigned char blueY;                /* Blue-y bits 9-2 */
+    unsigned char whiteX;               /* White-x bits 9-2 */
+    unsigned char whiteY;               /* White-y bits 9-2 */
+    
+    /* Established Timings (3 bytes) */
+    unsigned char estTiming[3];         /* Established Timings */
+    
+    /* Standard Timing Identification (16 bytes) */
+    standard_timing_t stdTiming[8];     /* Standard Timings Identification */
+
+    /* Detailed Timing Descriptions (72 bytes) */
+    union
+    {
+        detailed_timing_t detailTiming[4];  /* Detailed Timing Descriptor */
+        monitor_desc_t monitorDesc[4];  /* Monitor descriptor */
+    } miscInformation;
+    
+    /* Extension Flag (1 byte) */
+    unsigned char extFlag;              /* Number of (optional) 1280byte EDID
+                                           extension blocks to follow. 
+                                         */
+                                         
+    /* Checksum (1 byte) */
+    unsigned char checksum;             /* The 1-byte sum of all 128 bytes in 
+                                           this EDID block shall equal zero. 
+                                         */
+}
+edid_version_1_t;
+
+#if 0   /* Temporary on hold. To be completed later. */
+
+/* EDID Version 2.0. Not widely used. Usually defined for displays that follow 
+   the original VESA Plug & Display (P&D) and Flat Panel Display Interface-2 (FPDI-2)
+   Standards
+ */
+typedef struct _edid_version_2_t
+{
+    /* 
+     * EDID Structure Version/Revision (1 byte) 
+     */
+    unsigned char version:4;
+    unsigned char revision:4;
+    
+    /* 
+     * Vendor / Product ID (7 bytes) 
+     */
+    unsigned short manufacturerID;              /* ID Manufacturer Name */
+    unsigned short productID;                   /* ID Product Code */
+    unsigned char manufactureWeek;              /* Week of Manufacture */
+    unsigned short manufactureYear;             /* Year of Manufacture */
+    
+    /* 
+     * Manufacturer/Product ID string (32 bytes) 
+     */
+    unsigned char productName;                  /* This string is compiresed of both manufacture name 
+                                                   and model name, which are separated using ASCII code 09h.
+                                                   If the entire string is <32 bytes, then it is terminated
+                                                   with ASCII code 0Ah and the field is padded with ASCII 
+                                                   code 20h 
+                                                 */
+                                             
+    /* 
+     * Serial number string (16 bytes) 
+     */
+    unsigned char serianNumber[16];             /* Serial number string. If <16 bytes then the string is
+                                                   terminated with ASCII code 0Ah and the field padded
+                                                   with ASCII code 20h
+                                                 */
+                                             
+    /* 
+     * Unused/Reserved (8 bytes) 
+     */
+    unsigned char reserved[8];
+    
+    /* 
+     * Display Interface Parameters (15 bytes) 
+     */
+    unsigned char secondaryPhysicalIF:4;        /* Look at defaultPhysicalIF description above. */
+    unsigned char defaultPhysicalIF:4;          /* Physical Connector Types. Consists of 2 fields. Bit 7-4
+                                                   indicates the connector for the default interface. If
+                                                   a secondary interface is available, its connector is
+                                                   indicated using bit 3-0. Both fields value description
+                                                   is listed below:
+                                                        0 = None (Not valid for default connector)
+                                                        1 = BNC
+                                                        2 = 15 pin VGA
+                                                        3 = 13w3
+                                                        4 = VESA EVC
+                                                        5 = VESA P&D-D
+                                                        6 = Micro-ribbon Connector (per the VESA P&D standard)
+                                                        7 = IEEE-1394 connector
+                                                        8 = VESA FPDI-2
+                                                        9-E = Reserved
+                                                        F = Non-standard connector
+                                                 */
+    unsigned char secondaryVideoIF:4;           /* Look at the defaultVideoIF description above. */
+    unsigned char defaultVideoIF:4;             /* Video Interface Types. Consists of 2 fields. Bit 7-4
+                                                   defines the default video interface. Bit 3-0 defines
+                                                   the secondary interface. Descriptions of the field is
+                                                   listed below:
+                                                        0 = None (Not valid for default interface)
+                                                        1 = Analog
+                                                        2 = Analog w/ sampled pixel clock
+                                                        3 = TMDS (Transition Minimized Differential Signaling)
+                                                        4 = IEEE-1394-1995
+                                                        5 = LVDS
+                                                        6 = Parallel
+                                                        7-F = Reserved
+                                                 */
+    unsigned char analogIFDataFormat[4];        /* Analog Interface Data Format */
+    unsigned char digitalIFDataFormat[4];       /* Digital Interface Data Format */
+    unsigned char secondaryColorEncodingIF:4;   /* Channel1 Color Encoding Interface */
+    unsigned char defaultColorEncodingIF:4;     /* Color Encoding default Interface */
+    unsigned char primarySubChannel1:4;         /* Supported bit-depth of sub-channel 1 ("Green") 
+                                                   of the Channel0 interface. */
+    unsigned char primarySubChannel0:4;         /* Supported bit-depth of sub-channel 0 ("Red") 
+                                                   of the Channel0 interface. */
+    unsigned char primarySubChannel3:4;         /* Supported bit-depth of sub-channel 3 of the 
+                                                   Channel0 interface. */
+    unsigned char primarySubChannel2:4;         /* Supported bit-depth of sub-channel 2 ("Blue") 
+                                                   of the Channel0 interface. */
+    unsigned char secondarySubChannel1:4;       /* Supported bit-depth of sub-channel 1 ("Green") 
+                                                   of the Channel1 interface. */
+    unsigned char secondarySubChannel0:4;       /* Supported bit-depth of sub-channel 0 ("Red") 
+                                                   of the Channel1 interface. */
+    unsigned char secondarySubChannel3:4;       /* Supported bit-depth of sub-channel 3 of the 
+                                                   Channel1 interface. */
+    unsigned char secondarySubChannel2:4;       /* Supported bit-depth of sub-channel 2 ("Blue") 
+                                                   of the Channel1 interface. */
+                                                   
+    /* 
+     * Display Device Description (5 bytes) 
+     */
+    unsigned char displayType;                  /* Display technology type/subtype*/
+    unsigned char displayCharacteristic;        /* Major display characteristics. */
+    unsigned char featureSupport[3];            /* Feature Support */
+    
+    /* 
+     * Display Response Time (2 bytes) 
+     */
+    unsigned char riseTimeResponse:4;           /* Rise time response in seconds */
+    unsigned char riseTimeExponent:4;           /* Rise time exponent */
+    unsigned char fallTimeResponse:4;           /* Fall time response in seconds */
+    unsigned char fallTimeExponent:4;           /* Fall time exponent */
+    
+    /* 
+     * Color / Luminance Description (28 bytes) 
+     */
+    unsigned char whiteGamme;                   /* (Gamma x 100) - 100, [range 1.00 --> 3.55] */
+    unsigned char redGamma;                     /* Color 0 ("red") Gamma (optional). Set to ffh if unused. */
+    unsigned char greenGamma;                   /* Color 1 ("green") Gamma (optional). Set to ffh if unused. */
+    unsigned char blueGamma;                    /* Color 2 ("blue") Gamma (optional). Set to ffh if unused. */
+    unsigned short maxLuminance;                /* Maximum LUminance (white) in units of cd/m^2*10 */
+    unsigned char colorConfig;                  /* Standard RGB Model, adjustable Gamma and its offset */
+    unsigned char offsetValue;                  /* Color Offset value */
+    
+    /* Calorimetry and White Point(s) */
+    unsigned char redGreenLowBits;              /* Red / Green Low Bits */
+}
+edid_version_2_t;
+
+#endif
+
+/* Restore alignment */
+#pragma pack()
+
+/**************************************************************
+ *  Function Prototypes
+ **************************************************************/
+
+/*
+ *  ddk768_edidGetVersion
+ *      This function gets the EDID version
+ *
+ *  Input:
+ *      pEDIDBuffer - Buffer that contains the EDID structure of the monitor
+ *      pRevision   - Revision of the EDIE (if exist)
+ *
+ *  Output:
+ *      Revision number of the given EDID buffer.
+ */
+unsigned char ddk768_edidGetVersion(
+    unsigned char *pEDIDBuffer,
+    unsigned char *pRevision
+);
+
+/*
+ *  ddk768_edidGetProductInfo
+ *      This function gets the vendor and product information.
+ *
+ *  Input:
+ *      pEDIDBuffer         - Buffer that contains the EDID structure of the monitor [in]
+ *      pManufacturerName   - Pointer to a 3 byte length variable to store the manufacturer name [out]
+ *      pProductCode        - Pointer to a variable to store the product code [out]
+ *      pSerialNumber       - Pointer to a variable to store the serial number [out]
+ *      pWeekOfManufacture  - Pointer to a variable to store the week of manufacture [out]
+ *      pYearOfManufacture  - Pointer to a variable to store the year of manufacture 
+ *                            or model year (if WeekOfManufacture is 0xff) [out]
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long ddk768_edidGetProductInfo(
+    unsigned char *pEDIDBuffer,
+    char *pManufacturerName,
+    unsigned short *pProductCode,
+    unsigned long *pSerialNumber,
+    unsigned char *pWeekOfManufacture,
+    unsigned short *pYearOfManufacture
+);
+
+/*
+ *  ddk768_edidCheckMonitorInputSignal
+ *      This function checks whether the monitor is expected analog/digital 
+ *      input signal.
+ *
+ *  Input:
+ *      pEDIDBuffer     - Buffer that contains the EDID structure of the monitor
+ *
+ *  Output:
+ *      0   - Analog
+ *      1   - Digital
+ */
+unsigned char ddk768_edidCheckMonitorInputSignal(
+    unsigned char *pEDIDBuffer
+);
+
+/*
+ *  ddk768_edidGetAnalogSignalInfo
+ *      This function gets the analog video input signal information
+ *
+ *  Input:
+ *      pEDIDBuffer             - Buffer that contains the EDID structure of the monitor
+ *      pRefWhiteAboveBlank     - Pointer to a variable to store the reference white above blank
+ *                                value. The value is in milliVolt.
+ *      pSyncLevelBelowBlank    - Pointer to a variable to store the Sync tip level below blank
+ *                                The value is also in milliVolt
+ *      pBlank2BlackSetup       - Pointer to a variable to store the Blank to black setup or
+ *                                pedestal per appropriate Signal Level Standard flag. 
+ *                                1 means that the display expect the setup.
+ *      pSeparateSyncSupport    - Pointer to a variable to store the flag to indicate that the
+ *                                monitor supports separate sync.
+ *      pCompositeSyncSupport   - Pointer to a variable to store a flag to indicate that the
+ *                                monitor supports composite sync.
+ *      pSyncOnGreenSupport     - Pointer to a variable to store a flag to indicate that
+ *                                the monitor supports sync on green video.
+ *      pVSyncSerrationRequired - Pointer to a variable to store a flag to indicate that serration
+ *                                of the VSync pulse is required when composite sync or
+ *                                sync-on-green video is used.
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long ddk768_edidGetAnalogSignalInfo(
+    unsigned char *pEDIDBuffer,
+    unsigned short *pRefWhiteAboveBlank,
+    unsigned short *pSyncLevelBelowBlank,
+    unsigned char *pBlank2BlackSetup,
+    unsigned char *pSeparateSyncSupport,
+    unsigned char *pCompositeSyncSupport,
+    unsigned char *pSyncOnGreenSupport,
+    unsigned char *pVSyncSerrationRequired
+);
+
+/*
+ *  ddk768_edidGetDigitalSignalInfo
+ *      This function gets the digital video input signal information
+ *
+ *  Input:
+ *      pEDIDBuffer     - Buffer that contains the EDID structure of the monitor
+ *      pDFP1xSupport   - Pointer to a variable to store the flag to indicate that
+ *                        the mointor interface is signal compatible with VESA
+ *                        DFP 1.x TMDS CRGB, 1 pixel/clock, up to 8 bits / color
+ *                        MSB aligned, DE active high
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long ddk768_edidGetDigitalSignalInfo(
+    unsigned char *pEDIDBuffer,
+    unsigned char *pDFP1xSupport
+);
+
+/*
+ *  ddk768_edidGetDisplaySize
+ *      This function gets the display sizes in cm.
+ *
+ *  Input:
+ *      pEDIDBuffer         - Buffer that contains the EDID structure of the monitor
+ *      pMaxHorzImageSize   - Pointer to a variable to store the maximum horizontal 
+ *                            image size to the nearest centimeter. A value of 0
+ *                            indicates that the size is indeterminate size.
+ *      pMaxVertImageSize   - Pointer to a variable to store the maximum vertical
+ *                            image size to the nearest centimeter. A value of 0
+ *                            indicates that the size is indeterminate size.
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long ddk768_edidGetDisplaySize(
+    unsigned char *pEDIDBuffer,
+    unsigned char *pMaxHorzImageSize,
+    unsigned char *pMaxVertImageSize
+);
+
+/*
+ *  ddk768_edidGetPowerManagementSupport
+ *      This function gets the monitor's power management support.
+ *
+ *  Input:
+ *      pEDIDBuffer     - Buffer that contains the EDID structure of the monitor
+ *      pStandBy        - Pointer to a variable to store the flag to indicate that
+ *                        standby power mode is supported.
+ *      pSuspend        - Pointer to a variable to store the flag to indicate that
+ *                        suspend power mode is supported.
+ *      pLowPower       - Pointer to a variable to store the flag to indicate that
+ *                        the display consumes low power when it receives a timing
+ *                        signal that is outside its declared active operating range.
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long ddk768_edidGetPowerManagementSupport(
+    unsigned char *pEDIDBuffer,
+    unsigned char *pStandBy,
+    unsigned char *pSuspend,
+    unsigned char *pLowPower
+);
+
+/*
+ *  ddk768_edidGetDisplayType
+ *      This function gets the display type.
+ *
+ *  Input:
+ *      pEDIDBuffer     - Buffer that contains the EDID structure of the monitor
+ *
+ *  Output:
+ *      0   - Monochrome / grayscale display
+ *      1   - RGB Color Display
+ *      2   - Non-RGB multicolor display, e.g. R/G/Y
+ *      3   - Undefined
+ */
+unsigned char ddk768_edidGetDisplayType(
+    unsigned char *pEDIDBuffer
+);
+
+/*
+ *  ddk768_edidChecksRGBUsage
+ *      This function checks if the display is using the sRGB standard default
+ *      color space as its primary color space. 
+ *
+ *  Input:
+ *      pEDIDBuffer     - Buffer that contains the EDID structure of the monitor
+ *
+ *  Output:
+ *      0   - Does not use sRGB as its primary color space
+ *      1   - Use sRGB as its primary color space
+ */
+unsigned char ddk768_edidChecksRGBUsage(
+    unsigned char *pEDIDBuffer
+);
+
+/*
+ *  ddk768_edidIsPreferredTimingAvailable
+ *      This function checks whether the preffered timing mode is available.
+ *      Use of preferred timing mode is required by EDID structure version 1
+ *      Revision 3 and higher. 
+ *
+ *  Input:
+ *      pEDIDBuffer     - Buffer that contains the EDID structure of the monitor
+ *
+ *  Output:
+ *      0   - Preferred Timing is not available
+ *      1   - Preferred Timing is available
+ */
+unsigned char ddk768_edidIsPreferredTimingAvailable(
+    unsigned char *pEDIDBuffer
+);
+
+/*
+ *  ddk768_edidIsDefaultGTFSupported
+ *      This function checks whether the display supports timings based on the
+ *      GTF standard using default GTF parameter values. 
+ *
+ *  Input:
+ *      pEDIDBuffer     - Buffer that contains the EDID structure of the monitor
+ *
+ *  Output:
+ *      0   - Default GTF is not supported
+ *      1   - Default GTF is supported
+ */
+unsigned char ddk768_edidIsDefaultGTFSupported(
+    unsigned char *pEDIDBuffer
+);
+
+/*
+ *  ddk768_edidGetColorCharacteristic
+ *      This function gets the chromaticity and white point values expressed as
+ *      an integer value which represents the actual value times 1000.
+ *
+ *  Input:
+ *      pEDIDBuffer - Buffer that contains the EDID structure of the monitor
+ *      pRedX   - Pointer to a variable to store the Red X values
+ *      pRedY   - Pointer to a variable to store the Red Y values
+ *      pGreenX - Pointer to a variable to store the Green X values
+ *      pGreenY - Pointer to a variable to store the Green Y values
+ *      pBlueX  - Pointer to a variable to store the Blue X values
+ *      pBlueY  - Pointer to a variable to store the Blue Y values
+ *
+ *  Note:
+ *      To get the White color characteristic, use the ddk768_edidGetWhitePoint
+ */
+void ddk768_edidGetColorCharacteristic(
+    unsigned char *pEDIDBuffer,
+    unsigned short *pRedX,
+    unsigned short *pRedY,
+    unsigned short *pGreenX,
+    unsigned short *pGreenY,
+    unsigned short *pBlueX,
+    unsigned short *pBlueY
+);
+
+/*
+ *  ddk768_edidGetWhitePoint
+ *      This function gets the white point.
+ *      To get the default white point, set the index to 0. For multiple white point,
+ *      call this function multiple times to check if more than 1 white point is supported.
+ *
+ *  Input:
+ *      pEDIDBuffer         - Buffer that contains the EDID structure of the monitor
+ *      pWhitePointIndex    - Pointer to a variable that contains the white point index 
+ *                            to be retrieved.
+ *      pWhiteX             - Pointer to a variable to store the White X value
+ *      pWhiteY             - Pointer to a variable to store the White Y value
+ *      pWhiteGamma         - Pointer to a variable to store the White Gamma value
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long ddk768_edidGetWhitePoint(
+    unsigned char *pEDIDBuffer,
+    unsigned char *pWhitePointIndex,
+    unsigned short *pWhiteX,
+    unsigned short *pWhiteY,
+    unsigned short *pWhiteGamma
+);
+
+/*
+ *  ddk768_edidGetExtension
+ *      This function gets the number of (optional) EDID extension blocks to follow
+ *      the given EDID buffer.
+ *
+ *  Input:
+ *      pEDIDBuffer     - Buffer that contains the EDID structure of the monitor
+ *
+ *  Output:
+ *      Total number of EDID Extension to follow the given EDID buffer.
+ */
+unsigned char ddk768_edidGetExtension(
+    unsigned char *pEDIDBuffer
+);
+
+/*
+ *  ddk768_edidReadMonitor
+ *      This function reads the EDID structure from the attached monitor
+ *
+ *  Input:
+ *      pEDIDBuffer - Buffer that contains the EDID structure of the monitor
+ *      bufferSize  - The EDID Buffer size index (usually 128-bytes)
+ *      edidExtNo   - Extension Index of the EDID Structure to be read
+ *      i2cNumber   - 0 = I2c0 and 1 = 12c1
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long ddk768_edidReadMonitor(
+    unsigned char *pEDIDBuffer,
+    unsigned long bufferSize,
+    unsigned char edidExtNo,
+    unsigned char i2cNumber
+);
+
+/*
+ *  ddk768_edidReadMonitor
+ *      This function reads the EDID structure from the attached monitor
+ *
+ *  Input:
+ *      displayPath - Display device which EDID to be read from.
+ *      pEDIDBuffer - Buffer that contains the EDID structure of the monitor
+ *      bufferSize  - The EDID Buffer size index (usually 128-bytes)
+ *      edidExtNo   - Extension Index of the EDID Structure to be read
+ *      sclGpio     - GPIO pin used as the I2C Clock (SCL)
+ *      sdaGpio     - GPIO pin used as the I2C Data (SDA)
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long ddk768_edidReadMonitorEx(
+    unsigned char *pEDIDBuffer,
+    unsigned long bufferSize,
+    unsigned char edidExtNo,
+    unsigned char sclGpio,
+    unsigned char sdaGpio
+);
+
+/*
+ *  This function is same as editReadMonitorEx(), but using HW I2C.
+ *
+ *  Input:
+ *      pEDIDBuffer - Buffer that contains the EDID structure of the monitor
+ *      bufferSize  - The EDID Buffer size index (usually 128-bytes)
+ *      edidExtNo   - Extension Index of the EDID Structure to be read
+ *      i2cNumber   - 0 = I2C0 and 1 = I2C1
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long ddk768_edidReadMonitorExHwI2C(
+    unsigned char *pEDIDBuffer,
+    unsigned long bufferSize,
+    unsigned char edidExtNo,
+    unsigned char i2cNumber
+);
+
+long ddk750_edidHeaderReadMonitorExHwI2C(void);
+long ddk750_edidHeaderReadMonitorEx(
+    unsigned char sclGpio,
+    unsigned char sdaGpio
+);	
+
+
+/*
+ *  ddk768_edidGetEstablishedTiming
+ *      This function gets the established timing list from the given EDID buffer,
+ *      table, and timing index.
+ *
+ *  Input:
+ *      pEDIDBuffer     - Buffer that contains the EDID structure of the monitor (In)
+ *      pEstTableIndex  - Pointer to the Established Timing Table index  (In/Out)
+ *      pIndex          - Pointer to the Establihsed Timing Index (In/Out)
+ *      pWidth          - Pointer to a variable that to store the horizontal active / width
+ *                        value of the retrieved timing (Out)
+ *      pHeight         - Pointer to a variable to store the vertical active / height
+ *                        value of the retrieved timing (Out)
+ *      pRefreshRate    - Pointer to a variable to store the vertical frequency value
+ *                        of the retrieved timing (out)
+ *      pSource         - Pointer to a variable to store the standard timing source:
+ *                          0 - VESA
+ *                          1 - IBM
+ *                          2 - Apple
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long ddk768_edidGetEstablishedTiming(
+    unsigned char *pEDIDBuffer,
+    /*unsigned char *pEstTableIndex,*/
+    unsigned char *pIndex,
+    unsigned long *pWidth,
+    unsigned long *pHeight,
+    unsigned long *pRefreshRate,
+    unsigned char *pSource
+);
+
+/*
+ *  ddk768_edidGetStandardTiming
+ *      This function gets the standard timing from the given EDID buffer and
+ *      calculates the width, height, and vertical frequency from that timing.
+ *
+ *  Input:
+ *      pEDIDBuffer     - Buffer that contains the EDID structure of the monitor
+ *      pStdTimingIndex - Pointer to a standard timing index to be retrieved
+ *      pWidth          - Pointer to a variable that to store the horizontal active / width
+ *                        value of the retrieved timing (Out)
+ *      pHeight         - Pointer to a variable to store the vertical active / height
+ *                        value of the retrieved timing (Out)
+ *      pRefreshRate    - Pointer to a variable to store the vertical frequency value
+ *                        of the retrieved timing (out)
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long ddk768_edidGetStandardTiming(
+    unsigned char *pEDIDBuffer,
+    unsigned char *pStdTimingIndex,
+    unsigned long *pWidth,
+    unsigned long *pHeight,
+    unsigned long *pRefreshRate
+);
+
+/*
+ *  ddk768_edidGetDetailedTiming
+ *      This function gets the detailed timing from the given EDID buffer.
+ *
+ *  Input:
+ *      pEDIDBuffer             - Buffer that contains the EDID structure of the monitor
+ *      pDetailedTimingIndex    - Pointer to a detailed timing index to be retrieved
+ *      pModeParameter          - Pointer to a mode_parameter_t structure that will be
+ *                                filled with the detailed timing.
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long ddk768_edidGetDetailedTiming(
+    unsigned char *pEDIDBuffer,
+    unsigned char *pDetailedTimingIndex,
+    vdif_t *pVDIF
+);
+
+/*
+ *  ddk768_edidGetMonitorSerialNumber
+ *      This function gets the monitor serial number from the EDID structure.
+ *
+ *  Input:
+ *      pEDIDBuffer             - Buffer that contains the EDID structure of the monitor
+ *      pMonitorSerialNumber    - Pointer to a buffer to store the serial number 
+ *                                retrieved from the EDID
+ *      bufferSize              - The size of the buffer to store the serial number.
+ *                                The maximum size required is 13 bytes.
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long ddk768_edidGetMonitorSerialNumber(
+    unsigned char *pEDIDBuffer,
+    char *pMonitorSerialNumber,
+    unsigned char bufferSize
+);
+
+/*
+ *  ddk768_edidGetDataString
+ *      This function gets the data string from the EDID structure.
+ *
+ *  Input:
+ *      pEDIDBuffer             - Buffer that contains the EDID structure of the monitor
+ *      pMonitorSerialNumber    - Pointer to a buffer to store the data string 
+ *                                retrieved from the EDID
+ *      bufferSize              - The size of the buffer to store the data string
+ *                                The maximum size required is 13 bytes.
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long ddk768_edidGetDataString(
+    unsigned char *pEDIDBuffer,
+    char *pDataString,
+    unsigned char bufferSize
+);
+
+/*
+ *  ddk768_edidGetMonitorRangeLimit
+ *      This function gets the monitor range limits from the EDID structure.
+ *      Only EDID version 1 and revision 1 or above supports this feature.
+ *
+ *  Input:
+ *      pEDIDBuffer         - Buffer that contains the EDID structure of the monitor
+ *      pMinVerticalRate    - Pointer to a variable to store the Minimum Vertical Rate (Hz)
+ *      pMaxVerticalRate    - Pointer to a variable to store the Maximum Vertical Rate (Hz)
+ *      pMinHorzFreq        - Pointer to a variable to store the Minimum Horz. Freq (kHz)
+ *      pMaxHorzFreq        - Pointer to a variable to store the Maximum Horz. Freq (kHz)
+ *      pMaxPixelClock      - Pointer to a variable to store the Maximum Pixel Clock (Hz)
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long ddk768_edidGetMonitorRangeLimit(
+    unsigned char *pEDIDBuffer,
+    unsigned char *pMinVerticalRate,
+    unsigned char *pMaxVerticalRate,
+    unsigned char *pMinHorzFreq,
+    unsigned char *pMaxHorzFreq,
+    unsigned long *pMaxPixelClock
+);
+
+/*
+ *  edidGetChannel1TimingSupport
+ *      This function gets the secondary GTF timing support.
+ *
+ *  Input:
+ *      pEDIDBuffer             - Buffer that contains the EDID structure of the monitor
+ *      pStartFrequency         - Pointer to a variable to store the start frequency of 
+ *                                the secondary GTF
+ *      pOffset                 - Pointer to a variable to store the Offset (C) value of
+ *                                the secondary GTF
+ *      pGradient               - Pointer to a variable to store the Gradient (M) value of
+ *                                the secondary GTF
+ *      pScalingFactor          - Pointer to a variable to store the Scaling Factor (K)
+ *                                value of the secondary GTF
+ *      pScalingFactorWeight    - Pointer to a variable to store the Scaling Factore Weight (J)
+ *                                value of the secondary GTF
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long edidGetChannel1TimingSupport(
+    unsigned char *pEDIDBuffer,
+    unsigned short *pStartFrequency,
+    unsigned char *pOffset,
+    unsigned short *pGradient,
+    unsigned char *pScalingFactor,
+    unsigned char *pScalingFactorWeight
+);
+
+/*
+ *  ddk768_edidGetMonitorName
+ *      This function gets the monitor name from the EDID structure.
+ *
+ *  Input:
+ *      pEDIDBuffer             - Buffer that contains the EDID structure of the monitor
+ *      pMonitorName            - Pointer to a buffer to store the monitor name 
+ *                                retrieved from the EDID
+ *      bufferSize              - The size of the buffer to store the monitor name
+ *                                The maximum size required is 13 bytes. 
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long ddk768_edidGetMonitorName(
+    unsigned char *pEDIDBuffer,
+    char *pMonitorName,
+    unsigned char bufferSize
+);
+
+/*
+ *  ddk768_edidGetPreferredTiming
+ *      This function gets the preferred/native timing of the monitor
+ *
+ *  Input:
+ *      pEDIDBuffer         - Buffer that contains the EDID structure of the monitor
+ *      pWidth              - Pointer to an unsigned long buffer to store the width 
+ *                            of the preferred (native) timing.
+ *      pHeight             - Pointer to an unsigned long buffer to store the height
+ *                            of the preferred (native) timing.
+ *      pVerticalFrequency  - Pointer to an unsigned long buffer to store the refresh
+ *                            rate of the preferred (native) timing.
+ * 
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long ddk768_edidGetPreferredTiming(
+    unsigned char *pEDIDBuffer,
+    unsigned long *pWidth,
+    unsigned long *pHeight,
+    unsigned long *pVerticalFrequency
+);
+
+#endif  /* _EDID_H_ */
+
+
+
diff --git a/drivers/gpu/drm/smi/ddk768/ddk768_hdmi.c b/drivers/gpu/drm/smi/ddk768/ddk768_hdmi.c
new file mode 100644
index 000000000000..4f9c62f4c968
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk768/ddk768_hdmi.c
@@ -0,0 +1,1363 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2007 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  Hdmi.c ---  
+*  This file contains the source code for HDMI functions.
+* 
+*******************************************************************/
+
+
+
+#include <linux/delay.h>
+#include <linux/timer.h>
+
+#include "ddk768_help.h"
+#include "ddk768_hdmi.h"
+#include "ddk768_reg.h"
+#include "ddk768_power.h"
+#include "hdmiregs.h"
+
+
+//-----------------------------------------------------------------------------
+// Parameter Table
+//-----------------------------------------------------------------------------
+
+/*
+ *  Hdmi parameter for some popular modes.
+ *  Note that the most timings in this table is made according to CEA standard
+ *  parameters for the popular modes.
+ */
+static hdmi_PHY_param_t gHdmiPHYParamTable[] =
+{
+/* TMDS clock range 0-50 MHz [8bpc] */
+ { 0x22, 0x06, 0x00, 0x40, 0x40, 0x1E, 0x94, 0x2E, 0x30, 0x00},
+
+/* TMDS clock range 50-100 MHz [8bpc] */
+ { 0x22, 0x0A, 0x00, 0x40, 0x40, 0x1E, 0x94, 0x2E, 0x30, 0x00},
+
+/* TMDS clock range 100-150 MHz [8bpc] */
+ { 0x22, 0x0E, 0x00, 0x40, 0x40, 0x1E, 0x92, 0x2E, 0x71, 0x00},
+
+/* TMDS clock range 150-200 MHz [8bpc] */
+ { 0x22, 0x0E, 0x00, 0x40, 0x40, 0x1E, 0x94, 0x2E, 0x71, 0x00},
+
+/* TMDS clock range 200-250 MHz [8bpc] */
+ { 0x22, 0x0E, 0x00, 0x40, 0x40, 0x1E, 0x94, 0x2E, 0x71, 0x00},
+
+/* 4K mode  [8bpc] */
+ { 0x22, 0x0E, 0x00, 0x40, 0x40, 0x1E, 0x95, 0x2E, 0x71, 0x00},
+
+/* End of table. */
+ { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
+};
+
+
+//-----------------------------------------------------------------------------
+// Global Variable
+//-----------------------------------------------------------------------------
+
+BYTE g_INT_94h = 0;
+BYTE g_INT_95h = 0;
+BYTE PowerMode = PowerMode_A;
+BYTE g_ucHDMIedidRead=0;
+BYTE AudioMode = 0;
+BYTE gEdidBuffer[256] = {0};
+
+
+
+void Delay (void)
+{
+    unsigned long d;
+    for (d = 0; d < 0x13FF; d++)
+        ;
+}
+
+void DelayMs (BYTE millisecond)
+{
+	mdelay(millisecond);
+}
+
+//-----------------------------------------------------------------------------
+// HDMI Interrupt functions
+//-----------------------------------------------------------------------------
+typedef struct _hdmi_interrupt_t
+{
+    struct _hdmi_interrupt_t *next;
+    void (*handler)(void);
+}
+hdmi_interrupt_t;
+
+static hdmi_interrupt_t *g_pHdmiIntHandlers = ((hdmi_interrupt_t *)0);
+
+/* HDMI Interrupt Service Routine */
+void hdmiISR(
+    unsigned long status
+)
+{
+    hdmi_interrupt_t *pfnHandler;
+
+    if (FIELD_GET(status, INT_STATUS, HDMI) == INT_STATUS_HDMI_ACTIVE)
+    {
+        /* Walk all registered handlers for handlers that support this interrupt status */
+        for (pfnHandler = g_pHdmiIntHandlers; pfnHandler != ((hdmi_interrupt_t *)0); pfnHandler = pfnHandler->next)
+            pfnHandler->handler();
+        
+        // Save interrupt status value for further usage. 
+        if (PowerMode == PowerMode_A)
+        {
+            // PS mode a->b
+            HDMI_System_PD(PowerMode_B);
+            DelayMs(1);
+        }
+        g_INT_94h = readHDMIRegister (X94_INT1_ST);
+        g_INT_95h = readHDMIRegister (X95_INT2_ST);
+
+        // clear all interrupt status
+        writeHDMIRegister (X94_INT1_ST, 0xFF);
+        writeHDMIRegister (X95_INT2_ST, 0xFF);
+    }            
+}
+
+/*
+ * This is the main interrupt hook for HDMI engine.
+ */
+long hookHDMIInterrupt(
+    void (*handler)(void)
+)
+{
+
+#if 0
+	hdmi_interrupt_t *pfnNewHandler, *pfnHandler;
+    unsigned short returnValue = 0;
+
+    /* Allocate a new interrupt structure */
+    pfnNewHandler = (hdmi_interrupt_t *)malloc(sizeof(hdmi_interrupt_t));
+    if (pfnNewHandler == ((hdmi_interrupt_t *)0))
+    {
+        /* No more memory */
+        return (-1);
+    }
+
+    /* Make sure that it has not been register more than once */
+    for (pfnHandler = g_pHdmiIntHandlers; pfnHandler != ((hdmi_interrupt_t *)0); pfnHandler = pfnHandler->next)
+    {
+        if (pfnHandler->handler == handler)
+            return (-1);                   /* Duplicate entry */
+    }
+        
+    /* If this is the first interrupt handler, register this panel VSync ISR */
+    if (g_pHdmiIntHandlers == ((hdmi_interrupt_t *)0))
+        returnValue = registerHandler(hdmiISR, FIELD_SET(0, INT_MASK, HDMI, ENABLE));
+
+    if (returnValue == 0)
+    {
+        /* Fill interrupt structure. */
+        pfnNewHandler->next = g_pHdmiIntHandlers;
+        pfnNewHandler->handler = handler;
+        g_pHdmiIntHandlers = pfnNewHandler;
+    }
+#endif   
+    return 0;//returnValue;
+}
+
+/*
+ * This function un-register HDMI Interrupt handler.
+ */
+long unhookHDMIInterrupt(
+    void (*handler)(void)
+)
+{
+#if 0
+    hdmi_interrupt_t *pfnHandler, *prev;
+
+    /* Find the requested handle to unregister */
+    for (pfnHandler = g_pHdmiIntHandlers, prev = ((hdmi_interrupt_t *)0); 
+         pfnHandler != ((hdmi_interrupt_t *)0); 
+         prev = pfnHandler, pfnHandler = pfnHandler->next)
+    {
+        if (pfnHandler->handler == handler)
+        {
+            /* Remove the interrupt handler */
+            if (prev == ((hdmi_interrupt_t *)0))
+                g_pHdmiIntHandlers = pfnHandler->next;
+            else
+                prev->next = pfnHandler->next;
+
+            free(pfnHandler);
+            
+            /* If this was the last interrupt handler, remove the IRQ handler */
+            if (g_pHdmiIntHandlers == ((hdmi_interrupt_t *)0))
+                unregisterHandler(hdmiISR);
+            
+            /* Success */
+            return (0);
+        }
+    }
+#endif
+    /* Oops, handler is not registered */
+    return (-1);
+}
+
+//-----------------------------------------------------------------------------
+// HDMI Misc. functions
+//-----------------------------------------------------------------------------
+
+/*
+ *  Function: 
+ *      writeHDMIRegister
+ *
+ *  Input:
+ *      addr    - HDMI register index (could be from 0x01 to 0xFF)
+ *      value   - HDMI register value
+ *
+ *  Output:
+ *      None
+ *
+ *  
+ *  WRITE is a 2 step process. For example, write a value of 0x82 to register with index 0x45, the steps are:
+ *  (MMIO base + 0x800C0) = 0x00018245
+ *  (MMIO base + 0x800C0) = 0x00008245
+ *
+ */
+void writeHDMIRegister(unsigned char addr, unsigned char value)
+{
+
+    pokeRegisterDWord(HDMI_CONFIG, 
+        FIELD_SET(0, HDMI_CONFIG, WRITE, ENABLE) | 
+        FIELD_VALUE(0, HDMI_CONFIG, DATA, value) | 
+        FIELD_VALUE(0, HDMI_CONFIG, ADDRESS, addr));
+
+    DelayMs(1);
+    
+    pokeRegisterDWord(HDMI_CONFIG, 
+        FIELD_VALUE(0, HDMI_CONFIG, DATA, value) | 
+        FIELD_VALUE(0, HDMI_CONFIG, ADDRESS, addr));
+
+    DelayMs(1);
+}
+
+/*
+ *  Function: 
+ *      readHDMIRegister
+ *
+ *  Input:
+ *      addr    - HDMI register index (could be from 0x01 to 0xFF)
+ *
+ *  Output:
+ *      register value
+ *
+ *  
+ *  READ is a 3 step process, For example, read a value from register with index 0x45.
+ *  (MMIO base + 0x800C0) = 0x20045
+ *  (MMIO base + 0x800C0) = 0x00045
+ *  Value = (MMIO base + 0x800C0) =0x1845
+ *
+ */
+unsigned char readHDMIRegister(unsigned char addr)
+{
+    unsigned long value;
+
+    pokeRegisterDWord(HDMI_CONFIG, 
+        FIELD_SET(0, HDMI_CONFIG, READ, ENABLE) | 
+        FIELD_VALUE(0, HDMI_CONFIG, ADDRESS, addr));
+    
+    DelayMs(1);
+    
+    pokeRegisterDWord(HDMI_CONFIG, FIELD_VALUE(0, HDMI_CONFIG, ADDRESS, addr));
+    
+    DelayMs(1);
+
+    value = peekRegisterDWord(HDMI_CONFIG);
+    
+    return (unsigned char)((value >> 8) & 0xFF);
+}
+
+/*
+ *  Function: 
+ *      writeHDMIControlRegister
+ *      This functions writes HDMI System Control register (index 0x00). 
+ *
+ *  Input:
+ *      value   - HDMI register 0x00 value
+ *
+ *  Output:
+ *      None
+ *  
+ */
+void writeHDMIControlRegister(unsigned char value)
+{
+
+    pokeRegisterDWord(HDMI_CONTROL, value); 
+    
+}
+
+/*
+ *  Function: 
+ *      readHDMIRegister
+ *      This functions reads HDMI System Control register (index 0x00). 
+ *
+ *  Input:
+ *      None
+ *
+ *  Output:
+ *      register value
+ *
+ */
+unsigned char readHDMIControlRegister(void)
+{
+    unsigned long value;
+
+    // Need to write 0x800c0[7:0] (config address) to 00 first, otherwise could not read back
+    // real value of HDMI control register. 
+    pokeRegisterDWord(HDMI_CONFIG, 
+        FIELD_SET(0, HDMI_CONFIG, READ, ENABLE) | 
+        FIELD_VALUE(0, HDMI_CONFIG, ADDRESS, 0));
+    
+    DelayMs(1);
+    
+    value = peekRegisterDWord(HDMI_CONTROL);
+    
+    return (unsigned char)(value & 0xFF);
+}
+
+/*
+ *  Function: 
+ *      writeHdmiPHYRegister
+ *
+ *  Input:
+ *      addr    - HDMI register index (for PHY registers only, could be from 0x57 to 0x5E)
+ *      value   - HDMI register value
+ *
+ *  Output:
+ *      None
+ *
+ */
+void writeHdmiPHYRegister(unsigned char addr, unsigned char value)
+{
+    writeHDMIRegister(addr, value);
+    
+    writeHDMIControlRegister(0x2D);     // PLLA/B reset
+    DelayMs(1);     // wait 100us
+
+    writeHDMIControlRegister(0x21);     // PLLA/B release
+    DelayMs(1);     // wait 1ms for PLL lock
+}
+
+/*
+ *  Function:
+ *      setHDMIChannel
+ *
+ *  Input:
+ *      channel number      -   0 = Select Channel 0 to HDMI
+ *                                  -   1 = Select Channel 1 to HDMI
+ *
+ *  Output:
+ *      None
+ *
+ */
+void setHDMIChannel(unsigned char Channel)
+{
+    unsigned long value;
+
+    value = peekRegisterDWord(DISPLAY_CTRL);
+    if (Channel == 0)
+    {
+        pokeRegisterDWord(DISPLAY_CTRL, 
+            FIELD_SET(value, DISPLAY_CTRL, HDMI_SELECT, CHANNEL0));
+    }
+    else
+    {
+        pokeRegisterDWord(DISPLAY_CTRL, 
+            FIELD_SET(value, DISPLAY_CTRL, HDMI_SELECT, CHANNEL1));
+    }
+
+}
+
+/*
+ *  Function:
+ *      enableHdmiI2C
+ *
+ *  Input:
+ *      enable/disable      -   0 = HDMI I2C to GPIO[7:6]
+ *                                  -   1 = HW I2C to GPIO[7:6]
+ *
+ *  Output:
+ *      None
+ *
+ */
+void enableHdmI2C(unsigned long enable)
+{
+    unsigned long value;
+
+    value = peekRegisterDWord(TEST_CONTROL);
+
+    if (enable)
+        value = FIELD_SET(value, TEST_CONTROL, I2C, HDMI);
+    else
+        value = FIELD_SET(value, TEST_CONTROL, I2C, I2C1);
+
+    pokeRegisterDWord(TEST_CONTROL, value);
+}
+
+/*
+ *  Function:
+ *      HDMI_Dump_Registers (Used for debug)
+ *
+ *  Input:
+ *      None
+ *
+ *  Output:
+ *      None
+ *
+ *  Linda: for debug purpose only
+ */
+void HDMI_Dump_Registers (void)
+{
+    unsigned char i = 0, j = 0;
+
+    printk("++++++++++ HDMI Regsiters 0x00 - 0x7F ++++++++++\n");
+
+    for (i = 0; i < 16; i++)
+    {
+        printk("Offset 0x%02x:  ", (i * 8));
+        for (j = 0; j < 8; j++)
+            printk("%02x  ", readHDMIRegister((j + i * 8)));
+        printk("\n");
+    }
+}
+
+
+//-----------------------------------------------------------------------------
+// HDMI Functions
+//-----------------------------------------------------------------------------
+
+//
+// Parameters   : unsigned char mode. 4 modes available.
+//                  MODE_A (sleep), MODE_B (register access), MODE_D (clock), MODE_E (active).
+//
+void HDMI_System_PD (unsigned char mode) 
+{
+    PowerMode = mode;
+
+    // PLL A/B Reset
+    if (PowerMode != PowerMode_A)
+    {
+        writeHDMIControlRegister (mode | 0x0C);
+       	DelayMs(8);    // wait 8ms
+    }
+    // PLL A/B Release
+    writeHDMIControlRegister (mode);
+    DelayMs(10);    // wait 10ms
+
+
+}
+
+/*
+ *  Function:
+ *      HDMI_Set_Control_Packet
+ *
+ *  Input:
+ *      None
+ *
+ *  Output:
+ *      None
+ *
+ */
+void HDMI_Init(void)
+{
+    unsigned char temp;
+    
+    // Enable HDMI clock
+     ddk768_enableHDMI(1);
+    
+    // select channel 0 to HDMI by default
+    setHDMIChannel(0);
+    
+    // set INT polarity to Active High
+    temp = readHDMIControlRegister();
+    writeHDMIControlRegister (temp | 0x01);
+    
+    // Set to power mode B, in order to read/write to registers
+    HDMI_System_PD (PowerMode_B);
+    DelayMs(1);
+
+    // Setting AVI InfoFrame
+    writeHDMIRegister (X5F_PACKET_INDEX, AVI_INFO_PACKET); // Index.6 AVI InfoFrame
+    writeHDMIRegister (X60_PACKET_HB0, 0x82); // HB0
+    writeHDMIRegister (X61_PACKET_HB1, 0x02); // HB1
+    writeHDMIRegister (X62_PACKET_HB2, 0x0D); // HB2
+    writeHDMIRegister (X63_PACKET_PB0, 0x16); // PB0
+    writeHDMIRegister (X64_PACKET_PB1, 0x00); // PB1
+    writeHDMIRegister (X65_PACKET_PB2, 0x00); // PB2
+    writeHDMIRegister (X66_PACKET_PB3, 0x12); // PB3
+    writeHDMIRegister (X67_PACKET_PB4, 0x00); // PB4
+    writeHDMIRegister (X68_PACKET_PB5, 0x00); // PB5
+    writeHDMIRegister (X69_PACKET_PB6, 0xe4); // PB6
+    writeHDMIRegister (X6A_PACKET_PB7, 0xb5); // PB7
+    writeHDMIRegister (X6B_PACKET_PB8, 0x4e); // PB8
+    writeHDMIRegister (X6C_PACKET_PB9, 0x59); // PB9
+    writeHDMIRegister (X6D_PACKET_PB10, 0xd2); // PB10
+    writeHDMIRegister (X6E_PACKET_PB11, 0xeb); // PB11
+    writeHDMIRegister (X6F_PACKET_PB12, 0x18); // PB12
+    writeHDMIRegister (X70_PACKET_PB13, 0x1d); // PB13
+
+    // Setting Audio InfoFrame
+    writeHDMIRegister (X5F_PACKET_INDEX, AUDIO_INFO_PACKET); // Index.8 Audio
+    writeHDMIRegister (X60_PACKET_HB0, 0x84); // HB0
+    writeHDMIRegister (X61_PACKET_HB1, 0x01); // HB1
+    writeHDMIRegister (X62_PACKET_HB2, 0x0A); // HB2
+    writeHDMIRegister (X63_PACKET_PB0, 0x70); // PB0
+    writeHDMIRegister (X64_PACKET_PB1, 0x01); // PB1
+    writeHDMIRegister (X65_PACKET_PB2, 0x00); // PB2
+    writeHDMIRegister (X66_PACKET_PB3, 0x00); // PB3
+    writeHDMIRegister (X67_PACKET_PB4, 0x00); // PB4
+    writeHDMIRegister (X68_PACKET_PB5, 0x00); // PB5
+
+    // init DDC bus frequency
+    writeHDMIRegister (X81_ISRC2_PB0, 0x20);
+    writeHDMIRegister (X82_ISRC2_PB1, 0x00);
+
+    // Unmask MSENS detect interrupt. Hot plug interrupt is enough for hot-plug
+    // detection, we don't need to detect both at the same time.
+    // writeHDMIRegister (X92_INT_MASK1, 0x80);
+}
+
+/*
+ *  Function:
+ *      HDMI_Control_Packet_Auto_Send
+ *
+ *  Input:
+ *      None
+ *
+ *  Output:
+ *      None
+ *
+ */
+void HDMI_Control_Packet_Auto_Send (void)
+{
+    writeHDMIRegister (X42_AUTO_CHECKSUM, 0x01);    // enable auto checksum
+    writeHDMIRegister (X40_CTRL_PKT_EN, 0x00);
+}
+
+/*
+ *  Function:
+ *      HDMI_Audio_Setting_44100Hz
+ *
+ *  Input:
+ *      pLogicalMode
+ *
+ *  Output:
+ *      None
+ *
+ *  Return:
+ *      None
+ *
+ */
+void HDMI_Audio_Setting_44100Hz (mode_parameter_t *pModeParam)
+{
+    unsigned long N = 6272, CTS = 0;    // default N value is 6272
+    unsigned char regValue = 0;
+
+    // calculate CTS with recommended N
+    // recommended N value is 4704 for 4K mode
+    if ((pModeParam->horizontal_display_end >= 3840 && pModeParam->horizontal_display_end < 5120) && 
+        (pModeParam->vertical_display_end >= 2160 && pModeParam->vertical_display_end < 2880))
+    {
+        N = 4704;
+    }
+    
+    // CTS = (fTMDS_clock x N) / (128 X fS)
+    CTS = ((pModeParam->pixel_clock / 1000) * N / 128) * 10 / 441;
+    //printf("44100Hz: N = %d, CTS = %d\n", N, CTS);
+
+    // set N and CTS into registers
+    regValue = (unsigned char)((N >> 16) & 0x0F);
+    writeHDMIRegister(X01_N19_16, regValue);
+    regValue = (unsigned char)(N >> 8);
+    writeHDMIRegister(X02_N15_8, regValue);
+    regValue = (unsigned char)N;
+    writeHDMIRegister(X03_N7_0, regValue);
+
+    regValue = (unsigned char)((CTS >> 16) & 0x0F);
+    writeHDMIRegister(X07_CTS_EXT, regValue);
+    regValue = (unsigned char)(CTS >> 8);
+    writeHDMIRegister(X08_CTS_EXT, regValue);
+    regValue = (unsigned char)CTS;
+    writeHDMIRegister(X09_CTS_EXT, regValue);
+
+    // set audio setting registers
+    writeHDMIRegister(X0A_AUDIO_SOURCE, 0x00);      // internal CTS
+    writeHDMIRegister(X0B_AUDIO_SET2, 0x40);
+    writeHDMIRegister(X0C_I2S_MODE, 0x04);      // I2S 2ch (0x3C for 8ch) + I2S
+    //writeHDMIRegister(X0D_DSD_MODE, 0x00);      // DSD audio disabled
+    writeHDMIRegister(X10_I2S_PINMODE, 0x00);      // I2S input pin swap
+    writeHDMIRegister(X11_ASTATUS1, 0x0F);      // Original frequency not indicated(defult)
+    writeHDMIRegister(X12_ASTATUS2, 0x22);
+    writeHDMIRegister(X13_CAT_CODE, 0x00);
+    writeHDMIRegister(X14_A_SOURCE, 0x02);
+    
+    regValue = (readHDMIRegister(X15_AVSET1) & 0x0F);       // set freq 44.1kHz
+    writeHDMIRegister(X15_AVSET1, regValue);
+
+    regValue = readHDMIRegister(X0A_AUDIO_SOURCE) & 0x9F;
+    writeHDMIRegister(X0A_AUDIO_SOURCE, regValue);      // dounsampling none (bit 6:5 = 00)
+    
+    regValue = readHDMIRegister(X0A_AUDIO_SOURCE) & 0xF7;
+    writeHDMIRegister(X0A_AUDIO_SOURCE, regValue);      // disable SPDIF
+    
+}
+
+/*
+ *  Function:
+ *      HDMI_Video_Setting
+ *
+ *  Input:
+ *      pModeParam
+ *
+ *  Output:
+ *      None
+ *
+ *  Return:
+ *      None
+ *
+ */
+void HDMI_Video_Setting (mode_parameter_t *pModeParam, bool isHDMI)
+{
+    unsigned long temp = 0;
+    unsigned char regValue = 0;
+
+    // video set timing
+    regValue = readHDMIRegister(X30_EXT_VPARAMS);
+    regValue &= 0xF2;
+    regValue = 
+        (pModeParam->vertical_sync_polarity == POS
+        ? FIELD_SET(regValue, X30_EXT_VPARAMS, VSYNC_PHASE, POS)
+        : FIELD_SET(regValue, X30_EXT_VPARAMS, VSYNC_PHASE, NEG))
+        | (pModeParam->horizontal_sync_polarity == POS
+        ? FIELD_SET(regValue, X30_EXT_VPARAMS, HSYNC_PHASE, POS)
+        : FIELD_SET(regValue, X30_EXT_VPARAMS, HSYNC_PHASE, NEG))
+        | FIELD_SET(regValue, X30_EXT_VPARAMS, USE, EXTERNAL);
+    writeHDMIRegister(X30_EXT_VPARAMS, regValue);
+
+    writeHDMIRegister(X31_EXT_HTOTAL, (pModeParam->horizontal_total & 0xFF));   // horizontal total
+    writeHDMIRegister(X32_EXT_HTOTAL, (pModeParam->horizontal_total & 0xFF00)>>8);
+
+    temp = pModeParam->horizontal_total - pModeParam->horizontal_display_end;   // horizontal blanking
+    writeHDMIRegister(X33_EXT_HBLANK, (temp & 0xFF));
+    writeHDMIRegister(X34_EXT_HBLANK, (temp & 0xFF00)>>8);
+
+    temp = pModeParam->horizontal_total - pModeParam->horizontal_sync_start;    // horizontal delay
+    writeHDMIRegister(X35_EXT_HDLY, (temp & 0xFF));
+    writeHDMIRegister(X36_EXT_HDLY, (temp & 0xFF00)>>8);
+
+    writeHDMIRegister(X37_EXT_HS_DUR, (pModeParam->horizontal_sync_width & 0xFF));  // horizontal duration
+    writeHDMIRegister(X38_EXT_HS_DUR, (pModeParam->horizontal_sync_width & 0xFF00)>>8);
+
+    writeHDMIRegister(X39_EXT_VTOTAL, (pModeParam->vertical_total & 0xFF)); // vertical total
+    writeHDMIRegister(X3A_EXT_VTOTAL, (pModeParam->vertical_total & 0xFF00)>>8);
+
+    temp = pModeParam->vertical_total - pModeParam->vertical_display_end;   // vertical blanking
+    writeHDMIRegister(X3D_EXT_VBLANK, temp);
+
+    temp = pModeParam->vertical_total - pModeParam->vertical_sync_start;   // vertical delay
+    writeHDMIRegister(X3E_EXT_VDLY, temp);
+
+    writeHDMIRegister(X3F_EXT_VS_DUR, pModeParam->vertical_sync_height);    // vertical duration
+
+    // video set color - deep_color_8bit
+    regValue = readHDMIRegister(X17_DC_REG);
+    regValue = (regValue & 0x3F) | 0x00;
+    writeHDMIRegister(X17_DC_REG, regValue);
+    
+    writeHDMIRegister(X16_VIDEO1, 0x30);
+
+    // video set format
+    regValue = (readHDMIRegister(X15_AVSET1) & 0xF0);
+    regValue |= 0x01;       // set RGB & external DE
+    writeHDMIRegister(X15_AVSET1, regValue);
+    writeHDMIRegister(X3B_AVSET2, 0x40);
+    //writeHDMIRegister(X40_CTRL_PKT_EN, 0x00);
+    //writeHDMIRegister(X45_VIDEO2, 0x83);
+    writeHDMIRegister(X46_OUTPUT_OPTION, 0x04);
+    writeHDMIRegister(XD3_CSC_CONFIG1, 0x01);
+
+    // video set output - setting to HDMI/DVI mode
+    regValue = readHDMIRegister(XAF_HDCP_CTRL);
+    if (isHDMI)
+        writeHDMIRegister(XAF_HDCP_CTRL, (regValue | 0x02));
+    else
+        writeHDMIRegister(XAF_HDCP_CTRL, (regValue & 0xFD));
+
+    // set DDC bus access frequency control register based on pixel clock value (400kHz is preferred)
+    // At mode_d/mode_e: 
+    // DDC Bus access frequency = TDMS_CK input clock frequency / (register value) / 4
+    temp = pModeParam ->pixel_clock / 4 / 400000;
+    writeHDMIRegister(X81_ISRC2_PB0, (temp & 0xFF));    // LSB
+    writeHDMIRegister(X82_ISRC2_PB1, (temp & 0xFF00)>>8);   // MSB
+    
+}
+
+/*
+ *  Function:
+ *      HDMI_PHY_Setting
+ *
+ *  Input:
+ *      pLogicalMode
+ *
+ *  Output:
+ *      None
+ *
+ *  Return:
+ *      0 - Success
+ *      -1 - Error 
+ *
+ */
+long HDMI_PHY_Setting (mode_parameter_t *pModeParam)
+{
+    unsigned long clkIndex;
+    hdmi_PHY_param_t *pPHYParamTable;
+
+    // Decide which PHY params to use depend on TMDS clock range. 
+    if (pModeParam->pixel_clock > 0 && pModeParam->pixel_clock < 50000000)
+    {
+        clkIndex = CLK_0_to_50;
+    }
+    else if (pModeParam->pixel_clock >= 50000000 && pModeParam->pixel_clock < 100000000)
+    {
+        clkIndex = CLK_50_to_100;
+    }
+    else if (pModeParam->pixel_clock >= 100000000 && pModeParam->pixel_clock < 150000000)
+    {
+        clkIndex = CLK_100_to_150;
+    }
+    else if (pModeParam->pixel_clock >= 150000000 && pModeParam->pixel_clock < 200000000)
+    {
+        clkIndex = CLK_150_to_200;
+    }
+    else if (pModeParam->pixel_clock >= 200000000 && pModeParam->pixel_clock < 250000000)
+    {
+        clkIndex = CLK_200_to_250;
+    }
+    else if (pModeParam->pixel_clock >= 250000000 && pModeParam->pixel_clock <= 297000000)
+    {
+        clkIndex = CLK_4Kmode;
+    }
+    else
+    {
+        // Does not support TMDS clock larger than 297MHz.
+        return (-1);
+    }
+
+    pPHYParamTable = (hdmi_PHY_param_t *)gHdmiPHYParamTable;
+    
+    // load PHY parameters into registers
+    writeHdmiPHYRegister(X57_PHY_CTRL, pPHYParamTable[clkIndex].X57_PHY_value);
+    writeHdmiPHYRegister(X58_PHY_CTRL, pPHYParamTable[clkIndex].X58_PHY_value);
+    writeHdmiPHYRegister(X59_PHY_CTRL, pPHYParamTable[clkIndex].X59_PHY_value);
+    writeHdmiPHYRegister(X5A_PHY_CTRL, pPHYParamTable[clkIndex].X5A_PHY_value);
+    writeHdmiPHYRegister(X5B_PHY_CTRL, pPHYParamTable[clkIndex].X5B_PHY_value);
+    writeHdmiPHYRegister(X5C_PHY_CTRL, pPHYParamTable[clkIndex].X5C_PHY_value);
+    writeHdmiPHYRegister(X5D_PHY_CTRL, pPHYParamTable[clkIndex].X5D_PHY_value);
+    writeHdmiPHYRegister(X5E_PHY_CTRL, pPHYParamTable[clkIndex].X5E_PHY_value);
+    writeHdmiPHYRegister(X56_PHY_CTRL, pPHYParamTable[clkIndex].X56_PHY_value);
+    writeHdmiPHYRegister(X17_DC_REG, pPHYParamTable[clkIndex].X17_PHY_value);
+    
+    return 0;
+}
+
+/*
+ *  Function:
+ *      HDMI_Set_Mode
+ *
+ *  Input:
+ *      pLogicalMode
+ *
+ *  Output:
+ *      None
+ *
+ *  Return:
+ *      0 - Success
+ *      -1 - Error 
+ *
+ */
+long HDMI_Set_Mode (logicalMode_t *pLogicalMode, bool isHDMI)
+{
+    mode_parameter_t *pModeParam;
+    unsigned char temp = 0;
+    unsigned long ret = 0;
+    
+    // set mode b
+    if (PowerMode != PowerMode_B)
+    {
+        HDMI_System_PD (PowerMode_B);
+    }
+
+    // find mode parameters for input mode
+    pModeParam = ddk768_findModeParam(pLogicalMode->dispCtrl, pLogicalMode->x, pLogicalMode->y, pLogicalMode->hz, 0);
+    if (pModeParam == (mode_parameter_t *)0)
+        return -1;
+
+    // set video param
+    HDMI_Video_Setting(pModeParam, isHDMI);
+
+    // set audio param
+    HDMI_Audio_Setting_44100Hz(pModeParam);
+    
+    // control packet auto send
+    HDMI_Control_Packet_Auto_Send();
+
+    // set PHY param
+    ret = HDMI_PHY_Setting(pModeParam);
+    if (ret != 0)
+    {
+        return ret;
+    }
+
+    // disable video & audio output: write 11b to #45h[1:0]
+    temp = readHDMIRegister(X45_VIDEO2);
+    writeHDMIRegister(X45_VIDEO2, (temp | 0x03));
+
+    // set Channel # to HDMI
+    setHDMIChannel((unsigned char)pLogicalMode->dispCtrl);
+    
+    // mode b->d: (0x4d, 100us) -> (0x49, 100us) -> 0x41
+    PowerMode = PowerMode_D;
+    writeHDMIControlRegister (PowerMode | 0x0C);
+    DelayMs (1);
+    writeHDMIControlRegister (PowerMode | 0x08);
+    DelayMs (1);
+    writeHDMIControlRegister (PowerMode);
+    DelayMs (1);
+
+    // mode d->e: 0x81
+    HDMI_System_PD (PowerMode_E);
+
+    if (AudioMode)
+    {
+        // enable video & audio output: write 00b to #45h[1:0]
+        temp = readHDMIRegister(X45_VIDEO2);
+        writeHDMIRegister(X45_VIDEO2, (temp & (~0x03)));
+
+        // Audio reset/release
+        // Audio is mute after reset of audio is set.
+        // Therefore, set it in the following procedures.
+        //   Audio:  Save value of now => Audio Reset => Audio Active => Set value again
+        temp = readHDMIRegister(X45_VIDEO2);
+        writeHDMIRegister(X45_VIDEO2, temp | 0x04 );   // Reset
+        DelayMs(1);                                    // Followed by 1ms wait time
+        writeHDMIRegister(X45_VIDEO2, temp & 0xFB );   // Reset Release and Audio Mute)
+    }
+    else
+    {
+        // enable video output: write 0b to #45h[0]
+        temp = readHDMIRegister(X45_VIDEO2);
+        writeHDMIRegister(X45_VIDEO2, (temp & (~0x01)));
+    }
+
+#if 0   // for debug only
+    HDMI_Dump_Registers();
+#endif
+    
+    return 0;
+}
+void HDMI_Enable_Output(void)
+{
+    unsigned char temp = 0;
+
+	if (PowerMode == PowerMode_E)
+		return;
+
+	if (PowerMode == PowerMode_B){
+	    // mode b->d: (0x4d, 100us) -> (0x49, 100us) -> 0x41
+	    PowerMode = PowerMode_D;
+	    writeHDMIControlRegister (PowerMode | 0x0C);
+	    DelayMs (1);
+	    writeHDMIControlRegister (PowerMode | 0x08);
+	    DelayMs (1);
+	    writeHDMIControlRegister (PowerMode);
+	    DelayMs (1);
+
+	    // mode d->e: 0x81
+	    HDMI_System_PD (PowerMode_E);
+	}
+
+    // enable video & audio output: write 00b to #45h[1:0]
+    temp = readHDMIRegister(X45_VIDEO2);
+    writeHDMIRegister(X45_VIDEO2, (temp & (~0x03)));
+    
+    // Audio reset/release
+    // Audio is mute after reset of audio is set.
+    // Therefore, set it in the following procedures.
+    //   Audio:  Save value of now => Audio Reset => Audio Active => Set value again
+    temp = readHDMIRegister(X45_VIDEO2);
+    writeHDMIRegister(X45_VIDEO2, temp | 0x04 );   // Reset
+    DelayMs(1);                                    // Followed by 1ms wait time
+    writeHDMIRegister(X45_VIDEO2, temp & 0xFB );   // Reset Release and Audio Mute)
+
+#if 0   // for debug only
+    HDMI_Dump_Registers();
+#endif
+    
+    return ;
+
+}
+
+/*
+ *  Function:
+ *      HDMI_Disable_Output
+ *
+ *  Input:
+ *      None
+ *
+ *  Output:
+ *      None
+ *
+ *  Return:
+ *      None
+ *
+ */
+void HDMI_Disable_Output (void)
+{
+    unsigned char temp = 0;
+    
+    // disable video & audio output: write 11b to #45h[1:0]
+    temp = readHDMIRegister(X45_VIDEO2);
+    writeHDMIRegister(X45_VIDEO2, (temp | 0x03));
+
+    // audio reset: write 1b to #45h[2], followed by 500us wait time
+    temp = readHDMIRegister(X45_VIDEO2);
+    writeHDMIRegister(X45_VIDEO2, (temp | 0x04));
+    DelayMs(1);
+
+    // PS mode e->d->b
+    HDMI_System_PD (PowerMode_D);
+    HDMI_System_PD (PowerMode_B);
+}
+
+/*
+ *  Function:
+ *      HDMI_Unplugged
+ *
+ *  Input:
+ *      None
+ *
+ *  Return:
+ *      None
+ *
+ */
+void HDMI_Unplugged (void)
+{
+    unsigned char temp = 0;
+    
+    // disable video & audio output: write 11b to #45h[1:0]
+    temp = readHDMIRegister(X45_VIDEO2);
+    writeHDMIRegister(X45_VIDEO2, (temp | 0x03));
+
+    // PS mode e->d->b->a
+    HDMI_System_PD (PowerMode_D);
+    HDMI_System_PD (PowerMode_B);
+    HDMI_System_PD (PowerMode_A);
+}
+
+/*
+ *  Function:
+ *      HDMI_Audio_Mute
+ *
+ *  Input:
+ *      None
+ *
+ *  Output:
+ *      None
+ *
+ *  Return:
+ *      None
+ *
+ */
+void HDMI_Audio_Mute (void)
+{
+    unsigned char temp = 0;
+
+    if (PowerMode == PowerMode_E)
+    {
+        // disable audio output: write 1b to #45h[1]
+        temp = readHDMIRegister(X45_VIDEO2);
+        writeHDMIRegister(X45_VIDEO2, (temp | 0x02));
+    }
+
+	 AudioMode = Audio_Mute;
+}
+
+/*
+ *  Function:
+ *      HDMI_Audio_Unmute
+ *
+ *  Input:
+ *      None
+ *
+ *  Output:
+ *      None
+ *
+ *  Return:
+ *      None
+ *
+ */
+void HDMI_Audio_Unmute (void)
+{
+    unsigned char temp = 0;
+
+    if (PowerMode == PowerMode_E)
+    {
+        // enable audio output: write 0b to #45h[1]
+        temp = readHDMIRegister(X45_VIDEO2);
+        writeHDMIRegister(X45_VIDEO2, (temp & (~0x02)));
+
+        // Audio reset/release
+        // Audio is mute after reset of audio is set.
+        // Therefore, set it in the following procedures.
+        //   Audio:  Save value of now => Audio Reset => Audio Active => Set value again
+        temp = readHDMIRegister(X45_VIDEO2);
+        writeHDMIRegister(X45_VIDEO2, temp | 0x04 );   // Reset
+        DelayMs(1);                                    // Followed by 1ms wait time
+        writeHDMIRegister(X45_VIDEO2, temp & (~0x04) );   // Reset Release and Audio Mute)
+    }
+	AudioMode = Audio_Unmute;
+}
+
+/*
+ *  Function:
+ *      HDMI_Edid_ReadFirstByte
+ *
+ *  Input:
+ *      None
+ *
+ *  Return:
+ *      Fisrt byte of HDMI EDID FIFO
+ *
+ */
+unsigned char HDMI_Edid_ReadFirstByte(void)
+{
+    unsigned long value;
+
+    pokeRegisterDWord(HDMI_CONFIG, 
+        FIELD_SET(0, HDMI_CONFIG, READ, LATCH) | 
+        FIELD_VALUE(0, HDMI_CONFIG, ADDRESS, X80_EDID));
+    
+    DelayMs(1);
+    
+    pokeRegisterDWord(HDMI_CONFIG, FIELD_VALUE(0, HDMI_CONFIG, ADDRESS, X80_EDID));
+    
+    DelayMs(1);
+    
+    value = peekRegisterDWord(HDMI_CONFIG);
+
+    return (unsigned char)((value >> 8) & 0xFF);
+}
+
+/*
+ *  Function:
+ *      HDMI_Edid_CheckSum
+ *
+ *  Input:
+ *      array - EDID data
+ *      size - size of array
+ *
+ *  Return:
+ *      byChecksum
+ *
+ */
+BYTE HDMI_Edid_CheckSum (BYTE* array, unsigned long size)
+{
+    BYTE i, sum = 0;
+    for (i = 0; i < size; i++)
+        sum += array[i];
+
+    return sum;
+}
+
+/*
+ *  Function:
+ *      HDMI_Read_Edid.
+ *		 
+ *  Input:
+ *      pEDIDBuffer - EDID buffer
+ *      bufferSize - EDID buffer size (usually 128-bytes or 256 bytes)
+ *  Output:
+ *      -1 - Error
+ *      0 - exist block0 EDID (128 Bytes)
+ *      1 - exist block0 & block1 EDID (256 Bytes)
+ */
+long HDMI_Read_Edid(BYTE *pEDIDBuffer, unsigned long bufferSize)
+{
+    BYTE byEDID_current = 0;
+    BYTE byEDID_size = 0;
+    BYTE byEDID_finish = 0;
+    #define EDID_WORD   ((byEDID_current % 2) ? 0x80 : 0x00)
+    #define EDID_SEG    (byEDID_current /2)
+    #define EDID_EXT    (gEdidBuffer[126])
+    
+    BYTE byChecksum = 0, regValue;
+    unsigned long i = 0, j = 0;
+    unsigned long retry = 1000;
+            
+    if (pEDIDBuffer == (unsigned char *)0)
+    {
+        printk("buffer is NULL!\n");
+        return (-1);
+    }
+    
+    // PS mode a -> b if current power mode is in PS mode a
+    if (PowerMode == PowerMode_A)
+    {
+        HDMI_System_PD (PowerMode_B);
+    }
+
+    // clear interrupt status before reading EDID
+    writeHDMIRegister (X94_INT1_ST, 0xFF);
+    writeHDMIRegister (X95_INT2_ST, 0xFF);
+
+    // Enable EDID interrupt
+    regValue = readHDMIRegister (X92_INT_MASK1);
+    writeHDMIRegister (X92_INT_MASK1, (regValue | 0x06));
+
+    while(byEDID_finish == 0)
+    {			
+    	// Set EDID word address (set to 00h for the first 128 bytes)
+    	writeHDMIRegister (XC5_EDID_WD_ADDR, EDID_WORD);	
+    	// Set EDID segment pointer 0
+    	// (Regsiter write to XC4_SEG_PTR will start EDID reading)
+    	writeHDMIRegister (XC4_SEG_PTR, EDID_SEG);
+        
+    	/* Hook the interrupt before going to the while */ 
+        //hookHDMIInterrupt(HdmiHandler);
+    	
+        retry = 1000;
+        while(retry)
+    	{		
+            retry--;
+
+            g_INT_94h = readHDMIRegister (X94_INT1_ST);
+            g_INT_95h = readHDMIRegister (X95_INT2_ST);	
+
+            // EDID ERR interrupt, or EDID not ready
+            if ((g_INT_94h & EDID_ERR))
+            {
+                // clear error interrupt 
+                writeHDMIRegister (X94_INT1_ST, 0xFF);
+                writeHDMIRegister (X95_INT2_ST, 0xFF);
+                DelayMs(1);
+            }
+            else if (g_INT_94h & EDID_RDY)
+            {		
+                // clear ready interrupt 
+                writeHDMIRegister (X94_INT1_ST, 0xFF);
+                writeHDMIRegister (X95_INT2_ST, 0xFF);
+                
+                // Read EDID for current block (128bytes)         
+                gEdidBuffer[byEDID_current* 0x80] = HDMI_Edid_ReadFirstByte();
+                
+                for(i=1;i<128;i++)
+                {
+                    gEdidBuffer[byEDID_current* 0x80+i] = readHDMIRegister(X80_EDID);
+                    DelayMs(1);
+                }
+                printk("EDID read finish\n");
+                
+                // Calculate EDID data byChecksum 
+                byChecksum = HDMI_Edid_CheckSum(gEdidBuffer + (byEDID_current * 0x80), 128);                     
+              //  printf("checksum = %x\n", byChecksum);
+                
+                if (byChecksum != 0)
+                {
+                    // Return fail
+                    printk("Block %x Checksum != 0, fail.\n",byEDID_current);
+                    if (byEDID_current == 0)
+                    {
+                        // Disable EDID interrupt
+                        regValue = readHDMIRegister (X92_INT_MASK1);
+                        writeHDMIRegister (X92_INT_MASK1, (regValue & (~0x06)));
+
+                        return (-1);
+                    }
+                    else
+                    {
+                        // Disable EDID interrupt
+                        regValue = readHDMIRegister (X92_INT_MASK1);
+                        writeHDMIRegister (X92_INT_MASK1, (regValue & (~0x06)));
+
+                     //   DDKDEBUGPRINT((DISPLAY_LEVEL, "Return the first 128 bytes only.\n"));
+                        // Copy 128 bytes data to the given buffer
+                        for (i = 0; i < 128; i++)
+                        {
+                          //  printf("%x ", gEdidBuffer[i]);
+                            pEDIDBuffer[i] = gEdidBuffer[i];
+                        }
+                        printk("\n");
+                        
+                        return 0;   // read first 128 bytes successfully, extension 128 bytes failed. 
+                    }
+                }
+                else
+                {
+                    //Read Extension flag of EDID
+                    byEDID_size = EDID_EXT;
+
+                    if ((byEDID_size==1) && (byEDID_current < 1))
+                    {
+                        // Move to next EDID block
+                        byEDID_current++;
+                        printk("Exist extern EDID information.\n");
+                        // EDID read block1
+                        //byEDID_STATE = HDMI_STATE_EDID_START;	
+                        break;
+                    }
+                    else
+                    {
+                        printk("HDMI EDID Finished.\n");
+                        byEDID_finish = 1;
+                        break;
+                    }  
+                    
+                }
+                            
+            }
+        }
+        
+        if (retry == 0)
+        {
+            printk("Read HDMI EDID fail.\n");
+            // Disable EDID interrupt
+            regValue = readHDMIRegister (X92_INT_MASK1);
+            writeHDMIRegister (X92_INT_MASK1, (regValue & (~0x06)));
+            
+            return (-1);
+        }
+        /* unhook the interrupt */
+        //unhookHDMIInterrupt(HdmiHandler);
+    }
+                   	
+    // Disable EDID interrupt
+    regValue = readHDMIRegister (X92_INT_MASK1);
+    writeHDMIRegister (X92_INT_MASK1, (regValue & (~0x06)));
+
+    // Copy data to the given buffer
+   // printf("Copy buffer\n");
+    for (i = 0; i < bufferSize; i++)
+    {
+     //   printf("%x ", gEdidBuffer[i]);
+        pEDIDBuffer[i] = gEdidBuffer[i];
+    }
+
+#if 0   // for debug only
+    // Print EDID data
+    for (j = 0; j < 8; j++)
+    {
+        printf("0x%02x: ", (j*16));
+        for (i = 0; i < 16; i++)
+            printf("%02x ", gEdidBuffer[(j*16+i)]);
+        printf("\n");
+    }
+    if (byEDID_current > 0)
+    {
+        printf("E_EDID:\n");
+        for (j = 8; j < 16; j++)
+        {
+            printf("0x%02x: ", (j*16));
+            for (i = 0; i < 16; i++)
+                printf("%02x ", gEdidBuffer[(j*16+i)]);
+            printf("\n");
+        }
+        printf("\n");
+    }
+#endif
+
+    // Return EDID block number
+    return byEDID_current;
+}
+
+/*
+ *  Function:
+ *      HDMI_hotplug_check
+ *		 
+ *  Input:
+ *      None
+ * 
+ *  Output:
+ *      0 - unplugged
+ *      1 - plugged
+ * 
+ */
+BYTE HDMI_hotplug_check (void)
+{
+    BYTE STAT_DFh;
+
+    // Wait time before check hot plug & MSENS pin status
+    DelayMs (15);
+
+    STAT_DFh = readHDMIRegister (XDF_HPG_STATUS);
+
+    if ((STAT_DFh & HPG_MSENS) == HPG_MSENS)        // HPD & MSENS status both high? 
+    {
+        // DDC I2C master controller reset ... ddc_ctrl_reset[bit4]
+        writeHDMIRegister (X3B_AVSET2, readHDMIRegister (X3B_AVSET2) | 0x10);
+        writeHDMIRegister (X3B_AVSET2, readHDMIRegister (X3B_AVSET2) & 0xEF);
+        
+        return 1;
+    }
+    else
+    {
+        return 0;
+    }
+
+}
+
+
+int hdmi_detect(void)
+{
+    unsigned int intStatus;
+
+
+    intStatus = peekRegisterDWord(INT_STATUS);
+	
+    if (FIELD_GET(intStatus, INT_STATUS, HDMI) == INT_STATUS_HDMI_ACTIVE)
+    {
+        
+
+        if (PowerMode == PowerMode_A)
+        {
+            // PS mode a->b
+            HDMI_System_PD(PowerMode_B);
+        }
+
+        // Save interrupt status from the last interrupt
+        g_INT_94h = readHDMIRegister(X94_INT1_ST);
+        g_INT_95h = readHDMIRegister(X95_INT2_ST);
+
+        // check if plug-in or plug-out detect
+        if ((g_INT_94h & HPG_MSENS) == HPG_MSENS)        // HPD & MSENS status both high? 
+        {
+            // clear all interrupts
+            writeHDMIRegister(X94_INT1_ST, 0xFF);
+            writeHDMIRegister(X95_INT2_ST, 0xFF);
+
+            if (HDMI_hotplug_check())
+            {
+                return 1;
+            }
+            else
+            {
+                return 0;
+            }
+
+        }
+
+    }
+   return 3; //nothing to do 
+}
+
+
+
+
diff --git a/drivers/gpu/drm/smi/ddk768/ddk768_hdmi.h b/drivers/gpu/drm/smi/ddk768/ddk768_hdmi.h
new file mode 100644
index 000000000000..8e93add942cc
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk768/ddk768_hdmi.h
@@ -0,0 +1,459 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2009 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  HDMI.H --- SMI DDK 
+*  This file contains the source code for the HDMI controller chip
+* 
+*******************************************************************/
+
+#ifndef  _HDMI_HEADER_H_
+#define  _HDMI_HEADER_H_
+
+#include "ddk768_mode.h"
+
+#define SMI_HDMI_LIB_VERSION    ("2.0")
+
+#ifndef BYTE
+typedef unsigned char   BYTE;
+#endif
+
+// This macro is for HDMI PNP detection - interrupt mode
+//#define HDMI_PNP_USE_INT
+
+//-----------------------------------------------------------------------------
+// Global Constants
+//-----------------------------------------------------------------------------
+
+// Video setting constants
+#define VID_01_640x480p     1
+#define VID_02_720x480p     2
+#define VID_03_720x480p     3
+#define VID_04_1280x720p    4
+#define VID_05_1920x1080i   5
+#define VID_06_720x480i     6
+#define VID_07_720x480i     7
+#define VID_08_720x240p     8
+#define VID_09_720x240p     9
+#define VID_10_2880x480i    10
+#define VID_11_2880x480i    11
+#define VID_12_2880x240p    12
+#define VID_13_2880x240p    13
+#define VID_14_1440x480p    14
+#define VID_15_1440x480p    15
+#define VID_16_1920x1080p   16
+#define VID_17_720x576p     17
+#define VID_18_720x576p     18
+#define VID_19_1280x720p    19
+#define VID_20_1920x1080i   20
+#define VID_21_720x576i     21
+#define VID_22_720x576i     22
+#define VID_23_720x288p     23
+#define VID_24_720x288p     24
+#define VID_25_2880x576i    25
+#define VID_26_2880x576i    26
+#define VID_27_2880x288p    27
+#define VID_28_2880x288p    28
+#define VID_29_1440x576p    29
+#define VID_30_1440x576p    30
+#define VID_31_1920x1080p   31
+#define VID_32_1920x1080p   32
+#define VID_33_1920x1080p   33
+#define VID_34_1920x1080p   34
+#define VID_35_2880x480p    35
+#define VID_36_2880x480p    36
+#define VID_37_2880x576p    37
+#define VID_38_2880x567p    38
+#define VID_39_1920x1080i   39
+#define VID_40_1920x1080i   40
+#define VID_41_1280x720p    41
+#define VID_42_720x576p     42
+#define VID_43_720x576p     43
+#define VID_44_720x576i     44
+#define VID_45_720x576i     45
+#define VID_46_1920x1080i   46
+#define VID_47_1280x720p    47
+#define VID_48_720x480p     48
+#define VID_49_720x480p     49
+#define VID_50_720x480i     50
+#define VID_51_720x480i     51
+#define VID_52_720x576p     52
+#define VID_53_720x576p     53
+#define VID_54_720x576i     54
+#define VID_55_720x576i     55
+#define VID_56_720x480p     56
+#define VID_57_720x480p     57
+#define VID_58_720x480i     58
+#define VID_59_720x480i     59
+
+// Audio setting constants
+#define AUD_48K         0x10
+#define AUD_96K         0x20
+#define AUD_192K        0x30
+#define AUD_2CH         0x40    // 2ch audio
+#define AUD_8CH         0x80    // 8ch audio
+//#define DS_none           0x00    // No Downsampling
+#define DS_none         0x01    // No Downsampling
+#define DS_2            0x04    // Downsampling 96k to 48k
+#define DS_4            0x08    // DOwnsampling 192k to 48k
+#define AUD_SPDIF       0x01
+#define AUD_I2S         0x02
+
+// Power Mode - System Control
+#define PowerMode_A             0x11
+#define PowerMode_B             0x21
+#define PowerMode_D             0x41
+#define PowerMode_E             0x81
+
+// Audio Mode - For HDMI_Set_Mode's use, in case audio command is received before mode setting
+#define Audio_Mute               0x00
+#define Audio_Unmute             0x01
+
+// Output Format
+#define FORMAT_RGB              0
+#define FORMAT_YCC422           1
+#define FORMAT_YCC444           2
+
+// Deep Color Bit,
+// Should follow GCP_CD[3:0] definition
+#define DEEP_COLOR_8BIT         4
+#define DEEP_COLOR_10BIT        5
+#define DEEP_COLOR_12BIT        6
+
+// Register Values for Register 94h: Interrupt Status 1
+#define INT1_RSVD               0x09
+#define HOT_PLUG                0x80
+#define HPG_MSENS               0xC0
+#define EDID_ERR                0x02
+#define EDID_RDY                0x04
+#define VSYNC                   0x20
+
+// Register Values for Register 95h: Interrupt Status 2
+#define INT2_RSVD               0x07
+#define HDCP_ERR                0x80
+#define BKSV_RDY                0x60
+#define HDCP_AUTH               0x08
+#define HDCP_DONE               0x10
+
+// STATE
+#define HDMI_STATE_IDLE         0x01
+#define HDMI_STATE_HOTPLUG      0x02
+#define HDMI_STATE_EDID_START   0x03
+#define HDMI_STATE_EDID_READY   0x04
+#define HDMI_STATE_EDID_READ    0x05
+#define HDMI_STATE_EDID_PROCESS 0x06
+#define HDMI_STATE_TX_SETTING   0x07
+#define HDMI_STATE_TX_START     0x08
+#define HDMI_STATE_TX_RUNNING   0x09
+#define HDMI_STATE_HDCP_START   0x0A
+#define HDMI_STATE_HDCP_READY   0x0B
+#define HDMI_STATE_HDCP_READ    0x0C
+#define HDMI_STATE_HDCP_AUTH    0x0D
+//#define HDMI_STATE_PHY_RESET    0x0E
+#define HDMI_STATE_ERROR        0x00
+#define STATE_DEBUG             0xFF
+
+
+//-----------------------------------------------------------------------------
+// Type Definition
+//-----------------------------------------------------------------------------
+
+typedef enum _aspect_ratio_t
+{
+    AR_4to3, /* 4:3 */
+    AR_16to9, /* 16:9 */
+}
+aspect_ratio_t;
+
+typedef enum _TMDS_clk_t
+{
+    CLK_0_to_50, /* 0-50MHz TMDS clock */
+    CLK_50_to_100, /* 50-100MHz TMDS clock */
+    CLK_100_to_150, /* 100-150MHz TMDS clock */
+    CLK_150_to_200, /* 150-200MHz TMDS clock */
+    CLK_200_to_250, /* 200-250MHz TMDS clock */
+    CLK_4Kmode, /* 4K mode uses seperate PHY parameters */
+}
+TMDS_clk_t;
+
+typedef struct _hdmi_PHY_param_t
+{
+    unsigned char X17_PHY_value;
+    unsigned char X56_PHY_value;
+    unsigned char X57_PHY_value;
+    unsigned char X58_PHY_value;
+    unsigned char X59_PHY_value;
+    unsigned char X5A_PHY_value;
+    unsigned char X5B_PHY_value;
+    unsigned char X5C_PHY_value;
+    unsigned char X5D_PHY_value;
+    unsigned char X5E_PHY_value;
+}
+hdmi_PHY_param_t;
+
+//-----------------------------------------------------------------------------
+// Prototypes
+//-----------------------------------------------------------------------------
+
+/*
+ * This is the main interrupt hook for HDMI engine.
+ */
+long hookHDMIInterrupt(
+    void (*handler)(void)
+);
+
+/*
+ * This function un-register HDMI Interrupt handler.
+ */
+long unhookHDMIInterrupt(
+    void (*handler)(void)
+);
+
+/*
+ *  Function: 
+ *      writeHDMIRegister
+ *
+ *  Input:
+ *      addr    - HDMI register index (could be from 0x01 to 0xFF)
+ *      value   - HDMI register value
+ *
+ *  Output:
+ *      None
+ *
+ */
+void writeHDMIRegister(unsigned char addr, unsigned char value);
+
+/*
+ *  Function: 
+ *      readHDMIRegister
+ *
+ *  Input:
+ *      addr    - HDMI register index (could be from 0x01 to 0xFF)
+ *
+ *  Output:
+ *      register value
+ *
+ */
+unsigned char readHDMIRegister(unsigned char addr);
+
+/*
+ *  Function: 
+ *      writeHDMIControlRegister
+ *      This functions writes HDMI System Control register (index 0x00). 
+ *
+ *  Input:
+ *      value   - HDMI register 0x00 value
+ *
+ *  Output:
+ *      None
+ *  
+ */
+void writeHDMIControlRegister(unsigned char value);
+
+/*
+ *  Function: 
+ *      readHDMIRegister
+ *      This functions reads HDMI System Control register (index 0x00). 
+ *
+ *  Input:
+ *      None
+ *
+ *  Output:
+ *      register value
+ *
+ */
+unsigned char readHDMIControlRegister(void);
+
+/*
+ *  Function: 
+ *      writeHdmiPHYRegister
+ *
+ *  Input:
+ *      addr    - HDMI register index (for PHY registers only, could be from 0x57 to 0x5E)
+ *      value   - HDMI register value
+ *
+ *  Output:
+ *      None
+ *
+ */
+void writeHdmiPHYRegister(unsigned char addr, unsigned char value);
+
+/*
+ *  Function:
+ *      setHDMIChannel
+ *
+ *  Input:
+ *      channel number      -   0 = Select Channel 0 to HDMI
+ *                                  -   1 = Select Channel 1 to HDMI
+ *
+ *  Output:
+ *      None
+ *
+ */
+void setHDMIChannel(unsigned char Channel);
+
+/*
+ *  Function:
+ *      enableHdmiI2C
+ *
+ *  Input:
+ *      enable/disable      -   0 = HDMI I2C to GPIO[7:6]
+ *                                  -   1 = HW I2C to GPIO[7:6]
+ *
+ *  Output:
+ *      None
+ *
+ */
+void enableHdmI2C(unsigned long enable);
+
+/*
+ *  Function:
+ *      HDMI_Dump_Registers (Used for debug)
+ *
+ *  Input:
+ *      None
+ *
+ *  Output:
+ *      None
+ *
+ */
+void HDMI_Dump_Registers (void);
+
+//
+// Parameters   : unsigned char mode. 4 modes available.
+//                  MODE_A (sleep), MODE_B (register access), MODE_D (clock), MODE_E (active).
+//
+void HDMI_System_PD (unsigned char mode);
+
+/*
+ *  Function:
+ *      HDMI_Set_Control_Packet
+ *
+ *  Input:
+ *      None
+ *
+ *  Output:
+ *      None
+ *
+ */
+void HDMI_Init (void);
+
+/*
+ *  Function:
+ *      HDMI_Set_Mode
+ *
+ *  Input:
+ *      pLogicalMode
+ *
+ *  Output:
+ *      None
+ *
+ *  Return:
+ *      0 - Success
+ *      -1 - Error 
+ *
+ */
+long HDMI_Set_Mode (logicalMode_t *pLogicalMode, bool isHDMI);
+
+void HDMI_Enable_Output(void);
+
+/*
+ *  Function:
+ *      HDMI_Disable_Output
+ *
+ *  Input:
+ *      None
+ *
+ *  Output:
+ *      None
+ *
+ *  Return:
+ *      None
+ *
+ */
+void HDMI_Disable_Output (void);
+
+/*
+ *  Function:
+ *      HDMI_Unplugged
+ *
+ *  Input:
+ *      None
+ *
+ *  Return:
+ *      None
+ *
+ */
+void HDMI_Unplugged (void);
+
+/*
+ *  Function:
+ *      HDMI_Audio_Mute
+ *
+ *  Input:
+ *      None
+ *
+ *  Output:
+ *      None
+ *
+ *  Return:
+ *      None
+ *
+ */
+void HDMI_Audio_Mute (void);
+
+/*
+ *  Function:
+ *      HDMI_Audio_Unmute
+ *
+ *  Input:
+ *      None
+ *
+ *  Output:
+ *      None
+ *
+ *  Return:
+ *      None
+ *
+ */
+void HDMI_Audio_Unmute (void);
+
+/*
+ *  Function:
+ *      HDMI_Read_Edid.
+ *		 
+ *  Input:
+ *      pEDIDBuffer - EDID buffer
+ *      bufferSize - EDID buffer size (usually 128-bytes or 256 bytes)
+ *  Output:
+ *      -1 - Error
+ *      0 - exist block0 EDID (128 Bytes)
+ *      1 - exist block0 & block1 EDID (256 Bytes)
+ */
+long HDMI_Read_Edid(BYTE *pEDIDBuffer, unsigned long bufferSize);
+
+/*
+ *  Function:
+ *      HDMI_hotplug_check
+ *		 
+ *  Input:
+ *      None
+ * 
+ *  Output:
+ *      0 - unplugged
+ *      1 - plugged
+ * 
+ */
+BYTE HDMI_hotplug_check (void);
+
+int hdmi_detect(void);
+
+
+void hdmiHandler(void);
+void Delay (void);
+void DelayMs (BYTE millisecond);
+
+#endif  /* _HDMI_HEADER_H_ */
diff --git a/drivers/gpu/drm/smi/ddk768/ddk768_help.c b/drivers/gpu/drm/smi/ddk768/ddk768_help.c
new file mode 100644
index 000000000000..804f095a725a
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk768/ddk768_help.c
@@ -0,0 +1,16 @@
+#include "ddk768_help.h"
+
+volatile unsigned char __iomem * mmio768 = NULL;
+char revId768 = 0;
+unsigned short devId768 = 0;
+
+/* after driver mapped io registers, use this function first */
+void ddk768_set_mmio(volatile unsigned char * addr,unsigned short devId,char revId)
+{
+	mmio768 = addr;
+	devId768 = devId;
+	revId768 = revId;
+	printk("Found SM768 SOC Chip\n");
+}
+
+
diff --git a/drivers/gpu/drm/smi/ddk768/ddk768_help.h b/drivers/gpu/drm/smi/ddk768/ddk768_help.h
new file mode 100644
index 000000000000..4c4dc1c01200
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk768/ddk768_help.h
@@ -0,0 +1,32 @@
+#ifndef _DDK768_HELP_H__
+#define _DDK768_HELP_H__
+
+#ifndef USE_INTERNAL_REGISTER_ACCESS
+
+#include <linux/ioport.h>
+#include <linux/io.h>
+#include <linux/uaccess.h>
+
+#define PEEK32(addr) readl((addr)+mmio768)
+#define POKE32(addr,data) writel((data),(addr)+mmio768)
+
+#define peekRegisterDWord(addr) readl((addr)+mmio768)
+#define pokeRegisterDWord(addr,data) writel((data),(addr)+mmio768)
+
+#define peekRegisterByte(addr) readb((addr)+mmio768)
+#define pokeRegisterByte(addr,data) writeb((data),(addr)+mmio768)
+
+/* Size of SM768 MMIO and memory */
+#define SM768_PCI_ALLOC_MMIO_SIZE       (2*1024*1024)
+#define SM768_PCI_ALLOC_MEMORY_SIZE     (128*1024*1024)
+
+void ddk768_set_mmio(volatile unsigned char * addr,unsigned short devId,char revId);
+
+extern volatile unsigned  char __iomem * mmio768;
+extern char revId768;
+extern unsigned short devId768;
+#else
+/* implement if you want use it*/
+#endif
+
+#endif
diff --git a/drivers/gpu/drm/smi/ddk768/ddk768_helper.c b/drivers/gpu/drm/smi/ddk768/ddk768_helper.c
new file mode 100644
index 000000000000..9407956d1410
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk768/ddk768_helper.c
@@ -0,0 +1,84 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2009 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  helper.c --- SM750 DDK 
+*  This file contains helper functions those are used throughout
+*  the DDK library.
+* 
+*******************************************************************/
+#include "ddkdebug.h"
+
+/* A test counter to be shared by all modules */
+static unsigned long gTestCounter;
+
+/* Functions to manipulate a test counter. */
+unsigned long getTestCounter(void)
+{
+    return gTestCounter;
+}
+
+void setTestCounter(unsigned long value)
+{
+    gTestCounter = value;
+}
+
+void incTestCounter(void)
+{
+    gTestCounter++;
+}
+
+/* Perform a rounded division with signed number. 
+ * For example, if the result is 4.5, this function returns 5.
+ * If the result is 4.4, this function returns 4.
+ */
+long lRoundedDiv(long num, long denom)
+{
+    /* n / d + 1 / 2 = (2n + d) / 2d */
+    return (2 * num + denom) / (2 * denom);
+}
+
+/* Perform a rounded division. 
+ * For example, if the result is 4.5, this function returns 5.
+ * If the result is 4.4, this function returns 4.
+ */
+unsigned long ddk768_roundedDiv(unsigned long num, unsigned long denom)
+{
+    /* n / d + 1 / 2 = (2n + d) / 2d */
+    return (2 * num + denom) / (2 * denom);
+}
+
+/* Perform a rounded division with unsigned number. 
+ * For example, if the result is 4.5, this function returns 5.
+ * If the result is 4.4, this function returns 4.
+ */
+unsigned long ulRoundedDiv(unsigned long num, unsigned long denom)
+{
+    return ddk768_roundedDiv(num, denom);
+}
+
+/* Absolute differece between two numbers */
+unsigned long ddk768_absDiff(unsigned long a, unsigned long b)
+{
+    if ( a >= b )
+        return(a - b);
+    else
+        return(b - a);
+}
+
+/* This function calculates 2 to the power of x 
+   Input is the power number.
+ */
+unsigned long ddk768_twoToPowerOfx(unsigned long x)
+{
+    unsigned long i;
+    unsigned long result = 1;
+
+    for (i=1; i<=x; i++)
+        result *= 2;
+
+    return result;
+}
diff --git a/drivers/gpu/drm/smi/ddk768/ddk768_helper.h b/drivers/gpu/drm/smi/ddk768/ddk768_helper.h
new file mode 100644
index 000000000000..cd6f9f8bf0eb
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk768/ddk768_helper.h
@@ -0,0 +1,44 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2009 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  helper.h --- SMI DDK 
+*  This file contains the helper functions those are used throughout
+*  the library
+* 
+*******************************************************************/
+#ifndef _DDK768_HELPER_H_
+#define _DDK768_HELPER_H_
+
+/* Functions to manipulate a test counter. */
+unsigned long getTestCounter(void);
+
+void setTestCounter(unsigned long value);
+
+void incTestCounter(void);
+
+
+/* Perform a rounded division with signed number. 
+ * For example, if the result is 4.5, this function returns 5.
+ * If the result is 4.4, this function returns 4.
+ */
+long lRoundedDiv(long num, long denom);
+
+/* Perform a rounded division. 
+ * For example, if the result is 4.5, this function returns 5.
+ * If the result is 4.4, this function returns 4.
+ */
+unsigned long ddk768_roundedDiv(unsigned long num, unsigned long denom);
+
+/* Absolute differece between two numbers */
+unsigned long ddk768_absDiff(unsigned long a, unsigned long b);
+
+/* This function calculates 2 to the power of x 
+   Input is the power number.
+ */
+unsigned long ddk768_twoToPowerOfx(unsigned long x);
+
+#endif  /* _HELPER_H_ */
diff --git a/drivers/gpu/drm/smi/ddk768/ddk768_hwi2c.c b/drivers/gpu/drm/smi/ddk768/ddk768_hwi2c.c
new file mode 100644
index 000000000000..167639adafdc
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk768/ddk768_hwi2c.c
@@ -0,0 +1,294 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2007 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  hwi2c.c --- SMI DDK 
+*  This file contains the source code for hardware i2c.
+* 
+*******************************************************************/
+
+
+#include "ddk768_reg.h"
+#include "ddk768_power.h"
+#include "ddk768_hwi2c.h"
+#include "ddk768_help.h"
+/*
+ *  This function initializes the hardware i2c
+ *
+ *  Return Value:
+ *       0   - Success
+ *      -1   - Fail to initialize i2c
+ */
+long ddk768_hwI2CInit(
+    unsigned char i2cNumber //I2C0 or I2C1
+)
+{
+    unsigned long value, offset;
+
+    /* Enable GPIO pins as IIC clock & data */
+    if (i2cNumber == 0)
+    {
+        value = FIELD_SET(peekRegisterDWord(GPIO_MUX), GPIO_MUX, I2C0, ENABLE);
+        pokeRegisterDWord(GPIO_MUX, value);
+        offset = 0;
+    }
+    else
+    {
+        value = FIELD_SET(peekRegisterDWord(GPIO_MUX), GPIO_MUX, I2C1, ENABLE);
+        pokeRegisterDWord(GPIO_MUX, value);
+        offset = I2C_OFFSET;
+    }
+              
+    /* Enable the I2C Controller and set the bus speed mode */
+    value = FIELD_SET(peekRegisterByte(I2C_CTRL+offset), I2C_CTRL, EN, ENABLE);
+    value = FIELD_SET(value, I2C_CTRL, MODE, STANDARD);        
+    pokeRegisterByte(I2C_CTRL+offset, value);
+    
+    return 0;
+}
+
+/*
+ *  This function closes the hardware i2c.
+ */
+void ddk768_hwI2CClose(
+    unsigned char i2cNumber //I2C0 or I2C1
+)
+{
+    unsigned long value, offset;
+    
+    /* Set GPIO 30 & 31 back as GPIO pins */
+    if (i2cNumber == 0)
+    {
+        value = FIELD_SET(peekRegisterDWord(GPIO_MUX), GPIO_MUX, I2C0, DISABLE);
+        pokeRegisterDWord(GPIO_MUX, value);
+        offset = 0;
+    }
+    else
+    {
+        value = FIELD_SET(peekRegisterDWord(GPIO_MUX), GPIO_MUX, I2C1, DISABLE);
+        pokeRegisterDWord(GPIO_MUX, value);
+        offset = I2C_OFFSET;
+    }
+
+    /* Disable I2C controller */
+    value = FIELD_SET(peekRegisterByte(I2C_CTRL+offset), I2C_CTRL, EN, DISABLE);
+    pokeRegisterByte(I2C_CTRL+offset, value);
+}
+
+/*
+ *  This function waits until the transfer is completed within the timeout value.
+ *
+ *  Return Value:
+ *       0   - Transfer is completed
+ *      -1   - Tranfer is not successful (timeout)
+ */
+long ddk768_hwI2CWaitTXDone(
+    unsigned char i2cNumber //I2C0 or I2C1
+)
+{
+    unsigned long timeout, offset;
+
+    offset = (i2cNumber == 0)? 0 : I2C_OFFSET;
+
+    /* Wait until the transfer is completed. */
+    timeout = HWI2C_WAIT_TIMEOUT;
+    while ((FIELD_GET(peekRegisterByte(I2C_STATUS+offset), I2C_STATUS, TX) != I2C_STATUS_TX_COMPLETED) &&
+           (timeout != 0))
+        timeout--;
+    
+    if (timeout == 0)
+        return (-1);
+
+    return 0;
+}
+
+/*
+ *  This function writes data to the i2c slave device registers.
+ *
+ *  Parameters:
+ *      deviceAddress   - i2c Slave device address
+ *      length          - Total number of bytes to be written to the device
+ *      pBuffer         - The buffer that contains the data to be written to the
+ *                     i2c device.   
+ *
+ *  Return Value:
+ *      Total number of bytes those are actually written.
+ */
+unsigned long hwI2CWriteData(
+    unsigned char i2cNumber, //I2C0 or I2C1
+    unsigned char deviceAddress,
+    unsigned long length,
+    unsigned char *pBuffer
+)
+{
+    unsigned char value, count, i;
+    unsigned long offset, timeout, totalBytes = 0;
+    
+    offset = (i2cNumber == 0)? 0 : I2C_OFFSET;
+
+    /* Set the Device Address */
+    pokeRegisterByte(I2C_SLAVE_ADDRESS+offset, deviceAddress & ~0x01);
+    
+    /* Write data.
+     * Note:
+     *      Only 16 byte can be accessed per i2c start instruction.
+     */
+    do
+    {
+        /* Reset I2C by writing 0 to I2C_RESET register to clear the previous status. */
+        pokeRegisterByte(I2C_RESET+offset, 0);
+        
+        /* Set the number of bytes to be written */
+        if (length < MAX_HWI2C_FIFO)
+            count = length - 1;
+        else
+            count = MAX_HWI2C_FIFO - 1;
+        pokeRegisterByte(I2C_BYTE_COUNT+offset, count);
+        
+        /* Move the data to the I2C data register */
+        for (i = 0; i <= count; i++)
+            pokeRegisterByte(I2C_DATA0 + i + offset, *pBuffer++);
+
+        /* Start the I2C */
+        pokeRegisterByte(I2C_CTRL+offset, FIELD_SET(peekRegisterByte(I2C_CTRL+offset), I2C_CTRL, CTRL, START));
+        
+        /* Wait until the transfer is completed. */
+        if (ddk768_hwI2CWaitTXDone(i2cNumber) != 0)
+            break;
+    
+        /* Substract length */
+        length -= (count + 1);
+        
+        /* Total byte written */
+        totalBytes += (count + 1);
+        
+    } while (length > 0);
+            
+    return totalBytes;
+}
+
+/*
+ *  This function reads data from the slave device and stores them
+ *  in the given buffer
+ *
+ *  Parameters:
+ *      deviceAddress   - i2c Slave device address
+ *      length          - Total number of bytes to be read
+ *      pBuffer         - Pointer to a buffer to be filled with the data read
+ *                     from the slave device. It has to be the same size as the
+ *                     length to make sure that it can keep all the data read.   
+ *
+ *  Return Value:
+ *      Total number of actual bytes read from the slave device
+ */
+unsigned long hwI2CReadData(
+    unsigned char i2cNumber, //I2C0 or I2C1
+    unsigned char deviceAddress,
+    unsigned long length,
+    unsigned char *pBuffer
+)
+{
+    unsigned char value, count, i;
+    unsigned long offset, totalBytes = 0; 
+    
+    offset = (i2cNumber == 0)? 0 : I2C_OFFSET;
+
+    /* Set the Device Address */
+    pokeRegisterByte(I2C_SLAVE_ADDRESS+offset, deviceAddress | 0x01);
+    
+    /* Read data and save them to the buffer.
+     * Note:
+     *      Only 16 byte can be accessed per i2c start instruction.
+     */
+    do
+    {
+        /* Reset I2C by writing 0 to I2C_RESET register to clear all the status. */
+        pokeRegisterByte(I2C_RESET+offset, 0);
+        
+        /* Set the number of bytes to be read */
+        if (length <= MAX_HWI2C_FIFO)
+            count = length - 1;
+        else
+            count = MAX_HWI2C_FIFO - 1;
+        pokeRegisterByte(I2C_BYTE_COUNT+offset, count);
+
+        /* Start the I2C */
+        pokeRegisterByte(I2C_CTRL+offset, FIELD_SET(peekRegisterByte(I2C_CTRL+offset), I2C_CTRL, CTRL, START));
+        
+        /* Wait until transaction done. */
+        if (ddk768_hwI2CWaitTXDone(i2cNumber) != 0)
+            break;
+
+        /* Save the data to the given buffer */
+        for (i = 0; i <= count; i++)
+            *pBuffer++ = peekRegisterByte(I2C_DATA0 + i + offset);
+
+        /* Substract length by 16 */
+        length -= (count + 1);
+    
+        /* Number of bytes read. */
+        totalBytes += (count + 1); 
+        
+    } while (length > 0);
+    
+    return totalBytes;
+}
+
+/*
+ *  This function reads the slave device's register
+ *
+ *  Parameters:
+ *      deviceAddress   - i2c Slave device address which register
+ *                        to be read from
+ *      registerIndex   - Slave device's register to be read
+ *
+ *  Return Value:
+ *      Register value
+ */
+unsigned char ddk768_hwI2CReadReg(
+    unsigned char i2cNumber, //I2C0 or I2C1
+    unsigned char deviceAddress, 
+    unsigned char registerIndex
+)
+{
+    unsigned char value = (0xFF);
+
+    if (hwI2CWriteData(i2cNumber, deviceAddress, 1, &registerIndex) == 1)
+        hwI2CReadData(i2cNumber, deviceAddress, 1, &value);
+
+    return value;
+}
+
+/*
+ *  This function writes a value to the slave device's register
+ *
+ *  Parameters:
+ *      deviceAddress   - i2c Slave device address which register
+ *                        to be written
+ *      registerIndex   - Slave device's register to be written
+ *      data            - Data to be written to the register
+ *
+ *  Result:
+ *          0   - Success
+ *         -1   - Fail
+ */
+long ddk768_hwI2CWriteReg(
+    unsigned char i2cNumber, //I2C0 or I2C1
+    unsigned char deviceAddress, 
+    unsigned char registerIndex, 
+    unsigned char data
+)
+{
+    unsigned char value[2];
+    
+    value[0] = registerIndex;
+    value[1] = data;
+    if (hwI2CWriteData(i2cNumber, deviceAddress, 2, value) == 2)
+        return 0;
+
+    return (-1);
+}
+
diff --git a/drivers/gpu/drm/smi/ddk768/ddk768_hwi2c.h b/drivers/gpu/drm/smi/ddk768/ddk768_hwi2c.h
new file mode 100644
index 000000000000..fb329f9b35d8
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk768/ddk768_hwi2c.h
@@ -0,0 +1,69 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2008 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  hwi2c.H --- SMI DDK 
+*  This file contains the definitions for Hardware I2C.
+* 
+*******************************************************************/
+#ifndef _DDK768_HWI2C_H_
+#define _DDK768_HWI2C_H_
+
+#define MAX_HWI2C_FIFO 16
+#define HWI2C_WAIT_TIMEOUT 0x7FF
+
+/*
+ *  This function initializes the hardware i2c
+ *
+ *  Return Value:
+ *       0   - Success
+ *      -1   - Fail to initialize i2c
+ */
+long ddk768_hwI2CInit(
+    unsigned char i2cNumber //I2C0 or I2C1
+);
+
+/* 
+ * This function close the hardware i2c 
+ */
+void ddk768_hwI2CClose(
+    unsigned char i2cNumber //I2C0 or I2C1
+);
+
+/* 
+ * This function read the i2c device register value
+ *
+ * Input:   deviceAddress   - I2C Device Address
+ *          registerIndex   - Register index to be read
+ *
+ * Output:
+ *          The value of the register being read.
+ */
+unsigned char ddk768_hwI2CReadReg(
+    unsigned char i2cNumber, //I2C0 or I2C1
+    unsigned char deviceAddress, 
+    unsigned char registerIndex
+);
+
+/* 
+ * This function writes a value to the i2c device register.
+ *
+ * Input:   deviceAddress   - I2C Device Address
+ *          registerIndex   - Register index to be written to
+ *          data            - Data to be written to
+ *
+ * Output:
+ *          0   - Success
+ *         -1   - Fail
+ */
+long ddk768_hwI2CWriteReg(
+    unsigned char i2cNumber, //I2C0 or I2C1
+    unsigned char deviceAddress, 
+    unsigned char registerIndex, 
+    unsigned char data
+);
+
+#endif  /* _HWI2C_H_ */
diff --git a/drivers/gpu/drm/smi/ddk768/ddk768_iis.c b/drivers/gpu/drm/smi/ddk768/ddk768_iis.c
new file mode 100644
index 000000000000..40399d2752b2
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk768/ddk768_iis.c
@@ -0,0 +1,254 @@
+/*******************************************************************
+*
+*         Copyright (c) 2014 by Silicon Motion, Inc. (SMI)
+*
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+*
+*  This file contains the definitions for the IIS functions.
+*
+*******************************************************************/
+
+
+#include "ddk768_reg.h"
+#include "ddk768_iis.h"
+#include "ddk768_help.h"
+#include "ddk768_power.h"
+
+
+/*
+ * Set up I2S and GPIO registers to transmit/receive data.
+ */
+void iisOpen(
+   unsigned long wordLength, //Number of bits in IIS data: 16 bit, 24 bit, 32 bit
+   unsigned long sampleRate  //Sampling rate.
+)
+{
+    unsigned long gpioPin, clockDivider;
+    unsigned char ws;
+
+    ddk768_enableI2S(1); //Turn on I2S clock
+
+    /* Configure GPIO Mux for I2s output */
+    gpioPin = peekRegisterDWord(GPIO_MUX);
+    gpioPin &= ~0x1E000000;    //Clear bit 28:25
+    gpioPin |= 0x1000001c;    //Set up bit 28 and 4:2
+    pokeRegisterDWord(GPIO_MUX, gpioPin);
+
+    /* Make sure GPIO data direction (0x10004) bit 28 = 0 (input) */
+    gpioPin = peekRegisterDWord(GPIO_DATA_DIRECTION);
+    gpioPin &= ~0x10000000;
+    pokeRegisterDWord(GPIO_DATA_DIRECTION, gpioPin);
+
+    /* IIS register set up */
+    pokeRegisterDWord(I2S_TX_DATA_L, 0); //Clear Tx registers
+    pokeRegisterDWord(I2S_TX_DATA_R, 0);    
+
+    //Figure out Word Select value
+    switch (wordLength)
+    {
+        case 32:
+            ws = 2;
+            break;
+        case 24:
+            ws = 1;
+            break;
+        default:
+            ws = 0;
+    }
+
+    clockDivider = (IIS_REF_CLOCK/(4*sampleRate*wordLength)) - 1;
+
+    pokeRegisterDWord(I2S_CTRL, 
+          FIELD_VALUE(0, I2S_CTRL, CS, ws)
+        | FIELD_VALUE(0, I2S_CTRL , CDIV, clockDivider));
+
+    pokeRegisterDWord(I2S_SRAM_DMA, 0);  //Default no DMA. Call another function to set up DMA
+}
+
+
+/*
+ *    Turn off I2S and close GPIO 
+ */
+void iisClose()
+{
+    unsigned long gpioPin;
+
+    /* Close GPIO Mux for I2s output */
+    gpioPin = peekRegisterDWord(GPIO_MUX);
+    gpioPin &= ~0x1000001c;    //Clear bit 28 and 4:2
+    pokeRegisterDWord(GPIO_MUX, gpioPin);
+
+    pokeRegisterDWord(I2S_TX_DATA_L, 0); //Clear Tx registers
+    pokeRegisterDWord(I2S_TX_DATA_R, 0);    
+    pokeRegisterDWord(I2S_STATUS, 0);    //Disable Tx line out
+    pokeRegisterDWord(I2S_CTRL, 0);      //Clear clock setting.
+    pokeRegisterDWord(I2S_SRAM_DMA, 0);  //Clear DMA setting.
+
+    ddk768_enableI2S(0); //Turn off I2S clock
+}
+
+
+
+
+/*
+ *  This function set up I2S to DMA data from SRAM.
+ *
+ *  SRAM area has max size of 2048 bytes (or 512 DWords).
+ *  Max size of each I2S DMA session is 256 DWords.
+ *
+ *  Inputs: 
+ *        offset address in SRAM to start DMA (DWord aligned)
+ *        Number of bytes to DMA (DWord aligned)
+ */
+void iisTxDmaSetup(
+    unsigned long offset, /* Offset from start of SRAM to start DMA */
+    unsigned long len     /* Number of bytes to DMA */
+    )
+{
+    unsigned long dmaPointer;
+
+    offset >>= 2; //I2S DMA register requires offset to be expressed in DWord
+    len >>= 2;
+    len--; //I2S DMA register requires length to be expressed as DWord - 1.
+
+    dmaPointer = FIELD_GET(peekRegisterDWord(I2S_SRAM_DMA), I2S_SRAM_DMA, ADDRESS);
+
+    //If DMA pointer already at the requested offset. Just set up the length.
+    if (dmaPointer == offset)
+    {
+        pokeRegisterDWord(I2S_SRAM_DMA,
+          FIELD_SET(0, I2S_SRAM_DMA, STATE, ENABLE)
+        | FIELD_VALUE(0, I2S_SRAM_DMA, SIZE, len)
+        | FIELD_VALUE(0, I2S_SRAM_DMA, ADDRESS, offset));
+
+        return;
+    }
+
+    //Position DMA pointer to the new base pointer (or offset).
+    //Note that DMA reload base pointer only when it gets to end of SRAM.
+    //Therefore, we need to advance DMA from current position to the end.
+    pokeRegisterDWord(I2S_SRAM_DMA,
+          FIELD_SET(0, I2S_SRAM_DMA, STATE, ENABLE)
+        | FIELD_VALUE(0, I2S_SRAM_DMA, SIZE, (0x1FF - dmaPointer))
+        | FIELD_VALUE(0, I2S_SRAM_DMA, ADDRESS, dmaPointer));
+
+    iisStartNoTx();//Start DMA without output the old data from Tx line.
+
+    //Once DMA starts, make the new base pointer ready.
+    pokeRegisterDWord(I2S_SRAM_DMA,
+          FIELD_SET(0, I2S_SRAM_DMA, STATE, ENABLE)
+        | FIELD_VALUE(0, I2S_SRAM_DMA, SIZE, len)
+        | FIELD_VALUE(0, I2S_SRAM_DMA, ADDRESS, offset));
+
+    // When DMA get to the end of SRAM, it loads the new base pointer.
+    do
+    {
+      dmaPointer = FIELD_GET(peekRegisterDWord(I2S_SRAM_DMA), I2S_SRAM_DMA, ADDRESS);
+    } while(dmaPointer != offset);
+
+    iisStop();
+}
+
+/*
+ * Return current IIS DMA position.
+ */
+unsigned long iisDmaPointer(void)
+{
+    return(FIELD_GET(peekRegisterDWord(I2S_SRAM_DMA), I2S_SRAM_DMA, ADDRESS));
+}
+
+/*
+ * This function start IIS without enabling Tx line.
+ * It can be used to flush left over SRAM data without
+ * sending them to Codec.
+ */
+void iisStartNoTx(void)
+{
+    unsigned long value;
+
+    value = FIELD_SET(peekRegisterDWord(I2S_CTRL), I2S_CTRL, MODE, MASTER);
+    pokeRegisterDWord(I2S_CTRL, value);
+}
+
+
+/*
+ * This function is needed only when I2S is intended to operate in master mode.
+ *
+ * For slave mode, just use iisOpen() is enough, because I2S will start
+ * functioning as soon as an external clock is detected after iisOpen().
+ *
+ */
+
+void iisStart(void)
+{
+	unsigned long value;
+	
+	pokeRegisterDWord(I2S_STATUS, FIELD_SET(0, I2S_STATUS, TX, ENABLE));  //Enable Tx line out
+	
+	value = FIELD_SET(peekRegisterDWord(I2S_CTRL), I2S_CTRL, MODE, MASTER);
+	pokeRegisterDWord(I2S_CTRL, value);
+
+}
+
+/*
+ * Stop audio. 
+ */
+void iisStop(void)
+{
+    unsigned long value;
+
+    value = FIELD_SET(peekRegisterDWord(I2S_CTRL), I2S_CTRL, MODE, SLAVE);
+    pokeRegisterDWord(I2S_CTRL, value);
+
+    pokeRegisterDWord(I2S_STATUS, FIELD_SET(0, I2S_STATUS, TX, DISABLE));  //Disable Tx line out
+
+}
+
+
+/*
+ * Set values for left Tx and right Tx register.
+ */
+void iisSetTx(
+    unsigned long left, //Data for left channel Tx
+    unsigned long right //Data for right channel Tx
+    )
+{
+    pokeRegisterDWord(I2S_TX_DATA_L, left);
+    pokeRegisterDWord(I2S_TX_DATA_R, right);
+}
+
+
+
+/*
+ * This function clears the RAW interrupt status of I2S.
+ *
+ * When I2S completes sending data, the raw interrupt bit will be set.
+ * It has to be cleared, in order to distinguish between different sessions of countdown.
+ *
+ */
+void iisClearRawInt(void)
+{
+    /* Read I2S Control & TX to clear INT when IIS get data from Tx & Rx. */
+    peekRegisterDWord(I2S_STATUS);
+
+    /* Write 0 to I2S SRAM DMA status when IIS get data from SRAM */
+    pokeRegisterDWord(I2S_SRAM_DMA_STATUS, 0);
+
+}
+
+
+/* 
+ * This function returns the INT mask for IIS.
+ *
+ */
+unsigned long iisIntMask(void)
+{
+    unsigned long mask = 0;
+
+    mask |= FIELD_SET(0, INT_MASK, I2S, ENABLE);
+
+    return mask;
+}
+
+
diff --git a/drivers/gpu/drm/smi/ddk768/ddk768_iis.h b/drivers/gpu/drm/smi/ddk768/ddk768_iis.h
new file mode 100644
index 000000000000..230a7cb0ab8d
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk768/ddk768_iis.h
@@ -0,0 +1,109 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2014 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  This file contains the definitions for the IIS functions.
+* 
+*******************************************************************/
+#ifndef _IIS_H_
+#define _IIS_H_
+
+
+#define IIS_REF_CLOCK 48000000
+
+
+/*
+ * Set up I2S and GPIO registers to transmit/receive data.
+ */
+void iisOpen(
+   unsigned long wordLength, //Number of bits in IIS data: 16 bit, 24 bit, 32 bit
+   unsigned long sampleRate  //Sampling rate.
+);
+
+/*
+ *    Turn off I2S and close GPIO 
+ */
+void iisClose(void);
+
+/*
+ *  This function set up I2S to DMA data from SRAM.
+ *
+ *  SRAM area has max size of 2048 bytes (or 512 DWords).
+ *  Max size of each I2S DMA session is 256 DWords.
+ *
+ *  Inputs: 
+ *        offset address in SRAM to start DMA (DWord aligned)
+ *        Number of bytes to DMA (DWord aligned)
+ */
+void iisTxDmaSetup(
+    unsigned long offset, /* Offset from start of SRAM area */
+    unsigned long len     /* Number of bytes to DMA */
+    );
+
+/*
+ * Return current IIS DMA position.
+ */
+unsigned long iisDmaPointer(void);
+
+/*
+ * This function start IIS without enabling Tx line.
+ * It can be used to flush left over SRAM data without
+ * sending them to Codec.
+ */
+void iisStartNoTx(void);
+
+/*
+ * This function is needed only when I2S is intended to operate in master mode.
+ *
+ * For slave mode, just use iisOpen() is enough, because I2S will start
+ * functioning as soon as an external clock is detected after iisOpen().
+ *
+ */
+void iisStart(void);
+
+/*
+ * This function is useful only when I2S is operating in master mode.
+ *
+ * For slave mode, clock is external and cannot be stopped by IIS
+ * control register.
+ *
+ */
+void iisStop(void);
+
+/*
+ * Set values for left Tx and right Tx register.
+ */
+void iisSetTx(
+    unsigned long left, //Data for left channel Tx
+    unsigned long right //Data for right channel Tx
+    );
+
+/*
+ * This function clears the RAW interrupt status of I2S.
+ * 
+ * When I2S completes sending data, the raw interrupt bit will be set.
+ * It has to be cleared, in order to distinguish between different sessions of countdown.
+ * 
+ */
+void iisClearRawInt(void);
+
+/* 
+ * This function returns the INT mask for IIS.
+ *
+ */
+unsigned long iisIntMask(void);
+
+/*
+ * This is a reference sample showing how to implement ISR for I2S.
+ * It works wiht libsrc\intr.c together.
+ * 
+ * Refer to Apps\iis\tstiis.c on how to hook up this function with system
+ * interrupt under WATCOM DOS extender.
+ * 
+ */
+
+
+#endif /* _IIS_H_ */
diff --git a/drivers/gpu/drm/smi/ddk768/ddk768_intr.c b/drivers/gpu/drm/smi/ddk768/ddk768_intr.c
new file mode 100644
index 000000000000..16ad93c7e838
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk768/ddk768_intr.c
@@ -0,0 +1,62 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2007 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  intr.c --- SM750/SM718 DDK 
+*  This file contains the source code for the interrupt management.
+* 
+*******************************************************************/
+
+#include "ddk768_reg.h"
+#include "ddk768_chip.h"
+#include "ddk768_intr.h"
+#include "ddk768_help.h"
+
+
+/* 
+ * Change interrupt mask 
+ */
+void setIntMask(
+    unsigned long mask_on, 
+    unsigned long mask_off
+)
+{
+    unsigned long mask;
+
+    /* Get current interrupt mask */
+    mask = peekRegisterDWord(INT_MASK);
+
+    /* Enable new masks and disable old masks */
+    mask = mask | mask_on;
+    mask = mask & ~mask_off;
+
+    /* Program new interrupt mask */
+    pokeRegisterDWord(INT_MASK, mask);
+}
+
+
+void sb_IRQMask(int irq_num)
+{
+		unsigned int mask;
+        mask = peekRegisterDWord(INT_MASK);
+        mask &= ~(0x1<<irq_num);
+        pokeRegisterDWord(INT_MASK,mask);  
+  
+}
+
+
+
+
+void sb_IRQUnmask(int irq_num)
+{
+		unsigned int mask;
+        mask = peekRegisterDWord(INT_MASK);
+        mask = mask | 0x1<<irq_num;
+        pokeRegisterDWord(INT_MASK,mask);  
+  
+}
+
+
diff --git a/drivers/gpu/drm/smi/ddk768/ddk768_intr.h b/drivers/gpu/drm/smi/ddk768/ddk768_intr.h
new file mode 100644
index 000000000000..2cee65bd199b
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk768/ddk768_intr.h
@@ -0,0 +1,116 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2008 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  intr.h --- SM750/SM718 DDK 
+*  This file contains the source code for the interrupt mechanism 
+* 
+*******************************************************************/
+#ifndef _INTR_H_
+#define _INTR_H_
+
+
+/*******************************************************************
+ * Interrupt implementation
+ * 
+ * This implementation is used for handling the interrupt.
+ *******************************************************************/
+
+typedef void (*PFNINTRHANDLER)(unsigned long);
+
+/*
+ * Register an interrupt handler function to an interrupt status
+ */ 
+short registerHandler(
+    void (*handler)(unsigned long status), 
+    unsigned long mask
+);
+
+/*
+ * Un-register a registered interrupt handler
+ */
+short unregisterHandler(
+    void (*handler)(unsigned long status)
+);
+
+/* 
+ * Hook a ISR function to the interrupt.
+ *
+ * This is a low level function providing one to one mapping of a single ISR to the interrupt line.
+ * It is a quick method to verify if a specific interrupt is working.
+ * However, it does not provide the structure of chaining several ISR together (use registerHandler() to chain ISR, instead).
+ *
+ * Note: 
+ *   1. If this function is used to hook up interrupt, unhookInterrupt() must be use to release the INT.
+ *      Don't use unregisterHandler() to release interrupt set up by this function.
+ *
+ * Output:
+ *      0   - Success
+ *      -1  - Out of memory
+ * 
+ */
+short hookInterrupt(
+    void (*handler)(void),      /* Interrupt function to be registered */
+    unsigned long mask          /* interrupt mask */
+);
+
+/* 
+ * Unregister a registered interrupt handler
+ * The matching call for singleIsrRegisterHandler()
+ *
+ * Output:
+ *      0   - Success
+ *      -1  - Handler is not found 
+ */
+short unhookInterrupt(
+    unsigned long mask          /* interrupt mask */
+);
+
+/*
+ * When hookInterrupt() is used to set up interrupt.
+ * ISR should call this function before exit.
+ *
+ */
+void notifyEndOfISR(void);
+
+
+void sb_IRQMask(int irq_num);
+void sb_IRQUnmask(int irq_num);
+
+#define SB_IRQ_VAL_TC3     	31
+#define SB_IRQ_VAL_TC2     	30
+#define SB_IRQ_VAL_TC1     	29
+#define SB_IRQ_VAL_TC0     	28
+#define SB_IRQ_VAL_USBH		25
+#define SB_IRQ_VAL_USBS		24
+#define SB_IRQ_VAL_I2S		23
+#define SB_IRQ_VAL_USART1  22
+#define SB_IRQ_VAL_USART0  21
+#define SB_IRQ_VAL_SSP1  	20
+#define SB_IRQ_VAL_SSP0		19
+#define SB_IRQ_VAL_I2C1		18
+#define SB_IRQ_VAL_I2C0		17	
+#define SB_IRQ_VAL_PWM		16
+#define SB_IRQ_VAL_GPIO6	15
+#define SB_IRQ_VAL_GPIO5	14
+#define SB_IRQ_VAL_GPIO4	13
+#define SB_IRQ_VAL_GPIO3	12
+#define SB_IRQ_VAL_GPIO2	11
+#define SB_IRQ_VAL_GPIO1	10
+#define SB_IRQ_VAL_GPIO0	9
+#define SB_IRQ_VAL_DMA		8
+#define SB_IRQ_VAL_CPU		7
+#define SB_IRQ_VAL_CSC		5
+#define SB_IRQ_VAL_DE			4
+#define SB_IRQ_VAL_C			3
+#define SB_IRQ_VAL_DC1		2
+#define SB_IRQ_VAL_DC0		1
+#define SB_IRQ_VAL_VGA		0
+
+
+
+
+#endif /* _INTR_H_ */
diff --git a/drivers/gpu/drm/smi/ddk768/ddk768_mode.c b/drivers/gpu/drm/smi/ddk768/ddk768_mode.c
new file mode 100644
index 000000000000..63f0f3712c0d
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk768/ddk768_mode.c
@@ -0,0 +1,922 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2007 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  MODE.C --- SMI DDK 
+*  This file contains the source code for the mode table.
+* 
+*******************************************************************/
+
+#include "linux/string.h"
+
+#include "ddk768_reg.h"
+
+#include "ddk768_chip.h"
+#include "ddk768_clock.h"
+#include "ddk768_power.h"
+#include "ddk768_mode.h"
+
+#include "ddk768_help.h"
+
+
+
+/* The valid signature of the user data pointer  for the setmode function. 
+   The following definition is ASCII representation of the word 'USER'
+ */
+#define MODE_USER_DATA_SIGNATURE            0x55534552
+
+/*
+ *  Default Timing parameter for some popular modes.
+ *  Note that the most timings in this table is made according to standard VESA 
+ *  parameters for the popular modes.
+ */
+static mode_parameter_t gDefaultModeParamTable[] =
+{
+/* 640 x 480  [4:3] */
+/* The first 2 commented lines below are taken from SM502, the rest timing are
+   taken from the VESA Monitor Timing Standard */
+/* { 840, 640, 680, 64, NEG, 500, 480, 481, 3, NEG, 31500000, 37500, 75, NEG}, */
+/* { 832, 640, 700, 56, NEG, 509, 480, 481, 3, NEG, 36000000, 43269, 85, NEG}, */
+ { 800, 640, 656, 96, NEG, 525, 480, 490, 2, NEG, 25175000, 31469, 60, NEG},
+ { 840, 640, 656, 64, NEG, 500, 480, 481, 3, NEG, 31500000, 37500, 75, NEG},
+ { 832, 640, 696, 56, NEG, 509, 480, 481, 3, NEG, 36000000, 43269, 85, NEG},
+
+/* 720 x 480  [3:2] */
+ { 889, 720, 738,108, POS, 525, 480, 490, 2, NEG, 28000000, 31496, 60, NEG},
+
+/* 720 x 540  [4:3] -- Not a popular mode */
+ { 886, 720, 740, 96, POS, 576, 540, 545, 2, POS, 30600000, 34537, 60, NEG},
+
+/*720 x 576 [5:4] -- Not a popular mode*/
+ { 912, 720, 744, 96, POS, 597, 576, 580, 1, NEG, 32670000, 35820, 60, POS}, 
+
+/* 800 x 480  [5:3] -- Not a popular mode */
+ { 973, 800, 822, 56, POS, 524, 480, 490, 2, NEG, 30600000, 31449, 60, NEG},
+
+/* 800 x 600  [4:3] */
+/* The first 2 commented lines below are taken from SM502, the rest timing are
+   taken from the VESA Monitor Timing Standard */
+/* {1062, 800, 840,128, POS, 628, 600, 601, 4, POS, 40000000, 37665, 60, NEG}, */
+/* {1054, 800, 842, 64, POS, 625, 600, 601, 3, POS, 56000000, 53131, 85, NEG}, */
+ {1056, 800, 840,128, POS, 628, 600, 601, 4, POS, 40000000, 37879, 60, NEG},
+ {1056, 800, 816, 80, POS, 625, 600, 601, 3, POS, 49500000, 46875, 75, NEG},
+ {1048, 800, 832, 64, POS, 631, 600, 601, 3, POS, 56250000, 53674, 85, NEG},
+
+/* 960 x 720  [4:3] -- Not a popular mode */
+ {1245, 960, 992, 64, POS, 750, 720, 721, 3, POS, 56000000, 44980, 60, NEG},
+      
+/* 1024 x 600  [16:9] 1.7 */
+ {1313,1024,1064,104, POS, 622, 600, 601, 3, POS, 49000000, 37319, 60, NEG},
+     
+/* 1024 x 768  [4:3] */
+/* The first 2 commented lines below are taken from SM502, the rest timing are
+   taken from the VESA Monitor Timing Standard */
+/* {1340,1024,1060,136, NEG, 809, 768, 772, 6, NEG, 65000000, 48507, 60, NEG}, */
+/* {1337,1024,1072, 96, NEG, 808, 768, 780, 3, NEG, 81000000, 60583, 75, NEG}, */
+ {1344,1024,1048,136, NEG, 806, 768, 771, 6, NEG, 65000000, 48363, 60, NEG},
+ {1312,1024,1040, 96, POS, 800, 768, 769, 3, POS, 78750000, 60023, 75, NEG},
+ {1376,1024,1072, 96, POS, 808, 768, 769, 3, POS, 94500000, 68677, 85, NEG},
+  
+/* 1152 x 864  [4:3] -- Widescreen eXtended Graphics Array */
+/* {1475,1152,1208, 96, NEG, 888, 864, 866, 3, NEG, 78600000, 53288, 60, NEG},*/
+ {1475,1152,1208, 96, POS, 888, 864, 866, 3, POS, 78600000, 53288, 60, NEG},
+ {1600,1152,1216,128, POS, 900, 864, 865, 3, POS,108000000, 67500, 75, NEG},
+ 
+/* 1280 x 720  [16:9] -- HDTV (WXGA) */
+ {1664,1280,1336,136, POS, 746, 720, 721, 3, POS, 74481000, 44760, 60, NEG},
+
+/* 1280 x 768  [5:3] -- Not a popular mode */
+ {1678,1280,1350,136, POS, 795, 768, 769, 3, POS, 80000000, 47676, 60, NEG},
+
+/* 1280 x 800  [8:5] -- Not a popular mode */
+ {1650,1280,1344,136, NEG, 824, 800, 800, 3, NEG, 81600000, 49455, 60, NEG},
+
+/* 1280 x 960  [4:3] */
+/* The first commented line below are taken from SM502, the rest timing are
+   taken from the VESA Monitor Timing Standard */
+/* {1618,1280,1330, 96, NEG, 977, 960, 960, 2, NEG, 94500000, 59259, 60, NEG},*/
+ {1800,1280,1376,112, POS,1000, 960, 961, 3, POS,108000000, 60000, 60, NEG},
+ {1728,1280,1344,160, POS,1011, 960, 961, 3, POS,148500000, 85938, 85, NEG},
+    
+/* 1280 x 1024 [5:4] */
+#if 1
+ /* GTF with C = 40, M = 600, J = 20, K = 128 */
+ {1712,1280,1360,136, NEG,1060,1024,1025, 3, POS,108883200, 63600, 60, NEG},
+ {1728,1280,1368,136, NEG,1069,1024,1025, 3, POS,138542400, 80175, 75, NEG},
+ {1744,1280,1376,136, NEG,1075,1024,1025, 3, POS,159358000, 91375, 85, NEG},
+#else
+ /* VESA Standard */
+ {1688,1280,1328,112, POS,1066,1024,1025, 3, POS,108000000, 63981, 60, NEG},
+ {1688,1280,1296,144, POS,1066,1024,1025, 3, POS,135000000, 79976, 75, NEG},
+ {1728,1280,1344,160, POS,1072,1024,1025, 3, POS,157500000, 91146, 85, NEG},
+#endif
+
+/* 1360 x 768 [16:9] */
+#if 1
+ /* GTF with C = 40, M = 600, J = 20, K = 128 */
+ //{1776,1360,1432,136, NEG, 795, 768, 769, 3, POS, 84715200, 47700, 60, NEG},
+ 
+ /* GTF with C = 30, M = 600, J = 20, K = 128 */
+ {1664,1360,1384,128, NEG, 795, 768, 769, 3, POS, 79372800, 47700, 60, NEG},
+#else
+ /* Previous Calculation */
+ {1776,1360,1424,144, POS, 795, 768, 769, 3, POS, 84715000, 47700, 60, NEG},
+#endif
+ 
+/* 1366 x 768  [16:9] */
+ /* Previous Calculation  */
+ {1722,1366,1424,112, NEG, 784, 768, 769, 3, NEG, 81000000, 47038, 60, NEG},
+ 
+/* 1400 x 1050 [4:3] -- Hitachi TX38D95VC1CAH -- It is not verified yet, therefore
+   temporarily disabled. */
+ //{1688,1400,1448,112, NEG,1068,1050,1051, 3, NEG,108000000, 64000, 60, NEG},
+ //{1688,1400,1464,112, NEG,1068,1050,1051, 3, NEG,108167040, 64080, 60, NEG},
+ 
+ /* Taken from the www.tinyvga.com */
+ {1880,1400,1488,152, NEG,1087,1050,1051, 3, POS,122610000, 65218, 60, NEG},
+ 
+/* 1440 x 900  [8:5] -- Widescreen Super eXtended Graphics Array (WSXGA) */
+ {1904,1440,1520,152, NEG, 932, 900, 901, 3, POS,106470000, 55919, 60, NEG},
+
+/* 1440 x 960 [3:2] -- Not a popular mode */
+ {1920,1440,1528,152, POS, 994, 960, 961, 3, POS,114509000, 59640, 60, NEG},
+
+/* 1600 x 900 */
+{2128,1600,1664,192, POS,932,900,901, 3, POS,119000000, 56000, 60, NEG},
+
+
+/* 1600 x 1200 [4:3]. -- Ultra eXtended Graphics Array */
+ /* VESA */
+ {2160,1600,1664,192, POS,1250,1200,1201, 3, POS,162000000, 75000, 60, POS},
+ {2160,1600,1664,192, POS,1250,1200,1201, 3, POS,202500000, 93750, 75, POS},
+ {2160,1600,1664,192, POS,1250,1200,1201, 3, POS,229500000,106250, 85, POS},
+
+/* 
+ * The timing below is taken from the www.tinyvga.com/vga-timing.
+ * With the exception of 1920x1080.
+ */
+ 
+/* 1680 x 1050 [8:5]. -- Widescreen Super eXtended Graphics Array Plus (WSXGA+) */ 
+/* The first commented timing might be used for DVI LCD Monitor timing. */
+/* {1840,1680,1728, 32, NEG,1080,1050,1053, 6, POS,119232000, 64800, 60, NEG}, */
+ /* GTF with C = 30, M = 600, J = 20, K = 128 */
+ {2256,1680,1784,184, NEG,1087,1050,1051, 3, POS,147140000, 65222, 60, POS},
+/*
+ {2272,1680,1792,184, NEG,1093,1050,1051, 3, POS,173831000, 76510, 70, NEG},
+ {2288,1680,1800,184, NEG,1096,1050,1051, 3, POS,188074000, 82200, 75, NEG},
+*/
+ 
+/* 1792 x 1344 [4:3]. -- Not a popular mode */ 
+ {2448,1792,1920,200, NEG,1394,1344,1345, 3, POS,204800000, 83660, 60, NEG},
+ {2456,1792,1888,216, NEG,1417,1344,1345, 3, POS,261000000,106270, 75, NEG},
+ 
+/* 1856 x 1392 [4:3]. -- Not a popular mode 
+   The 1856 x 1392 @ 75Hz has not been tested due to high Horizontal Frequency
+   where not all monitor can support it (including the developer monitor)
+ */
+ {2528,1856,1952,224, NEG,1439,1392,1393, 3, POS,218300000, 86353, 60, NEG},
+/* {2560,1856,1984,224, NEG,1500,1392,1393, 3, POS,288000000,112500, 75, NEG},*/
+
+/* 1920 x 1080 [16:9]. This is a make-up value, need to be proven. 
+   The Pixel clock is calculated based on the maximum resolution of
+   "Single Link" DVI, which support a maximum 165MHz pixel clock.
+   The second values are taken from:
+   http://www.tek.com/Measurement/App_Notes/25_14700/eng/25W_14700_3.pdf
+ */
+/* {2560,1920,2048,208, NEG,1125,1080,1081, 3, POS,172800000, 67500, 60, NEG}, */
+ {2200,1920,2008, 44, NEG,1125,1080,1081, 3, POS,148500000, 67500, 60, POS},
+
+/* 1920 x 1200 [8:5]. -- Widescreen Ultra eXtended Graphics Array (WUXGA) */
+ {2592,1920,2048,208, NEG,1242,1200,1201, 3, POS,193160000, 74522, 60, NEG},
+
+/* 1920 x 1440 [4:3]. */
+/* In the databook, it mentioned only support up to 1920x1440 @ 60Hz. 
+   The timing for 75 Hz is provided here if necessary to do testing. - Some underflow
+   has been noticed. */
+ {2600,1920,2048,208, NEG,1500,1440,1441, 3, POS,234000000, 90000, 60, NEG},
+/* {2640,1920,2064,224, NEG,1500,1440,1441, 3, POS,297000000,112500, 75, NEG}, */
+
+/* 2560x1440 [16:9]. */
+/* 2K mode */
+ {2720,2560,2608,32, POS,1481,1440,1443, 5, NEG,241500000, 88000, 60, NEG},
+
+/* 3840 x 2160 (UHD) */
+ {4400,3840,4016,88, POS,2250,2160,2168, 10, POS,297000000, 67500, 30, NEG},
+
+
+/* End of table. */
+ { 0, 0, 0, 0, NEG, 0, 0, 0, 0, NEG, 0, 0, 0, NEG},
+};
+
+static mode_parameter_t gChannel0ModeParamTable[MAX_MODE_TABLE_ENTRIES] =
+{
+    /* End of table */
+     { 0, 0, 0, 0, NEG, 0, 0, 0, 0, NEG, 0, 0, 0, NEG},
+};
+
+static mode_parameter_t gChannel1ModeParamTable[MAX_MODE_TABLE_ENTRIES] =
+{
+    /* End of table */
+     { 0, 0, 0, 0, NEG, 0, 0, 0, 0, NEG, 0, 0, 0, NEG},
+};
+
+/* Static variable to store the mode information. */
+static mode_parameter_t gChannel0CurrentModeParam;
+static mode_parameter_t gChannel1CurrentModeParam;
+
+/*
+ *  ddk768_getUserDataSignature
+ *      This function gets the user data mode signature
+ *
+ *  Output:
+ *      The signature to be filled in the user_data_mode_t structure to be considered
+ *      a valid structure.
+ */
+unsigned long ddk768_getUserDataSignature()
+{
+    return MODE_USER_DATA_SIGNATURE;
+}
+
+/*
+ *  compareModeParam
+ *      This function compares two mode parameters
+ *
+ *  Input:
+ *      pModeParam1 - Pointer to the first mode parameter to be compared
+ *      pModeParam2 - Pointer to the second mode parameter to be compared
+ *
+ *  Output:
+ *      0   - Identical mode
+ *     -1   - Mode is not identical
+ */
+long compareModeParam(
+    mode_parameter_t *pModeParam1,
+    mode_parameter_t *pModeParam2
+)
+{
+    if ((pModeParam1 != (mode_parameter_t *)0) &&
+        (pModeParam2 != (mode_parameter_t *)0))
+    {
+        if (memcmp((void *)pModeParam1, (void *)pModeParam2, sizeof(mode_parameter_t)) == 0)
+            return 0;
+    }
+        
+    return (-1);
+}
+
+/*
+ *  getDuplicateModeIndex
+ *      This function retrieves the index of dupicate modes, but having different timing.
+ *
+ *  Input:
+ *      dispCtrl    - Display Control where the mode table belongs to.
+ *      pModeParam  - The mode parameters which index to be checked.
+ *
+ *  Output:
+ *      The index of the given parameters among the duplicate modes.
+ *          0 means that the mode param is the first mode encountered in the table
+ *          1 means that the mode param is the second mode encountered in the table
+ *          etc...
+ */
+unsigned short getDuplicateModeIndex(
+    disp_control_t dispCtrl,
+    mode_parameter_t *pModeParam
+)
+{
+    unsigned short index, modeIndex;
+    mode_parameter_t *pModeTable;
+    
+    /* Get the mode table */
+    pModeTable = ddk768_getStockModeParamTableEx(dispCtrl);
+    
+    /* Search the current mode */
+    modeIndex = 0;
+    index = 0;
+    while (pModeTable[modeIndex].pixel_clock != 0)
+    {
+        if ((pModeTable[modeIndex].horizontal_display_end == pModeParam->horizontal_display_end) &&
+            (pModeTable[modeIndex].vertical_display_end == pModeParam->vertical_display_end) &&
+            (pModeTable[modeIndex].vertical_frequency == pModeParam->vertical_frequency))
+        {
+            /* Check if this is the same/identical mode param. */
+            if (compareModeParam(&pModeTable[modeIndex], pModeParam) == 0)
+                break;
+                
+            /* Increment the index */
+            index++;
+        }
+        modeIndex++;
+    }
+    
+    return index;
+}
+
+/*
+ *  ddk768_findModeParamFromTable
+ *      This function locates the requested mode in the given parameter table
+ *
+ *  Input:
+ *      width           - Mode width
+ *      height          - Mode height
+ *      refresh_rate    - Mode refresh rate
+ *      index           - Index that is used for multiple search of the same mode 
+ *                        that have the same width, height, and refresh rate, 
+ *                        but have different timing parameters.
+ *
+ *  Output:
+ *      Success: return a pointer to the mode_parameter_t entry.
+ *      Fail: a NULL pointer.
+ */
+mode_parameter_t *ddk768_findModeParamFromTable(
+    unsigned long width, 
+    unsigned long height, 
+    unsigned long refresh_rate,
+    unsigned short index,
+    mode_parameter_t *pModeTable
+)
+{
+    extern int lvds_channel;
+    unsigned short modeIndex = 0, tempIndex = 0;
+    static mode_parameter_t lvds_1920_1080_60 = {2142,1920,2008,44,POS,1100,1080,1081,3,POS,141400000,67500,60,NEG};
+    
+    if (lvds_channel && pModeTable == gDefaultModeParamTable &&
+	        width == 1920 && height == 1080 && refresh_rate == 60)
+	    return &lvds_1920_1080_60;
+
+    /* Walk the entire mode table. */    
+    while (pModeTable[modeIndex].pixel_clock != 0)
+    {
+        if (((width == (unsigned long)(-1)) || (pModeTable[modeIndex].horizontal_display_end == width)) &&
+            ((height == (unsigned long)(-1)) || (pModeTable[modeIndex].vertical_display_end == height)) &&
+            ((refresh_rate == (unsigned long)(-1)) || (pModeTable[modeIndex].vertical_frequency == refresh_rate)))
+        {
+            if (tempIndex < index)
+                tempIndex++;
+            else
+                return (&pModeTable[modeIndex]);
+        }
+        
+        /* Next entry */
+        modeIndex++;
+    }
+
+    /* No match, return NULL pointer */
+    return((mode_parameter_t *)0);
+}
+
+/*
+ *  Locate in-stock parameter table for the requested mode.
+ *  Success: return a pointer to the mode_parameter_t entry.
+ *  Fail: a NULL pointer.
+ */
+mode_parameter_t *ddk768_findModeParam(
+    disp_control_t dispCtrl,
+    unsigned long width, 
+    unsigned long height, 
+    unsigned long refresh_rate,
+    unsigned short index
+)
+{
+    return ddk768_findModeParamFromTable(width, height, refresh_rate, index, ddk768_getStockModeParamTableEx(dispCtrl));
+}
+
+/*
+ *  Use the
+ *  Locate timing parameter for the requested mode from the default mode table.
+ *  Success: return a pointer to the mode_parameter_t entry.
+ *  Fail: a NULL pointer.
+ */
+mode_parameter_t *ddk768_findVesaModeParam(
+    unsigned long width, 
+    unsigned long height, 
+    unsigned long refresh_rate
+)
+{
+    return ddk768_findModeParamFromTable(width, height, refresh_rate, 0, gDefaultModeParamTable);
+}
+
+/*
+ * (Obsolete) 
+ * Return a point to the gDefaultModeParamTable.
+ * Function in other files used this to get the mode table pointer.
+ */
+mode_parameter_t *ddk768_getStockModeParamTable()
+{
+    return(gDefaultModeParamTable);
+}
+
+/*
+ * (Obsolete)
+ * Return the size of the Stock Mode Param Table
+ */
+unsigned long ddk768_getStockModeParamTableSize()
+{
+    return (sizeof(gDefaultModeParamTable) / sizeof(mode_parameter_t) - 1);
+}
+
+/* 
+ *  ddk768_getStockModeParamTableEx
+ *      This function gets the mode parameters table associated to the
+ *      display control (CHANNEL0_CTRL or SECONDAR_CTRL).
+ *
+ *  Input:
+ *      dispCtrl    - Display Control of the mode table that is associated to.
+ *
+ *  Output:
+ *      Pointer to the mode table
+ */
+mode_parameter_t *ddk768_getStockModeParamTableEx(
+    disp_control_t dispCtrl
+)
+{
+    mode_parameter_t *pModeTable;
+    
+    if (dispCtrl == CHANNEL0_CTRL)
+        pModeTable = (mode_parameter_t *)gChannel0ModeParamTable;
+    else
+        pModeTable = (mode_parameter_t *)gChannel1ModeParamTable;
+        
+    /* Check if the table exist by checking the first entry. 
+       If it doesn't, then use the default mode table. */
+
+    if (pModeTable->pixel_clock == 0)
+    {
+        pModeTable = ddk768_getStockModeParamTable();
+    }
+        
+    return (pModeTable);
+}
+
+/*
+ *  ddk768_getStockModeParamTableSizeEx
+ *      This function gets the size of the mode parameter table associated with
+ *      specific display control
+ *
+ *  Input:
+ *      dispCtrl    - Display control of the mode param table that is associated to.
+ *
+ *  Output:
+ *      Size of the requeted mode param table.
+ */
+unsigned long ddk768_getStockModeParamTableSizeEx(
+    disp_control_t dispCtrl
+)
+{
+    unsigned long tableSize;
+    mode_parameter_t *pModeTable;
+    
+    /* Get the mode table */
+    pModeTable = ddk768_getStockModeParamTableEx(dispCtrl);
+    
+    /* Calculate the table size by finding the end of table entry indicated by all zeroes. */    
+    tableSize = 0;
+    while (pModeTable[tableSize].pixel_clock != 0)
+        tableSize++;
+        
+    return tableSize;
+}
+
+/*
+ *  getMaximumModeEntries
+ *      This function gets the maximum entries that can be stored in the mode table.
+ *
+ *  Output:
+ *      Total number of maximum entries
+ */
+unsigned long getMaximumModeEntries()
+{
+    return MAX_MODE_TABLE_ENTRIES;
+}
+
+/* 
+ * This function returns the current mode.
+ */
+mode_parameter_t ddk768_getCurrentModeParam(
+    disp_control_t dispCtrl
+)
+{
+    if (dispCtrl == CHANNEL0_CTRL)
+        return gChannel0CurrentModeParam;
+    else
+        return gChannel1CurrentModeParam;
+}
+
+/*
+ *  addTiming
+ *      This function adds the SM750 mode parameter timing to the specified mode table
+ *
+ *  Input:
+ *      dispCtrl        - Display control where the mode will be associated to
+ *      pNewModeList    - Pointer to a list table of SM750 mode parameter to be added 
+ *                        to the current specified display control mode table.
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long addTiming(
+    disp_control_t dispCtrl,
+    mode_parameter_t *pNewModeList,
+    unsigned long totalList,
+    unsigned char clearTable
+)
+{
+    mode_parameter_t *pModeParamTable;
+    unsigned char index;
+    long returnValue = 0;
+    
+    /* Get the correct table */
+    if (dispCtrl == CHANNEL0_CTRL)
+        pModeParamTable = (mode_parameter_t *)gChannel0ModeParamTable;
+    else
+        pModeParamTable = (mode_parameter_t *)gChannel1ModeParamTable;
+    
+    if (clearTable == 0)
+    {    
+        /* Find the last index where the timing will be added to */
+        index = 0;
+        while(pModeParamTable[index].pixel_clock != 0)
+            index++;
+    }
+    else
+    {
+        /* Clear and reset the mode table first */
+        for (index = 0; index < MAX_MODE_TABLE_ENTRIES; index++)
+            memset((void*)&pModeParamTable[index], 0, sizeof(mode_parameter_t));
+            
+        /* Reset index */
+        index = 0;
+    }
+        
+    /* Update the number of modes those can be added to the current table. */
+    if (totalList > (unsigned long)(MAX_MODE_TABLE_ENTRIES - index))
+        totalList = (unsigned long)(MAX_MODE_TABLE_ENTRIES - index);
+    else
+        returnValue = (-1);
+    
+    /* Check if totalList is 0, which means that the table is full. */        
+    if (totalList == 0)
+        returnValue = (-1);
+        
+    /* Add the list of modes provided by the caller */
+    while (totalList--)
+    {
+        memcpy((void *)&pModeParamTable[index], (void *)&pNewModeList[index], sizeof(mode_parameter_t));
+        index++;
+    }
+        
+    return returnValue;
+}
+
+/*
+ *	This function sets the display base address
+ *
+ *	Input:
+ *		dispControl		- display control of which base address to be set.
+ *		ulBaseAddress	- Base Address value to be set.
+ */
+void ddk768_setDisplayBaseAddress(
+	disp_control_t dispControl,
+	unsigned long ulBaseAddress
+)
+{
+    unsigned long regFB;
+
+    regFB = (dispControl == CHANNEL0_CTRL) ? FB_ADDRESS : (FB_ADDRESS+CHANNEL_OFFSET);
+
+		/* Frame buffer base for this mode */
+	pokeRegisterDWord(regFB,
+          FIELD_SET(0, FB_ADDRESS, STATUS, PENDING)
+        | FIELD_VALUE(0, FB_ADDRESS, ADDRESS, ulBaseAddress));
+}
+
+/*
+ *    This function checks if change of "display base address" has effective.
+ *    Change of DC base address will not effective until next VSync, SW sets pending bit to 1 during address change.
+ *    HW resets pending bit when it starts to use the new address.
+ *
+ *    Input:
+ *        dispControl        - display control of which display status to be retrieved.
+ *
+ *  Output:
+ *      1   - Display is pending
+ *      0   - Display is not pending
+ */
+long isDisplayBasePending(
+    disp_control_t dispControl
+)
+{
+    unsigned long regFB;
+
+    regFB = (dispControl == CHANNEL0_CTRL) ? FB_ADDRESS : (FB_ADDRESS+CHANNEL_OFFSET);
+
+    if (FIELD_GET(peekRegisterDWord(regFB), FB_ADDRESS, STATUS) == FB_ADDRESS_STATUS_PENDING)
+        return 1;
+
+    return (0);
+}
+
+
+/* 
+ * Program the hardware for a specific video mode
+ *
+ * return:
+ *         0 = success
+ *        -1 = fail.
+ */
+long ddk768_programModeRegisters(
+logicalMode_t *pLogicalMode, 
+mode_parameter_t *pModeParam,   /* mode information about pixel clock, horizontal total, etc. */
+pll_value_t *pPLL               /* Pre-calculated values for the PLL */
+)
+{
+    unsigned long ulTmpValue;
+    unsigned long paletteRam;
+    unsigned long offset, pllReg;
+
+#if 0 // print UHD register setting for debug.
+    if (pLogicalMode->x == 3840)
+        return(printModeRegisters(pLogicalMode, pModeParam, pPLL));
+#endif
+
+    /*  Make sure normal display channel is used, not VGA channel */
+    pokeRegisterDWord(VGA_CONFIGURATION,
+          FIELD_SET(0, VGA_CONFIGURATION, PLL, PANEL)
+        | FIELD_SET(0, VGA_CONFIGURATION, MODE, GRAPHIC));
+
+    offset = (pLogicalMode->dispCtrl==CHANNEL0_CTRL)? 0 : CHANNEL_OFFSET;
+	pllReg = (pLogicalMode->dispCtrl==CHANNEL0_CTRL)? VCLK0_PLL : VCLK1_PLL;
+
+    /* Program PLL */
+    pokeRegisterDWord(pllReg, ddk768_formatPllReg(pPLL));
+    
+#if 0
+    /* Frame buffer base */
+    pokeRegisterDWord((FB_ADDRESS+offset),
+          FIELD_SET(0, FB_ADDRESS, STATUS, PENDING)
+        | FIELD_VALUE(0, FB_ADDRESS, ADDRESS, pLogicalMode->baseAddress));
+
+#endif
+
+
+    /* Pitch value (Hardware people calls it Offset) */
+    pokeRegisterDWord((FB_WIDTH+offset),
+          FIELD_VALUE(0, FB_WIDTH, WIDTH, pLogicalMode->pitch));
+
+    pokeRegisterDWord((HORIZONTAL_TOTAL+offset),
+          FIELD_VALUE(0, HORIZONTAL_TOTAL, TOTAL, pModeParam->horizontal_total - 1)
+        | FIELD_VALUE(0, HORIZONTAL_TOTAL, DISPLAY_END, pModeParam->horizontal_display_end - 1));
+
+    pokeRegisterDWord((HORIZONTAL_SYNC+offset),
+          FIELD_VALUE(0, HORIZONTAL_SYNC, WIDTH, pModeParam->horizontal_sync_width)
+        | FIELD_VALUE(0, HORIZONTAL_SYNC, START, pModeParam->horizontal_sync_start - 1));
+
+    pokeRegisterDWord((VERTICAL_TOTAL+offset),
+          FIELD_VALUE(0, VERTICAL_TOTAL, TOTAL, pModeParam->vertical_total - 1)
+        | FIELD_VALUE(0, VERTICAL_TOTAL, DISPLAY_END, pModeParam->vertical_display_end - 1));
+
+    pokeRegisterDWord((VERTICAL_SYNC+offset),
+          FIELD_VALUE(0, VERTICAL_SYNC, HEIGHT, pModeParam->vertical_sync_height)
+        | FIELD_VALUE(0, VERTICAL_SYNC, START, pModeParam->vertical_sync_start - 1));
+
+
+    
+    unsigned long hdmi_channel = FIELD_GET(peekRegisterDWord(DISPLAY_CTRL+offset),
+                                   DISPLAY_CTRL,
+                                   HDMI_SELECT);    
+
+    /* Set control register value */
+    ulTmpValue =       
+        (pModeParam->vertical_sync_polarity == POS
+        ? FIELD_SET(0, DISPLAY_CTRL, VSYNC_PHASE, ACTIVE_HIGH)
+        : FIELD_SET(0, DISPLAY_CTRL, VSYNC_PHASE, ACTIVE_LOW))
+      | (pModeParam->horizontal_sync_polarity == POS
+        ? FIELD_SET(0, DISPLAY_CTRL, HSYNC_PHASE, ACTIVE_HIGH)
+        : FIELD_SET(0, DISPLAY_CTRL, HSYNC_PHASE, ACTIVE_LOW))
+      | (pModeParam->clock_phase_polarity== POS
+        ? FIELD_SET(0, DISPLAY_CTRL, CLOCK_PHASE, ACTIVE_HIGH)
+        : FIELD_SET(0, DISPLAY_CTRL, CLOCK_PHASE, ACTIVE_LOW))
+      | FIELD_SET(0, DISPLAY_CTRL, DATA_PATH, EXTENDED)
+      | FIELD_SET(0, DISPLAY_CTRL, DIRECTION, INPUT)
+      | FIELD_SET(0, DISPLAY_CTRL, TIMING, ENABLE)
+      | FIELD_SET(0, DISPLAY_CTRL, PLANE, ENABLE) 
+      | (pLogicalMode->bpp == 8
+        ? FIELD_SET(0, DISPLAY_CTRL, FORMAT, 8)
+        : (pLogicalMode->bpp == 16
+        ? FIELD_SET(0, DISPLAY_CTRL, FORMAT, 16)
+        : FIELD_SET(0, DISPLAY_CTRL, FORMAT, 32)));
+
+	
+	if( hdmi_channel == DISPLAY_CTRL_HDMI_SELECT_CHANNEL0)
+		 ulTmpValue= FIELD_SET(ulTmpValue,DISPLAY_CTRL, HDMI_SELECT, CHANNEL0);
+	else
+		 ulTmpValue= FIELD_SET(ulTmpValue,DISPLAY_CTRL, HDMI_SELECT, CHANNEL1);
+
+
+    pokeRegisterDWord((DISPLAY_CTRL+offset), ulTmpValue);
+
+    /* Palette RAM. */
+    paletteRam = PALETTE_RAM + offset;
+    
+    /* Save the current mode param */
+    if (pLogicalMode->dispCtrl == CHANNEL0_CTRL)
+        gChannel0CurrentModeParam = *pModeParam;
+    else
+        gChannel1CurrentModeParam = *pModeParam;
+
+    /* In case of 8-bpp, fill palette */
+    if (pLogicalMode->bpp==8)
+    {
+        /* Start with RGB = 0,0,0. */
+        unsigned char red = 0, green = 0, blue = 0;
+        unsigned long gray = 0;
+        for (offset = 0; offset < 256 * 4; offset += 4)
+        {
+            /* Store current RGB value. */
+            pokeRegisterDWord(paletteRam + offset, gray
+                                ? RGB((gray + 50) / 100,
+                                      (gray + 50) / 100,
+                                      (gray + 50) / 100)
+                                : RGB(red, green, blue));
+
+            if (gray)
+            {
+                /* Walk through grays (40 in total). */
+                gray += 654;
+            }
+
+            else
+            {
+                /* Walk through colors (6 per base color). */
+                if (blue != 255)
+                {
+                    blue += 51;
+                }
+                else if (green != 255)
+                {
+                    blue = 0;
+                    green += 51;
+                }
+                else if (red != 255)
+                {
+                    green = blue = 0;
+                    red += 51;
+                }
+                else
+                {
+                    gray = 1;
+                }
+            }
+        }
+    }
+    /* For 16- and 32-bpp,  fill palette with gamma values. */
+    else
+    {
+        /* Start with RGB = 0,0,0. */
+        ulTmpValue = 0x000000;
+        for (offset = 0; offset < 256 * 4; offset += 4)
+        {
+            pokeRegisterDWord(paletteRam + offset, ulTmpValue);
+
+            /* Advance RGB by 1,1,1. */
+            ulTmpValue += 0x010101;
+        }
+    }
+
+    return 0;
+}
+
+/*
+ * Input:
+ *     1) pLogicalMode contains information such as x, y resolution and bpp.
+ *     2) A user defined parameter table for the mode.
+ *
+ * This function calculate and programs the hardware to set up the
+ * requested mode.
+ *
+ * This function allows the use of user defined parameter table if
+ * predefined Vesa parameter table (gDefaultModeParamTable) does not fit.
+ *
+ * Return: 0 (or NO_ERROR) if mode can be set successfully.
+ *         -1 if any set mode error.
+ */
+long ddk768_setCustomMode(
+    logicalMode_t *pLogicalMode, 
+    mode_parameter_t *pUserModeParam
+)
+{
+    mode_parameter_t pModeParam; /* physical parameters for the mode */
+    pll_value_t pll;
+    unsigned long ulActualPixelClk, ulTemp;
+
+    /*
+     * Minimum check on mode base address.
+     * At least it shouldn't be bigger than the size of frame buffer.
+     */
+    if (ddk768_getFrameBufSize() <= pLogicalMode->baseAddress)
+        return -1;
+
+    /*
+     * Set up PLL, a structure to hold the value to be set in clocks.
+     */
+    pll.inputFreq = DEFAULT_INPUT_CLOCK; /* Defined in CLOCK.H */
+
+
+
+    /* 
+     * Call calcPllValue() to fill up the other fields for PLL structure.
+     * Sometime, the chip cannot set up the exact clock required by User.
+     * Return value from calcPllValue() gives the actual possible pixel clock.
+     */
+    ulActualPixelClk = ddk768_calcPllValue(pUserModeParam->pixel_clock, &pll);
+  
+
+
+
+    /* If calling function don't have a preferred pitch value, 
+       work out a 16 byte aligned pitch value.
+    */
+    if (pLogicalMode->pitch == 0)
+    {
+        /* 
+         * Pitch value calculation in Bytes.
+         * Usually, it is (screen width) * (byte per pixel).
+         * However, there are cases that screen width is not 16 pixel aligned, which is
+         * a requirement for some OS and the hardware itself.
+         * For standard 4:3 resolutions: 320, 640, 800, 1024 and 1280, they are all
+         * 16 pixel aligned and pitch is simply (screen width) * (byte per pixel).
+         *   
+         * However, 1366 resolution, for example, has to be adjusted for 16 pixel aligned.
+         */
+        pLogicalMode->pitch = PITCH(pLogicalMode->x, pLogicalMode->bpp);
+    }
+
+    /* Program the hardware to set up the mode. */
+    return( ddk768_programModeRegisters( 
+            pLogicalMode, 
+            pUserModeParam,
+            &pll));
+}
+
+/*
+ * Input pLogicalMode contains information such as x, y resolution and bpp 
+ * The main difference between setMode and setModeEx userData.
+ *
+ * Return: 0 (or NO_ERROR) if mode can be set successfully.
+ *         -1 if any set mode error.
+ */
+long ddk768_setModeEx(
+    logicalMode_t *pLogicalMode
+)
+{
+    mode_parameter_t *pModeParam;       /* physical parameters for the mode */
+    unsigned short index = 0;
+    userData_t *pUserData;
+
+    /*
+     * Check the validity of the userData pointer and translate the information as necessary
+     */
+    pUserData = (userData_t *)pLogicalMode->userData;
+    if ((pUserData != (userData_t *)0) &&
+        (pUserData->signature == ddk768_getUserDataSignature()) &&
+        (pUserData->size == sizeof(userData_t)))
+    {
+        /* Interpret the userData information */
+        if (pUserData->paramList.size == sizeof(userDataParam_t))
+        {
+            if (pUserData->paramList.modeInfoID == MODE_INFO_INDEX)
+                index = pUserData->paramList.paramInfo.index;
+        }
+    }
+    
+    /* 
+     * Check if we already have physical timing parameter for this mode.
+     */
+    pModeParam = ddk768_findModeParam(pLogicalMode->dispCtrl, pLogicalMode->x, pLogicalMode->y, pLogicalMode->hz, index);
+    if (pModeParam == (mode_parameter_t *)0)
+        return -1;
+
+    return(ddk768_setCustomMode(pLogicalMode, pModeParam));
+}
+
+/*
+ * Input pLogicalMode contains information such as x, y resolution and bpp.
+ * If there is no special parameters, use this function.
+ * If there are special parameters, use setModeEx.
+ *
+ * Return: 0 (or NO_ERROR) if mode can be set successfully.
+ *         -1 if any set mode error.
+ */
+long ddk768_setMode(
+    logicalMode_t *pLogicalMode
+)
+{
+    pLogicalMode->userData = (void *)0;
+
+    /* Call the setModeEx to set the mode. */
+    return ddk768_setModeEx(pLogicalMode);
+}
+
diff --git a/drivers/gpu/drm/smi/ddk768/ddk768_mode.h b/drivers/gpu/drm/smi/ddk768/ddk768_mode.h
new file mode 100644
index 000000000000..1df52dd1ea1b
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk768/ddk768_mode.h
@@ -0,0 +1,380 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2007 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  MODE.H --- SMI DDK 
+*  This file contains the definitions for the mode tables.
+* 
+*******************************************************************/
+#ifndef _DDK768_MODE_H_
+#define _DDK768_MODE_H_
+
+/* Maximum parameters those can be saved in the mode table. */
+#define MAX_MODE_TABLE_ENTRIES              60
+#define PITCH(width, bpp)               (((width) * (bpp) / 8 + 15) & ~15)
+
+/* Set the alignment to 1-bit aligned. Otherwise, the memory compare used in the
+   modeext to compare timing will not work. */
+#pragma pack(1)
+
+typedef enum _spolarity_t
+{
+    POS, /* positive */
+    NEG, /* negative */
+}
+spolarity_t;
+
+typedef struct _mode_parameter_t
+{
+    /* Horizontal timing. */
+    unsigned long horizontal_total;
+    unsigned long horizontal_display_end;
+    unsigned long horizontal_sync_start;
+    unsigned long horizontal_sync_width;
+    spolarity_t horizontal_sync_polarity;
+
+    /* Vertical timing. */
+    unsigned long vertical_total;
+    unsigned long vertical_display_end;
+    unsigned long vertical_sync_start;
+    unsigned long vertical_sync_height;
+    spolarity_t vertical_sync_polarity;
+
+    /* Refresh timing. */
+    unsigned long pixel_clock;
+    unsigned long horizontal_frequency;
+    unsigned long vertical_frequency;
+    
+    /* Clock Phase. This clock phase only applies to Panel. */
+    spolarity_t clock_phase_polarity;
+}
+mode_parameter_t;
+
+typedef enum _disp_control_t
+{
+    CHANNEL0_CTRL = 0,
+    CHANNEL1_CTRL = 1,
+}
+disp_control_t;
+
+typedef struct _logicalMode_t
+{
+    unsigned long x;            /* X resolution */
+    unsigned long y;            /* Y resolution */
+    unsigned long bpp;          /* Bits per pixel */
+    unsigned long hz;           /* Refresh rate */
+
+    unsigned long baseAddress;  /* Offset from beginning of frame buffer.
+                                   It is used to control the starting location of a mode.
+                                   Calling function must initialize this field.
+                                 */
+
+    unsigned long pitch;        /* Mode pitch in byte.
+                                   If initialized to 0, setMode function will set
+                                   up this field.
+                                   If not zero, setMode function will use this value.
+                                 */
+
+    disp_control_t dispCtrl;    /* CHANNEL1 or CHANNEL0 display control channel */
+    
+    /* These two parameters are used in the setModeEx. */
+    unsigned long xLCD;         /* Panel width */
+    unsigned long yLCD;         /* Panel height */
+    
+    void *userData;             /* Not used now, set it to 0 (for future used only) */
+}
+logicalMode_t;
+
+/*
+ * ID of the modeInfoID used in the userDataParam_t
+ */
+#define MODE_INFO_INDEX         0x01
+
+typedef struct _userDataParam_t
+{
+    unsigned long size;         /* Size of this parameter */
+    unsigned char modeInfoID;   /* Mode information ID */
+    
+    /* As the modeInfoID might be expanded in the future to support more stuffs as necessary, 
+       the following parameter list might be expanded in the future. */
+    union
+    {
+        unsigned char index;    /* The index of the mode timing of the given resolution:
+                                        0   - The first mode timing found in the table
+                                        1   - The second mode timing found in the table
+                                        etc...
+                                 */
+        /* Add more user data information parameters here as necessary. */
+    } paramInfo;
+} userDataParam_t;
+
+/* 
+ * Structure that is used as userData pointer in the logicalMode_t 
+ */
+typedef struct _userData_t
+{
+    unsigned long signature;    /* Signature of the userData pointer. 
+                                   It has to be filled with user data Signature to be a valid
+                                   structure pointer. The signature can be obtained by
+                                   calling ddk768_getUserDataSignature function.
+                                 */
+    unsigned long size;         /* Size of this data structure. */
+    userDataParam_t paramList;  /* List of parameters those are associated with this userData 
+                                   Currently, only one modeInfoID is supported. Later on, when
+                                   the ID is expanded, then the paramList might be expanded
+                                   as an array. */
+} 
+userData_t;
+
+/* Restore alignment */
+#pragma pack()
+
+/*
+ *  ddk768_getUserDataSignature
+ *      This function gets the user data mode signature
+ *
+ *  Output:
+ *      The signature to be filled in the user_data_mode_t structure to be considered
+ *      a valid structure.
+ */
+unsigned long ddk768_getUserDataSignature(void);
+
+/*
+ *  compareModeParam
+ *      This function compares two mode parameters
+ *
+ *  Input:
+ *      pModeParam1 - Pointer to the first mode parameter to be compared
+ *      pModeParam2 - Pointer to the second mode parameter to be compared
+ *
+ *  Output:
+ *      0   - Identical mode
+ *     -1   - Mode is not identical
+ */
+long compareModeParam(
+    mode_parameter_t *pModeParam1,
+    mode_parameter_t *pModeParam2
+);
+
+/*
+ *  getDuplicateModeIndex
+ *      This function retrieves the index of dupicate modes, but having different timing.
+ *
+ *  Input:
+ *      dispCtrl    - Display Control where the mode table belongs to.
+ *      pModeParam  - The mode parameters which index to be checked.
+ *
+ *  Output:
+ *      The index of the given parameters among the duplicate modes.
+ *          0 means that the mode param is the first mode encountered in the table
+ *          1 means that the mode param is the second mode encountered in the table
+ *          etc...
+ */
+unsigned short getDuplicateModeIndex(
+    disp_control_t dispCtrl,
+    mode_parameter_t *pModeParam
+);
+
+/*
+ *  ddk768_findModeParamFromTable
+ *      This function locates the requested mode in the given parameter table
+ *
+ *  Input:
+ *      width           - Mode width
+ *      height          - Mode height
+ *      refresh_rate    - Mode refresh rate
+ *      index           - Index that is used for multiple search of the same mode 
+ *                        that have the same width, height, and refresh rate, 
+ *                        but have different timing parameters.
+ *
+ *  Output:
+ *      Success: return a pointer to the mode_parameter_t entry.
+ *      Fail: a NULL pointer.
+ */
+mode_parameter_t *ddk768_findModeParamFromTable(
+    unsigned long width, 
+    unsigned long height, 
+    unsigned long refresh_rate,
+    unsigned short index,
+    mode_parameter_t *pModeTable
+);
+
+/*
+ *  Locate in-stock parameter table for the requested mode.
+ *  Success: return a pointer to the mode_parameter_t entry.
+ *  Fail: a NULL pointer.
+ */
+mode_parameter_t *ddk768_findModeParam(
+    disp_control_t dispCtrl,
+    unsigned long width, 
+    unsigned long height, 
+    unsigned long refresh_rate,
+    unsigned short index
+);
+
+/*
+ *  Use the
+ *  Locate timing parameter for the requested mode from the default mode table.
+ *  Success: return a pointer to the mode_parameter_t entry.
+ *  Fail: a NULL pointer.
+ */
+mode_parameter_t *ddk768_findVesaModeParam(
+    unsigned long width, 
+    unsigned long height, 
+    unsigned long refresh_rate
+);
+
+/*
+ * Return a point to the gDefaultModeParamTable.
+ * Function in other files used this to get the mode table pointer.
+ */
+mode_parameter_t *ddk768_getStockModeParamTable(void);
+
+/*
+ * Return the size of the Stock Mode Param Table
+ */
+unsigned long ddk768_getStockModeParamTableSize(void);
+
+/* 
+ *  ddk768_getStockModeParamTableEx
+ *      This function gets the mode parameters table associated to the
+ *      display control (CHANNEL0_CTRL or SECONDAR_CTRL).
+ *
+ *  Input:
+ *      dispCtrl    - Display Control of the mode table that is associated to.
+ *
+ *  Output:
+ *      Pointer to the mode table
+ */
+mode_parameter_t *ddk768_getStockModeParamTableEx(
+    disp_control_t dispCtrl
+);
+
+/*
+ *  ddk768_getStockModeParamTableSizeEx
+ *      This function gets the size of the mode parameter table associated with
+ *      specific display control
+ *
+ *  Input:
+ *      dispCtrl    - Display control of the mode param table that is associated to.
+ *
+ *  Output:
+ *      Size of the requeted mode param table.
+ */
+unsigned long ddk768_getStockModeParamTableSizeEx(
+    disp_control_t dispCtrl
+);
+
+/* 
+ * This function returns the current mode.
+ */
+mode_parameter_t ddk768_getCurrentModeParam(
+    disp_control_t dispCtrl
+);
+
+/*
+ *  getMaximumModeEntries
+ *      This function gets the maximum entries that can be stored in the mode table.
+ *
+ *  Output:
+ *      Total number of maximum entries
+ */
+unsigned long getMaximumModeEntries(void);
+
+/*
+ *  addTiming
+ *      This function adds the SM750 mode parameter timing to the specified mode table
+ *
+ *  Input:
+ *      dispCtrl        - Display control where the mode will be associated to
+ *      pNewModeList    - Pointer to a list table of SM750 mode parameter to be added 
+ *                        to the current specified display control mode table.
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long addTiming(
+    disp_control_t dispCtrl,
+    mode_parameter_t *pNewModeList,
+    unsigned long totalList,
+    unsigned char clearTable
+);
+
+
+
+/*
+ *    This function sets the display base address
+ *
+ *    Input:
+ *        dispControl        - display control of which base address to be set.
+ *        ulBaseAddress    - Base Address value to be set.
+ */
+void ddk768_setDisplayBaseAddress(
+    disp_control_t dispControl,
+    unsigned long ulBaseAddress
+);
+
+/*
+ *    This function checks if change of "display base address" has effective.
+ *    Change of DC base address will not effective until next VSync, SW sets pending bit to 1 during address change.
+ *    HW resets pending bit when it starts to use the new address.
+ *
+ *    Input:
+ *        dispControl        - display control of which display status to be retrieved.
+ *
+ *  Output:
+ *      1   - Display is pending
+ *      0   - Display is not pending
+ */
+long isDisplayBasePending(
+    disp_control_t dispControl
+);
+
+/*
+ * Input:
+ *     1) pLogicalMode contains information such as x, y resolution and bpp.
+ *     2) A user defined parameter table for the mode.
+ *
+ * This function calculate and programs the hardware to set up the
+ * requested mode.
+ *
+ * This function allows the use of user defined parameter table if
+ * predefined Vesa parameter table (gDefaultModeParamTable) does not fit.
+ *
+ * Return: 0 (or NO_ERROR) if mode can be set successfully.
+ *         -1 if any set mode error.
+ */
+long ddk768_setCustomMode(
+    logicalMode_t *pLogicalMode, 
+    mode_parameter_t *pUserModeParam
+);
+
+/*
+ * Input pLogicalMode contains information such as x, y resolution and bpp 
+ * The main difference between setMode and setModeEx userData.
+ *
+ * Return: 0 (or NO_ERROR) if mode can be set successfully.
+ *         -1 if any set mode error.
+ */
+long ddk768_setModeEx(
+    logicalMode_t *pLogicalMode
+);
+
+/*
+ * Input pLogicalMode contains information such as x, y resolution and bpp.
+ * If there is no special parameters, use this function.
+ * If there are special parameters, use setModeEx.
+ *
+ * Return: 0 (or NO_ERROR) if mode can be set successfully.
+ *         -1 if any set mode error.
+ */
+long ddk768_setMode(
+    logicalMode_t *pLogicalMode
+);
+
+
+#endif /* _MODE_H_ */
diff --git a/drivers/gpu/drm/smi/ddk768/ddk768_power.c b/drivers/gpu/drm/smi/ddk768/ddk768_power.c
new file mode 100644
index 000000000000..023022c99606
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk768/ddk768_power.c
@@ -0,0 +1,269 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2007 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  power.c --- Voyager GX SDK 
+*  This file contains the source code for the power functions.
+* 
+*******************************************************************/
+#include "ddk768_reg.h"
+
+#include "ddk768_chip.h"
+#include "ddk768_power.h"
+
+#include "ddk768_help.h"
+
+
+
+/*
+ *  Enable/disable jpeg decoder 1.
+ */
+void ddk768_enableJPU1(unsigned long enable)
+{
+    unsigned long regValue;
+
+    regValue = peekRegisterDWord(CLOCK_ENABLE);
+    if (enable)
+        regValue = FIELD_SET(regValue, CLOCK_ENABLE, JPU1, ON);
+    else
+        regValue = FIELD_SET(regValue, CLOCK_ENABLE, JPU1, OFF);
+
+    pokeRegisterDWord(CLOCK_ENABLE, regValue);
+}
+
+/* 
+ * This function enable/disable the 2D engine.
+ */
+void ddk768_enable2DEngine(unsigned long enable)
+{
+	unsigned long regValue;
+	
+	regValue = peekRegisterDWord(CLOCK_ENABLE);
+	   if (enable)
+		   regValue = FIELD_SET(regValue, CLOCK_ENABLE, DE, ON);
+	   else
+		   regValue = FIELD_SET(regValue, CLOCK_ENABLE, DE, OFF);
+	
+	pokeRegisterDWord(CLOCK_ENABLE, regValue);
+
+}
+
+/* 
+ * This function enable/disable the ZV Port.
+ */
+void ddk768_enableZVPort(unsigned long enable)
+{
+    unsigned long regValue;
+
+    regValue = peekRegisterDWord(CLOCK_ENABLE);
+	if (enable)
+		regValue = FIELD_SET(regValue, CLOCK_ENABLE, ZV, ON);
+	else
+		regValue = FIELD_SET(regValue, CLOCK_ENABLE, ZV, OFF);
+
+	pokeRegisterDWord(CLOCK_ENABLE, regValue);
+
+}
+
+/* 
+ * This function enable/disable the SSP.
+ */
+void ddk768_enableSSP(unsigned long enable)
+{
+    unsigned long regValue;
+
+    regValue = peekRegisterDWord(CLOCK_ENABLE);
+	if (enable)
+		regValue = FIELD_SET(regValue, CLOCK_ENABLE, SSP, ON);
+	else
+		regValue = FIELD_SET(regValue, CLOCK_ENABLE, SSP, OFF);
+
+	pokeRegisterDWord(CLOCK_ENABLE, regValue);
+
+}
+
+/* 
+ * This function enable/disable the DMA Engine
+ */
+void ddk768_enableDMA(unsigned long enable)
+{
+    unsigned long regValue;
+
+    regValue = peekRegisterDWord(CLOCK_ENABLE);
+	if (enable)
+		regValue = FIELD_SET(regValue, CLOCK_ENABLE, DMA, ON);
+	else
+		regValue = FIELD_SET(regValue, CLOCK_ENABLE, DMA, OFF);
+
+	pokeRegisterDWord(CLOCK_ENABLE, regValue);
+
+}
+
+
+
+/*
+ *  This function enable/disable HDMI
+ */
+void ddk768_enableHDMI(unsigned long enable)
+{
+    unsigned long regValue;
+
+    regValue = peekRegisterDWord(CLOCK_ENABLE);
+	if (enable)
+		regValue = FIELD_SET(regValue, CLOCK_ENABLE, HDMI, ON);
+	else
+		regValue = FIELD_SET(regValue, CLOCK_ENABLE, HDMI, OFF);
+
+	pokeRegisterDWord(CLOCK_ENABLE, regValue);
+}
+
+/*
+ *  Enable/disable USB 2 Host.
+ */
+void ddk768_enableUsbHost(unsigned long enable)
+{
+    unsigned long regValue;
+
+    regValue = peekRegisterDWord(CLOCK_ENABLE);
+	if (enable)
+		regValue = FIELD_SET(regValue, CLOCK_ENABLE, USBH, ON);
+	else
+		regValue = FIELD_SET(regValue, CLOCK_ENABLE, USBH, OFF);
+
+	pokeRegisterDWord(CLOCK_ENABLE, regValue);
+}
+
+/*
+ *  Enable/disable USB 3 device
+ */
+void ddk768_enableUsbDevice(unsigned long enable)
+{
+    unsigned long regValue;
+
+    regValue = peekRegisterDWord(CLOCK_ENABLE);
+	if (enable)
+		regValue = FIELD_SET(regValue, CLOCK_ENABLE, USBS, ON);
+	else
+		regValue = FIELD_SET(regValue, CLOCK_ENABLE, USBS, OFF);
+
+	pokeRegisterDWord(CLOCK_ENABLE, regValue);
+}
+
+/*
+ *  Enable/disable jpeg decoder.
+ */
+void ddk768_enableJPU(unsigned long enable)
+{
+    unsigned long regValue;
+
+    regValue = peekRegisterDWord(CLOCK_ENABLE);
+	if (enable)
+		regValue = FIELD_SET(regValue, CLOCK_ENABLE, JPU, ON);
+	else
+		regValue = FIELD_SET(regValue, CLOCK_ENABLE, JPU, OFF);
+
+	pokeRegisterDWord(CLOCK_ENABLE, regValue);
+}
+
+/*
+ *	Enable/disable H264 video decoder.
+ */ 
+void ddk768_enableVPU(unsigned long enable)
+{
+    unsigned long regValue;
+
+    regValue = peekRegisterDWord(CLOCK_ENABLE);
+	if (enable)
+		regValue = FIELD_SET(regValue, CLOCK_ENABLE, VPU, ON);
+	else
+		regValue = FIELD_SET(regValue, CLOCK_ENABLE, VPU, OFF);
+
+	pokeRegisterDWord(CLOCK_ENABLE, regValue);
+}
+
+
+/*
+ *	Enable/disable UART
+ */ 
+void ddk768_enableUART(unsigned long enable)
+{
+    unsigned long regValue;
+
+    regValue = peekRegisterDWord(CLOCK_ENABLE);
+	if (enable)
+		regValue = FIELD_SET(regValue, CLOCK_ENABLE, UART, ON);
+	else
+		regValue = FIELD_SET(regValue, CLOCK_ENABLE, UART, OFF);
+
+	pokeRegisterDWord(CLOCK_ENABLE, regValue);
+}
+
+/*
+ *	Enable/disable I2S
+ */ 
+void ddk768_enableI2S(unsigned long enable)
+{
+    unsigned long regValue;
+
+    regValue = peekRegisterDWord(CLOCK_ENABLE);
+	if (enable)
+		regValue = FIELD_SET(regValue, CLOCK_ENABLE, I2S, ON);
+	else
+		regValue = FIELD_SET(regValue, CLOCK_ENABLE, I2S, OFF);
+
+	pokeRegisterDWord(CLOCK_ENABLE, regValue);
+}
+
+
+
+/*
+ *	Enable/disable ARM
+ */ 
+void ddk768_enableARM(unsigned long enable)
+{
+    unsigned long regValue;
+
+    regValue = peekRegisterDWord(CLOCK_ENABLE);
+	if (enable)
+		regValue = FIELD_SET(regValue, CLOCK_ENABLE, ARM, ON);
+	else
+		regValue = FIELD_SET(regValue, CLOCK_ENABLE, ARM, OFF);
+
+	pokeRegisterDWord(CLOCK_ENABLE, regValue);
+}
+
+/*
+ *	Enable/disable display control 0
+ */ 
+void ddk768_enableDC0(unsigned long enable)
+{
+    unsigned long regValue;
+
+    regValue = peekRegisterDWord(CLOCK_ENABLE);
+	if (enable)
+		regValue = FIELD_SET(regValue, CLOCK_ENABLE, DC0, ON);
+	else
+		regValue = FIELD_SET(regValue, CLOCK_ENABLE, DC0, OFF);
+
+	pokeRegisterDWord(CLOCK_ENABLE, regValue);
+}
+
+/*
+ *	Enable/disable display control 1
+ */ 
+void ddk768_enableDC1(unsigned long enable)
+{
+    unsigned long regValue;
+
+    regValue = peekRegisterDWord(CLOCK_ENABLE);
+	if (enable)
+		regValue = FIELD_SET(regValue, CLOCK_ENABLE, DC1, ON);
+	else
+		regValue = FIELD_SET(regValue, CLOCK_ENABLE, DC1, OFF);
+
+	pokeRegisterDWord(CLOCK_ENABLE, regValue);
+}
+
diff --git a/drivers/gpu/drm/smi/ddk768/ddk768_power.h b/drivers/gpu/drm/smi/ddk768/ddk768_power.h
new file mode 100644
index 000000000000..d48f7a12bcd0
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk768/ddk768_power.h
@@ -0,0 +1,58 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2007 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  power.h --- Voyager GX SDK 
+*  This file contains the definitions for the power functions.
+* 
+*******************************************************************/
+#ifndef _DDK768_POWER_H_
+#define _DDK768_POWER_H_
+
+/*
+ *  Enable/disable jpeg decoder 1.
+ */
+void ddk768_enableJPU1(unsigned long enable);
+
+
+/* 
+ * This function enable/disable the 2D engine.
+ */
+void ddk768_enable2DEngine(unsigned long enable);
+
+/* 
+ * This function enable/disable the ZV Port 
+ */
+void ddk768_enableZVPort(unsigned long enable);
+
+/* 
+ * This function enable/disable the DMA Engine
+ */
+void ddk768_enableDMA(unsigned long enable);
+
+
+
+/* 
+ * This function enable/disable the PWM Engine
+ */
+void ddk768_enablePWM(unsigned long enable);
+
+/* 
+ * This function enable/disable the SSP.
+ */
+void ddk768_enableSSP(unsigned long enable);
+
+/*
+ * This function enable/disable the HDMI Clock. 
+ */
+void ddk768_enableHDMI(unsigned long enable);
+
+
+void ddk768_enableI2S(unsigned long enable);
+
+
+
+#endif /* _POWER_H_ */
diff --git a/drivers/gpu/drm/smi/ddk768/ddk768_reg.h b/drivers/gpu/drm/smi/ddk768/ddk768_reg.h
new file mode 100644
index 000000000000..ecd3af415dac
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk768/ddk768_reg.h
@@ -0,0 +1,2785 @@
+
+//#include "regsc.h"
+
+#define SCRATCH_PAD0                                0x000060
+
+#define SCRATCH_PAD1                                0x000064
+
+#define CLOCK_ENABLE                                0x000068
+#define CLOCK_ENABLE_JPU1R                          30:30
+#define CLOCK_ENABLE_JPU1R_NORMAL                   0
+#define CLOCK_ENABLE_JPU1R_RESET                    1
+#define CLOCK_ENABLE_HDMIR                          29:29
+#define CLOCK_ENABLE_HDMIR_NORMAL                   0
+#define CLOCK_ENABLE_HDMIR_RESET                    1
+#define CLOCK_ENABLE_USBHR                          28:28
+#define CLOCK_ENABLE_USBHR_NORMAL                   0
+#define CLOCK_ENABLE_USBHR_RESET                    1
+#define CLOCK_ENABLE_USBSR                          27:27
+#define CLOCK_ENABLE_USBSR_NORMAL                   0
+#define CLOCK_ENABLE_USBSR_RESET                    1
+#define CLOCK_ENABLE_ZVR                            26:26
+#define CLOCK_ENABLE_ZVR_NORMAL                     0
+#define CLOCK_ENABLE_ZVR_RESET                      1
+#define CLOCK_ENABLE_JPUR                           25:25
+#define CLOCK_ENABLE_JPUR_NORMAL                    0
+#define CLOCK_ENABLE_JPUR_RESET                     1
+#define CLOCK_ENABLE_VPUR                           24:24
+#define CLOCK_ENABLE_VPUR_NORMAL                    0
+#define CLOCK_ENABLE_VPUR_RESET                     1
+#define CLOCK_ENABLE_DER                            23:23
+#define CLOCK_ENABLE_DER_NORMAL                     0
+#define CLOCK_ENABLE_DER_RESET                      1
+#define CLOCK_ENABLE_DMAR                           22:22
+#define CLOCK_ENABLE_DMAR_NORMAL                    0
+#define CLOCK_ENABLE_DMAR_RESET                     1
+#define CLOCK_ENABLE_DC1R                           18:18
+#define CLOCK_ENABLE_DC1R_NORMAL                    0
+#define CLOCK_ENABLE_DC1R_RESET                     1
+#define CLOCK_ENABLE_DC0R                           17:17
+#define CLOCK_ENABLE_DC0R_NORMAL                    0
+#define CLOCK_ENABLE_DC0R_RESET                     1
+#define CLOCK_ENABLE_ARMR                           16:16
+#define CLOCK_ENABLE_ARMR_NORMAL                    0
+#define CLOCK_ENABLE_ARMR_RESET                     1
+#define CLOCK_ENABLE_JPU1                           14:14
+#define CLOCK_ENABLE_JPU1_OFF                       0
+#define CLOCK_ENABLE_JPU1_ON                        1
+#define CLOCK_ENABLE_HDMI                           13:13
+#define CLOCK_ENABLE_HDMI_OFF                       0 
+#define CLOCK_ENABLE_HDMI_ON                        1
+#define CLOCK_ENABLE_USBH                           12:12
+#define CLOCK_ENABLE_USBH_OFF                       0
+#define CLOCK_ENABLE_USBH_ON                        1
+#define CLOCK_ENABLE_USBS                           11:11
+#define CLOCK_ENABLE_USBS_OFF                       0
+#define CLOCK_ENABLE_USBS_ON                        1
+#define CLOCK_ENABLE_ZV                             10:10
+#define CLOCK_ENABLE_ZV_OFF                         0
+#define CLOCK_ENABLE_ZV_ON                          1
+#define CLOCK_ENABLE_JPU                            9:9
+#define CLOCK_ENABLE_JPU_OFF                        0
+#define CLOCK_ENABLE_JPU_ON                         1
+#define CLOCK_ENABLE_VPU                            8:8
+#define CLOCK_ENABLE_VPU_OFF                        0
+#define CLOCK_ENABLE_VPU_ON                         1
+#define CLOCK_ENABLE_DE                             7:7
+#define CLOCK_ENABLE_DE_OFF                         0
+#define CLOCK_ENABLE_DE_ON                          1
+#define CLOCK_ENABLE_DMA                            6:6
+#define CLOCK_ENABLE_DMA_OFF                        0
+#define CLOCK_ENABLE_DMA_ON                         1
+#define CLOCK_ENABLE_UART                           5:5
+#define CLOCK_ENABLE_UART_OFF                       0
+#define CLOCK_ENABLE_UART_ON                        1
+#define CLOCK_ENABLE_I2S                            4:4
+#define CLOCK_ENABLE_I2S_OFF                        0
+#define CLOCK_ENABLE_I2S_ON                         1
+#define CLOCK_ENABLE_SSP                            3:3
+#define CLOCK_ENABLE_SSP_OFF                        0
+#define CLOCK_ENABLE_SSP_ON                         1
+#define CLOCK_ENABLE_DC1                            2:2
+#define CLOCK_ENABLE_DC1_OFF                        0
+#define CLOCK_ENABLE_DC1_ON                         1
+#define CLOCK_ENABLE_DC0                            1:1
+#define CLOCK_ENABLE_DC0_OFF                        0
+#define CLOCK_ENABLE_DC0_ON                         1
+#define CLOCK_ENABLE_ARM                            0:0
+#define CLOCK_ENABLE_ARM_OFF                        0
+#define CLOCK_ENABLE_ARM_ON                         1
+
+/* No bit fields for VGA PLL since DDK don't use it */
+#define VGA25PLL                                    0x00006C
+#define VGA28PLL                                    0x000070
+
+
+/* Master clock for DDR and core */
+#define MCLK_PLL                                     0x000074
+#define MCLK_PLL_VCO                                23:22
+#define MCLK_PLL_INT                                21:16
+#define MCLK_PLL_POWER                                0:0
+#define MCLK_PLL_POWER_NORMAL                        0
+#define MCLK_PLL_POWER_DOWN                            1
+
+/* Video clock 0  */
+#define VCLK0_PLL                                      0x000078
+/* VCLK Definition for FPGA */
+#define VCLK0_PLL_FREQ                                 4:0
+#define VCLK0_PLL_FREQ_25MHZ                           0
+#define VCLK0_PLL_FREQ_40MHZ                           1
+#define VCLK0_PLL_FREQ_65MHZ                           3
+#define VCLK0_PLL_FREQ_74MHZ                           4
+#define VCLK0_PLL_FREQ_80MHZ                           5
+#define VCLK0_PLL_FREQ_108MHZ                          6
+
+/* VCLK Definition for ASIC */
+#define VCLK_PLL_SSCG                                30:30
+#define VCLK_PLL_SSC                                29:28
+#define VCLK_PLL_FN                                    27:27
+#define VCLK_PLL_FN_INT_MODE                            0
+#define VCLK_PLL_FN_FRAC_MODE                            1
+#define VCLK_PLL_BS                                    26:25
+#define VCLK_PLL_VCO                                24:22
+#define VCLK_PLL_INT                                21:16
+#define VCLK_PLL_FRAC                                15:1
+#define VCLK_PLL_POWER                                0:0
+#define VCLK_PLL_POWER_NORMAL                        0
+#define VCLK_PLL_POWER_DOWN                            1
+
+/* Video clock 1. Bit field definiton is same as VCLK0 */
+#define VCLK1_PLL                                      0x00007C
+
+#define PROTOCOL_SEMAPHORE0                            0x000080
+#define PROTOCOL_SEMAPHORE1                            0x000084
+
+
+#define VGA_CONFIGURATION                          	0x000088
+#define VGA_CONFIGURATION_PLL                      	2:2
+#define VGA_CONFIGURATION_PLL_VGA                  	0
+#define VGA_CONFIGURATION_PLL_PANEL                	1
+#define VGA_CONFIGURATION_MODE                     	1:1
+#define VGA_CONFIGURATION_MODE_TEXT                	0
+#define VGA_CONFIGURATION_MODE_GRAPHIC             	1
+#define VGA_CONFIGURATION_PREFETCH                 	0:0
+#define VGA_CONFIGURATION_PREFETCH_DISABLE         	0
+#define VGA_CONFIGURATION_PREFETCH_ENABLE          	1
+
+/* Lock or unlock PCIE bar 2 to 5 */
+#define PCIE_BAR									0x00008C
+#define PCIE_BAR_LOCK								0:0
+#define PCIE_BAR_LOCK_UNLOCK						0
+#define PCIE_BAR_LOCK_LOCK							1
+
+
+#define RAW_INT                                    0x000090
+#define RAW_INT_CSC                                5:5
+#define RAW_INT_CSC_INACTIVE                       0
+#define RAW_INT_CSC_ACTIVE                         1
+#define RAW_INT_CSC_CLEAR                          1
+#define RAW_INT_DE                                 4:4
+#define RAW_INT_DE_INACTIVE                        0
+#define RAW_INT_DE_ACTIVE                          1
+#define RAW_INT_DE_CLEAR                           1
+#define RAW_INT_ZVPORT_VSYNC                       3:3
+#define RAW_INT_ZVPORT_VSYNC_INACTIVE              0
+#define RAW_INT_ZVPORT_VSYNC_ACTIVE                1
+#define RAW_INT_ZVPORT_VSYNC_CLEAR                 1
+#define RAW_INT_CHANNEL1_VSYNC                     2:2
+#define RAW_INT_CHANNEL1_VSYNC_INACTIVE            0
+#define RAW_INT_CHANNEL1_VSYNC_ACTIVE              1
+#define RAW_INT_CHANNEL1_VSYNC_CLEAR               1
+#define RAW_INT_CHANNEL0_VSYNC                     1:1
+#define RAW_INT_CHANNEL0_VSYNC_INACTIVE            0
+#define RAW_INT_CHANNEL0_VSYNC_ACTIVE              1
+#define RAW_INT_CHANNEL0_VSYNC_CLEAR               1
+#define RAW_INT_VGA_VSYNC                          0:0
+#define RAW_INT_VGA_VSYNC_INACTIVE                 0
+#define RAW_INT_VGA_VSYNC_ACTIVE                   1
+#define RAW_INT_VGA_VSYNC_CLEAR                    1
+
+#ifdef SMI_ARM
+#define INT_STATUS                                 0x0000A8
+#else
+#define INT_STATUS                                 0x000094
+#endif
+#define INT_STATUS_TIMER3                          31:31
+#define INT_STATUS_TIMER3_INACTIVE                 0
+#define INT_STATUS_TIMER3_ACTIVE                   1
+#define INT_STATUS_TIMER2                          30:30
+#define INT_STATUS_TIMER2_INACTIVE                 0
+#define INT_STATUS_TIMER2_ACTIVE                   1
+#define INT_STATUS_TIMER1                          29:29
+#define INT_STATUS_TIMER1_INACTIVE                 0
+#define INT_STATUS_TIMER1_ACTIVE                   1
+#define INT_STATUS_TIMER0                          28:28
+#define INT_STATUS_TIMER0_INACTIVE                 0
+#define INT_STATUS_TIMER0_ACTIVE                   1
+#define INT_STATUS_VPU                             27:27
+#define INT_STATUS_VPU_INACTIVE                    0
+#define INT_STATUS_VPU_ACTIVE                      1
+#define INT_STATUS_JPU                             26:26
+#define INT_STATUS_JPU_INACTIVE                    0
+#define INT_STATUS_JPU_ACTIVE                      1
+#define INT_STATUS_USBH                            25:25
+#define INT_STATUS_USBH_INACTIVE                   0
+#define INT_STATUS_USBH_ACTIVE                     1
+#define INT_STATUS_USBS                            24:24
+#define INT_STATUS_USBS_INACTIVE                   0
+#define INT_STATUS_USBS_ACTIVE                     1
+#define INT_STATUS_I2S                             23:23
+#define INT_STATUS_I2S_INACTIVE                    0
+#define INT_STATUS_I2S_ACTIVE                      1
+#define INT_STATUS_UART1                           22:22
+#define INT_STATUS_UART1_INACTIVE                  0
+#define INT_STATUS_UART1_ACTIVE                    1
+#define INT_STATUS_UART0                           21:21
+#define INT_STATUS_UART0_INACTIVE                  0
+#define INT_STATUS_UART0_ACTIVE                    1 
+#define INT_STATUS_SSP1                            20:20
+#define INT_STATUS_SSP1_INACTIVE                   0
+#define INT_STATUS_SSP1_ACTIVE                     1
+#define INT_STATUS_SSP0                            19:19
+#define INT_STATUS_SSP0_INACTIVE                   0
+#define INT_STATUS_SSP0_ACTIVE                     1
+#define INT_STATUS_I2C1                            18:18
+#define INT_STATUS_I2C1_INACTIVE                   0
+#define INT_STATUS_I2C1_ACTIVE                     1
+#define INT_STATUS_I2C0                            17:17
+#define INT_STATUS_I2C0_INACTIVE                   0
+#define INT_STATUS_I2C0_ACTIVE                     1
+#define INT_STATUS_PWM                             16:16
+#define INT_STATUS_PWM_INACTIVE                    0
+#define INT_STATUS_PWM_ACTIVE                      1 
+#define INT_STATUS_GPIO6                           15:15
+#define INT_STATUS_GPIO6_INACTIVE                  0
+#define INT_STATUS_GPIO6_ACTIVE                    1
+#define INT_STATUS_GPIO5                           14:14
+#define INT_STATUS_GPIO5_INACTIVE                  0
+#define INT_STATUS_GPIO5_ACTIVE                    1
+#define INT_STATUS_GPIO4                           13:13
+#define INT_STATUS_GPIO4_INACTIVE                  0
+#define INT_STATUS_GPIO4_ACTIVE                    1
+#define INT_STATUS_GPIO3                           12:12
+#define INT_STATUS_GPIO3_INACTIVE                  0
+#define INT_STATUS_GPIO3_ACTIVE                    1
+#define INT_STATUS_GPIO2                           11:11
+#define INT_STATUS_GPIO2_INACTIVE                  0
+#define INT_STATUS_GPIO2_ACTIVE                    1
+#define INT_STATUS_GPIO1                           10:10
+#define INT_STATUS_GPIO1_INACTIVE                  0
+#define INT_STATUS_GPIO1_ACTIVE                    1
+#define INT_STATUS_GPIO0                           9:9
+#define INT_STATUS_GPIO0_INACTIVE                  0
+#define INT_STATUS_GPIO0_ACTIVE                    1
+#define INT_STATUS_DMA                             8:8
+#define INT_STATUS_DMA_INACTIVE                    0
+#define INT_STATUS_DMA_ACTIVE                      1
+#define INT_STATUS_PCI                             7:7
+#define INT_STATUS_PCI_INACTIVE                    0
+#define INT_STATUS_PCI_ACTIVE                      1
+#define INT_STATUS_HDMI							   6:6
+#define INT_STATUS_HDMI_INACTIVE				   0
+#define INT_STATUS_HDMI_ACTIVE					   1
+#define INT_STATUS_CSC                             5:5
+#define INT_STATUS_CSC_INACTIVE                    0
+#define INT_STATUS_CSC_ACTIVE                      1
+#define INT_STATUS_DE                              4:4
+#define INT_STATUS_DE_INACTIVE                     0
+#define INT_STATUS_DE_ACTIVE                       1
+#define INT_STATUS_ZVPORT_VSYNC                    3:3
+#define INT_STATUS_ZVPORT_VSYNC_INACTIVE           0
+#define INT_STATUS_ZVPORT_VSYNC_ACTIVE             1
+#define INT_STATUS_CHANNEL1_VSYNC                  2:2
+#define INT_STATUS_CHANNEL1_VSYNC_INACTIVE         0
+#define INT_STATUS_CHANNEL1_VSYNC_ACTIVE           1
+#define INT_STATUS_CHANNEL0_VSYNC                  1:1
+#define INT_STATUS_CHANNEL0_VSYNC_INACTIVE         0
+#define INT_STATUS_CHANNEL0_VSYNC_ACTIVE           1
+#define INT_STATUS_VGA_VSYNC                       0:0
+#define INT_STATUS_VGA_VSYNC_INACTIVE              0
+#define INT_STATUS_VGA_VSYNC_ACTIVE                1
+
+#ifdef SMI_ARM
+#define INT_MASK                                   0x00009C
+#else
+#define INT_MASK                                   0x000098
+#endif
+
+#define INT_MASK_TIMER3                            31:31
+#define INT_MASK_TIMER3_DISABLE                    0
+#define INT_MASK_TIMER3_ENABLE                     1
+#define INT_MASK_TIMER2                            30:30
+#define INT_MASK_TIMER2_DISABLE                    0
+#define INT_MASK_TIMER2_ENABLE                     1
+#define INT_MASK_TIMER1                            29:29
+#define INT_MASK_TIMER1_DISABLE                    0
+#define INT_MASK_TIMER1_ENABLE                     1
+#define INT_MASK_TIMER0                            28:28
+#define INT_MASK_TIMER0_DISABLE                    0
+#define INT_MASK_TIMER0_ENABLE                     1
+#define INT_MASK_VPU                               27:27
+#define INT_MASK_VPU_DISABLE                       0
+#define INT_MASK_VPU_ENABLE                        1
+#define INT_MASK_JPU                               26:26
+#define INT_MASK_JPU_DISABLE                       0
+#define INT_MASK_JPU_ENABLE                        1
+#define INT_MASK_USBH                              25:25
+#define INT_MASK_USBH_DISABLE                      0
+#define INT_MASK_USBH_ENABLE                       1
+#define INT_MASK_USBS                              24:24
+#define INT_MASK_USBS_DISABLE                      0
+#define INT_MASK_USBS_ENABLE                       1
+#define INT_MASK_I2S                               23:23
+#define INT_MASK_I2S_DISABLE                       0
+#define INT_MASK_I2S_ENABLE                        1
+#define INT_MASK_UART1                             22:22
+#define INT_MASK_UART1_DISABLE                     0
+#define INT_MASK_UART1_ENABLE                      1
+#define INT_MASK_UART0                             21:21
+#define INT_MASK_UART0_DISABLE                     0
+#define INT_MASK_UART0_ENABLE                      1 
+#define INT_MASK_SSP1                              20:20
+#define INT_MASK_SSP1_DISABLE                      0
+#define INT_MASK_SSP1_ENABLE                       1
+#define INT_MASK_SSP0                              19:19
+#define INT_MASK_SSP0_DISABLE                      0
+#define INT_MASK_SSP0_ENABLE                       1
+#define INT_MASK_I2C1                              18:18
+#define INT_MASK_I2C1_DISABLE                      0
+#define INT_MASK_I2C1_ENABLE                       1
+#define INT_MASK_I2C0                              17:17
+#define INT_MASK_I2C0_DISABLE                      0
+#define INT_MASK_I2C0_ENABLE                       1
+#define INT_MASK_PWM                               16:16
+#define INT_MASK_PWM_DISABLE                       0
+#define INT_MASK_PWM_ENABLE                        1 
+#define INT_MASK_GPIO6                             15:15
+#define INT_MASK_GPIO6_DISABLE                     0
+#define INT_MASK_GPIO6_ENABLE                      1
+#define INT_MASK_GPIO5                             14:14
+#define INT_MASK_GPIO5_DISABLE                     0
+#define INT_MASK_GPIO5_ENABLE                      1
+#define INT_MASK_GPIO4                             13:13
+#define INT_MASK_GPIO4_DISABLE                     0
+#define INT_MASK_GPIO4_ENABLE                      1
+#define INT_MASK_GPIO3                             12:12
+#define INT_MASK_GPIO3_DISABLE                     0
+#define INT_MASK_GPIO3_ENABLE                      1
+#define INT_MASK_GPIO2                             11:11
+#define INT_MASK_GPIO2_DISABLE                     0
+#define INT_MASK_GPIO2_ENABLE                      1
+#define INT_MASK_GPIO1                             10:10
+#define INT_MASK_GPIO1_DISABLE                     0
+#define INT_MASK_GPIO1_ENABLE                      1
+#define INT_MASK_GPIO0                             9:9
+#define INT_MASK_GPIO0_DISABLE                     0
+#define INT_MASK_GPIO0_ENABLE                      1
+#define INT_MASK_DMA                               8:8
+#define INT_MASK_DMA_DISABLE                       0
+#define INT_MASK_DMA_ENABLE                        1
+#define INT_MASK_CPU                               7:7
+#define INT_MASK_CPU_DISABLE                       0
+#define INT_MASK_CPU_ENABLE                        1
+#define INT_MASK_HDMI							   6:6
+#define INT_MASK_HDMI_DISABLE					   0
+#define INT_MASK_HDMI_ENABLE					   1
+#define INT_MASK_CSC                               5:5
+#define INT_MASK_CSC_DISABLE                       0
+#define INT_MASK_CSC_ENABLE                        1
+#define INT_MASK_DE                                4:4
+#define INT_MASK_DE_DISABLE                        0
+#define INT_MASK_DE_ENABLE                         1
+#define INT_MASK_ZVPORT_VSYNC                      3:3
+#define INT_MASK_ZVPORT_VSYNC_DISABLE              0
+#define INT_MASK_ZVPORT_VSYNC_ENABLE               1
+#define INT_MASK_CHANNEL1_VSYNC                    2:2
+#define INT_MASK_CHANNEL1_VSYNC_DISABLE            0
+#define INT_MASK_CHANNEL1_VSYNC_ENABLE             1
+#define INT_MASK_CHANNEL0_VSYNC                    1:1
+#define INT_MASK_CHANNEL0_VSYNC_DISABLE            0
+#define INT_MASK_CHANNEL0_VSYNC_ENABLE             1
+#define INT_MASK_VGA_VSYNC                         0:0
+#define INT_MASK_VGA_VSYNC_DISABLE                 0
+#define INT_MASK_VGA_VSYNC_ENABLE                  1
+
+#define ARM_PROTOCOL_INT                           	0x0000A0
+#define ARM_PROTOCOL_INT_TOKEN						31:1
+#define ARM_PROTOCOL_INT_ENABLE						0:0
+#define ARM_PROTOCOL_INT_ENABLE_CLEAR				0
+#define ARM_PROTOCOL_INT_ENABLE_ENABLE				1
+
+#define PCIE_PROTOCOL_INT                          	0x0000A4
+#define PCIE_PROTOCOL_INT_TOKEN						31:1
+#define PCIE_PROTOCOL_INT_ENABLE					0:0
+#define PCIE_PROTOCOL_INT_ENABLE_CLEAR				0
+#define PCIE_PROTOCOL_INT_ENABLE_ENABLE				1
+
+#define ARM_STARTUP_CONFIG	                        0x000100
+#define ARM_STARTUP_CONFIG_USBH						30:30
+#define ARM_STARTUP_CONFIG_USBH_NORMAL				0
+#define ARM_STARTUP_CONFIG_USBH_RESET				1
+#define ARM_STARTUP_CONFIG_USBHPHY					29:29
+#define ARM_STARTUP_CONFIG_USBHPHY_NORMAL			0
+#define ARM_STARTUP_CONFIG_USBHPHY_RESET			1
+#define ARM_STARTUP_CONFIG_USBSPHY					28:28
+#define ARM_STARTUP_CONFIG_USBSPHY_NORMAL			0
+#define ARM_STARTUP_CONFIG_USBSPHY_RESET			1
+#define ARM_STARTUP_CONFIG_USBS						27:27
+#define ARM_STARTUP_CONFIG_USBS_NORMAL				0
+#define ARM_STARTUP_CONFIG_USBS_RESET				1
+#define ARM_STARTUP_CONFIG_ARM						0:0
+#define ARM_STARTUP_CONFIG_ARM_STOP					0
+#define ARM_STARTUP_CONFIG_ARM_START				1
+
+#define ARM_CONTROL                          		0x000110
+#define ARM_CONTROL_RESET							0:0
+#define ARM_CONTROL_RESET_RESET						0
+#define ARM_CONTROL_RESET_NORMAL					1
+
+/* DDK shoudn't need to program this register */
+#define USBH_HOST_CLOCK                                0x000114
+
+#define TEST_CONTROL                                0x00011C
+#define TEST_CONTROL_I2C                            11:11
+#define TEST_CONTROL_I2C_I2C1                        0
+#define TEST_CONTROL_I2C_HDMI                        1
+#define TEST_CONTROL_SSP1                            10:10
+#define TEST_CONTROL_SSP1_GPIO                        0
+#define TEST_CONTROL_SSP1_USBSPHY                    1
+
+
+#define STRAP_PINS                                    0x00012C
+#define STRAP_PINS_15_2                                15:2
+#define STRAP_PINS_MEM_SIZE                         1:0
+#define STRAP_PINS_MEM_SIZE_128M                    0
+#define STRAP_PINS_MEM_SIZE_256M                    1
+#define STRAP_PINS_MEM_SIZE_512M                    2
+#define STRAP_PINS_MEM_SIZE_1024M                   3
+
+
+#define DDR_CONTROL                                  0x000130
+#define DDR_CONTROL_COL                              3:2
+#define DDR_CONTROL_COL_1024                         0   
+#define DDR_CONTROL_COL_2048                         1
+#define DDR_CONTROL_COL_256                          2
+#define DDR_CONTROL_COL_512                          3
+#define DDR_CONTROL_SIZE                             1:0   
+#define DDR_CONTROL_SIZE_256M                        0
+#define DDR_CONTROL_SIZE_512M                        1
+#define DDR_CONTROL_SIZE_1024M                       2   
+#define DDR_CONTROL_SIZE_128M                        3
+
+#define JPU_PERFORMANCE_MODE                         0x000134
+#define JPU_PERFORMANCE_MODE_JPU1                    3:2
+#define JPU_PERFORMANCE_MODE_JPU1_DISABLE            0
+#define JPU_PERFORMANCE_MODE_JPU1_HD                 1
+#define JPU_PERFORMANCE_MODE_JPU1_UHD                2
+#define JPU_PERFORMANCE_MODE_JPU0                    1:0
+#define JPU_PERFORMANCE_MODE_JPU0_DISABLE	     0
+#define JPU_PERFORMANCE_MODE_JPU0_HD                 1
+#define JPU_PERFORMANCE_MODE_JPU0_UHD                2
+
+#define DDR_PRIORITY1                                0x000138
+
+#define DDR_PRIORITY2                                0x00013C
+
+
+//#include "reggpio.h"
+
+
+
+#define GPIO_DATA                                       0x010000
+#define GPIO_DATA_IIC0_DATA_DVI_SHIFT                     31
+#define GPIO_DATA_IIC0_CLK_DVI_SHIFT                        30
+#define GPIO_DATA_SSP1_CLK_OUT_SHIFT                      29
+#define GPIO_DATA_GPIO_CODEC_DATA_SHIFT               29
+#define GPIO_DATA_SSP1_FRAMEINPUT_SHIFT                          28
+#define GPIO_DATA_IIS_RX_SHIFT                                   28
+#define GPIO_DATA_SSP1_FRAMEOUT_SHIFT                   27
+#define GPIO_DATA_GPIO_IIS_TX_SHIFT                         27
+#define GPIO_DATA_SSP1_RX_SHIFT                          26
+#define GPIO_DATA_GPIO_IIS_WS_SHIFT                        26
+#define GPIO_DATA_SSP1_TX_SHIFT                   25
+#define GPIO_DATA_GPIO_IIS_CLK_SHIFT                       25
+#define GPIO_DATA_SSP0_CLK_OUT_SHIFT                     24
+#define GPIO_DATA_GPIO_SWSSP_CLK_OUT_SHIFT                     24
+#define GPIO_DATA_SSP0_FRAMINPUT_SHIFT                 23
+#define GPIO_DATA_GPIO_SWSSP_FRAMINPUT_SHIFT                 23
+#define GPIO_DATA_SSP0_FRAMEOUT_SHIFT                  22
+#define GPIO_DATA_GPIO_SWSSP_FRAMEOUT_SHIFT                  22
+#define GPIO_DATA_SSP0_RX_SHIFT                               21
+#define GPIO_DATA_GPIO_SWSSP_RX_SHIFT                               21
+#define GPIO_DATA_SSP0_TX_SHIFT                               20
+#define GPIO_DATA_GPIO_SWSSP_TX_SHIFT                               20
+#define GPIO_DATA_PWM2_SHIFT                                   19
+#define GPIO_DATA_GPIO_UART1_EXT_CLK_SHIFT        19
+#define GPIO_DATA_GPIO_UART0_EXT_CLK_SHIFT        19
+#define GPIO_DATA_PWM1_SHIFT                                   18
+#define GPIO_DATA_PWM0_SHIFT                                   17
+#define GPIO_DATA_PCIE_SHIFT                                     16
+#define GPIO_DATA_UART0_SIN_SHIFT                          15
+#define GPIO_DATA_UART0_NCTSIN_SHIFT                   14
+#define GPIO_DATA_UART0_TXD_SHIFT                         13
+#define GPIO_DATA_UART0_NRTS_SHIFT                       12
+#define GPIO_DATA_UART1_SIN_SHIFT                         11
+#define GPIO_DATA_GPIO_CODEC_CLK_SHIFT               11
+#define GPIO_DATA_UART1_NCTSIN_SHIFT                   10
+#define GPIO_DATA_GPIO_CODEC_MODE_SHIFT            10
+#define GPIO_DATA_UART1_TXD_SHIFT                         9
+#define GPIO_DATA_GPIO_IIC_DATA_HDMI_SHIFT       9
+#define GPIO_DATA_GPIO_IIC_CLK_HDMI_SHIFT          8
+#define GPIO_DATA_UART1_NRTS_SHIFT                       8
+#define GPIO_DATA_IIC1_DATA_CRT_SHIFT                  7
+#define GPIO_DATA_IIC1_CLK_CRT_SHIFT                     6
+#define GPIO_DATA_GPIO_VBUS_SHIFT                         5
+#define GPIO_DATA_IIS_TX_SELECT_SHIFT                   4
+#define GPIO_DATA_GPIO_DVI_PNP_SHIFT                   4
+#define GPIO_DATA_IIS_WS_SELECT_SHIFT                 3
+#define GPIO_DATA_GPIO_AUDIO_PNP_SHIFT              3
+#define GPIO_DATA_IIS_CLK_SELECT_SHIFT                2
+#define GPIO_DATA_UART1_EXT_CLK_SELECT_SHIFT   1
+#define GPIO_DATA_GPIO_HDMI_PNP_SHIFT                1
+#define GPIO_DATA_UART0_EXT_CLK_SELECT_SHIFT   0
+
+#define GPIO_DATA_DIRECTION                             0x010004
+#define GPIO_DATA_DIRECTION_IIC0_DATA_DVI_SHIFT                     31
+#define GPIO_DATA_DIRECTION_IIC0_CLK_DVI_SHIFT                        30
+#define GPIO_DATA_DIRECTION_SSP1_CLK_OUT_SHIFT                      29
+#define GPIO_DATA_DIRECTION_GPIO_CODEC_DATA_SHIFT               29
+#define GPIO_DATA_DIRECTION_SSP1_FRAMEINPUT_SHIFT                          28
+#define GPIO_DATA_DIRECTION_IIS_RX_SHIFT                                   28
+#define GPIO_DATA_DIRECTION_SSP1_FRAMEOUT_SHIFT                   27
+#define GPIO_DATA_DIRECTION_GPIO_IIS_TX_SHIFT                         27
+#define GPIO_DATA_DIRECTION_SSP1_RX_SHIFT                          26
+#define GPIO_DATA_DIRECTION_GPIO_IIS_WS_SHIFT                        26
+#define GPIO_DATA_DIRECTION_SSP1_TX_SHIFT                   25
+#define GPIO_DATA_DIRECTION_GPIO_IIS_CLK_SHIFT                       25
+#define GPIO_DATA_DIRECTION_SSP0_CLK_OUT_SHIFT                     24
+#define GPIO_DATA_DIRECTION_GPIO_SWSSP_CLK_OUT_SHIFT                     24
+#define GPIO_DATA_DIRECTION_SSP0_FRAMEINPUT_SHIFT                         23
+#define GPIO_DATA_DIRECTION_GPIO_SWSSP_FRAMEINPUT_SHIFT                         23
+#define GPIO_DATA_DIRECTION_SSP0_FRAMEOUT_SHIFT                  22
+#define GPIO_DATA_DIRECTION_GPIO_SWSSP_FRAMEOUT_SHIFT                  22
+#define GPIO_DATA_DIRECTION_SSP0_RX_SHIFT                         21
+#define GPIO_DATA_DIRECTION_GPIO_SWSSP_RX_SHIFT                         21
+#define GPIO_DATA_DIRECTION_SSP0_TX_SHIFT                  20
+#define GPIO_DATA_DIRECTION_GPIO_SWSSP_TX_SHIFT                  20
+#define GPIO_DATA_DIRECTION_PWM2_SHIFT                                   19
+#define GPIO_DATA_DIRECTION_GPIO_UART1_EXT_CLK_SHIFT        19
+#define GPIO_DATA_DIRECTION_GPIO_UART0_EXT_CLK_SHIFT        19
+#define GPIO_DATA_DIRECTION_PWM1_SHIFT                                   18
+#define GPIO_DATA_DIRECTION_PWM0_SHIFT                                   17
+#define GPIO_DATA_DIRECTION_PCIE_SHIFT                                     16
+#define GPIO_DATA_DIRECTION_UART0_SIN_SHIFT                          15
+#define GPIO_DATA_DIRECTION_UART0_NCTSIN_SHIFT                   14
+#define GPIO_DATA_DIRECTION_UART0_TXD_SHIFT                         13
+#define GPIO_DATA_DIRECTION_UART0_NRTS_SHIFT                       12
+#define GPIO_DATA_DIRECTION_UART1_SIN_SHIFT                         11
+#define GPIO_DATA_DIRECTION_GPIO_CODEC_CLK_SHIFT               11
+#define GPIO_DATA_DIRECTION_UART1_NCTSIN_SHIFT                   10
+#define GPIO_DATA_DIRECTION_GPIO_CODEC_MODE_SHIFT            10
+#define GPIO_DATA_DIRECTION_UART1_TXD_SHIFT                         9
+#define GPIO_DATA_DIRECTION_GPIO_IIC_DATA_HDMI_SHIFT       9
+#define GPIO_DATA_DIRECTION_GPIO_IIC_CLK_HDMI_SHIFT          8
+#define GPIO_DATA_DIRECTION_UART1_NRTS_SHIFT                       8
+#define GPIO_DATA_DIRECTION_IIC1_DATA_CRT_SHIFT                  7
+#define GPIO_DATA_DIRECTION_IIC1_CLK_CRT_SHIFT                     6
+#define GPIO_DATA_DIRECTION_GPIO_VBUS_SHIFT                         5
+#define GPIO_DATA_DIRECTION_IIS_TX_SELECT_SHIFT                   4
+#define GPIO_DATA_DIRECTION_GPIO_DVI_PNP_SHIFT                   4
+#define GPIO_DATA_DIRECTION_IIS_WS_SELECT_SHIFT                 3
+#define GPIO_DATA_DIRECTION_GPIO_AUDIO_PNP_SHIFT              3
+#define GPIO_DATA_DIRECTION_IIS_CLK_SELECT_SHIFT                2
+#define GPIO_DATA_DIRECTION_UART1_EXT_CLK_SELECT_SHIFT   1
+#define GPIO_DATA_DIRECTION_GPIO_HDMI_PNP_SHIFT                1
+#define GPIO_DATA_DIRECTION_UART0_EXT_CLK_SELECT_SHIFT   0
+
+
+#define GPIO_INTERRUPT_SETUP                            0x010008
+#define GPIO_INTERRUPT_SETUP_VBUS_TRIGGER_EDGE_SHIFT    21
+#define GPIO_INTERRUPT_SETUP_VBUS_TRIGGER_LEVEL_SHIFT   21
+#define GPIO_INTERRUPT_SETUP_DVI_PNP_TRIGGER_EDGE_SHIFT    20
+#define GPIO_INTERRUPT_SETUP_DVI_PNP_TRIGGER_LEVEL_SHIFT   20
+#define GPIO_INTERRUPT_SETUP_AUDIO_PNP_TRIGGER_EDGE_SHIFT    19
+#define GPIO_INTERRUPT_SETUP_AUDIO_PNP_TRIGGER_LEVEL_SHIFT   19
+#define GPIO_INTERRUPT_SETUP_HDMI_PNP_TRIGGER_EDGE_SHIFT    17
+#define GPIO_INTERRUPT_SETUP_HDMI_PNP_TRIGGER_LEVEL_SHIFT   17
+
+
+#define GPIO_INTERRUPT_SETUP_VBUS_ACTIVE_LOW_SHIFT    13
+#define GPIO_INTERRUPT_SETUP_VBUS_ACTIVE_HIGH_SHIFT  13
+#define GPIO_INTERRUPT_SETUP_DVI_PNP_ACTIVE_LOW_SHIFT    12
+#define GPIO_INTERRUPT_SETUP_DVI_PNP_ACTIVE_HIGH_SHIFT   12
+#define GPIO_INTERRUPT_SETUP_AUDIO_PNP_ACTIVE_LOW_SHIFT    11
+#define GPIO_INTERRUPT_SETUP_AUDIO_PNP_ACTIVE_HIGH_SHIFT   11
+#define GPIO_INTERRUPT_SETUP_HDMI_PNP_ACTIVE_LOW_SHIFT    9
+#define GPIO_INTERRUPT_SETUP_HDMI_PNP_ACTIVE_HIGH_SHIFT   9
+
+
+#define GPIO_INTERRUPT_SETUP_VBUS_ENABLE_SHIFT             5
+#define GPIO_INTERRUPT_SETUP_VBUS_GPIO_ENABLE_SHIFT             5
+#define GPIO_INTERRUPT_SETUP_DVI_PNP_ENABLE_SHIFT            4
+#define GPIO_INTERRUPT_SETUP_DVI_PNP_GPIO_ENABLE_SHIFT        4
+#define GPIO_INTERRUPT_SETUP_AUDIO_PNP_ENABLE_SHIFT             3
+#define GPIO_INTERRUPT_SETUP_AUDIO_PNP_GPIO_ENABLE_SHIFT        3
+#define GPIO_INTERRUPT_SETUP_HDMI_PNP_ENABLE_SHIFT             1
+#define GPIO_INTERRUPT_SETUP_HDMI_PNP_GPIO_ENABLE_SHIFT        1
+
+#define GPIO_INTERRUPT_STATUS                          0x01000C
+#define GPIO_INTERRUPT_STATUS_VBUS_INACTIVE               5
+#define GPIO_INTERRUPT_STATUS_VBUS_ACTIVE                 5
+#define GPIO_INTERRUPT_STATUS_VBUS_RESET                  5
+#define GPIO_INTERRUPT_STATUS_DVI_PNP_INACTIVE               4
+#define GPIO_INTERRUPT_STATUS_DVI_PNP_ACTIVE                 4
+#define GPIO_INTERRUPT_STATUS_DVI_PNP_RESET                  4
+#define GPIO_INTERRUPT_STATUS_AUDIO_PNP_INACTIVE              3
+#define GPIO_INTERRUPT_STATUS_AUDIO_PNP_ACTIVE                 3
+#define GPIO_INTERRUPT_STATUS_AUDIO_PNP_RESET                  3
+#define GPIO_INTERRUPT_STATUS_HDMI_PNP_INACTIVE             1
+#define GPIO_INTERRUPT_STATUS_HDMI_PNP_ACTIVE                 1
+#define GPIO_INTERRUPT_STATUS_HDMI_PNP_RESET                  1
+
+/*xxx_GPIO_xxxx means 0 is valid*/
+#define GPIO_MUX                                                     0x010010
+#define GPIO_MUX_IIC0_DATA_DVI_SHIFT                     31
+#define GPIO_MUX_IIC0_CLK_DVI_SHIFT                        30
+#define GPIO_MUX_SSP1_CLK_OUT_SHIFT                      29
+#define GPIO_MUX_GPIO_CODEC_DATA_SHIFT               29
+#define GPIO_MUX_SSP1_FRAMEINPUT_SHIFT                28
+#define GPIO_MUX_IIS_RX_SHIFT                                   28
+#define GPIO_MUX_SSP1_FRAMEOUT_SHIFT                   27
+#define GPIO_MUX_GPIO_IIS_TX_SHIFT                         27
+#define GPIO_MUX_SSP1_RX_SHIFT                                26
+#define GPIO_MUX_GPIO_IIS_WS_SHIFT                        26
+#define GPIO_MUX_SSP1_TX_SHIFT                               25
+#define GPIO_MUX_GPIO_IIS_CLK_SHIFT                       25
+#define GPIO_MUX_SSP0_CLK_OUT_SHIFT                     24
+#define GPIO_MUX_GPIO_SWSSP_CLK_OUT_SHIFT                  24
+#define GPIO_MUX_SSP0_FRAMEINPUT_SHIFT              23
+#define GPIO_MUX_GPIO_SWSSP_FRAMEINPUT_SHIFT           23
+#define GPIO_MUX_SSP0_FRAMEOUT_SHIFT                  22
+#define GPIO_MUX_GPIO_SWSSP_FRAMEOUT_SHIFT               22
+#define GPIO_MUX_SSP0_RX_SHIFT                               21
+#define GPIO_MUX_GPIO_SWSSP_RX_SHIFT                            21
+#define GPIO_MUX_SSP0_TX_SHIFT                               20
+#define GPIO_MUX_GPIO_SWSSP_TX_SHIFT                            20
+#define GPIO_MUX_PWM2_SHIFT                                   19
+#define GPIO_MUX_GPIO_UART1_EXT_CLK_SHIFT        19
+#define GPIO_MUX_GPIO_UART0_EXT_CLK_SHIFT        19
+#define GPIO_MUX_PWM1_SHIFT                                   18
+#define GPIO_MUX_PWM0_SHIFT                                   17
+#define GPIO_MUX_PCIE_SHIFT                                     16
+#define GPIO_MUX_UART0_SIN_SHIFT                          15
+#define GPIO_MUX_UART0_NCTSIN_SHIFT                   14
+#define GPIO_MUX_UART0_TXD_SHIFT                         13
+#define GPIO_MUX_UART0_NRTS_SHIFT                       12
+#define GPIO_MUX_UART1_SIN_SHIFT                         11
+#define GPIO_MUX_GPIO_CODEC_CLK_SHIFT               11
+#define GPIO_MUX_UART1_NCTSIN_SHIFT                   10
+#define GPIO_MUX_GPIO_CODEC_MODE_SHIFT            10
+#define GPIO_MUX_UART1_TXD_SHIFT                         9
+#define GPIO_MUX_GPIO_IIC_DATA_HDMI_SHIFT       9
+#define GPIO_MUX_GPIO_IIC_CLK_HDMI_SHIFT          8
+#define GPIO_MUX_UART1_NRTS_SHIFT                       8
+#define GPIO_MUX_IIC1_DATA_CRT_SHIFT                  7
+#define GPIO_MUX_IIC1_CLK_CRT_SHIFT                     6
+#define GPIO_MUX_GPIO_VBUS_SHIFT                         5
+#define GPIO_MUX_IIS_TX_SELECT_SHIFT                   4
+#define GPIO_MUX_GPIO_DVI_PNP_SHIFT                   4
+#define GPIO_MUX_IIS_WS_SELECT_SHIFT                 3
+#define GPIO_MUX_GPIO_AUDIO_PNP_SHIFT              3
+#define GPIO_MUX_IIS_CLK_SELECT_SHIFT                2
+#define GPIO_MUX_UART1_EXT_CLK_SELECT_SHIFT   1
+#define GPIO_MUX_GPIO_HDMI_PNP_SHIFT                1
+#define GPIO_MUX_UART0_EXT_CLK_SELECT_SHIFT   0
+
+
+
+#define GPIO_DATA_31                                    31:31
+#define GPIO_DATA_30                                    30:30
+#define GPIO_DATA_29                                    29:29
+#define GPIO_DATA_28                                    28:28
+#define GPIO_DATA_27                                    27:27
+#define GPIO_DATA_26                                    26:26
+#define GPIO_DATA_25                                    25:25
+#define GPIO_DATA_24                                    24:24
+#define GPIO_DATA_23                                    23:23
+#define GPIO_DATA_22                                    22:22
+#define GPIO_DATA_21                                    21:21
+#define GPIO_DATA_20                                    20:20
+#define GPIO_DATA_19                                    19:19
+#define GPIO_DATA_18                                    18:18
+#define GPIO_DATA_17                                    17:17
+#define GPIO_DATA_16                                    16:16
+#define GPIO_DATA_15                                    15:15
+#define GPIO_DATA_14                                    14:14
+#define GPIO_DATA_13                                    13:13
+#define GPIO_DATA_12                                    12:12
+#define GPIO_DATA_11                                    11:11
+#define GPIO_DATA_10                                    10:10
+#define GPIO_DATA_9                                     9:9
+#define GPIO_DATA_8                                     8:8
+#define GPIO_DATA_7                                     7:7
+#define GPIO_DATA_6                                     6:6
+#define GPIO_DATA_5                                     5:5
+#define GPIO_DATA_4                                     4:4
+#define GPIO_DATA_3                                     3:3
+#define GPIO_DATA_2                                     2:2
+#define GPIO_DATA_1                                     1:1
+#define GPIO_DATA_0                                     0:0
+
+
+#define GPIO_DATA_DIRECTION_31                          31:31
+#define GPIO_DATA_DIRECTION_31_INPUT                    0
+#define GPIO_DATA_DIRECTION_31_OUTPUT                   1
+#define GPIO_DATA_DIRECTION_30                          30:30
+#define GPIO_DATA_DIRECTION_30_INPUT                    0
+#define GPIO_DATA_DIRECTION_30_OUTPUT                   1
+#define GPIO_DATA_DIRECTION_29                          29:29
+#define GPIO_DATA_DIRECTION_29_INPUT                    0
+#define GPIO_DATA_DIRECTION_29_OUTPUT                   1
+#define GPIO_DATA_DIRECTION_28                          28:28
+#define GPIO_DATA_DIRECTION_28_INPUT                    0
+#define GPIO_DATA_DIRECTION_28_OUTPUT                   1
+#define GPIO_DATA_DIRECTION_27                          27:27
+#define GPIO_DATA_DIRECTION_27_INPUT                    0
+#define GPIO_DATA_DIRECTION_27_OUTPUT                   1
+#define GPIO_DATA_DIRECTION_26                          26:26
+#define GPIO_DATA_DIRECTION_26_INPUT                    0
+#define GPIO_DATA_DIRECTION_26_OUTPUT                   1
+#define GPIO_DATA_DIRECTION_25                          25:25
+#define GPIO_DATA_DIRECTION_25_INPUT                    0
+#define GPIO_DATA_DIRECTION_25_OUTPUT                   1
+#define GPIO_DATA_DIRECTION_24                          24:24
+#define GPIO_DATA_DIRECTION_24_INPUT                    0
+#define GPIO_DATA_DIRECTION_24_OUTPUT                   1
+#define GPIO_DATA_DIRECTION_23                          23:23
+#define GPIO_DATA_DIRECTION_23_INPUT                    0
+#define GPIO_DATA_DIRECTION_23_OUTPUT                   1
+#define GPIO_DATA_DIRECTION_22                          22:22
+#define GPIO_DATA_DIRECTION_22_INPUT                    0
+#define GPIO_DATA_DIRECTION_22_OUTPUT                   1
+#define GPIO_DATA_DIRECTION_21                          21:21
+#define GPIO_DATA_DIRECTION_21_INPUT                    0
+#define GPIO_DATA_DIRECTION_21_OUTPUT                   1
+#define GPIO_DATA_DIRECTION_20                          20:20
+#define GPIO_DATA_DIRECTION_20_INPUT                    0
+#define GPIO_DATA_DIRECTION_20_OUTPUT                   1
+#define GPIO_DATA_DIRECTION_19                          19:19
+#define GPIO_DATA_DIRECTION_19_INPUT                    0
+#define GPIO_DATA_DIRECTION_19_OUTPUT                   1
+#define GPIO_DATA_DIRECTION_18                          18:18
+#define GPIO_DATA_DIRECTION_18_INPUT                    0
+#define GPIO_DATA_DIRECTION_18_OUTPUT                   1
+#define GPIO_DATA_DIRECTION_17                          17:17
+#define GPIO_DATA_DIRECTION_17_INPUT                    0
+#define GPIO_DATA_DIRECTION_17_OUTPUT                   1
+#define GPIO_DATA_DIRECTION_16                          16:16
+#define GPIO_DATA_DIRECTION_16_INPUT                    0
+#define GPIO_DATA_DIRECTION_16_OUTPUT                   1
+#define GPIO_DATA_DIRECTION_15                          15:15
+#define GPIO_DATA_DIRECTION_15_INPUT                    0
+#define GPIO_DATA_DIRECTION_15_OUTPUT                   1
+#define GPIO_DATA_DIRECTION_14                          14:14
+#define GPIO_DATA_DIRECTION_14_INPUT                    0
+#define GPIO_DATA_DIRECTION_14_OUTPUT                   1
+#define GPIO_DATA_DIRECTION_13                          13:13
+#define GPIO_DATA_DIRECTION_13_INPUT                    0
+#define GPIO_DATA_DIRECTION_13_OUTPUT                   1
+#define GPIO_DATA_DIRECTION_12                          12:12
+#define GPIO_DATA_DIRECTION_12_INPUT                    0
+#define GPIO_DATA_DIRECTION_12_OUTPUT                   1
+#define GPIO_DATA_DIRECTION_11                          11:11
+#define GPIO_DATA_DIRECTION_11_INPUT                    0
+#define GPIO_DATA_DIRECTION_11_OUTPUT                   1
+#define GPIO_DATA_DIRECTION_10                          10:10
+#define GPIO_DATA_DIRECTION_10_INPUT                    0
+#define GPIO_DATA_DIRECTION_10_OUTPUT                   1
+#define GPIO_DATA_DIRECTION_9                           9:9
+#define GPIO_DATA_DIRECTION_9_INPUT                     0
+#define GPIO_DATA_DIRECTION_9_OUTPUT                    1
+#define GPIO_DATA_DIRECTION_8                           8:8
+#define GPIO_DATA_DIRECTION_8_INPUT                     0
+#define GPIO_DATA_DIRECTION_8_OUTPUT                    1
+#define GPIO_DATA_DIRECTION_7                           7:7
+#define GPIO_DATA_DIRECTION_7_INPUT                     0
+#define GPIO_DATA_DIRECTION_7_OUTPUT                    1
+#define GPIO_DATA_DIRECTION_6                           6:6
+#define GPIO_DATA_DIRECTION_6_INPUT                     0
+#define GPIO_DATA_DIRECTION_6_OUTPUT                    1
+#define GPIO_DATA_DIRECTION_5                           5:5
+#define GPIO_DATA_DIRECTION_5_INPUT                     0
+#define GPIO_DATA_DIRECTION_5_OUTPUT                    1
+#define GPIO_DATA_DIRECTION_4                           4:4
+#define GPIO_DATA_DIRECTION_4_INPUT                     0
+#define GPIO_DATA_DIRECTION_4_OUTPUT                    1
+#define GPIO_DATA_DIRECTION_3                           3:3
+#define GPIO_DATA_DIRECTION_3_INPUT                     0
+#define GPIO_DATA_DIRECTION_3_OUTPUT                    1
+#define GPIO_DATA_DIRECTION_2                           2:2
+#define GPIO_DATA_DIRECTION_2_INPUT                     0
+#define GPIO_DATA_DIRECTION_2_OUTPUT                    1
+#define GPIO_DATA_DIRECTION_1                           1:1
+#define GPIO_DATA_DIRECTION_1_INPUT                     0
+#define GPIO_DATA_DIRECTION_1_OUTPUT                    1
+#define GPIO_DATA_DIRECTION_0                           0:0
+#define GPIO_DATA_DIRECTION_0_INPUT                     0
+#define GPIO_DATA_DIRECTION_0_OUTPUT                    1
+
+
+#define GPIO_INTERRUPT_SETUP_TRIGGER_31                 22:22
+#define GPIO_INTERRUPT_SETUP_TRIGGER_31_EDGE            0
+#define GPIO_INTERRUPT_SETUP_TRIGGER_31_LEVEL           1
+#define GPIO_INTERRUPT_SETUP_TRIGGER_30                 21:21
+#define GPIO_INTERRUPT_SETUP_TRIGGER_30_EDGE            0
+#define GPIO_INTERRUPT_SETUP_TRIGGER_30_LEVEL           1
+#define GPIO_INTERRUPT_SETUP_TRIGGER_29                 20:20
+#define GPIO_INTERRUPT_SETUP_TRIGGER_29_EDGE            0
+#define GPIO_INTERRUPT_SETUP_TRIGGER_29_LEVEL           1
+#define GPIO_INTERRUPT_SETUP_TRIGGER_28                 19:19
+#define GPIO_INTERRUPT_SETUP_TRIGGER_28_EDGE            0
+#define GPIO_INTERRUPT_SETUP_TRIGGER_28_LEVEL           1
+#define GPIO_INTERRUPT_SETUP_TRIGGER_27                 18:18
+#define GPIO_INTERRUPT_SETUP_TRIGGER_27_EDGE            0
+#define GPIO_INTERRUPT_SETUP_TRIGGER_27_LEVEL           1
+#define GPIO_INTERRUPT_SETUP_TRIGGER_26                 17:17
+#define GPIO_INTERRUPT_SETUP_TRIGGER_26_EDGE            0
+#define GPIO_INTERRUPT_SETUP_TRIGGER_26_LEVEL           1
+#define GPIO_INTERRUPT_SETUP_TRIGGER_25                 16:16
+#define GPIO_INTERRUPT_SETUP_TRIGGER_25_EDGE            0
+#define GPIO_INTERRUPT_SETUP_TRIGGER_25_LEVEL           1
+#define GPIO_INTERRUPT_SETUP_ACTIVE_31                  14:14
+#define GPIO_INTERRUPT_SETUP_ACTIVE_31_LOW              0
+#define GPIO_INTERRUPT_SETUP_ACTIVE_31_HIGH             1
+#define GPIO_INTERRUPT_SETUP_ACTIVE_30                  13:13
+#define GPIO_INTERRUPT_SETUP_ACTIVE_30_LOW              0
+#define GPIO_INTERRUPT_SETUP_ACTIVE_30_HIGH             1
+#define GPIO_INTERRUPT_SETUP_ACTIVE_29                  12:12
+#define GPIO_INTERRUPT_SETUP_ACTIVE_29_LOW              0
+#define GPIO_INTERRUPT_SETUP_ACTIVE_29_HIGH             1
+#define GPIO_INTERRUPT_SETUP_ACTIVE_28                  11:11
+#define GPIO_INTERRUPT_SETUP_ACTIVE_28_LOW              0
+#define GPIO_INTERRUPT_SETUP_ACTIVE_28_HIGH             1
+#define GPIO_INTERRUPT_SETUP_ACTIVE_27                  10:10
+#define GPIO_INTERRUPT_SETUP_ACTIVE_27_LOW              0
+#define GPIO_INTERRUPT_SETUP_ACTIVE_27_HIGH             1
+#define GPIO_INTERRUPT_SETUP_ACTIVE_26                  9:9
+#define GPIO_INTERRUPT_SETUP_ACTIVE_26_LOW              0
+#define GPIO_INTERRUPT_SETUP_ACTIVE_26_HIGH             1
+#define GPIO_INTERRUPT_SETUP_ACTIVE_25                  8:8
+#define GPIO_INTERRUPT_SETUP_ACTIVE_25_LOW              0
+#define GPIO_INTERRUPT_SETUP_ACTIVE_25_HIGH             1
+#define GPIO_INTERRUPT_SETUP_ENABLE_31                  6:6
+#define GPIO_INTERRUPT_SETUP_ENABLE_31_GPIO             0
+#define GPIO_INTERRUPT_SETUP_ENABLE_31_INTERRUPT        1
+#define GPIO_INTERRUPT_SETUP_ENABLE_30                  5:5
+#define GPIO_INTERRUPT_SETUP_ENABLE_30_GPIO             0
+#define GPIO_INTERRUPT_SETUP_ENABLE_30_INTERRUPT        1
+#define GPIO_INTERRUPT_SETUP_ENABLE_29                  4:4
+#define GPIO_INTERRUPT_SETUP_ENABLE_29_GPIO             0
+#define GPIO_INTERRUPT_SETUP_ENABLE_29_INTERRUPT        1
+#define GPIO_INTERRUPT_SETUP_ENABLE_28                  3:3
+#define GPIO_INTERRUPT_SETUP_ENABLE_28_GPIO             0
+#define GPIO_INTERRUPT_SETUP_ENABLE_28_INTERRUPT        1
+#define GPIO_INTERRUPT_SETUP_ENABLE_27                  2:2
+#define GPIO_INTERRUPT_SETUP_ENABLE_27_GPIO             0
+#define GPIO_INTERRUPT_SETUP_ENABLE_27_INTERRUPT        1
+#define GPIO_INTERRUPT_SETUP_ENABLE_26                  1:1
+#define GPIO_INTERRUPT_SETUP_ENABLE_26_GPIO             0
+#define GPIO_INTERRUPT_SETUP_ENABLE_26_INTERRUPT        1
+#define GPIO_INTERRUPT_SETUP_ENABLE_25                  0:0
+#define GPIO_INTERRUPT_SETUP_ENABLE_25_GPIO             0
+#define GPIO_INTERRUPT_SETUP_ENABLE_25_INTERRUPT        1
+
+
+#define GPIO_INTERRUPT_STATUS_31                        22:22
+#define GPIO_INTERRUPT_STATUS_31_INACTIVE               0
+#define GPIO_INTERRUPT_STATUS_31_ACTIVE                 1
+#define GPIO_INTERRUPT_STATUS_31_RESET                  1
+#define GPIO_INTERRUPT_STATUS_30                        21:21
+#define GPIO_INTERRUPT_STATUS_30_INACTIVE               0
+#define GPIO_INTERRUPT_STATUS_30_ACTIVE                 1
+#define GPIO_INTERRUPT_STATUS_30_RESET                  1
+#define GPIO_INTERRUPT_STATUS_29                        20:20
+#define GPIO_INTERRUPT_STATUS_29_INACTIVE               0
+#define GPIO_INTERRUPT_STATUS_29_ACTIVE                 1
+#define GPIO_INTERRUPT_STATUS_29_RESET                  1
+#define GPIO_INTERRUPT_STATUS_28                        19:19
+#define GPIO_INTERRUPT_STATUS_28_INACTIVE               0
+#define GPIO_INTERRUPT_STATUS_28_ACTIVE                 1
+#define GPIO_INTERRUPT_STATUS_28_RESET                  1
+#define GPIO_INTERRUPT_STATUS_27                        18:18
+#define GPIO_INTERRUPT_STATUS_27_INACTIVE               0
+#define GPIO_INTERRUPT_STATUS_27_ACTIVE                 1
+#define GPIO_INTERRUPT_STATUS_27_RESET                  1
+#define GPIO_INTERRUPT_STATUS_26                        17:17
+#define GPIO_INTERRUPT_STATUS_26_INACTIVE               0
+#define GPIO_INTERRUPT_STATUS_26_ACTIVE                 1
+#define GPIO_INTERRUPT_STATUS_26_RESET                  1
+#define GPIO_INTERRUPT_STATUS_25                        16:16
+#define GPIO_INTERRUPT_STATUS_25_INACTIVE               0
+#define GPIO_INTERRUPT_STATUS_25_ACTIVE                 1
+#define GPIO_INTERRUPT_STATUS_25_RESET                  1
+
+
+#define GPIO_MUX_I2C0                                 31:30
+#define GPIO_MUX_I2C0_DISABLE                         0
+#define GPIO_MUX_I2C0_ENABLE                          3
+#define GPIO_MUX_31                                   31:31
+#define GPIO_MUX_31_GPIO                              0
+#define GPIO_MUX_31_I2C0                              1
+#define GPIO_MUX_30                                   30:30
+#define GPIO_MUX_30_GPIO                              0
+#define GPIO_MUX_30_I2C0                              1
+#define GPIO_MUX_29                                   29:29
+#define GPIO_MUX_29_GPIO                              0
+#define GPIO_MUX_29_SSP1                              1
+#define GPIO_MUX_28                                   28:28
+#define GPIO_MUX_28_GPIO                              0
+#define GPIO_MUX_28_SSP1                              1
+#define GPIO_MUX_28_I2S_RX                            1
+#define GPIO_MUX_27                                   27:27
+#define GPIO_MUX_27_GPIO                              0
+#define GPIO_MUX_27_I2S_TX                            0
+#define GPIO_MUX_27_SSP1                              1
+#define GPIO_MUX_26                                   26:26
+#define GPIO_MUX_26_GPIO                              0
+#define GPIO_MUX_26_I2S_WS                            0
+#define GPIO_MUX_26_SSP1                              1
+#define GPIO_MUX_25                                   25:25
+#define GPIO_MUX_25_GPIO                              0
+#define GPIO_MUX_25_I2S_CK                            0
+#define GPIO_MUX_25_SSP1                              1
+#define GPIO_MUX_24                                   24:24
+#define GPIO_MUX_24_GPIO                              0
+#define GPIO_MUX_24_SSP0                              1
+#define GPIO_MUX_23                                   23:23
+#define GPIO_MUX_23_GPIO                              0
+#define GPIO_MUX_23_SSP0                              1
+#define GPIO_MUX_22                                   22:22
+#define GPIO_MUX_22_GPIO                              0
+#define GPIO_MUX_22_SSP0                              1
+#define GPIO_MUX_21                                   21:21
+#define GPIO_MUX_21_GPIO                              0
+#define GPIO_MUX_21_SSP0                              1
+#define GPIO_MUX_20                                   20:20
+#define GPIO_MUX_20_GPIO                              0
+#define GPIO_MUX_20_SSP0                              1
+#define GPIO_MUX_19                                   19:19
+#define GPIO_MUX_19_GPIO                              0
+#define GPIO_MUX_19_PWM2                              1
+#define GPIO_MUX_18                                   18:18
+#define GPIO_MUX_18_GPIO                              0
+#define GPIO_MUX_18_PWM1                              1
+#define GPIO_MUX_17                                   17:17
+#define GPIO_MUX_17_GPIO                              0
+#define GPIO_MUX_17_PWM0                              1
+#define GPIO_MUX_16                                   16:16
+#define GPIO_MUX_16_GPIO                              0
+#define GPIO_MUX_16_UNUSED                            1
+#define GPIO_MUX_UART0                                15:12
+#define GPIO_MUX_UART0_DISABLE                        0
+#define GPIO_MUX_UART0_ENABLE                         15
+#define GPIO_MUX_15                                   15:15
+#define GPIO_MUX_15_GPIO                              0
+#define GPIO_MUX_15_UART0                             1
+#define GPIO_MUX_14                                   14:14
+#define GPIO_MUX_14_GPIO		                      0
+#define GPIO_MUX_14_UART0	                          1
+#define GPIO_MUX_13                                   13:13
+#define GPIO_MUX_13_GPIO		                      0
+#define GPIO_MUX_13_UART0                             1
+#define GPIO_MUX_12                                   12:12
+#define GPIO_MUX_12_GPIO		                      0
+#define GPIO_MUX_12_UART0                             1
+#define GPIO_MUX_UART1                                11:8
+#define GPIO_MUX_UART1_DISABLE                        0
+#define GPIO_MUX_UART1_ENABLE                         15
+#define GPIO_MUX_11                                   11:11
+#define GPIO_MUX_11_GPIO                              0
+#define GPIO_MUX_11_UART1                             1
+#define GPIO_MUX_10                                   10:10
+#define GPIO_MUX_10_GPIO		                      0
+#define GPIO_MUX_10_UART1	                          1
+#define GPIO_MUX_9                                    9:9
+#define GPIO_MUX_9_GPIO			                      0
+#define GPIO_MUX_9_UART1                              1
+#define GPIO_MUX_8                                    8:8
+#define GPIO_MUX_8_GPIO			                      0
+#define GPIO_MUX_8_UART1                              1
+#define GPIO_MUX_I2C1                                 7:6
+#define GPIO_MUX_I2C1_DISABLE                         0
+#define GPIO_MUX_I2C1_ENABLE                          3
+#define GPIO_MUX_7                                    7:7
+#define GPIO_MUX_7_GPIO			                      0
+#define GPIO_MUX_7_I2C1                               1
+#define GPIO_MUX_6                                    6:6
+#define GPIO_MUX_6_GPIO			                      0
+#define GPIO_MUX_6_I2C1                               1
+#define GPIO_MUX_5                                    5:5
+#define GPIO_MUX_5_GPIO			                      0
+#define GPIO_MUX_5_RESERVE                            1
+#define GPIO_MUX_4                                    4:4
+#define GPIO_MUX_4_GPIO27		                      0
+#define GPIO_MUX_4_I2S_TX                             1
+#define GPIO_MUX_3                                    3:3
+#define GPIO_MUX_3_GPIO26		                      0
+#define GPIO_MUX_3_I2S_WS                             1
+#define GPIO_MUX_2                                    2:2
+#define GPIO_MUX_2_GPIO25		                      0
+#define GPIO_MUX_2_I2S_CK                             1
+#define GPIO_MUX_1                                    1:1
+#define GPIO_MUX_1_UART1_INT_CLK                      0
+#define GPIO_MUX_1_UART1_EXT_CLK                      1
+#define GPIO_MUX_0                                    0:0
+#define GPIO_MUX_0_UART0_INT_CLK                      0
+#define GPIO_MUX_0_UART0_EXT_CLK                      1
+
+
+//#include "regpwm.h"
+
+#define PWM_CONTROL                                               0x010020
+#define PWM_CONTROL_HIGH_COUNTER                                  31:20
+#define PWM_CONTROL_LOW_COUNTER                                   19:8
+#define PWM_CONTROL_CLOCK_DIVIDE                                  7:4
+#define PWM_CONTROL_CLOCK_DIVIDE_1                                0
+#define PWM_CONTROL_CLOCK_DIVIDE_2                                1
+#define PWM_CONTROL_CLOCK_DIVIDE_4                                2
+#define PWM_CONTROL_CLOCK_DIVIDE_8                                3
+#define PWM_CONTROL_CLOCK_DIVIDE_16                               4
+#define PWM_CONTROL_CLOCK_DIVIDE_32                               5
+#define PWM_CONTROL_CLOCK_DIVIDE_64                               6
+#define PWM_CONTROL_CLOCK_DIVIDE_128                              7
+#define PWM_CONTROL_CLOCK_DIVIDE_256                              8
+#define PWM_CONTROL_CLOCK_DIVIDE_512                              9
+#define PWM_CONTROL_CLOCK_DIVIDE_1024                             10
+#define PWM_CONTROL_CLOCK_DIVIDE_2048                             11
+#define PWM_CONTROL_CLOCK_DIVIDE_4096                             12
+#define PWM_CONTROL_CLOCK_DIVIDE_8192                             13
+#define PWM_CONTROL_CLOCK_DIVIDE_16384                            14
+#define PWM_CONTROL_CLOCK_DIVIDE_32768                            15
+#define PWM_CONTROL_INTERRUPT_STATUS                              3:3
+#define PWM_CONTROL_INTERRUPT_STATUS_NOT_PENDING                  0
+#define PWM_CONTROL_INTERRUPT_STATUS_PENDING                      1
+#define PWM_CONTROL_INTERRUPT_STATUS_CLEAR                        1
+#define PWM_CONTROL_INTERRUPT                                     2:2
+#define PWM_CONTROL_INTERRUPT_DISABLE                             0
+#define PWM_CONTROL_INTERRUPT_ENABLE                              1
+#define PWM_CONTROL_STATUS                                        0:0
+#define PWM_CONTROL_STATUS_DISABLE                                0
+#define PWM_CONTROL_STATUS_ENABLE                                 1
+
+
+//#include "regssp.h"
+
+#define SSP_0_CONTROL_0                                 0x020000
+#define SSP_0_CONTROL_0_CLOCK_RATE                      15:8
+#define SSP_0_CONTROL_0_SCLKOUT_PHASE                   7:7
+#define SSP_0_CONTROL_0_SCLKOUT_PHASE_0                 0
+#define SSP_0_CONTROL_0_SCLKOUT_PHASE_1                 1
+#define SSP_0_CONTROL_0_SCLKOUT_POLARITY                6:6
+#define SSP_0_CONTROL_0_SCLKOUT_POLARITY_RISING         0
+#define SSP_0_CONTROL_0_SCLKOUT_POLARITY_FALLING        1
+#define SSP_0_CONTROL_0_FRAME_FORMAT                    5:4
+#define SSP_0_CONTROL_0_FRAME_FORMAT_MOTOROLA           0
+#define SSP_0_CONTROL_0_FRAME_FORMAT_TI                 1
+#define SSP_0_CONTROL_0_FRAME_FORMAT_NATIONAL           2
+#define SSP_0_CONTROL_0_DATA_SIZE                       3:0
+#define SSP_0_CONTROL_0_DATA_SIZE_4                     3
+#define SSP_0_CONTROL_0_DATA_SIZE_5                     4
+#define SSP_0_CONTROL_0_DATA_SIZE_6                     5
+#define SSP_0_CONTROL_0_DATA_SIZE_7                     6
+#define SSP_0_CONTROL_0_DATA_SIZE_8                     7
+#define SSP_0_CONTROL_0_DATA_SIZE_9                     8
+#define SSP_0_CONTROL_0_DATA_SIZE_10                    9
+#define SSP_0_CONTROL_0_DATA_SIZE_11                    10
+#define SSP_0_CONTROL_0_DATA_SIZE_12                    11
+#define SSP_0_CONTROL_0_DATA_SIZE_13                    12
+#define SSP_0_CONTROL_0_DATA_SIZE_14                    13
+#define SSP_0_CONTROL_0_DATA_SIZE_15                    14
+#define SSP_0_CONTROL_0_DATA_SIZE_16                    15
+
+#define SSP_0_CONTROL_1                                 0x020004
+#define SSP_0_CONTROL_1_SLAVE_OUTPUT                    6:6
+#define SSP_0_CONTROL_1_SLAVE_OUTPUT_ENABLE             0
+#define SSP_0_CONTROL_1_SLAVE_OUTPUT_DISABLE            1
+#define SSP_0_CONTROL_1_MODE_SELECT                     5:5
+#define SSP_0_CONTROL_1_MODE_SELECT_MASTER              0
+#define SSP_0_CONTROL_1_MODE_SELECT_SLAVE               1
+#define SSP_0_CONTROL_1_STATUS                          4:4
+#define SSP_0_CONTROL_1_STATUS_DISABLE                  0
+#define SSP_0_CONTROL_1_STATUS_ENABLE                   1
+#define SSP_0_CONTROL_1_LOOP_BACK                       3:3
+#define SSP_0_CONTROL_1_LOOP_BACK_DISABLE               0
+#define SSP_0_CONTROL_1_LOOP_BACK_ENABLE                1
+#define SSP_0_CONTROL_1_OVERRUN_INTERRUPT               2:2
+#define SSP_0_CONTROL_1_OVERRUN_INTERRUPT_DISABLE       0
+#define SSP_0_CONTROL_1_OVERRUN_INTERRUPT_ENABLE        1
+#define SSP_0_CONTROL_1_TRANSMIT_INTERRUPT              1:1
+#define SSP_0_CONTROL_1_TRANSMIT_INTERRUPT_DISABLE      0
+#define SSP_0_CONTROL_1_TRANSMIT_INTERRUPT_ENABLE       1
+#define SSP_0_CONTROL_1_RECEIVE_INTERRUPT               0:0
+#define SSP_0_CONTROL_1_RECEIVE_INTERRUPT_DISABLE       0
+#define SSP_0_CONTROL_1_RECEIVE_INTERRUPT_ENABLE        1
+
+#define SSP_0_DATA                                      0x020008
+#define SSP_0_DATA_DATA                                 15:0
+
+#define SSP_0_STATUS                                    0x02000C
+#define SSP_0_STATUS_STATUS                             4:4
+#define SSP_0_STATUS_STATUS_IDLE                        0
+#define SSP_0_STATUS_STATUS_BUSY                        1
+#define SSP_0_STATUS_RECEIVE_FIFO                       3:2
+#define SSP_0_STATUS_RECEIVE_FIFO_EMPTY                 0
+#define SSP_0_STATUS_RECEIVE_FIFO_NOT_EMPTY             1
+#define SSP_0_STATUS_RECEIVE_FIFO_FULL                  3
+#define SSP_0_STATUS_TRANSMIT_FIFO                      1:0
+#define SSP_0_STATUS_TRANSMIT_FIFO_FULL                 0
+#define SSP_0_STATUS_TRANSMIT_FIFO_NOT_FULL             2
+#define SSP_0_STATUS_TRANSMIT_FIFO_EMPTY                3
+
+#define SSP_0_CLOCK_PRESCALE                            0x020010
+#define SSP_0_CLOCK_PRESCALE_DIVISOR                    7:0
+
+#define SSP_0_INTERRUPT_STATUS                          0x020014
+#define SSP_0_INTERRUPT_STATUS_OVERRUN                  2:2
+#define SSP_0_INTERRUPT_STATUS_OVERRUN_NOT_ACTIVE       0
+#define SSP_0_INTERRUPT_STATUS_OVERRUN_ACTIVE           1
+#define SSP_0_INTERRUPT_STATUS_OVERRUN_CLEAR            1
+#define SSP_0_INTERRUPT_STATUS_TRANSMIT                 1:1
+#define SSP_0_INTERRUPT_STATUS_TRANSMIT_NOT_ACTIVE      0
+#define SSP_0_INTERRUPT_STATUS_TRANSMIT_ACTIVE          1
+#define SSP_0_INTERRUPT_STATUS_RECEIVE                  0:0
+#define SSP_0_INTERRUPT_STATUS_RECEIVE_NOT_ACTIVE       0
+#define SSP_0_INTERRUPT_STATUS_RECEIVE_ACTIVE           1
+
+/* SSP 1 */
+
+#define SSP_1_CONTROL_0                                 0x020100
+#define SSP_1_CONTROL_0_CLOCK_RATE                      15:8
+#define SSP_1_CONTROL_0_SCLKOUT_PHASE                   7:7
+#define SSP_1_CONTROL_0_SCLKOUT_PHASE_0                 0
+#define SSP_1_CONTROL_0_SCLKOUT_PHASE_1                 1
+#define SSP_1_CONTROL_0_SCLKOUT_POLARITY                6:6
+#define SSP_1_CONTROL_0_SCLKOUT_POLARITY_RISING         0
+#define SSP_1_CONTROL_0_SCLKOUT_POLARITY_FALLING        1
+#define SSP_1_CONTROL_0_FRAME_FORMAT                    5:4
+#define SSP_1_CONTROL_0_FRAME_FORMAT_MOTOROLA           0
+#define SSP_1_CONTROL_0_FRAME_FORMAT_TI                 1
+#define SSP_1_CONTROL_0_FRAME_FORMAT_NATIONAL           2
+#define SSP_1_CONTROL_0_DATA_SIZE                       3:0
+#define SSP_1_CONTROL_0_DATA_SIZE_4                     3
+#define SSP_1_CONTROL_0_DATA_SIZE_5                     4
+#define SSP_1_CONTROL_0_DATA_SIZE_6                     5
+#define SSP_1_CONTROL_0_DATA_SIZE_7                     6
+#define SSP_1_CONTROL_0_DATA_SIZE_8                     7
+#define SSP_1_CONTROL_0_DATA_SIZE_9                     8
+#define SSP_1_CONTROL_0_DATA_SIZE_10                    9
+#define SSP_1_CONTROL_0_DATA_SIZE_11                    10
+#define SSP_1_CONTROL_0_DATA_SIZE_12                    11
+#define SSP_1_CONTROL_0_DATA_SIZE_13                    12
+#define SSP_1_CONTROL_0_DATA_SIZE_14                    13
+#define SSP_1_CONTROL_0_DATA_SIZE_15                    14
+#define SSP_1_CONTROL_0_DATA_SIZE_16                    15
+
+#define SSP_1_CONTROL_1                                 0x020104
+#define SSP_1_CONTROL_1_SLAVE_OUTPUT                    6:6
+#define SSP_1_CONTROL_1_SLAVE_OUTPUT_ENABLE             0
+#define SSP_1_CONTROL_1_SLAVE_OUTPUT_DISABLE            1
+#define SSP_1_CONTROL_1_MODE_SELECT                     5:5
+#define SSP_1_CONTROL_1_MODE_SELECT_MASTER              0
+#define SSP_1_CONTROL_1_MODE_SELECT_SLAVE               1
+#define SSP_1_CONTROL_1_STATUS                          4:4
+#define SSP_1_CONTROL_1_STATUS_DISABLE                  0
+#define SSP_1_CONTROL_1_STATUS_ENABLE                   1
+#define SSP_1_CONTROL_1_LOOP_BACK                       3:3
+#define SSP_1_CONTROL_1_LOOP_BACK_DISABLE               0
+#define SSP_1_CONTROL_1_LOOP_BACK_ENABLE                1
+#define SSP_1_CONTROL_1_OVERRUN_INTERRUPT               2:2
+#define SSP_1_CONTROL_1_OVERRUN_INTERRUPT_DISABLE       0
+#define SSP_1_CONTROL_1_OVERRUN_INTERRUPT_ENABLE        1
+#define SSP_1_CONTROL_1_TRANSMIT_INTERRUPT              1:1
+#define SSP_1_CONTROL_1_TRANSMIT_INTERRUPT_DISABLE      0
+#define SSP_1_CONTROL_1_TRANSMIT_INTERRUPT_ENABLE       1
+#define SSP_1_CONTROL_1_RECEIVE_INTERRUPT               0:0
+#define SSP_1_CONTROL_1_RECEIVE_INTERRUPT_DISABLE       0
+#define SSP_1_CONTROL_1_RECEIVE_INTERRUPT_ENABLE        1
+
+#define SSP_1_DATA                                      0x020108
+#define SSP_1_DATA_DATA                                 15:0
+
+#define SSP_1_STATUS                                    0x02010C
+#define SSP_1_STATUS_STATUS                             4:4
+#define SSP_1_STATUS_STATUS_IDLE                        0
+#define SSP_1_STATUS_STATUS_BUSY                        1
+#define SSP_1_STATUS_RECEIVE_FIFO                       3:2
+#define SSP_1_STATUS_RECEIVE_FIFO_EMPTY                 0
+#define SSP_1_STATUS_RECEIVE_FIFO_NOT_EMPTY             1
+#define SSP_1_STATUS_RECEIVE_FIFO_FULL                  3
+#define SSP_1_STATUS_TRANSMIT_FIFO                      1:0
+#define SSP_1_STATUS_TRANSMIT_FIFO_FULL                 0
+#define SSP_1_STATUS_TRANSMIT_FIFO_NOT_FULL             2
+#define SSP_1_STATUS_TRANSMIT_FIFO_EMPTY                3
+
+#define SSP_1_CLOCK_PRESCALE                            0x020110
+#define SSP_1_CLOCK_PRESCALE_DIVISOR                    7:0
+
+#define SSP_1_INTERRUPT_STATUS                          0x020114
+#define SSP_1_INTERRUPT_STATUS_OVERRUN                  2:2
+#define SSP_1_INTERRUPT_STATUS_OVERRUN_NOT_ACTIVE       0
+#define SSP_1_INTERRUPT_STATUS_OVERRUN_ACTIVE           1
+#define SSP_1_INTERRUPT_STATUS_OVERRUN_CLEAR            1
+#define SSP_1_INTERRUPT_STATUS_TRANSMIT                 1:1
+#define SSP_1_INTERRUPT_STATUS_TRANSMIT_NOT_ACTIVE      0
+#define SSP_1_INTERRUPT_STATUS_TRANSMIT_ACTIVE          1
+#define SSP_1_INTERRUPT_STATUS_RECEIVE                  0:0
+#define SSP_1_INTERRUPT_STATUS_RECEIVE_NOT_ACTIVE       0
+#define SSP_1_INTERRUPT_STATUS_RECEIVE_ACTIVE           1
+
+//#include "regdc.h"
+
+
+#define HDMI_CONTROL									0x0800C4
+#define HDMI_CONTROL_MODE_SELECT						7:4
+#define HDMI_CONTROL_MODE_SELECT_A						1
+#define HDMI_CONTROL_MODE_SELECT_B						2
+#define HDMI_CONTROL_MODE_SELECT_D						4
+#define HDMI_CONTROL_MODE_SELECT_E						8
+#define HDMI_CONTROL_PLLB								3:3
+#define HDMI_CONTROL_PLLB_NORMAL						0
+#define HDMI_CONTROL_PLLB_RESET							1
+#define HDMI_CONTROL_PLLA								2:2
+#define HDMI_CONTROL_PLLA_NORMAL						0
+#define HDMI_CONTROL_PLLA_RESET							1
+#define HDMI_CONTROL_INTMODE							1:1
+#define HDMI_CONTROL_INT_MODE_OPEN						0
+#define HDMI_CONTROL_INT_MODE_PULL						1
+#define HDMI_CONTROL_INT_POLARITY						0:0
+#define HDMI_CONTROL_INT_POLARITY_LOW					0
+#define HDMI_CONTROL_INT_POLARITY_HIGH					1
+
+#define HDMI_CONFIG										0x0800C0
+#define HDMI_CONFIG_READ								17:17
+#define HDMI_CONFIG_READ_LATCH							0
+#define HDMI_CONFIG_READ_ENABLE							1
+#define HDMI_CONFIG_WRITE								16:16
+#define HDMI_CONFIG_WRITE_LATCH							0
+#define HDMI_CONFIG_WRITE_ENABLE						1
+#define HDMI_CONFIG_DATA								15:8
+#define HDMI_CONFIG_ADDRESS								7:0
+
+
+
+
+#define DISPLAY_CTRL                            0x080000
+#define DISPLAY_CTRL_DPMS                         31:30
+#define DISPLAY_CTRL_DPMS_VPHP                       0
+#define DISPLAY_CTRL_DPMS_VPHN                       1
+#define DISPLAY_CTRL_DPMS_VNHP                       2
+#define DISPLAY_CTRL_DPMS_VNHN                       3
+#define DISPLAY_CTRL_DATA_PATH                 29:29
+#define DISPLAY_CTRL_DATA_PATH_VGA    	         0
+#define DISPLAY_CTRL_DATA_PATH_EXTENDED         1
+#define DISPLAY_CTRL_DIRECTION                   28:28
+#define DISPLAY_CTRL_DIRECTION_INPUT             	 0
+#define DISPLAY_CTRL_DIRECTION_OUTPUT                1
+#define DISPLAY_CTRL_FPEN                       27:27
+#define DISPLAY_CTRL_FPEN_LOW                   0
+#define DISPLAY_CTRL_FPEN_HIGH                  1
+#define DISPLAY_CTRL_VBIASEN                    26:26
+#define DISPLAY_CTRL_VBIASEN_LOW                0
+#define DISPLAY_CTRL_VBIASEN_HIGH               1
+#define DISPLAY_CTRL_DATA                       25:25
+#define DISPLAY_CTRL_DATA_DISABLE               0
+#define DISPLAY_CTRL_DATA_ENABLE                1
+#define DISPLAY_CTRL_FPVDDEN                    24:24
+#define DISPLAY_CTRL_FPVDDEN_LOW                0
+#define DISPLAY_CTRL_FPVDDEN_HIGH               1
+#define DISPLAY_CTRL_CAPTURE_DATA_SELECT	                    23:23
+#define DISPLAY_CTRL_CAPTURE_DATA_SELECT_CHANNEL0              0
+#define DISPLAY_CTRL_CAPTURE_DATA_SELECT_CHANNEL1              1
+#define DISPLAY_CTRL_LOOP_BACK_SELECT              			22:22
+#define DISPLAY_CTRL_LOOP_BACK_SELECT_CHANNEL0        			0
+#define DISPLAY_CTRL_LOOP_BACK_SELECT_CHANNEL1        			1
+#define DISPLAY_CTRL_CHANNEL_OUTPUT_FORMAT         			21:20
+#define DISPLAY_CTRL_CHANNEL_OUTPUT_FORMAT_CHANNEL0_24BIT      0
+#define DISPLAY_CTRL_CHANNEL_OUTPUT_FORMAT_CHANNEL1_24BIT      1
+#define DISPLAY_CTRL_CHANNEL_OUTPUT_FORMAT_CHANNEL0_48BIT      2
+#define DISPLAY_CTRL_CHANNEL_OUTPUT_FORMAT_CHANNEL1_48BIT      3
+#define DISPLAY_CTRL_HDMI_CLK                   19:19
+#define DISPLAY_CTRL_HDMI_CLK_NEG               0
+#define DISPLAY_CTRL_HDMI_CLK_POS               1
+#define DISPLAY_CTRL_HDMI_SELECT				18:18
+#define DISPLAY_CTRL_HDMI_SELECT_CHANNEL0		0
+#define DISPLAY_CTRL_HDMI_SELECT_CHANNEL1		1
+#define DISPLAY_CTRL_LVDS_OUTPUT_FORMAT						17:16
+#define DISPLAY_CTRL_LVDS_OUTPUT_FORMAT_CHANNEL0_24BIT		0
+#define DISPLAY_CTRL_LVDS_OUTPUT_FORMAT_CHANNEL1_24BIT		1
+#define DISPLAY_CTRL_LVDS_OUTPUT_FORMAT_CHANNEL0_48BIT		2
+#define DISPLAY_CTRL_LVDS_OUTPUT_FORMAT_CHANNEL1_48BIT		3
+#define DISPLAY_CTRL_PIXEL_CLOCK_SELECT         15:15
+#define DISPLAY_CTRL_PIXEL_CLOCK_SELECT_SINGLE  0
+#define DISPLAY_CTRL_PIXEL_CLOCK_SELECT_HALF    1
+#define DISPLAY_CTRL_CLOCK_PHASE                14:14
+#define DISPLAY_CTRL_CLOCK_PHASE_ACTIVE_HIGH    0
+#define DISPLAY_CTRL_CLOCK_PHASE_ACTIVE_LOW     1
+#define DISPLAY_CTRL_VSYNC_PHASE                13:13
+#define DISPLAY_CTRL_VSYNC_PHASE_ACTIVE_HIGH    0
+#define DISPLAY_CTRL_VSYNC_PHASE_ACTIVE_LOW     1
+#define DISPLAY_CTRL_HSYNC_PHASE                12:12
+#define DISPLAY_CTRL_HSYNC_PHASE_ACTIVE_HIGH    0
+#define DISPLAY_CTRL_HSYNC_PHASE_ACTIVE_LOW     1
+#define DISPLAY_CTRL_DOUBLE_PIXEL_CLOCK         11:11
+#define DISPLAY_CTRL_DOUBLE_PIXEL_CLOCK_DISABLE 0
+#define DISPLAY_CTRL_DOUBLE_PIXEL_CLOCK_ENABLE  1
+#define DISPLAY_CTRL_VSYNC						11:11
+#define DISPLAY_CTRL_VSYNC_INACTIVE				0
+#define DISPLAY_CTRL_VSYNC_ACTIVE				1
+#define DISPLAY_CTRL_DAC_FORMAT	             10:10
+#define DISPLAY_CTRL_DAC_FORMAT_6BIT		     0
+#define DISPLAY_CTRL_DAC_FORMAT_8BIT		     1
+#define DISPLAY_CTRL_COLOR_KEY                  9:9
+#define DISPLAY_CTRL_COLOR_KEY_DISABLE          0
+#define DISPLAY_CTRL_COLOR_KEY_ENABLE           1
+#define DISPLAY_CTRL_TIMING                     8:8
+#define DISPLAY_CTRL_TIMING_DISABLE             0
+#define DISPLAY_CTRL_TIMING_ENABLE              1
+#define DISPLAY_CTRL_PIXEL                      7:4
+#define DISPLAY_CTRL_GAMMA                      3:3
+#define DISPLAY_CTRL_GAMMA_DISABLE              0
+#define DISPLAY_CTRL_GAMMA_ENABLE               1
+#define DISPLAY_CTRL_PLANE                      2:2
+#define DISPLAY_CTRL_PLANE_DISABLE              0
+#define DISPLAY_CTRL_PLANE_ENABLE               1
+#define DISPLAY_CTRL_FORMAT                     1:0
+#define DISPLAY_CTRL_FORMAT_8                   0
+#define DISPLAY_CTRL_FORMAT_16                  1
+#define DISPLAY_CTRL_FORMAT_32                  2
+
+#define FB_ADDRESS                              0x080004
+#define FB_ADDRESS_STATUS                       31:31
+#define FB_ADDRESS_STATUS_CURRENT               0
+#define FB_ADDRESS_STATUS_PENDING               1
+#define FB_ADDRESS_ADDRESS                      29:0
+
+#define CHANNEL1_FB_ADDRESS   					0x088004
+#define CHANNEL1_FB_ADDRESS_STATUS                       31:31
+#define CHANNEL1_FB_ADDRESS_STATUS_CURRENT               0
+#define CHANNEL1_FB_ADDRESS_STATUS_PENDING               1
+#define CHANNEL1_FB_ADDRESS_ADDRESS                      29:0
+
+
+
+#define FB_WIDTH                                0x080008
+#define FB_WIDTH_WIDTH                          29:16
+#define FB_WIDTH_OFFSET                         13:0
+
+#define HORIZONTAL_TOTAL                        0x08000C
+#define HORIZONTAL_TOTAL_TOTAL                  28:16
+#define HORIZONTAL_TOTAL_DISPLAY_END            11:0
+
+#define HORIZONTAL_SYNC                         0x080010
+#define HORIZONTAL_SYNC_WIDTH                   25:16
+#define HORIZONTAL_SYNC_START                   12:0
+
+#define VERTICAL_TOTAL                          0x080014
+#define VERTICAL_TOTAL_TOTAL                    27:16
+#define VERTICAL_TOTAL_DISPLAY_END              11:0
+
+#define VERTICAL_SYNC                           0x080018
+#define VERTICAL_SYNC_HEIGHT                    21:16
+#define VERTICAL_SYNC_START                     11:0
+
+#define CURRENT_LINE                            0x080020
+#define CURRENT_LINE_LINE                       11:0
+
+#define LVDS_CTRL1				0x080020
+#define LVDS_CTRL1_CLKSEL_PLL2			31:31
+#define LVDS_CTRL1_CLKSEL_PLL2_RE		0
+#define LVDS_CTRL1_CLKSEL_PLL2_FE		1
+#define LVDS_CTRL1_CLKSEL_PLL1			30:30
+#define LVDS_CTRL1_CLKSEL_PLL1_RE		0
+#define LVDS_CTRL1_CLKSEL_PLL1_FE		1
+#define LVDS_CTRL1_DCLK2			29:23
+#define LVDS_CTRL1_DCLK2_DEFAULT		0x63
+#define LVDS_CTRL1_DCLK1			22:16
+#define LVDS_CTRL1_DCLK1_DEFAULT		0x63
+#define LVDS_CTRL1_PLL2_LOCK			15:15
+#define LVDS_CTRL1_PLL1_LOCK			14:14
+#define LVDS_CTRL1_POR25			13:13
+#define LVDS_CTRL1_POR12			12:12
+
+#define CRT_DETECT                     0x080024
+#define CRT_DETECT_DAC				   31:31
+#define CRT_DETECT_DAC_ENABLE		   0
+#define CRT_DETECT_DAC_DOWN			   1
+#define CRT_DETECT_CRT_CLK             27:27
+#define CRT_DETECT_CRT_CLK_POS         0
+#define CRT_DETECT_CRT_CLK_NEG         1   
+#define CRT_DETECT_LVDS_CLK            26:26
+#define CRT_DETECT_LVDS_CLK_POS		   0
+#define CRT_DETECT_LVDS_CLK_NEG		   1
+#define CRT_DETECT_CRT                 25:25
+#define CRT_DETECT_CRT_ABSENT          0
+#define CRT_DETECT_CRT_PRESENT         1
+#define CRT_DETECT_ENABLE              24:24
+#define CRT_DETECT_ENABLE_DISABLE      0
+#define CRT_DETECT_ENABLE_ENABLE       1
+#define CRT_DETECT_DATA_RED            23:16
+#define CRT_DETECT_DATA_GREEN          15:8
+#define CRT_DETECT_DATA_BLUE           7:0
+
+#define COLOR_KEY                               0x080028
+#define COLOR_KEY_MASK                          31:16
+#define COLOR_KEY_VALUE                         15:0
+
+
+#define LVDS_CTRL2					0x08002C
+#define LVDS_CTRL2_SHTDNB2				30:30
+#define LVDS_CTRL2_SHTDNB2_RESET			0
+#define LVDS_CTRL2_SHTDNB2_NORMAL			1
+#define LVDS_CTRL2_SHTDNB1				29:29
+#define LVDS_CTRL2_SHTDNB1_RESET			0
+#define LVDS_CTRL2_SHTDNB1_NORMAL			1
+#define LVDS_CTRL2_CLK2_DS 				28:27
+#define LVDS_CTRL2_CLK2_DS_3MA				0
+#define LVDS_CTRL2_CLK2_DS_1MA				1
+#define LVDS_CTRL2_CLK2_DS_5MA				2
+#define LVDS_CTRL2_CLK2_DS_2MA				3
+#define LVDS_CTRL2_CLK1_DS 				26:25
+#define LVDS_CTRL2_CLK1_DS_3MA				0
+#define LVDS_CTRL2_CLK1_DS_1MA				1
+#define LVDS_CTRL2_CLK1_DS_5MA				2
+#define LVDS_CTRL2_CLK1_DS_2MA				3
+#define LVDS_CTRL2_DS					24:23
+#define LVDS_CTRL2_DS_3MA				0
+#define LVDS_CTRL2_DS_1MA				1
+#define LVDS_CTRL2_DS_5MA				2
+#define LVDS_CTRL2_DS_2MA				3
+#define LVDS_CTRL2_CLK2_TR				22:22
+#define LVDS_CTRL2_CLK2_TR_0				0
+#define LVDS_CTRL2_CLK2_TR_100				1
+#define LVDS_CTRL2_CLK1_TR				21:21
+#define LVDS_CTRL2_CLK1_TR_0				0
+#define LVDS_CTRL2_CLK1_TR_100				1
+#define LVDS_CTRL2_TR					20:20
+#define LVDS_CTRL2_TR_0					0
+#define LVDS_CTRL2_TR_100				1
+#define LVDS_CTRL2_CLK2_COMP				19:18
+#define LVDS_CTRL2_CLK2_COMP_0				0
+#define LVDS_CTRL2_CLK2_COMP_1				1
+#define LVDS_CTRL2_CLK2_COMP_2				2
+#define LVDS_CTRL2_CLK2_COMP_3				3
+#define LVDS_CTRL2_CLK1_COMP				17:16
+#define LVDS_CTRL2_CLK1_COMP_0				0
+#define LVDS_CTRL2_CLK1_COMP_1				1
+#define LVDS_CTRL2_CLK1_COMP_2				2
+#define LVDS_CTRL2_CLK1_COMP_3				3
+#define LVDS_CTRL2_PRE_COMP				15:14
+#define LVDS_CTRL2_PRE_COMP_0				0
+#define LVDS_CTRL2_PRE_COMP_1				1
+#define LVDS_CTRL2_PRE_COMP_2				2
+#define LVDS_CTRL2_PRE_COMP_3				3
+#define LVDS_CTRL2_VCOS_PLL2				13:11
+#define LVDS_CTRL2_VCOS_PLL2_10M			0
+#define LVDS_CTRL2_VCOS_PLL2_20M			1
+#define LVDS_CTRL2_VCOS_PLL2_40M			2
+#define LVDS_CTRL2_VCOS_PLL2_80M			3
+#define LVDS_CTRL2_VCOS_PLL2_160M			4
+#define LVDS_CTRL2_VCOS_PLL2_350M			5
+#define LVDS_CTRL2_VCOS_PLL1				10:8
+#define LVDS_CTRL2_VCOS_PLL1_10M			0
+#define LVDS_CTRL2_VCOS_PLL1_20M			1
+#define LVDS_CTRL2_VCOS_PLL1_40M			2
+#define LVDS_CTRL2_VCOS_PLL1_80M			3
+#define LVDS_CTRL2_VCOS_PLL1_160M			4
+#define LVDS_CTRL2_VCOS_PLL1_350M			5
+#define LVDS_CTRL2_SHORTS_PLL2				7:6
+#define LVDS_CTRL2_SHORTS_PLL2_2048			0
+#define LVDS_CTRL2_SHORTS_PLL2_1024			1
+#define LVDS_CTRL2_SHORTS_PLL2_512			2
+#define LVDS_CTRL2_SHORTS_PLL2_256			3
+#define LVDS_CTRL2_SHORTS_PLL1				5:4
+#define LVDS_CTRL2_SHORTS_PLL1_2048			0
+#define LVDS_CTRL2_SHORTS_PLL1_1024			1
+#define LVDS_CTRL2_SHORTS_PLL1_512			2
+#define LVDS_CTRL2_SHORTS_PLL1_256			3
+#define LVDS_CTRL2_PD_PLL2				3:3
+#define LVDS_CTRL2_PD_PLL2_NORMAL			0
+#define LVDS_CTRL2_PD_PLL2_DOWN				1
+#define LVDS_CTRL2_PD_PLL1				2:2
+#define LVDS_CTRL2_PD_PLL1_NORMAL			0
+#define LVDS_CTRL2_PD_PLL1_DOWN				1
+#define LVDS_CTRL2_MODESEL2				1:1
+#define LVDS_CTRL2_MODESEL2_DC0				0
+#define LVDS_CTRL2_MODESEL2_DC1				1
+#define LVDS_CTRL2_MODESEL1				0:0
+#define LVDS_CTRL2_MODESEL1_DC0				0
+#define LVDS_CTRL2_MODESEL1_DC1				1
+
+/* Cursor Control */
+#define HWC_CONTROL                             0x080030
+#define HWC_CONTROL_MODE                        31:30
+#define HWC_CONTROL_MODE_DISABLE                0
+#define HWC_CONTROL_MODE_MASK                   1
+#define HWC_CONTROL_MODE_MONO                   2
+#define HWC_CONTROL_MODE_ALPHA                  3
+#define HWC_CONTROL_ADDRESS                     29:0
+
+#define HWC_LOCATION                            0x080034
+#define HWC_LOCATION_TOP                        31:31
+#define HWC_LOCATION_TOP_INSIDE                 0
+#define HWC_LOCATION_TOP_OUTSIDE                1
+#define HWC_LOCATION_Y                          27:16
+#define HWC_LOCATION_LEFT                       15:15
+#define HWC_LOCATION_LEFT_INSIDE                0
+#define HWC_LOCATION_LEFT_OUTSIDE               1
+#define HWC_LOCATION_X                          11:0
+
+#define HWC_COLOR0                              0x080038
+#define HWC_COLOR0_RGB888                       23:0
+
+#define HWC_COLOR1                              0x08003C
+#define HWC_COLOR1_RGB888                       23:0
+
+
+/* Channel0 Cursor Control */
+#define CHANNEL0_HWC_ADDRESS                             0x080030
+#define CHANNEL0_HWC_ADDRESS_ENABLE                      31:30
+#define CHANNEL0_HWC_ADDRESS_ENABLE_DISABLE              0
+#define CHANNEL0_HWC_ADDRESS_ENABLE_MASK	             1
+#define CHANNEL0_HWC_ADDRESS_ENABLE_MONO	             2
+#define CHANNEL0_HWC_ADDRESS_ENABLE_ALPHA	             3
+#define CHANNEL0_HWC_ADDRESS_ADDRESS                     29:0
+
+#define CHANNEL0_HWC_LOCATION                            0x080034
+#define CHANNEL0_HWC_LOCATION_TOP                        31:31
+#define CHANNEL0_HWC_LOCATION_TOP_INSIDE                 0
+#define CHANNEL0_HWC_LOCATION_TOP_OUTSIDE                1
+#define CHANNEL0_HWC_LOCATION_Y                          27:16
+#define CHANNEL0_HWC_LOCATION_LEFT                       15:15
+#define CHANNEL0_HWC_LOCATION_LEFT_INSIDE                0
+#define CHANNEL0_HWC_LOCATION_LEFT_OUTSIDE               1
+#define CHANNEL0_HWC_LOCATION_X                          11:0
+
+#define CHANNEL0_HWC_COLOR_0                            0x080038
+#define CHANNEL0_HWC_COLOR_0_RGB888		                23:0
+
+#define CHANNEL0_HWC_COLOR_1                            0x08003C
+#define CHANNEL0_HWC_COLOR_1_RGB888                   	23:0
+
+/* Channel1 Cursor Control */
+#define CHANNEL1_HWC_ADDRESS                             0x088030
+#define CHANNEL1_HWC_ADDRESS_ENABLE                      31:30
+#define CHANNEL1_HWC_ADDRESS_ENABLE_DISABLE              0
+#define CHANNEL1_HWC_ADDRESS_ENABLE_MASK	             1
+#define CHANNEL1_HWC_ADDRESS_ENABLE_MONO	             2
+#define CHANNEL1_HWC_ADDRESS_ENABLE_ALPHA	             3
+#define CHANNEL1_HWC_ADDRESS_ADDRESS                     29:0
+
+#define CHANNEL1_HWC_LOCATION                            0x088034
+#define CHANNEL1_HWC_LOCATION_TOP                        31:31
+#define CHANNEL1_HWC_LOCATION_TOP_INSIDE                 0
+#define CHANNEL1_HWC_LOCATION_TOP_OUTSIDE                1
+#define CHANNEL1_HWC_LOCATION_Y                          27:16
+#define CHANNEL1_HWC_LOCATION_LEFT                       15:15
+#define CHANNEL1_HWC_LOCATION_LEFT_INSIDE                0
+#define CHANNEL1_HWC_LOCATION_LEFT_OUTSIDE               1
+#define CHANNEL1_HWC_LOCATION_X                          11:0
+
+#define CHANNEL1_HWC_COLOR_0                            0x088038
+#define CHANNEL1_HWC_COLOR_0_RGB888		                23:0
+
+#define CHANNEL1_HWC_COLOR_1                            0x08803C
+#define CHANNEL1_HWC_COLOR_1_RGB888                   	23:0
+
+
+/* Video Control */
+#define VIDEO_DISPLAY_CTRL                              0x080040
+#define VIDEO_DISPLAY_CTRL_BYTE_SWAP                    12:12
+#define VIDEO_DISPLAY_CTRL_BYTE_SWAP_DISABLE            0
+#define VIDEO_DISPLAY_CTRL_BYTE_SWAP_ENABLE             1
+#define VIDEO_DISPLAY_CTRL_VERTICAL_MODE                9:9
+#define VIDEO_DISPLAY_CTRL_VERTICAL_MODE_REPLICATE      0
+#define VIDEO_DISPLAY_CTRL_VERTICAL_MODE_INTERPOLATE    1
+#define VIDEO_DISPLAY_CTRL_HORIZONTAL_MODE              8:8
+#define VIDEO_DISPLAY_CTRL_HORIZONTAL_MODE_REPLICATE    0
+#define VIDEO_DISPLAY_CTRL_HORIZONTAL_MODE_INTERPOLATE  1
+#define VIDEO_DISPLAY_CTRL_PIXEL                        7:4
+#define VIDEO_DISPLAY_CTRL_GAMMA                        3:3
+#define VIDEO_DISPLAY_CTRL_GAMMA_DISABLE                0
+#define VIDEO_DISPLAY_CTRL_GAMMA_ENABLE                 1
+#define VIDEO_DISPLAY_CTRL_PLANE                        2:2
+#define VIDEO_DISPLAY_CTRL_PLANE_DISABLE                0
+#define VIDEO_DISPLAY_CTRL_PLANE_ENABLE                 1
+#define VIDEO_DISPLAY_CTRL_FORMAT                       1:0
+#define VIDEO_DISPLAY_CTRL_FORMAT_16                    0
+#define VIDEO_DISPLAY_CTRL_FORMAT_32                    1
+#define VIDEO_DISPLAY_CTRL_FORMAT_YUV422                2
+#define VIDEO_DISPLAY_CTRL_FORMAT_YUV420                3
+
+#define VIDEO_FB_ADDRESS                              0x080044
+#define VIDEO_FB_ADDRESS_STATUS                       31:31
+#define VIDEO_FB_ADDRESS_STATUS_CURRENT               0
+#define VIDEO_FB_ADDRESS_STATUS_PENDING               1
+#define VIDEO_FB_ADDRESS_ADDRESS                      29:0
+
+#define VIDEO_FB_WIDTH                                0x080048
+#define VIDEO_FB_WIDTH_WIDTH                          29:16
+#define VIDEO_FB_WIDTH_OFFSET                         13:0
+
+#define VIDEO_FB_ADDRESS_Y                            0x080044
+#define VIDEO_FB_ADDRESS_Y_ADDRESS                    29:0
+
+#define VIDEO_FB_WIDTH_Y                              0x080048
+#define VIDEO_FB_WIDTH_Y_WIDTH                        29:16
+#define VIDEO_FB_WIDTH_Y_OFFSET                       13:0
+
+
+#define VIDEO_FB_ADDRESS_U                            0x08004C
+#define VIDEO_FB_ADDRESS_U_ADDRESS                    29:0
+
+#define VIDEO_FB_WIDTH_U                              0x080050
+#define VIDEO_FB_WIDTH_U_WIDTH                        29:16
+#define VIDEO_FB_WIDTH_U_OFFSET                       13:0
+
+#define VIDEO_FB_ADDRESS_V                            0x080054
+#define VIDEO_FB_ADDRESS_V_ADDRESS                    29:0
+
+#define VIDEO_FB_WIDTH_V                              0x080058
+#define VIDEO_FB_WIDTH_V_WIDTH                        29:16
+#define VIDEO_FB_WIDTH_V_OFFSET                       13:0
+
+#define VIDEO_YUV_CONSTANTS                           0x08005C
+#define VIDEO_YUV_CONSTANTS_Y                         31:24
+#define VIDEO_YUV_CONSTANTS_R                         23:16
+#define VIDEO_YUV_CONSTANTS_G                         15:8
+#define VIDEO_YUV_CONSTANTS_B                         7:0
+
+#define VIDEO_PLANE_TL                                  0x080060
+#define VIDEO_PLANE_TL_TOP                              26:16
+#define VIDEO_PLANE_TL_LEFT                             11:0
+
+#define VIDEO_PLANE_BR                                  0x080064
+#define VIDEO_PLANE_BR_BOTTOM                           26:16
+#define VIDEO_PLANE_BR_RIGHT                            11:0
+
+#define VIDEO_SCALE                                     0x080068
+#define VIDEO_SCALE_VERTICAL_SCALE                      27:16
+#define VIDEO_SCALE_HORIZONTAL_SCALE                    11:0
+
+#define VIDEO_INITIAL_SCALE                             0x08006C
+#define VIDEO_INITIAL_SCALE_VERTICAL                    27:16
+#define VIDEO_INITIAL_SCALE_HORIZONTAL                     11:0
+
+/* Video Alpha Control */
+#if 1
+#define VIDEO_ALPHA_DISPLAY_CTRL                        0x080080
+#define VIDEO_ALPHA_DISPLAY_CTRL_SELECT                 28:28
+#define VIDEO_ALPHA_DISPLAY_CTRL_SELECT_PER_PIXEL       0
+#define VIDEO_ALPHA_DISPLAY_CTRL_SELECT_ALPHA           1
+#define VIDEO_ALPHA_DISPLAY_CTRL_ALPHA                  27:24
+#define VIDEO_ALPHA_DISPLAY_CTRL_FIFO                   17:16
+#define VIDEO_ALPHA_DISPLAY_CTRL_FIFO_1                 0
+#define VIDEO_ALPHA_DISPLAY_CTRL_FIFO_3                 1
+#define VIDEO_ALPHA_DISPLAY_CTRL_FIFO_7                 2
+#define VIDEO_ALPHA_DISPLAY_CTRL_FIFO_11                3
+#define VIDEO_ALPHA_DISPLAY_CTRL_PIXEL                  7:4
+#define VIDEO_ALPHA_DISPLAY_CTRL_CHROMA_KEY             3:3
+#define VIDEO_ALPHA_DISPLAY_CTRL_CHROMA_KEY_DISABLE     0
+#define VIDEO_ALPHA_DISPLAY_CTRL_CHROMA_KEY_ENABLE      1
+#define VIDEO_ALPHA_DISPLAY_CTRL_PLANE                  2:2
+#define VIDEO_ALPHA_DISPLAY_CTRL_PLANE_DISABLE          0
+#define VIDEO_ALPHA_DISPLAY_CTRL_PLANE_ENABLE           1
+#define VIDEO_ALPHA_DISPLAY_CTRL_FORMAT                 1:0
+#define VIDEO_ALPHA_DISPLAY_CTRL_FORMAT_8               0
+#define VIDEO_ALPHA_DISPLAY_CTRL_FORMAT_16              1
+#define VIDEO_ALPHA_DISPLAY_CTRL_FORMAT_ALPHA_4_4       2
+#define VIDEO_ALPHA_DISPLAY_CTRL_FORMAT_ALPHA_4_4_4_4   3
+
+#define VIDEO_ALPHA_FB_ADDRESS                          0x080084
+#define VIDEO_ALPHA_FB_ADDRESS_STATUS                   31:31
+#define VIDEO_ALPHA_FB_ADDRESS_STATUS_CURRENT           0
+#define VIDEO_ALPHA_FB_ADDRESS_STATUS_PENDING           1
+#define VIDEO_ALPHA_FB_ADDRESS_ADDRESS                  29:0
+
+#define VIDEO_ALPHA_FB_WIDTH                            0x080088
+#define VIDEO_ALPHA_FB_WIDTH_WIDTH                      29:16
+#define VIDEO_ALPHA_FB_WIDTH_OFFSET                     13:0
+
+#define VIDEO_ALPHA_PLANE_TL                            0x08008C
+#define VIDEO_ALPHA_PLANE_TL_TOP                        26:16
+#define VIDEO_ALPHA_PLANE_TL_LEFT                       11:0
+
+#define VIDEO_ALPHA_PLANE_BR                            0x080090
+#define VIDEO_ALPHA_PLANE_BR_BOTTOM                     26:16
+#define VIDEO_ALPHA_PLANE_BR_RIGHT                      11:0
+
+#define VIDEO_ALPHA_CHROMA_KEY                          0x080094
+#define VIDEO_ALPHA_CHROMA_KEY_MASK                     31:16
+#define VIDEO_ALPHA_CHROMA_KEY_VALUE                    15:0
+
+#define VIDEO_ALPHA_COLOR_LOOKUP_01                     0x080098
+#define VIDEO_ALPHA_COLOR_LOOKUP_01_1                   31:16
+#define VIDEO_ALPHA_COLOR_LOOKUP_01_1_RED               31:27
+#define VIDEO_ALPHA_COLOR_LOOKUP_01_1_GREEN             26:21
+#define VIDEO_ALPHA_COLOR_LOOKUP_01_1_BLUE              20:16
+#define VIDEO_ALPHA_COLOR_LOOKUP_01_0                   15:0
+#define VIDEO_ALPHA_COLOR_LOOKUP_01_0_RED               15:11
+#define VIDEO_ALPHA_COLOR_LOOKUP_01_0_GREEN             10:5
+#define VIDEO_ALPHA_COLOR_LOOKUP_01_0_BLUE              4:0
+
+#define VIDEO_ALPHA_COLOR_LOOKUP_23                     0x08009C
+#define VIDEO_ALPHA_COLOR_LOOKUP_23_3                   31:16
+#define VIDEO_ALPHA_COLOR_LOOKUP_23_3_RED               31:27
+#define VIDEO_ALPHA_COLOR_LOOKUP_23_3_GREEN             26:21
+#define VIDEO_ALPHA_COLOR_LOOKUP_23_3_BLUE              20:16
+#define VIDEO_ALPHA_COLOR_LOOKUP_23_2                   15:0
+#define VIDEO_ALPHA_COLOR_LOOKUP_23_2_RED               15:11
+#define VIDEO_ALPHA_COLOR_LOOKUP_23_2_GREEN             10:5
+#define VIDEO_ALPHA_COLOR_LOOKUP_23_2_BLUE              4:0
+
+#define VIDEO_ALPHA_COLOR_LOOKUP_45                     0x0800A0
+#define VIDEO_ALPHA_COLOR_LOOKUP_45_5                   31:16
+#define VIDEO_ALPHA_COLOR_LOOKUP_45_5_RED               31:27
+#define VIDEO_ALPHA_COLOR_LOOKUP_45_5_GREEN             26:21
+#define VIDEO_ALPHA_COLOR_LOOKUP_45_5_BLUE              20:16
+#define VIDEO_ALPHA_COLOR_LOOKUP_45_4                   15:0
+#define VIDEO_ALPHA_COLOR_LOOKUP_45_4_RED               15:11
+#define VIDEO_ALPHA_COLOR_LOOKUP_45_4_GREEN             10:5
+#define VIDEO_ALPHA_COLOR_LOOKUP_45_4_BLUE              4:0
+
+#define VIDEO_ALPHA_COLOR_LOOKUP_67                     0x0800A4
+#define VIDEO_ALPHA_COLOR_LOOKUP_67_7                   31:16
+#define VIDEO_ALPHA_COLOR_LOOKUP_67_7_RED               31:27
+#define VIDEO_ALPHA_COLOR_LOOKUP_67_7_GREEN             26:21
+#define VIDEO_ALPHA_COLOR_LOOKUP_67_7_BLUE              20:16
+#define VIDEO_ALPHA_COLOR_LOOKUP_67_6                   15:0
+#define VIDEO_ALPHA_COLOR_LOOKUP_67_6_RED               15:11
+#define VIDEO_ALPHA_COLOR_LOOKUP_67_6_GREEN             10:5
+#define VIDEO_ALPHA_COLOR_LOOKUP_67_6_BLUE              4:0
+
+#define VIDEO_ALPHA_COLOR_LOOKUP_89                     0x0800A8
+#define VIDEO_ALPHA_COLOR_LOOKUP_89_9                   31:16
+#define VIDEO_ALPHA_COLOR_LOOKUP_89_9_RED               31:27
+#define VIDEO_ALPHA_COLOR_LOOKUP_89_9_GREEN             26:21
+#define VIDEO_ALPHA_COLOR_LOOKUP_89_9_BLUE              20:16
+#define VIDEO_ALPHA_COLOR_LOOKUP_89_8                   15:0
+#define VIDEO_ALPHA_COLOR_LOOKUP_89_8_RED               15:11
+#define VIDEO_ALPHA_COLOR_LOOKUP_89_8_GREEN             10:5
+#define VIDEO_ALPHA_COLOR_LOOKUP_89_8_BLUE              4:0
+
+#define VIDEO_ALPHA_COLOR_LOOKUP_AB                     0x0800AC
+#define VIDEO_ALPHA_COLOR_LOOKUP_AB_B                   31:16
+#define VIDEO_ALPHA_COLOR_LOOKUP_AB_B_RED               31:27
+#define VIDEO_ALPHA_COLOR_LOOKUP_AB_B_GREEN             26:21
+#define VIDEO_ALPHA_COLOR_LOOKUP_AB_B_BLUE              20:16
+#define VIDEO_ALPHA_COLOR_LOOKUP_AB_A                   15:0
+#define VIDEO_ALPHA_COLOR_LOOKUP_AB_A_RED               15:11
+#define VIDEO_ALPHA_COLOR_LOOKUP_AB_A_GREEN             10:5
+#define VIDEO_ALPHA_COLOR_LOOKUP_AB_A_BLUE              4:0
+
+#define VIDEO_ALPHA_COLOR_LOOKUP_CD                     0x0800B0
+#define VIDEO_ALPHA_COLOR_LOOKUP_CD_D                   31:16
+#define VIDEO_ALPHA_COLOR_LOOKUP_CD_D_RED               31:27
+#define VIDEO_ALPHA_COLOR_LOOKUP_CD_D_GREEN             26:21
+#define VIDEO_ALPHA_COLOR_LOOKUP_CD_D_BLUE              20:16
+#define VIDEO_ALPHA_COLOR_LOOKUP_CD_C                   15:0
+#define VIDEO_ALPHA_COLOR_LOOKUP_CD_C_RED               15:11
+#define VIDEO_ALPHA_COLOR_LOOKUP_CD_C_GREEN             10:5
+#define VIDEO_ALPHA_COLOR_LOOKUP_CD_C_BLUE              4:0
+
+#define VIDEO_ALPHA_COLOR_LOOKUP_EF                     0x0800B4
+#define VIDEO_ALPHA_COLOR_LOOKUP_EF_F                   31:16
+#define VIDEO_ALPHA_COLOR_LOOKUP_EF_F_RED               31:27
+#define VIDEO_ALPHA_COLOR_LOOKUP_EF_F_GREEN             26:21
+#define VIDEO_ALPHA_COLOR_LOOKUP_EF_F_BLUE              20:16
+#define VIDEO_ALPHA_COLOR_LOOKUP_EF_E                   15:0
+#define VIDEO_ALPHA_COLOR_LOOKUP_EF_E_RED               15:11
+#define VIDEO_ALPHA_COLOR_LOOKUP_EF_E_GREEN             10:5
+#define VIDEO_ALPHA_COLOR_LOOKUP_EF_E_BLUE              4:0
+#endif
+
+/* Alpha Control */
+
+#define ALPHA_DISPLAY_CTRL                              0x080080
+#define ALPHA_DISPLAY_CTRL_SELECT                       28:28
+#define ALPHA_DISPLAY_CTRL_SELECT_PER_PIXEL             0
+#define ALPHA_DISPLAY_CTRL_SELECT_ALPHA                 1
+#define ALPHA_DISPLAY_CTRL_ALPHA                        27:24
+#define ALPHA_DISPLAY_CTRL_FIFO                         17:16
+#define ALPHA_DISPLAY_CTRL_FIFO_1                       0
+#define ALPHA_DISPLAY_CTRL_FIFO_3                       1
+#define ALPHA_DISPLAY_CTRL_FIFO_7                       2
+#define ALPHA_DISPLAY_CTRL_FIFO_11                      3
+#define ALPHA_DISPLAY_CTRL_PIXEL                        7:4
+#define ALPHA_DISPLAY_CTRL_CHROMA_KEY                   3:3
+#define ALPHA_DISPLAY_CTRL_CHROMA_KEY_DISABLE           0
+#define ALPHA_DISPLAY_CTRL_CHROMA_KEY_ENABLE            1
+#define ALPHA_DISPLAY_CTRL_PLANE                        2:2
+#define ALPHA_DISPLAY_CTRL_PLANE_DISABLE                0
+#define ALPHA_DISPLAY_CTRL_PLANE_ENABLE                 1
+#define ALPHA_DISPLAY_CTRL_FORMAT                       1:0
+#define ALPHA_DISPLAY_CTRL_FORMAT_16                    1
+#define ALPHA_DISPLAY_CTRL_FORMAT_ALPHA_4_4             2
+#define ALPHA_DISPLAY_CTRL_FORMAT_ALPHA_4_4_4_4         3
+
+#define ALPHA_FB_ADDRESS                                0x080084
+#define ALPHA_FB_ADDRESS_STATUS                         31:31
+#define ALPHA_FB_ADDRESS_STATUS_CURRENT                 0
+#define ALPHA_FB_ADDRESS_STATUS_PENDING                 1
+#define ALPHA_FB_ADDRESS_ADDRESS                        29:0
+
+#define ALPHA_FB_WIDTH                                  0x080088
+#define ALPHA_FB_WIDTH_WIDTH                            29:16
+#define ALPHA_FB_WIDTH_OFFSET                           13:0
+
+#define ALPHA_PLANE_TL                                  0x08008C
+#define ALPHA_PLANE_TL_TOP                              26:16
+#define ALPHA_PLANE_TL_LEFT                             10:0
+
+#define ALPHA_PLANE_BR                                  0x080090
+#define ALPHA_PLANE_BR_BOTTOM                           26:16
+#define ALPHA_PLANE_BR_RIGHT                            10:0
+
+#define ALPHA_CHROMA_KEY                                0x080094
+#define ALPHA_CHROMA_KEY_MASK                           31:16
+#define ALPHA_CHROMA_KEY_VALUE                          15:0
+
+#define ALPHA_COLOR_LOOKUP_01                           0x080098
+#define ALPHA_COLOR_LOOKUP_01_1                         31:16
+#define ALPHA_COLOR_LOOKUP_01_1_RED                     31:27
+#define ALPHA_COLOR_LOOKUP_01_1_GREEN                   26:21
+#define ALPHA_COLOR_LOOKUP_01_1_BLUE                    20:16
+#define ALPHA_COLOR_LOOKUP_01_0                         15:0
+#define ALPHA_COLOR_LOOKUP_01_0_RED                     15:11
+#define ALPHA_COLOR_LOOKUP_01_0_GREEN                   10:5
+#define ALPHA_COLOR_LOOKUP_01_0_BLUE                    4:0
+
+#define ALPHA_COLOR_LOOKUP_23                           0x08009C
+#define ALPHA_COLOR_LOOKUP_23_3                         31:16
+#define ALPHA_COLOR_LOOKUP_23_3_RED                     31:27
+#define ALPHA_COLOR_LOOKUP_23_3_GREEN                   26:21
+#define ALPHA_COLOR_LOOKUP_23_3_BLUE                    20:16
+#define ALPHA_COLOR_LOOKUP_23_2                         15:0
+#define ALPHA_COLOR_LOOKUP_23_2_RED                     15:11
+#define ALPHA_COLOR_LOOKUP_23_2_GREEN                   10:5
+#define ALPHA_COLOR_LOOKUP_23_2_BLUE                    4:0
+
+#define ALPHA_COLOR_LOOKUP_45                           0x0800a0
+#define ALPHA_COLOR_LOOKUP_45_5                         31:16
+#define ALPHA_COLOR_LOOKUP_45_5_RED                     31:27
+#define ALPHA_COLOR_LOOKUP_45_5_GREEN                   26:21
+#define ALPHA_COLOR_LOOKUP_45_5_BLUE                    20:16
+#define ALPHA_COLOR_LOOKUP_45_4                         15:0
+#define ALPHA_COLOR_LOOKUP_45_4_RED                     15:11
+#define ALPHA_COLOR_LOOKUP_45_4_GREEN                   10:5
+#define ALPHA_COLOR_LOOKUP_45_4_BLUE                    4:0
+
+#define ALPHA_COLOR_LOOKUP_67                           0x0800a4
+#define ALPHA_COLOR_LOOKUP_67_7                         31:16
+#define ALPHA_COLOR_LOOKUP_67_7_RED                     31:27
+#define ALPHA_COLOR_LOOKUP_67_7_GREEN                   26:21
+#define ALPHA_COLOR_LOOKUP_67_7_BLUE                    20:16
+#define ALPHA_COLOR_LOOKUP_67_6                         15:0
+#define ALPHA_COLOR_LOOKUP_67_6_RED                     15:11
+#define ALPHA_COLOR_LOOKUP_67_6_GREEN                   10:5
+#define ALPHA_COLOR_LOOKUP_67_6_BLUE                    4:0
+
+#define ALPHA_COLOR_LOOKUP_89                           0x0800a8
+#define ALPHA_COLOR_LOOKUP_89_9                         31:16
+#define ALPHA_COLOR_LOOKUP_89_9_RED                     31:27
+#define ALPHA_COLOR_LOOKUP_89_9_GREEN                   26:21
+#define ALPHA_COLOR_LOOKUP_89_9_BLUE                    20:16
+#define ALPHA_COLOR_LOOKUP_89_8                         15:0
+#define ALPHA_COLOR_LOOKUP_89_8_RED                     15:11
+#define ALPHA_COLOR_LOOKUP_89_8_GREEN                   10:5
+#define ALPHA_COLOR_LOOKUP_89_8_BLUE                    4:0
+
+#define ALPHA_COLOR_LOOKUP_AB                           0x0800AC
+#define ALPHA_COLOR_LOOKUP_AB_B                         31:16
+#define ALPHA_COLOR_LOOKUP_AB_B_RED                     31:27
+#define ALPHA_COLOR_LOOKUP_AB_B_GREEN                   26:21
+#define ALPHA_COLOR_LOOKUP_AB_B_BLUE                    20:16
+#define ALPHA_COLOR_LOOKUP_AB_A                         15:0
+#define ALPHA_COLOR_LOOKUP_AB_A_RED                     15:11
+#define ALPHA_COLOR_LOOKUP_AB_A_GREEN                   10:5
+#define ALPHA_COLOR_LOOKUP_AB_A_BLUE                    4:0
+
+#define ALPHA_COLOR_LOOKUP_CD                           0x0800B0
+#define ALPHA_COLOR_LOOKUP_CD_D                         31:16
+#define ALPHA_COLOR_LOOKUP_CD_D_RED                     31:27
+#define ALPHA_COLOR_LOOKUP_CD_D_GREEN                   26:21
+#define ALPHA_COLOR_LOOKUP_CD_D_BLUE                    20:16
+#define ALPHA_COLOR_LOOKUP_CD_C                         15:0
+#define ALPHA_COLOR_LOOKUP_CD_C_RED                     15:11
+#define ALPHA_COLOR_LOOKUP_CD_C_GREEN                   10:5
+#define ALPHA_COLOR_LOOKUP_CD_C_BLUE                    4:0
+
+#define ALPHA_COLOR_LOOKUP_EF                           0x0800B4
+#define ALPHA_COLOR_LOOKUP_EF_F                         31:16
+#define ALPHA_COLOR_LOOKUP_EF_F_RED                     31:27
+#define ALPHA_COLOR_LOOKUP_EF_F_GREEN                   26:21
+#define ALPHA_COLOR_LOOKUP_EF_F_BLUE                    20:16
+#define ALPHA_COLOR_LOOKUP_EF_E                         15:0
+#define ALPHA_COLOR_LOOKUP_EF_E_RED                     15:11
+#define ALPHA_COLOR_LOOKUP_EF_E_GREEN                   10:5
+#define ALPHA_COLOR_LOOKUP_EF_E_BLUE                    4:0
+
+/* Distance between channel 1 and channel 2 display control */
+#define CHANNEL_OFFSET 0x8000
+
+#define DC_OFFSET 0x8000
+
+
+/* Palette RAM */
+/* Panel Pallete register starts at 0x080400 ~ 0x0807FC */
+#define CHANNEL0_PALETTE_RAM                             0x080C00
+#define PALETTE_RAM                             0x080C00
+
+/* Panel Pallete register starts at 0x080C00 ~ 0x080FFC */
+#define CHANNEL1_PALETTE_RAM                           0x088C00
+
+//#include "regdma.h"
+
+/* New DMA engine definition for Falcon */
+/* DMA 0 is uni-directional from Serial ROM to local DDR only */
+#define DMA0_DESTINATION                                0x0D0000
+#define DMA0_DESTINATION_ADDRESS                        29:0
+
+#define DMA0_SOURCE                                     0x0D0004
+#define DMA0_SOURCE_ADDRESS                             23:0
+
+#define DMA0_CONTROL                                    0x0D0008
+#define DMA0_CONTROL_STATUS                             31:31
+#define DMA0_CONTROL_STATUS_IDLE                        0
+#define DMA0_CONTROL_STATUS_ENABLE                      1
+#define DMA0_CONTROL_SIZE                               23:0
+
+/* DMA 1 can transfer from:
+   System to local DDR.
+   local DDR to system.
+   local DDR to local DDR.
+
+   The source is alwasy linear and the destination is always tiled.
+*/
+#define DMA1_SOURCE0                                    0x0D0010
+#define DMA1_SOURCE0_SEL                                31:31 
+#define DMA1_SOURCE0_SEL_LOCAL                          0
+#define DMA1_SOURCE0_SEL_SYSTEM                         1  
+#define DMA1_SOURCE0_DECODE                             30:30
+#define DMA1_SOURCE0_DECODE_DISABLE                     0
+#define DMA1_SOURCE0_DECODE_ENABLE                      1
+#define DMA1_SOURCE0_ADDRESS                            29:0
+
+#define DMA1_SOURCE0_SIZE                               0x0D0014
+#define DMA1_SOURCE0_SIZE_NSC_CSS                       27:27
+#define DMA1_SOURCE0_SIZE_NSC_CSS_DISABLE               0
+#define DMA1_SOURCE0_SIZE_NSC_CSS_ENABLE                1
+#define DMA1_SOURCE0_SIZE_NSC_CLL                       26:24
+#define DMA1_SOURCE0_SIZE_SIZE                          23:0
+
+#define DMA1_DESTINATION                                0x0D0018
+#define DMA1_DESTINATION_SEL                            31:31
+#define DMA1_DESTINATION_SEL_LOCAL                      0
+#define DMA1_DESTINATION_SEL_SYSTEM                     1 
+#define DMA1_DESTINATION_ADDRESS                        29:0
+
+#define DMA1_CONTROL                                    0x0D001C
+#define DMA1_CONTROL_STATUS                             31:31
+#define DMA1_CONTROL_STATUS_IDLE                        0 
+#define DMA1_CONTROL_STATUS_ENABLE                      1 
+#define DMA1_CONTROL_TRI_STREAM                         30:30
+#define DMA1_CONTROL_TRI_STREAM_DISABLE                 0
+#define DMA1_CONTROL_TRI_STREAM_ENABLE                  1
+#define DMA1_CONTROL_FORMAT                             29:28
+#define DMA1_CONTROL_FORMAT_8BPP                        0
+#define DMA1_CONTROL_FORMAT_16BPP                       1
+#define DMA1_CONTROL_FORMAT_32BPP                       2
+#define DMA1_CONTROL_TILE_HEIGHT                        27:16
+#define DMA1_CONTROL_TILE_WIDTH                         12:0
+
+#define DMA1_DESTINATION_PITCH                          0x0D0020
+#define DMA1_DESTINATION_PITCH_PITCH                    14:0
+
+#define DMA_CONTROL                                     0x0D0024
+#define DMA_CONTROL_NSC_RB_SWAP                         11:11
+#define DMA_CONTROL_NSC_RB_SWAP_DISABLE                 0
+#define DMA_CONTROL_NSC_RB_SWAP_ENABLE                  1
+#define DMA_CONTROL_CSC                                 10:10
+#define DMA_CONTROL_CSC_DISABLE                         0
+#define DMA_CONTROL_CSC_ENABLE                          1
+#define DMA_CONTROL_DECOMP                              9:8
+#define DMA_CONTROL_DECOMP_TEXT                         0
+#define DMA_CONTROL_DECOMP_NSC                          1
+#define DMA_CONTROL_DECOMP_GOLOMB                       2
+#define DMA_CONTROL_DMA1_STATUS                         5:5
+#define DMA_CONTROL_DMA1_STATUS_NORMAL                  0
+#define DMA_CONTROL_DMA1_STATUS_ABORT                   1
+#define DMA_CONTROL_DMA0_STATUS                         4:4
+#define DMA_CONTROL_DMA0_STATUS_NORMAL                  0
+#define DMA_CONTROL_DMA0_STATUS_ABORT                   1
+#define DMA_CONTROL_DMA1_RAWINT                         1:1
+#define DMA_CONTROL_DMA1_RAWINT_CLEAR                   0
+#define DMA_CONTROL_DMA1_RAWINT_SET                     1
+#define DMA_CONTROL_DMA0_RAWINT                         0:0
+#define DMA_CONTROL_DMA0_RAWINT_CLEAR                   0
+#define DMA_CONTROL_DMA0_RAWINT_SET                     1
+
+/* DMA 1 source 1 and source 2 are only used when RGB is in 3 separate planes.*/
+#define DMA1_SOURCE1                                    0x0D0028
+#define DMA1_SOURCE1_ADDRESS                            29:0
+
+#define DMA1_SOURCE1_SIZE                               0x0D002c
+#define DMA1_SOURCE1_SIZE_NSC_CSS                       27:27
+#define DMA1_SOURCE1_SIZE_NSC_CSS_DISABLE               0
+#define DMA1_SOURCE1_SIZE_NSC_CSS_ENABLE                1
+#define DMA1_SOURCE1_SIZE_NSC_CLL                       26:24
+#define DMA1_SOURCE1_SIZE_SIZE                          23:0
+
+#define DMA1_SOURCE2                                    0x0D0030
+#define DMA1_SOURCE2_ADDRESS                            29:0
+
+#define DMA1_SOURCE2_SIZE                               0x0D0034
+#define DMA1_SOURCE2_SIZE_NSC_CSS                       27:27
+#define DMA1_SOURCE2_SIZE_NSC_CSS_DISABLE               0
+#define DMA1_SOURCE2_SIZE_NSC_CSS_ENABLE                1
+#define DMA1_SOURCE2_SIZE_NSC_CLL                       26:24
+#define DMA1_SOURCE2_SIZE_SIZE                          23:0
+
+
+//#include "regde.h"
+/* 2D registers. */
+
+#define DE_SOURCE                                       0x100000
+#define DE_SOURCE_WRAP                                  31:31
+#define DE_SOURCE_WRAP_DISABLE                          0
+#define DE_SOURCE_WRAP_ENABLE                           1
+
+/* 
+ * The following definitions are used in different setting 
+ */
+
+/* Use these definitions in XY addressing mode or linear addressing mode. */
+#define DE_SOURCE_X_K1                                  27:16
+#define DE_SOURCE_Y_K2                                  11:0
+
+/* Use this definition in host write mode for mono. The Y_K2 is not used
+   in host write mode. */
+#define DE_SOURCE_X_K1_MONO                             20:16
+
+/* Use these definitions in Bresenham line drawing mode. */
+#define DE_SOURCE_X_K1_LINE                             29:16
+#define DE_SOURCE_Y_K2_LINE                             13:0
+
+#define DE_DESTINATION                                  0x100004
+#define DE_DESTINATION_WRAP                             31:31
+#define DE_DESTINATION_WRAP_DISABLE                     0
+#define DE_DESTINATION_WRAP_ENABLE                      1
+#if 1
+    #define DE_DESTINATION_X                            27:16
+    #define DE_DESTINATION_Y                            11:0
+#else
+    #define DE_DESTINATION_X                            28:16
+    #define DE_DESTINATION_Y                            15:0
+#endif
+
+#define DE_DIMENSION                                    0x100008
+#define DE_DIMENSION_X                                  28:16
+#define DE_DIMENSION_Y_ET                               15:0
+
+#define DE_CONTROL                                      0x10000C
+#define DE_CONTROL_STATUS                               31:31
+#define DE_CONTROL_STATUS_STOP                          0
+#define DE_CONTROL_STATUS_START                         1
+#define DE_CONTROL_PATTERN                              30:30
+#define DE_CONTROL_PATTERN_MONO                         0
+#define DE_CONTROL_PATTERN_COLOR                        1
+#define DE_CONTROL_UPDATE_DESTINATION_X                 29:29
+#define DE_CONTROL_UPDATE_DESTINATION_X_DISABLE         0
+#define DE_CONTROL_UPDATE_DESTINATION_X_ENABLE          1
+#define DE_CONTROL_QUICK_START                          28:28
+#define DE_CONTROL_QUICK_START_DISABLE                  0
+#define DE_CONTROL_QUICK_START_ENABLE                   1
+#define DE_CONTROL_DIRECTION                            27:27
+#define DE_CONTROL_DIRECTION_LEFT_TO_RIGHT              0
+#define DE_CONTROL_DIRECTION_RIGHT_TO_LEFT              1
+#define DE_CONTROL_MAJOR                                26:26
+#define DE_CONTROL_MAJOR_X                              0
+#define DE_CONTROL_MAJOR_Y                              1
+#define DE_CONTROL_STEP_X                               25:25
+#define DE_CONTROL_STEP_X_POSITIVE                      0
+#define DE_CONTROL_STEP_X_NEGATIVE                      1
+#define DE_CONTROL_STEP_Y                               24:24
+#define DE_CONTROL_STEP_Y_POSITIVE                      0
+#define DE_CONTROL_STEP_Y_NEGATIVE                      1
+#define DE_CONTROL_STRETCH                              23:23
+#define DE_CONTROL_STRETCH_DISABLE                      0
+#define DE_CONTROL_STRETCH_ENABLE                       1
+#define DE_CONTROL_HOST                                 22:22
+#define DE_CONTROL_HOST_COLOR                           0
+#define DE_CONTROL_HOST_MONO                            1
+#define DE_CONTROL_LAST_PIXEL                           21:21
+#define DE_CONTROL_LAST_PIXEL_OFF                       0
+#define DE_CONTROL_LAST_PIXEL_ON                        1
+#define DE_CONTROL_COMMAND                              20:16
+#define DE_CONTROL_COMMAND_BITBLT                       0
+#define DE_CONTROL_COMMAND_RECTANGLE_FILL               1
+#define DE_CONTROL_COMMAND_DE_TILE                      2
+#define DE_CONTROL_COMMAND_TRAPEZOID_FILL               3
+#define DE_CONTROL_COMMAND_ALPHA_BLEND                  4
+#define DE_CONTROL_COMMAND_RLE_STRIP                    5
+#define DE_CONTROL_COMMAND_SHORT_STROKE                 6
+#define DE_CONTROL_COMMAND_LINE_DRAW                    7
+#define DE_CONTROL_COMMAND_HOST_WRITE                   8
+#define DE_CONTROL_COMMAND_HOST_READ                    9
+#define DE_CONTROL_COMMAND_HOST_WRITE_BOTTOM_UP         10
+#define DE_CONTROL_COMMAND_ROTATE                       11
+#define DE_CONTROL_COMMAND_FONT                         12
+#define DE_CONTROL_COMMAND_TEXTURE_LOAD                 15
+#define DE_CONTROL_ROP_SELECT                           15:15
+#define DE_CONTROL_ROP_SELECT_ROP3                      0
+#define DE_CONTROL_ROP_SELECT_ROP2                      1
+#define DE_CONTROL_ROP2_SOURCE                          14:14
+#define DE_CONTROL_ROP2_SOURCE_BITMAP                   0
+#define DE_CONTROL_ROP2_SOURCE_PATTERN                  1
+#define DE_CONTROL_MONO_DATA                            13:12
+#define DE_CONTROL_MONO_DATA_NOT_PACKED                 0
+#define DE_CONTROL_MONO_DATA_8_PACKED                   1
+#define DE_CONTROL_MONO_DATA_16_PACKED                  2
+#define DE_CONTROL_MONO_DATA_32_PACKED                  3
+#define DE_CONTROL_REPEAT_ROTATE                        11:11
+#define DE_CONTROL_REPEAT_ROTATE_DISABLE                0
+#define DE_CONTROL_REPEAT_ROTATE_ENABLE                 1
+#define DE_CONTROL_TRANSPARENCY_MATCH                   10:10
+#define DE_CONTROL_TRANSPARENCY_MATCH_OPAQUE            0
+#define DE_CONTROL_TRANSPARENCY_MATCH_TRANSPARENT       1
+#define DE_CONTROL_TRANSPARENCY_SELECT                  9:9
+#define DE_CONTROL_TRANSPARENCY_SELECT_SOURCE           0
+#define DE_CONTROL_TRANSPARENCY_SELECT_DESTINATION      1
+#define DE_CONTROL_TRANSPARENCY                         8:8
+#define DE_CONTROL_TRANSPARENCY_DISABLE                 0
+#define DE_CONTROL_TRANSPARENCY_ENABLE                  1
+#define DE_CONTROL_ROP                                  7:0
+
+/* Pseudo fields. */
+
+#define DE_CONTROL_SHORT_STROKE_DIR                     27:24
+#define DE_CONTROL_SHORT_STROKE_DIR_225                 0
+#define DE_CONTROL_SHORT_STROKE_DIR_135                 1
+#define DE_CONTROL_SHORT_STROKE_DIR_315                 2
+#define DE_CONTROL_SHORT_STROKE_DIR_45                  3
+#define DE_CONTROL_SHORT_STROKE_DIR_270                 4
+#define DE_CONTROL_SHORT_STROKE_DIR_90                  5
+#define DE_CONTROL_SHORT_STROKE_DIR_180                 8
+#define DE_CONTROL_SHORT_STROKE_DIR_0                   10
+#define DE_CONTROL_ROTATION                             25:24
+#define DE_CONTROL_ROTATION_0                           0
+#define DE_CONTROL_ROTATION_270                         1
+#define DE_CONTROL_ROTATION_90                          2
+#define DE_CONTROL_ROTATION_180                         3
+
+#define DE_PITCH                                        0x100010
+#define DE_PITCH_DESTINATION                            28:16
+#define DE_PITCH_SOURCE                                 12:0
+
+#define DE_FOREGROUND                                   0x100014
+#define DE_FOREGROUND_COLOR                             31:0
+
+#define DE_BACKGROUND                                   0x100018
+#define DE_BACKGROUND_COLOR                             31:0
+
+#define DE_STRETCH_FORMAT                               0x10001C
+#define DE_STRETCH_FORMAT_PATTERN_XY                    30:30
+#define DE_STRETCH_FORMAT_PATTERN_XY_NORMAL             0
+#define DE_STRETCH_FORMAT_PATTERN_XY_OVERWRITE          1
+#define DE_STRETCH_FORMAT_PATTERN_Y                     29:27
+#define DE_STRETCH_FORMAT_PATTERN_X                     25:23
+#define DE_STRETCH_FORMAT_PIXEL_FORMAT                  21:20
+#define DE_STRETCH_FORMAT_PIXEL_FORMAT_8                0
+#define DE_STRETCH_FORMAT_PIXEL_FORMAT_16               1
+#define DE_STRETCH_FORMAT_PIXEL_FORMAT_32               2
+#define DE_STRETCH_FORMAT_ADDRESSING                    19:16
+#define DE_STRETCH_FORMAT_ADDRESSING_XY                 0
+#define DE_STRETCH_FORMAT_ADDRESSING_LINEAR             15
+#define DE_STRETCH_FORMAT_SOURCE_HEIGHT                 11:0
+
+#define DE_COLOR_COMPARE                                0x100020
+#define DE_COLOR_COMPARE_COLOR                          23:0
+
+#define DE_COLOR_COMPARE_MASK                           0x100024
+#define DE_COLOR_COMPARE_MASK_MASKS                     23:0
+
+#define DE_MASKS                                        0x100028
+#define DE_MASKS_BYTE_MASK                              31:16
+#define DE_MASKS_BIT_MASK                               15:0
+
+#define DE_CLIP_TL                                      0x10002C
+#define DE_CLIP_TL_TOP                                  31:16
+#define DE_CLIP_TL_STATUS                               13:13
+#define DE_CLIP_TL_STATUS_DISABLE                       0
+#define DE_CLIP_TL_STATUS_ENABLE                        1
+#define DE_CLIP_TL_INHIBIT                              12:12
+#define DE_CLIP_TL_INHIBIT_OUTSIDE                      0
+#define DE_CLIP_TL_INHIBIT_INSIDE                       1
+#define DE_CLIP_TL_LEFT                                 11:0
+
+#define DE_CLIP_BR                                      0x100030
+#define DE_CLIP_BR_BOTTOM                               31:16
+#define DE_CLIP_BR_RIGHT                                12:0
+
+#define DE_MONO_PATTERN_LOW                             0x100034
+#define DE_MONO_PATTERN_LOW_PATTERN                     31:0
+
+#define DE_MONO_PATTERN_HIGH                            0x100038
+#define DE_MONO_PATTERN_HIGH_PATTERN                    31:0
+
+#define DE_WINDOW_WIDTH                                 0x10003C
+#define DE_WINDOW_WIDTH_DESTINATION                     28:16
+#define DE_WINDOW_WIDTH_SOURCE                          12:0
+
+#define DE_WINDOW_SOURCE_BASE                           0x100040
+#define DE_WINDOW_SOURCE_BASE_ADDRESS                   29:0
+
+#define DE_WINDOW_DESTINATION_BASE                      0x100044
+#define DE_WINDOW_DESTINATION_BASE_ADDRESS              29:0
+
+#define DE_ALPHA                                        0x100048
+#define DE_ALPHA_VALUE                                  7:0
+
+#define DE_WRAP                                         0x10004C
+#define DE_WRAP_X                                       31:16
+#define DE_WRAP_Y                                       15:0
+
+#define DE_STATE2                                        0x100054
+#define DE_STATE2_DE_FIFO                                3:3
+#define DE_STATE2_DE_FIFO_NOTEMPTY                       1
+#define DE_STATE2_DE_FIFO_EMPTY                          0
+#define DE_STATE2_DE_STATUS                              2:2
+#define DE_STATE2_DE_STATUS_IDLE                         0
+#define DE_STATE2_DE_STATUS_BUSY                         1
+#define DE_STATE2_DE_MEM_FIFO                            1:1
+#define DE_STATE2_DE_MEM_FIFO_NOTEMPTY                   0
+#define DE_STATE2_DE_MEM_FIFO_EMPTY                      1
+#define DE_STATE2_DE_ABORT                               0:0
+#define DE_STATE2_DE_ABORT_OFF                           0
+#define DE_STATE2_DE_ABORT_ON                            1
+
+/* Color Space Conversion registers. */
+
+#define CSC_Y_SOURCE_BASE                               0x1000C8
+#define CSC_Y_SOURCE_BASE_ADDRESS                       29:0
+
+#define CSC_CONSTANTS                                   0x1000CC
+#define CSC_CONSTANTS_Y                                 31:24
+#define CSC_CONSTANTS_R                                 23:16
+#define CSC_CONSTANTS_G                                 15:8
+#define CSC_CONSTANTS_B                                 7:0
+
+#define CSC_Y_SOURCE_X                                  0x1000D0
+#define CSC_Y_SOURCE_X_INTEGER                          26:16
+#define CSC_Y_SOURCE_X_FRACTION                         15:3
+
+#define CSC_Y_SOURCE_Y                                  0x1000D4
+#define CSC_Y_SOURCE_Y_INTEGER                          27:16
+#define CSC_Y_SOURCE_Y_FRACTION                         15:3
+
+#define CSC_U_SOURCE_BASE                               0x1000D8
+#define CSC_U_SOURCE_BASE_ADDRESS                       29:0
+
+#define CSC_V_SOURCE_BASE                               0x1000DC
+#define CSC_V_SOURCE_BASE_ADDRESS                       29:0
+
+#define CSC_SOURCE_DIMENSION                            0x1000E0
+#define CSC_SOURCE_DIMENSION_X                          31:16
+#define CSC_SOURCE_DIMENSION_Y                          15:0
+
+#define CSC_SOURCE_PITCH                                0x1000E4
+#define CSC_SOURCE_PITCH_Y                              31:16
+#define CSC_SOURCE_PITCH_UV                             15:0
+
+#define CSC_DESTINATION                                 0x1000E8
+#define CSC_DESTINATION_WRAP                            31:31
+#define CSC_DESTINATION_WRAP_DISABLE                    0
+#define CSC_DESTINATION_WRAP_ENABLE                     1
+#define CSC_DESTINATION_X                               27:16
+#define CSC_DESTINATION_Y                               11:0
+
+#define CSC_DESTINATION_DIMENSION                       0x1000EC
+#define CSC_DESTINATION_DIMENSION_X                     31:16
+#define CSC_DESTINATION_DIMENSION_Y                     15:0
+
+#define CSC_DESTINATION_PITCH                           0x1000F0
+#define CSC_DESTINATION_PITCH_X                         31:16
+#define CSC_DESTINATION_PITCH_Y                         15:0
+
+#define CSC_SCALE_FACTOR                                0x1000F4
+#define CSC_SCALE_FACTOR_HORIZONTAL                     31:16
+#define CSC_SCALE_FACTOR_VERTICAL                       15:0
+
+#define CSC_DESTINATION_BASE                            0x1000F8
+#define CSC_DESTINATION_BASE_ADDRESS                    29:0
+
+#define CSC_CONTROL                                     0x1000FC
+#define CSC_CONTROL_STATUS                              31:31
+#define CSC_CONTROL_STATUS_STOP                         0
+#define CSC_CONTROL_STATUS_START                        1
+#define CSC_CONTROL_SOURCE_FORMAT                       30:28
+#define CSC_CONTROL_SOURCE_FORMAT_YUV422                0
+#define CSC_CONTROL_SOURCE_FORMAT_YUV420I               1
+#define CSC_CONTROL_SOURCE_FORMAT_YUV420                2
+#define CSC_CONTROL_SOURCE_FORMAT_YVU9                  3
+#define CSC_CONTROL_SOURCE_FORMAT_IYU1                  4
+#define CSC_CONTROL_SOURCE_FORMAT_IYU2                  5
+#define CSC_CONTROL_SOURCE_FORMAT_RGB565                6
+#define CSC_CONTROL_SOURCE_FORMAT_RGB8888               7
+#define CSC_CONTROL_DESTINATION_FORMAT                  27:26
+#define CSC_CONTROL_DESTINATION_FORMAT_RGB565           0
+#define CSC_CONTROL_DESTINATION_FORMAT_RGB8888          1
+#define CSC_CONTROL_HORIZONTAL_FILTER                   25:25
+#define CSC_CONTROL_HORIZONTAL_FILTER_DISABLE           0
+#define CSC_CONTROL_HORIZONTAL_FILTER_ENABLE            1
+#define CSC_CONTROL_VERTICAL_FILTER                     24:24
+#define CSC_CONTROL_VERTICAL_FILTER_DISABLE             0
+#define CSC_CONTROL_VERTICAL_FILTER_ENABLE              1
+#define CSC_CONTROL_BYTE_ORDER                          23:23
+#define CSC_CONTROL_BYTE_ORDER_YUYV                     0
+#define CSC_CONTROL_BYTE_ORDER_UYVY                     1
+
+#define DE_DATA_PORT                                    0x110000
+
+//#include "regzv.h"
+
+/* ZV0 */
+
+#define ZV0_CAPTURE_CTRL                                0x090000
+#define ZV0_CAPTURE_CTRL_FIELD_INPUT                    27:27
+#define ZV0_CAPTURE_CTRL_FIELD_INPUT_EVEN_FIELD         0
+#define ZV0_CAPTURE_CTRL_FIELD_INPUT_ODD_FIELD          1
+#define ZV0_CAPTURE_CTRL_SCAN                           26:26
+#define ZV0_CAPTURE_CTRL_SCAN_PROGRESSIVE               0
+#define ZV0_CAPTURE_CTRL_SCAN_INTERLACE                 1
+#define ZV0_CAPTURE_CTRL_CURRENT_BUFFER                 25:25
+#define ZV0_CAPTURE_CTRL_CURRENT_BUFFER_0               0
+#define ZV0_CAPTURE_CTRL_CURRENT_BUFFER_1               1
+#define ZV0_CAPTURE_CTRL_VERTICAL_SYNC                  24:24
+#define ZV0_CAPTURE_CTRL_VERTICAL_SYNC_INACTIVE         0
+#define ZV0_CAPTURE_CTRL_VERTICAL_SYNC_ACTIVE           1
+#define ZV0_CAPTURE_CTRL_OUTPUT_FORMAT                  22:22
+#define ZV0_CAPTURE_CTRL_OUTPUT_FORMAT_16               0
+#define ZV0_CAPTURE_CTRL_OUTPUT_FORMAT_32               1
+#define ZV0_CAPTURE_CTRL_INCOME_DATA                  	21:21
+#define ZV0_CAPTURE_CTRL_INCOME_DATA_16                 0
+#define ZV0_CAPTURE_CTRL_INCOME_DATA_32	                1
+#define ZV0_CAPTURE_CTRL_ADJ                            19:19
+#define ZV0_CAPTURE_CTRL_ADJ_NORMAL                     0
+#define ZV0_CAPTURE_CTRL_ADJ_DELAY                      1
+#define ZV0_CAPTURE_CTRL_HA                             18:18
+#define ZV0_CAPTURE_CTRL_HA_DISABLE                     0
+#define ZV0_CAPTURE_CTRL_HA_ENABLE                      1
+#define ZV0_CAPTURE_CTRL_VSK                            17:17
+#define ZV0_CAPTURE_CTRL_VSK_DISABLE                    0
+#define ZV0_CAPTURE_CTRL_VSK_ENABLE                     1
+#define ZV0_CAPTURE_CTRL_HSK                            16:16
+#define ZV0_CAPTURE_CTRL_HSK_DISABLE                    0
+#define ZV0_CAPTURE_CTRL_HSK_ENABLE                     1
+#define ZV0_CAPTURE_CTRL_FD                             15:15
+#define ZV0_CAPTURE_CTRL_FD_RISING                      0
+#define ZV0_CAPTURE_CTRL_FD_FALLING                     1
+#define ZV0_CAPTURE_CTRL_VP                             14:14
+#define ZV0_CAPTURE_CTRL_VP_HIGH                        0
+#define ZV0_CAPTURE_CTRL_VP_LOW                         1
+#define ZV0_CAPTURE_CTRL_HP                             13:13
+#define ZV0_CAPTURE_CTRL_HP_HIGH                        0
+#define ZV0_CAPTURE_CTRL_HP_LOW                         1
+#define ZV0_CAPTURE_CTRL_CP                             12:12
+#define ZV0_CAPTURE_CTRL_CP_HIGH                        0
+#define ZV0_CAPTURE_CTRL_CP_LOW                         1
+#define ZV0_CAPTURE_CTRL_UVS                            11:11
+#define ZV0_CAPTURE_CTRL_UVS_DISABLE                    0
+#define ZV0_CAPTURE_CTRL_UVS_ENABLE                     1
+#define ZV0_CAPTURE_CTRL_BS                             10:10
+#define ZV0_CAPTURE_CTRL_BS_DISABLE                     0
+#define ZV0_CAPTURE_CTRL_BS_ENABLE                      1
+#define ZV0_CAPTURE_CTRL_CS                             9:9
+#define ZV0_CAPTURE_CTRL_CS_16                          0
+#define ZV0_CAPTURE_CTRL_CS_8                           1
+#define ZV0_CAPTURE_CTRL_CF                             8:8
+#define ZV0_CAPTURE_CTRL_CF_YUV                         0
+#define ZV0_CAPTURE_CTRL_CF_RGB                         1
+#define ZV0_CAPTURE_CTRL_FS                             7:7
+#define ZV0_CAPTURE_CTRL_FS_DISABLE                     0
+#define ZV0_CAPTURE_CTRL_FS_ENABLE                      1
+#define ZV0_CAPTURE_CTRL_WEAVE                          6:6
+#define ZV0_CAPTURE_CTRL_WEAVE_DISABLE                  0
+#define ZV0_CAPTURE_CTRL_WEAVE_ENABLE                   1
+#define ZV0_CAPTURE_CTRL_BOB                            5:5
+#define ZV0_CAPTURE_CTRL_BOB_DISABLE                    0
+#define ZV0_CAPTURE_CTRL_BOB_ENABLE                     1
+#define ZV0_CAPTURE_CTRL_DB                             4:4
+#define ZV0_CAPTURE_CTRL_DB_DISABLE                     0
+#define ZV0_CAPTURE_CTRL_DB_ENABLE                      1
+#define ZV0_CAPTURE_CTRL_CC                             3:3
+#define ZV0_CAPTURE_CTRL_CC_CONTINUE                    0
+#define ZV0_CAPTURE_CTRL_CC_CONDITION                   1
+#define ZV0_CAPTURE_CTRL_RGB                            2:2
+#define ZV0_CAPTURE_CTRL_RGB_DISABLE                    0
+#define ZV0_CAPTURE_CTRL_RGB_ENABLE                     1
+#define ZV0_CAPTURE_CTRL_656                            1:1
+#define ZV0_CAPTURE_CTRL_656_DISABLE                    0
+#define ZV0_CAPTURE_CTRL_656_ENABLE                     1
+#define ZV0_CAPTURE_CTRL_CAP                            0:0
+#define ZV0_CAPTURE_CTRL_CAP_DISABLE                    0
+#define ZV0_CAPTURE_CTRL_CAP_ENABLE                     1
+
+#define ZV0_CAPTURE_CLIP                                0x090004
+#define ZV0_CAPTURE_CLIP_YCLIP_EVEN_FIELD                25:16
+#define ZV0_CAPTURE_CLIP_YCLIP                          25:16
+#define ZV0_CAPTURE_CLIP_XCLIP                          9:0
+
+#define ZV0_CAPTURE_SIZE                                0x090008
+#define ZV0_CAPTURE_SIZE_HEIGHT                         26:16
+#define ZV0_CAPTURE_SIZE_WIDTH                          10:0   
+
+#define ZV0_CAPTURE_BUF0_ADDRESS                        0x09000C
+#define ZV0_CAPTURE_BUF0_ADDRESS_STATUS                 31:31
+#define ZV0_CAPTURE_BUF0_ADDRESS_STATUS_CURRENT         0
+#define ZV0_CAPTURE_BUF0_ADDRESS_STATUS_PENDING         1
+#define ZV0_CAPTURE_BUF0_ADDRESS_ADDRESS                29:0
+
+#define ZV0_CAPTURE_BUF1_ADDRESS                        0x090010
+#define ZV0_CAPTURE_BUF1_ADDRESS_STATUS                 31:31
+#define ZV0_CAPTURE_BUF1_ADDRESS_STATUS_CURRENT         0
+#define ZV0_CAPTURE_BUF1_ADDRESS_STATUS_PENDING         1
+#define ZV0_CAPTURE_BUF1_ADDRESS_ADDRESS                29:0
+
+#define ZV0_CAPTURE_BUF_OFFSET                          0x090014
+#define ZV0_CAPTURE_BUF_OFFSET_YCLIP_ODD_FIELD          25:16
+#define ZV0_CAPTURE_BUF_OFFSET_OFFSET                   15:0
+
+#define ZV0_CAPTURE_FIFO_CTRL                           0x090018
+#define ZV0_CAPTURE_FIFO_CTRL_FIFO                      2:0
+#define ZV0_CAPTURE_FIFO_CTRL_FIFO_0                    0
+#define ZV0_CAPTURE_FIFO_CTRL_FIFO_1                    1
+#define ZV0_CAPTURE_FIFO_CTRL_FIFO_2                    2
+#define ZV0_CAPTURE_FIFO_CTRL_FIFO_3                    3
+#define ZV0_CAPTURE_FIFO_CTRL_FIFO_4                    4
+#define ZV0_CAPTURE_FIFO_CTRL_FIFO_5                    5
+#define ZV0_CAPTURE_FIFO_CTRL_FIFO_6                    6
+#define ZV0_CAPTURE_FIFO_CTRL_FIFO_7                    7
+
+#define ZV0_CAPTURE_YRGB_CONST                          0x09001C
+#define ZV0_CAPTURE_YRGB_CONST_Y                        31:24
+#define ZV0_CAPTURE_YRGB_CONST_R                        23:16
+#define ZV0_CAPTURE_YRGB_CONST_G                        15:8
+#define ZV0_CAPTURE_YRGB_CONST_B                        7:0
+
+#define ZV0_CAPTURE_LINE_COMP                           0x090020
+#define ZV0_CAPTURE_LINE_COMP_LC                        10:0
+
+/* ZV1 */
+
+#define ZV1_CAPTURE_CTRL                                0x098000
+#define ZV1_CAPTURE_CTRL_FIELD_INPUT                    27:27
+#define ZV1_CAPTURE_CTRL_FIELD_INPUT_EVEN_FIELD         0
+#define ZV1_CAPTURE_CTRL_FIELD_INPUT_ODD_FIELD          0
+#define ZV1_CAPTURE_CTRL_SCAN                           26:26
+#define ZV1_CAPTURE_CTRL_SCAN_PROGRESSIVE               0
+#define ZV1_CAPTURE_CTRL_SCAN_INTERLACE                 1
+#define ZV1_CAPTURE_CTRL_CURRENT_BUFFER                 25:25
+#define ZV1_CAPTURE_CTRL_CURRENT_BUFFER_0               0
+#define ZV1_CAPTURE_CTRL_CURRENT_BUFFER_1               1
+#define ZV1_CAPTURE_CTRL_VERTICAL_SYNC                  24:24
+#define ZV1_CAPTURE_CTRL_VERTICAL_SYNC_INACTIVE         0
+#define ZV1_CAPTURE_CTRL_VERTICAL_SYNC_ACTIVE           1
+#define ZV1_CAPTURE_CTRL_CHANNEL0                        20:20
+#define ZV1_CAPTURE_CTRL_CHANNEL0_DISABLE                0
+#define ZV1_CAPTURE_CTRL_CHANNEL0_ENABLE                 1
+#define ZV1_CAPTURE_CTRL_ADJ                            19:19
+#define ZV1_CAPTURE_CTRL_ADJ_NORMAL                     0
+#define ZV1_CAPTURE_CTRL_ADJ_DELAY                      1
+#define ZV1_CAPTURE_CTRL_HA                             18:18
+#define ZV1_CAPTURE_CTRL_HA_DISABLE                     0
+#define ZV1_CAPTURE_CTRL_HA_ENABLE                      1
+#define ZV1_CAPTURE_CTRL_VSK                            17:17
+#define ZV1_CAPTURE_CTRL_VSK_DISABLE                    0
+#define ZV1_CAPTURE_CTRL_VSK_ENABLE                     1
+#define ZV1_CAPTURE_CTRL_HSK                            16:16
+#define ZV1_CAPTURE_CTRL_HSK_DISABLE                    0
+#define ZV1_CAPTURE_CTRL_HSK_ENABLE                     1
+#define ZV1_CAPTURE_CTRL_FD                             15:15
+#define ZV1_CAPTURE_CTRL_FD_RISING                      0
+#define ZV1_CAPTURE_CTRL_FD_FALLING                     1
+#define ZV1_CAPTURE_CTRL_VP                             14:14
+#define ZV1_CAPTURE_CTRL_VP_HIGH                        0
+#define ZV1_CAPTURE_CTRL_VP_LOW                         1
+#define ZV1_CAPTURE_CTRL_HP                             13:13
+#define ZV1_CAPTURE_CTRL_HP_HIGH                        0
+#define ZV1_CAPTURE_CTRL_HP_LOW                         1
+#define ZV1_CAPTURE_CTRL_CP                             12:12
+#define ZV1_CAPTURE_CTRL_CP_HIGH                        0
+#define ZV1_CAPTURE_CTRL_CP_LOW                         1
+#define ZV1_CAPTURE_CTRL_UVS                            11:11
+#define ZV1_CAPTURE_CTRL_UVS_DISABLE                    0
+#define ZV1_CAPTURE_CTRL_UVS_ENABLE                     1
+#define ZV1_CAPTURE_CTRL_BS                             10:10
+#define ZV1_CAPTURE_CTRL_BS_DISABLE                     0
+#define ZV1_CAPTURE_CTRL_BS_ENABLE                      1
+#define ZV1_CAPTURE_CTRL_CS                             9:9
+#define ZV1_CAPTURE_CTRL_CS_16                          0
+#define ZV1_CAPTURE_CTRL_CS_8                           1
+#define ZV1_CAPTURE_CTRL_CF                             8:8
+#define ZV1_CAPTURE_CTRL_CF_YUV                         0
+#define ZV1_CAPTURE_CTRL_CF_RGB                         1
+#define ZV1_CAPTURE_CTRL_FS                             7:7
+#define ZV1_CAPTURE_CTRL_FS_DISABLE                     0
+#define ZV1_CAPTURE_CTRL_FS_ENABLE                      1
+#define ZV1_CAPTURE_CTRL_WEAVE                          6:6
+#define ZV1_CAPTURE_CTRL_WEAVE_DISABLE                  0
+#define ZV1_CAPTURE_CTRL_WEAVE_ENABLE                   1
+#define ZV1_CAPTURE_CTRL_BOB                            5:5
+#define ZV1_CAPTURE_CTRL_BOB_DISABLE                    0
+#define ZV1_CAPTURE_CTRL_BOB_ENABLE                     1
+#define ZV1_CAPTURE_CTRL_DB                             4:4
+#define ZV1_CAPTURE_CTRL_DB_DISABLE                     0
+#define ZV1_CAPTURE_CTRL_DB_ENABLE                      1
+#define ZV1_CAPTURE_CTRL_CC                             3:3
+#define ZV1_CAPTURE_CTRL_CC_CONTINUE                    0
+#define ZV1_CAPTURE_CTRL_CC_CONDITION                   1
+#define ZV1_CAPTURE_CTRL_RGB                            2:2
+#define ZV1_CAPTURE_CTRL_RGB_DISABLE                    0
+#define ZV1_CAPTURE_CTRL_RGB_ENABLE                     1
+#define ZV1_CAPTURE_CTRL_656                            1:1
+#define ZV1_CAPTURE_CTRL_656_DISABLE                    0
+#define ZV1_CAPTURE_CTRL_656_ENABLE                     1
+#define ZV1_CAPTURE_CTRL_CAP                            0:0
+#define ZV1_CAPTURE_CTRL_CAP_DISABLE                    0
+#define ZV1_CAPTURE_CTRL_CAP_ENABLE                     1
+
+#define ZV1_CAPTURE_CLIP                                0x098004
+#define ZV1_CAPTURE_CLIP_YCLIP                          25:16
+#define ZV1_CAPTURE_CLIP_XCLIP                          9:0
+
+#define ZV1_CAPTURE_SIZE                                0x098008
+#define ZV1_CAPTURE_SIZE_HEIGHT                         26:16   
+#define ZV1_CAPTURE_SIZE_WIDTH                          10:0   
+
+#define ZV1_CAPTURE_BUF0_ADDRESS                        0x09800C
+#define ZV1_CAPTURE_BUF0_ADDRESS_STATUS                 31:31
+#define ZV1_CAPTURE_BUF0_ADDRESS_STATUS_CURRENT         0
+#define ZV1_CAPTURE_BUF0_ADDRESS_STATUS_PENDING         1
+#define ZV1_CAPTURE_BUF0_ADDRESS_ADDRESS                29:0
+
+#define ZV1_CAPTURE_BUF1_ADDRESS                        0x098010
+#define ZV1_CAPTURE_BUF1_ADDRESS_STATUS                 31:31
+#define ZV1_CAPTURE_BUF1_ADDRESS_STATUS_CURRENT         0
+#define ZV1_CAPTURE_BUF1_ADDRESS_STATUS_PENDING         1
+#define ZV1_CAPTURE_BUF1_ADDRESS_ADDRESS                29:0
+
+#define ZV1_CAPTURE_BUF_OFFSET                          0x098014
+#define ZV1_CAPTURE_BUF_OFFSET_OFFSET                   15:0
+
+#define ZV1_CAPTURE_FIFO_CTRL                           0x098018
+#define ZV1_CAPTURE_FIFO_CTRL_FIFO                      2:0
+#define ZV1_CAPTURE_FIFO_CTRL_FIFO_0                    0
+#define ZV1_CAPTURE_FIFO_CTRL_FIFO_1                    1
+#define ZV1_CAPTURE_FIFO_CTRL_FIFO_2                    2
+#define ZV1_CAPTURE_FIFO_CTRL_FIFO_3                    3
+#define ZV1_CAPTURE_FIFO_CTRL_FIFO_4                    4
+#define ZV1_CAPTURE_FIFO_CTRL_FIFO_5                    5
+#define ZV1_CAPTURE_FIFO_CTRL_FIFO_6                    6
+#define ZV1_CAPTURE_FIFO_CTRL_FIFO_7                    7
+
+#define ZV1_CAPTURE_YRGB_CONST                          0x09801C
+#define ZV1_CAPTURE_YRGB_CONST_Y                        31:24
+#define ZV1_CAPTURE_YRGB_CONST_R                        23:16
+#define ZV1_CAPTURE_YRGB_CONST_G                        15:8
+#define ZV1_CAPTURE_YRGB_CONST_B                        7:0
+
+
+
+//#include "regi2c.h"
+#define I2C_BYTE_COUNT                                  0x010040
+#define I2C_BYTE_COUNT_COUNT                            3:0
+
+#define I2C_CTRL                                        0x010041
+#define I2C_CTRL_INT                                    4:4
+#define I2C_CTRL_INT_DISABLE                            0
+#define I2C_CTRL_INT_ENABLE                             1
+#define I2C_CTRL_CTRL                                   2:2
+#define I2C_CTRL_CTRL_STOP                              0
+#define I2C_CTRL_CTRL_START                             1
+#define I2C_CTRL_MODE                                   1:1
+#define I2C_CTRL_MODE_STANDARD                          0
+#define I2C_CTRL_MODE_FAST                              1
+#define I2C_CTRL_EN                                     0:0
+#define I2C_CTRL_EN_DISABLE                             0
+#define I2C_CTRL_EN_ENABLE                              1
+
+#define I2C_STATUS                                      0x010042
+#define I2C_STATUS_TX                                   3:3
+#define I2C_STATUS_TX_PROGRESS                          0
+#define I2C_STATUS_TX_COMPLETED                         1
+#define I2C_STATUS_ERR                                  2:2
+#define I2C_STATUS_ERR_NORMAL                           0
+#define I2C_STATUS_ERR_ERROR                            1
+#define I2C_STATUS_ERR_CLEAR                            0
+#define I2C_STATUS_ACK                                  1:1
+#define I2C_STATUS_ACK_RECEIVED                         0
+#define I2C_STATUS_ACK_NOT                              1
+#define I2C_STATUS_BSY                                  0:0
+#define I2C_STATUS_BSY_IDLE                             0
+#define I2C_STATUS_BSY_BUSY                             1
+
+#define I2C_RESET                                       0x010042
+#define I2C_RESET_BUS_ERROR                             2:2
+#define I2C_RESET_BUS_ERROR_CLEAR                       0
+
+#define I2C_SLAVE_ADDRESS                               0x010043
+#define I2C_SLAVE_ADDRESS_ADDRESS                       7:1
+#define I2C_SLAVE_ADDRESS_RW                            0:0
+#define I2C_SLAVE_ADDRESS_RW_W                          0
+#define I2C_SLAVE_ADDRESS_RW_R                          1
+
+#define I2C_DATA0                                       0x010044
+#define I2C_DATA1                                       0x010045
+#define I2C_DATA2                                       0x010046
+#define I2C_DATA3                                       0x010047
+#define I2C_DATA4                                       0x010048
+#define I2C_DATA5                                       0x010049
+#define I2C_DATA6                                       0x01004A
+#define I2C_DATA7                                       0x01004B
+#define I2C_DATA8                                       0x01004C
+#define I2C_DATA9                                       0x01004D
+#define I2C_DATA10                                      0x01004E
+#define I2C_DATA11                                      0x01004F
+#define I2C_DATA12                                      0x010050
+#define I2C_DATA13                                      0x010051
+#define I2C_DATA14                                      0x010052
+#define I2C_DATA15                                      0x010053
+
+/* MMIO offset between I2C0 and I2C1 */
+#define I2C_OFFSET 0x20
+
+//#include "regtimer.h"
+
+/* There are 4 timers in the system with the same definition,
+   but different MMIO address as below
+  
+   TIMER 0  0x010030
+   TIMER 1  0x010034
+   TIMER 2  0x010038
+   TIMER 3  0x01003C
+
+   We only define the MMIO for timer 0, the MMIO for other
+   timer can be work out like this:
+   0x10030 + (4 x Timer number)
+
+*/
+
+#define TIMER_CONTROL                                   0x010030
+#define TIMER_CONTROL_COUNTER                           31:4
+#define TIMER_CONTROL_RAWINT_STATUS                     3:3
+#define TIMER_CONTROL_RAWINT_STATUS_CLEAR               0
+#define TIMER_CONTROL_RAWINT_STATUS_PENDING             1
+#define TIMER_CONTROL_RAWINT_STATUS_RESET               1
+#define TIMER_CONTROL_RAWINT_ENABLE                     2:2  
+#define TIMER_CONTROL_RAWINT_ENABLE_DISABLE             0
+#define TIMER_CONTROL_RAWINT_ENABLE_ENABLE              1
+#define TIMER_CONTROL_DIV16                             1:1
+#define TIMER_CONTROL_DIV16_DISABLE                     0
+#define TIMER_CONTROL_DIV16_ENABLE                      1
+#define TIMER_CONTROL_ENABLE                            0:0
+#define TIMER_CONTROL_ENABLE_DISABLE                    0
+#define TIMER_CONTROL_ENABLE_ENABLE                     1
+
+#define I2S_TX_DATA_L                              0x0A0200
+#define I2S_TX_DATA_L_DATA						   15:0
+
+#define I2S_TX_DATA_R                              0x0A0204
+#define I2S_TX_DATA_R_DATA                         15:0
+
+#define I2S_RX_DATA_L                              0x0A0208
+#define I2S_RX_DATA_L_DATA						   15:0
+
+#define I2S_RX_DATA_R                              0x0A020C
+#define I2S_RX_DATA_R_DATA						   15:0
+
+#define I2S_STATUS                                 0x0A0210
+#define I2S_STATUS_R                               11:11
+#define I2S_STATUS_R_NO_ERR                        0
+#define I2S_STATUS_R_OVERFLOW                      1
+#define I2S_STATUS_T                               10:10
+#define I2S_STATUS_T_NO_ERR                        0
+#define I2S_STATUS_T_UNDERFLOW                     1
+#define I2S_STATUS_TX                              2:2
+#define I2S_STATUS_TX_DISABLE                      0
+#define I2S_STATUS_TX_ENABLE                       1
+
+#define I2S_CTRL                                    0x0A0214
+#define I2S_CTRL_MODE                               7:7
+#define I2S_CTRL_MODE_SLAVE                         0
+#define I2S_CTRL_MODE_MASTER                        1
+#define I2S_CTRL_CS                                 6:5
+#define I2S_CTRL_CS_16                              0
+#define I2S_CTRL_CS_24                              1
+#define I2S_CTRL_CS_32                              2
+#define I2S_CTRL_CDIV                               4:0
+
+
+#define I2S_SRAM_DMA                                0x0A0218
+#define I2S_SRAM_DMA_STATE                          31:31    
+#define I2S_SRAM_DMA_STATE_DISABLE                  0            
+#define I2S_SRAM_DMA_STATE_ENABLE                   1
+#define I2S_SRAM_DMA_SIZE                           23:16     
+#define I2S_SRAM_DMA_ADDRESS						8:0                               
+           
+#define I2S_SRAM_DMA_STATUS                         0x0A021C
+#define I2S_SRAM_DMA_STATUS_TC                      0:0    
+#define I2S_SRAM_DMA_STATUS_TC_COMPLETE             1            
+#define I2S_SRAM_DMA_STATUS_TC_CLEAR                0
+
+
+
+#define SRAM_OUTPUT_BASE							0x8000
+#define SRAM_INPUT_BASE								0x8800
+#define SRAM_SIZE									0x0800
+
+
+
+/* Internal macros */
+#define _F_START(f)             (0 ? f)
+#define _F_END(f)               (1 ? f)
+#define _F_SIZE(f)              (1 + _F_END(f) - _F_START(f))
+#define _F_MASK(f)              (((1 << _F_SIZE(f)) - 1) << _F_START(f))
+#define _F_NORMALIZE(v, f)      (((v) & _F_MASK(f)) >> _F_START(f))
+#define _F_DENORMALIZE(v, f)    (((v) << _F_START(f)) & _F_MASK(f))
+
+/* Global macros */
+#define FIELD_GET(x, reg, field) \
+( \
+    _F_NORMALIZE((x), reg ## _ ## field) \
+)
+
+#define FIELD_SET(x, reg, field, value) \
+( \
+    (x & ~_F_MASK(reg ## _ ## field)) \
+    | _F_DENORMALIZE(reg ## _ ## field ## _ ## value, reg ## _ ## field) \
+)
+
+#define FIELD_VALUE(x, reg, field, value) \
+( \
+    (x & ~_F_MASK(reg ## _ ## field)) \
+    | _F_DENORMALIZE(value, reg ## _ ## field) \
+)
+
+#define FIELD_CLEAR(reg, field) \
+( \
+    ~ _F_MASK(reg ## _ ## field) \
+)
+
+/* FIELD MACROS */
+#define FIELD_START(field)              (0 ? field)
+#define FIELD_END(field)                (1 ? field)
+#define FIELD_SIZE(field)               (1 + FIELD_END(field) - FIELD_START(field))
+#define FIELD_MASK(field)               (((1 << (FIELD_SIZE(field)-1)) | ((1 << (FIELD_SIZE(field)-1)) - 1)) << FIELD_START(field))
+#define FIELD_NORMALIZE(reg, field)     (((reg) & FIELD_MASK(field)) >> FIELD_START(field))
+#define FIELD_DENORMALIZE(field, value) (((value) << FIELD_START(field)) & FIELD_MASK(field))
+#define FIELD_INIT(reg, field, value)   FIELD_DENORMALIZE(reg ## _ ## field, \
+                                                          reg ## _ ## field ## _ ## value)
+#define FIELD_INIT_VAL(reg, field, value) \
+                                        (FIELD_DENORMALIZE(reg ## _ ## field, value))
+#define FIELD_VAL_SET(x, r, f, v)       x = x & ~FIELD_MASK(r ## _ ## f) \
+                                              | FIELD_DENORMALIZE(r ## _ ## f, r ## _ ## f ## _ ## v)
+
+#define RGB(r, g, b) \
+( \
+    (unsigned long) (((r) << 16) | ((g) << 8) | (b)) \
+)
+
+#define RGB16(r, g, b) \
+( \
+    (unsigned short) ((((r) & 0xF8) << 8) | (((g) & 0xFC) << 3) | (((b) & 0xF8) >> 3)) \
+)
+
+
diff --git a/drivers/gpu/drm/smi/ddk768/ddk768_swi2c.c b/drivers/gpu/drm/smi/ddk768/ddk768_swi2c.c
new file mode 100644
index 000000000000..82caf7311cc7
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk768/ddk768_swi2c.c
@@ -0,0 +1,465 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2007 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  swi2c.c --- SM750/SM718 DDK 
+*  This file contains the source code for I2C using software
+*  implementation.
+* 
+*******************************************************************/
+//#include "defs.h"
+#include "ddk768_reg.h"
+//#include "ddk768_hardware.h"
+#include "ddk768_chip.h"
+#include "ddk768_power.h"
+#include "ddk768_timer.h"
+#include "ddk768_swi2c.h"
+#include "ddk768_help.h"
+/*******************************************************************
+ * I2C Software Master Driver:   
+ * ===========================
+ * Each i2c cycle is split into 4 sections. Each of these section marks
+ * a point in time where the SCL or SDA may be changed. 
+ * 
+ * 1 Cycle == |  Section I. |  Section 2. |  Section 3. |  Section 4. |
+ *            +-------------+-------------+-------------+-------------+
+ *            | SCL set LOW |SCL no change| SCL set HIGH|SCL no change|
+ *                 
+ *                                          ____________ _____________
+ * SCL == XXXX _____________ ____________ /
+ *                 
+ * I.e. the SCL may only be changed in section 1. and section 3. while
+ * the SDA may only be changed in section 2. and section 4. The table
+ * below gives the changes for these 2 lines in the varios sections.
+ * 
+ * Section changes Table:        
+ * ======================
+ * blank = no change, L = set bit LOW, H = set bit HIGH
+ *                       
+ *                                | 1.| 2.| 3.| 4.|      
+ *                 ---------------+---+---+---+---+      
+ *                 Tx Start   SDA |   | H |   | L |      
+ *                            SCL | L |   | H |   |      
+ *                 ---------------+---+---+---+---+                
+ *                 Tx Stop    SDA |   | L |   | H |      
+ *                            SCL | L |   | H |   |      
+ *                 ---------------+---+---+---+---+                
+ *                 Tx bit H   SDA |   | H |   |   |      
+ *                            SCL | L |   | H |   |      
+ *                 ---------------+---+---+---+---+                
+ *                 Tx bit L   SDA |   | L |   |   |      
+ *                            SCL | L |   | H |   |      
+ *                 ---------------+---+---+---+---+                
+ *                                  
+ ******************************************************************/
+
+/* GPIO pins used for this I2C. It ranges from 0 to 31. */
+static unsigned char g_i2cClockGPIO = DEFAULT_I2C0_SCL;
+static unsigned char g_i2cDataGPIO = DEFAULT_I2C0_SDA;
+
+/*
+ *  Below is the variable declaration for the GPIO pin register usage
+ *  for the i2c Clock and i2c Data.
+ *
+ *  Note:
+ *      Notice that the GPIO usage for the i2c clock and i2c Data are
+ *      separated. This is to make this code flexible enough when 
+ *      two separate GPIO pins for the clock and data are located
+ *      in two different GPIO register set (worst case).
+ */
+
+/* i2c Clock GPIO Register usage */
+static unsigned long g_i2cClkGPIOMuxReg = GPIO_MUX;
+static unsigned long g_i2cClkGPIODataReg = GPIO_DATA;
+static unsigned long g_i2cClkGPIODataDirReg = GPIO_DATA_DIRECTION;
+
+/* i2c Data GPIO Register usage */
+static unsigned long g_i2cDataGPIOMuxReg = GPIO_MUX;
+static unsigned long g_i2cDataGPIODataReg = GPIO_DATA;
+static unsigned long g_i2cDataGPIODataDirReg = GPIO_DATA_DIRECTION;
+
+/*
+ *  This function puts a delay between command
+ */        
+static void swI2CWait(void)
+{
+    //SM768 has build-in timer. Use it instead of SW loop.
+    timerWaitTicks(3, 0x3ff);
+}
+
+/*
+ *  This function set/reset the SCL GPIO pin
+ *
+ *  Parameters:
+ *      value    - Bit value to set to the SCL or SDA (0 = low, 1 = high)
+ *
+ *  Notes:
+ *      When setting SCL to high, just set the GPIO as input where the pull up
+ *      resistor will pull the signal up. Do not use software to pull up the
+ *      signal because the i2c will fail when other device try to drive the
+ *      signal due to SM50x will drive the signal to always high.
+ */ 
+void ddk768_swI2CSCL(unsigned char value)
+{
+    unsigned long ulGPIOData;
+    unsigned long ulGPIODirection;
+
+    ulGPIODirection = peekRegisterDWord(g_i2cClkGPIODataDirReg);
+    if (value)      /* High */
+    {
+        /* Set direction as input. This will automatically pull the signal up. */
+        ulGPIODirection &= ~(1 << g_i2cClockGPIO);    
+        pokeRegisterDWord(g_i2cClkGPIODataDirReg, ulGPIODirection);
+    }
+    else            /* Low */
+    {
+        /* Set the signal down */
+        ulGPIOData = peekRegisterDWord(g_i2cClkGPIODataReg);
+        ulGPIOData &= ~(1 << g_i2cClockGPIO);
+        pokeRegisterDWord(g_i2cClkGPIODataReg, ulGPIOData);
+
+        /* Set direction as output */
+        ulGPIODirection |= (1 << g_i2cClockGPIO);        
+        pokeRegisterDWord(g_i2cClkGPIODataDirReg, ulGPIODirection);
+    }
+}
+
+/*
+ *  This function set/reset the SDA GPIO pin
+ *
+ *  Parameters:
+ *      value    - Bit value to set to the SCL or SDA (0 = low, 1 = high)
+ *
+ *  Notes:
+ *      When setting SCL to high, just set the GPIO as input where the pull up
+ *      resistor will pull the signal up. Do not use software to pull up the
+ *      signal because the i2c will fail when other device try to drive the
+ *      signal due to SM50x will drive the signal to always high.
+ */
+void ddk768_swI2CSDA(unsigned char value)
+{
+    unsigned long ulGPIOData;
+    unsigned long ulGPIODirection;
+
+    ulGPIODirection = peekRegisterDWord(g_i2cDataGPIODataDirReg);
+    if (value)      /* High */
+    {
+        /* Set direction as input. This will automatically pull the signal up. */
+        ulGPIODirection &= ~(1 << g_i2cDataGPIO);    
+        pokeRegisterDWord(g_i2cDataGPIODataDirReg, ulGPIODirection);
+    }
+    else            /* Low */
+    {
+        /* Set the signal down */
+        ulGPIOData = peekRegisterDWord(g_i2cDataGPIODataReg);
+        ulGPIOData &= ~(1 << g_i2cDataGPIO);
+        pokeRegisterDWord(g_i2cDataGPIODataReg, ulGPIOData);
+
+        /* Set direction as output */
+        ulGPIODirection |= (1 << g_i2cDataGPIO);        
+        pokeRegisterDWord(g_i2cDataGPIODataDirReg, ulGPIODirection);
+    }
+}
+
+/*
+ *  This function read the data from the SDA GPIO pin
+ *
+ *  Return Value:
+ *      The SDA data bit sent by the Slave
+ */
+static unsigned char swI2CReadSDA(void)
+{
+    unsigned long ulGPIODirection;
+    unsigned long ulGPIOData;
+
+    /* Make sure that the direction is input (High) */
+    ulGPIODirection = peekRegisterDWord(g_i2cDataGPIODataDirReg);
+    if ((ulGPIODirection & (1 << g_i2cDataGPIO)) != (~(1 << g_i2cDataGPIO)))
+    {
+        ulGPIODirection &= ~(1 << g_i2cDataGPIO);
+        pokeRegisterDWord(g_i2cDataGPIODataDirReg, ulGPIODirection);
+    }
+
+    /* Now read the SDA line */
+    ulGPIOData = peekRegisterDWord(g_i2cDataGPIODataReg);
+    if (ulGPIOData & (1 << g_i2cDataGPIO)) 
+        return 1;
+    else 
+        return 0;
+}
+
+#pragma optimize( "", off )
+
+/*
+ *  This function sends ACK signal
+ */
+static void swI2CAck(void)
+{
+    return;  /* Single byte read is ok without it. */
+}
+
+/*
+ *  This function sends the start command to the slave device
+ */
+void ddk768_swI2CStart(void)
+{
+    /* Start I2C */
+    ddk768_swI2CSDA(1);
+    ddk768_swI2CSCL(1);
+    ddk768_swI2CSDA(0);
+}
+
+/*
+ *  This function sends the stop command to the slave device
+ */
+void ddk768_swI2CStop(void)
+{
+    /* Stop the I2C */
+    ddk768_swI2CSCL(1);
+    ddk768_swI2CSDA(0);
+    ddk768_swI2CSDA(1);
+}
+
+/*
+ *  This function writes one byte to the slave device
+ *
+ *  Parameters:
+ *      data    - Data to be write to the slave device
+ *
+ *  Return Value:
+ *       0   - Success
+ *      -1   - Fail to write byte
+ */
+long ddk768_swI2CWriteByte(unsigned char data) 
+{
+    unsigned char value = data;
+    int i;
+
+    /* Sending the data bit by bit */
+    for (i=0; i<8; i++)
+    {
+        /* Set SCL to low */
+        ddk768_swI2CSCL(0);
+
+        /* Send data bit */
+        if ((value & 0x80) != 0)
+            ddk768_swI2CSDA(1);
+        else
+            ddk768_swI2CSDA(0);
+
+        swI2CWait();
+
+        /* Toggle clk line to one */
+        ddk768_swI2CSCL(1);
+        swI2CWait();
+
+        /* Shift byte to be sent */
+        value = value << 1;
+    }
+
+    /* Set the SCL Low and SDA High (prepare to get input) */
+    ddk768_swI2CSCL(0);
+    ddk768_swI2CSDA(1);
+
+    /* Set the SCL High for ack */
+    swI2CWait();
+    ddk768_swI2CSCL(1);
+    swI2CWait();
+
+    /* Read SDA, until SDA==0 */
+    for(i=0; i<0xff; i++) 
+    {
+        if (!swI2CReadSDA())
+            break;
+
+        ddk768_swI2CSCL(0);
+        swI2CWait();
+        ddk768_swI2CSCL(1);
+        swI2CWait();
+    }
+
+    /* Set the SCL Low and SDA High */
+    ddk768_swI2CSCL(0);
+    ddk768_swI2CSDA(1);
+
+    if (i<0xff)
+        return 0;
+    else
+        return (-1);
+}
+
+/*
+ *  This function reads one byte from the slave device
+ *
+ *  Parameters:
+ *      ack    - Flag to indicate either to send the acknowledge
+ *            message to the slave device or not
+ *
+ *  Return Value:
+ *      One byte data read from the Slave device
+ */
+unsigned char ddk768_swI2CReadByte(unsigned char ack)
+{
+    int i;
+    unsigned char data = 0;
+
+    for(i=7; i>=0; i--)
+    {
+        /* Set the SCL to Low and SDA to High (Input) */
+        ddk768_swI2CSCL(0);
+        ddk768_swI2CSDA(1);
+        swI2CWait();
+
+        /* Set the SCL High */
+        ddk768_swI2CSCL(1);
+        swI2CWait();
+
+        /* Read data bits from SDA */
+        data |= (swI2CReadSDA() << i);
+    }
+
+    if (ack)
+        swI2CAck();
+
+    /* Set the SCL Low and SDA High */
+    ddk768_swI2CSCL(0);
+    ddk768_swI2CSDA(1);
+
+    return data;
+}
+#pragma optimize( "", on )
+
+
+/*
+ * This function initializes the i2c attributes and bus
+ *
+ * Parameters:
+ *      i2cClkGPIO      - The GPIO pin to be used as i2c SCL
+ *      i2cDataGPIO     - The GPIO pin to be used as i2c SDA
+ *
+ * Return Value:
+ *      -1   - Fail to initialize the i2c
+ *       0   - Success
+ */
+long ddk768_swI2CInit(
+    unsigned char i2cClkGPIO, 
+    unsigned char i2cDataGPIO
+)
+{
+    int i;
+    
+    /* Return 0 if the GPIO pins to be used is out of range. The range is only from [0..63] */
+    if ((i2cClkGPIO > 31) || (i2cDataGPIO > 31))
+        return (-1);
+
+   
+    /* Initialize the GPIO pin for the i2c Clock Register */
+    g_i2cClkGPIOMuxReg = GPIO_MUX;   
+    g_i2cClkGPIODataReg = GPIO_DATA;    
+    g_i2cClkGPIODataDirReg = GPIO_DATA_DIRECTION;
+    
+    /* Initialize the Clock GPIO Offset */
+    g_i2cClockGPIO = i2cClkGPIO;
+    
+    /* Initialize the GPIO pin for the i2c Data Register */
+    g_i2cDataGPIOMuxReg = GPIO_MUX;    
+    g_i2cDataGPIODataReg = GPIO_DATA;    
+    g_i2cDataGPIODataDirReg = GPIO_DATA_DIRECTION;
+    
+    /* Initialize the Data GPIO Offset */
+    g_i2cDataGPIO = i2cDataGPIO;
+
+    /* Enable the GPIO pins for the i2c Clock and Data (GPIO MUX) */
+    pokeRegisterDWord(g_i2cClkGPIOMuxReg, 
+                      peekRegisterDWord(g_i2cClkGPIOMuxReg) & ~(1 << g_i2cClockGPIO));
+    pokeRegisterDWord(g_i2cDataGPIOMuxReg, 
+                      peekRegisterDWord(g_i2cDataGPIOMuxReg) & ~(1 << g_i2cDataGPIO));
+
+
+    /* Clear the i2c lines. */
+    for(i=0; i<9; i++) 
+        ddk768_swI2CStop();
+
+    return 0;
+}
+
+/*
+ *  This function reads the slave device's register
+ *
+ *  Parameters:
+ *      deviceAddress   - i2c Slave device address which register
+ *                        to be read from
+ *      registerIndex   - Slave device's register to be read
+ *
+ *  Return Value:
+ *      Register value
+ */
+unsigned char ddk768_swI2CReadReg(
+    unsigned char deviceAddress, 
+    unsigned char registerIndex
+)
+{
+    unsigned char data;
+
+    /* Send the Start signal */
+    ddk768_swI2CStart();
+
+    /* Send the device address */
+    ddk768_swI2CWriteByte(deviceAddress);                                                  
+
+    /* Send the register index */
+    ddk768_swI2CWriteByte(registerIndex);               
+
+    /* Get the bus again and get the data from the device read address */
+    ddk768_swI2CStart();
+    ddk768_swI2CWriteByte(deviceAddress + 1);
+    data = ddk768_swI2CReadByte(1);
+
+    /* Stop swI2C and release the bus */
+    ddk768_swI2CStop();
+
+    return data;
+}
+
+/*
+ *  This function writes a value to the slave device's register
+ *
+ *  Parameters:
+ *      deviceAddress   - i2c Slave device address which register
+ *                        to be written
+ *      registerIndex   - Slave device's register to be written
+ *      data            - Data to be written to the register
+ *
+ *  Result:
+ *          0   - Success
+ *         -1   - Fail
+ */
+long ddk768_swI2CWriteReg(
+    unsigned char deviceAddress, 
+    unsigned char registerIndex, 
+    unsigned char data
+)
+{
+    long returnValue = 0;
+    
+    /* Send the Start signal */
+    ddk768_swI2CStart();
+
+    /* Send the device address and read the data. All should return success
+       in order for the writing processed to be successful
+     */
+    if ((ddk768_swI2CWriteByte(deviceAddress) != 0) ||
+        (ddk768_swI2CWriteByte(registerIndex) != 0) ||
+        (ddk768_swI2CWriteByte(data) != 0))
+    {
+        returnValue = -1;
+    }
+    
+    /* Stop i2c and release the bus */
+    ddk768_swI2CStop();
+
+    return returnValue;
+}
diff --git a/drivers/gpu/drm/smi/ddk768/ddk768_swi2c.h b/drivers/gpu/drm/smi/ddk768/ddk768_swi2c.h
new file mode 100644
index 000000000000..0dc81ebce094
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk768/ddk768_swi2c.h
@@ -0,0 +1,95 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2007 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  swi2c.h --- SM750/SM718 DDK 
+*  This file contains the definitions for i2c using software 
+*  implementation.
+* 
+*******************************************************************/
+#ifndef _DDK768_SWI2C_H_
+#define _DDK768_SWI2C_H_
+
+/* Default i2c CLK and Data GPIO. These are the default i2c pins */
+#define DEFAULT_I2C0_SCL                     30
+#define DEFAULT_I2C0_SDA                     31
+
+#define DEFAULT_I2C1_SCL                     6
+#define DEFAULT_I2C1_SDA                     7
+
+/*
+ * This function initializes the i2c attributes and bus
+ *
+ * Parameters:
+ *      i2cClkGPIO  - The GPIO pin to be used as i2c SCL
+ *      i2cDataGPIO - The GPIO pin to be used as i2c SDA
+ *
+ * Return Value:
+ *      -1   - Fail to initialize the i2c
+ *       0   - Success
+ */
+long ddk768_swI2CInit(
+    unsigned char i2cClkGPIO, 
+    unsigned char i2cDataGPIO
+);
+
+/*
+ *  This function reads the slave device's register
+ *
+ *  Parameters:
+ *      deviceAddress   - i2c Slave device address which register
+ *                        to be read from
+ *      registerIndex   - Slave device's register to be read
+ *
+ *  Return Value:
+ *      Register value
+ */
+unsigned char ddk768_swI2CReadReg(
+    unsigned char deviceAddress, 
+    unsigned char registerIndex
+);
+
+/*
+ *  This function writes a value to the slave device's register
+ *
+ *  Parameters:
+ *      deviceAddress   - i2c Slave device address which register
+ *                        to be written
+ *      registerIndex   - Slave device's register to be written
+ *      data            - Data to be written to the register
+ *
+ *  Result:
+ *          0   - Success
+ *         -1   - Fail
+ */
+long ddk768_swI2CWriteReg(
+    unsigned char deviceAddress, 
+    unsigned char registerIndex, 
+    unsigned char data
+);
+
+/*
+ *  These two functions are used to toggle the data on the SCL and SDA I2C lines.
+ *  The used of these two functions are not recommended unless it is necessary.
+ */
+
+/*
+ *  This function set/reset the SCL GPIO pin
+ *
+ *  Parameters:
+ *      value	- Bit value to set to the SCL or SDA (0 = low, 1 = high)
+ */ 
+void ddk768_swI2CSCL(unsigned char value);
+
+/*
+ *  This function set/reset the SDA GPIO pin
+ *
+ *  Parameters:
+ *      value	- Bit value to set to the SCL or SDA (0 = low, 1 = high)
+ */
+void ddk768_swI2CSDA(unsigned char value);
+
+#endif  /* _SWI2C_H_ */
diff --git a/drivers/gpu/drm/smi/ddk768/ddk768_timer.c b/drivers/gpu/drm/smi/ddk768/ddk768_timer.c
new file mode 100644
index 000000000000..23d76dc7d275
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk768/ddk768_timer.c
@@ -0,0 +1,341 @@
+/*******************************************************************
+*
+*         Copyright (c) 2014 by Silicon Motion, Inc. (SMI)
+*
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+*
+*  This file contains the definitions for the timer functions.
+*
+*******************************************************************/
+#include "ddk768_reg.h"
+#include "ddk768_helper.h"
+#include "ddk768_intr.h"
+#include "ddk768_timer.h"
+#include "ddk768_help.h"
+
+/* 
+ * A global varible to store the counter values set in the timer.
+ * It is needed because the counter value cannot be read back from the timer.
+ * A read to the timer counter only gets the latest value being decremented.
+ */
+static unsigned long gTimerCounter[4] = {0, 0, 0, 0};
+
+/*
+ * Calculate a value for timer counter according to input time in micro-second.
+ * Calculation is based on 168MHz master clock, and the counter decrements at every 16 ticks.
+ */
+unsigned long calcTimerCounter(
+    unsigned long microSeconds
+)
+{
+    return( microSeconds * 168 / 16);
+}
+
+/*
+ * This function start the timer with raw interrupt enabled.
+ * When the timer decrements to 0, timer raw interrupt will be generated.
+ *
+ * Raw interrupt of the timers can be used in one of 2 ways:
+ * 1. In pulling mode, detection of raw interrupt pending means timer is decremented to 0.
+ * 2. In interrupt mode, unlock the timer interrupt mask will generate a interrput to system.
+ *
+ */
+void timerStart(
+    timer_number_t timer,         /* which timer: 0 to 3 */
+    unsigned long timerCounter,   /* Timer counter */
+    unsigned long div16Enable     /* Enable the 16 divisor, time out will be increased by 16 */
+)
+{  
+    unsigned long ulTimerAddr, ulTimerValue;
+
+    if (timerCounter == 0) return; /* Nothing to set */
+
+    /* Work out the timer's MMIO address 
+       Timer 0 address + ( timer number x 4 )
+    */
+    ulTimerAddr = TIMER_CONTROL + (timer << 2);
+
+    ulTimerValue =
+          FIELD_VALUE(0, TIMER_CONTROL, COUNTER, timerCounter)
+        | FIELD_SET(0, TIMER_CONTROL, RAWINT_STATUS, RESET)    /* Reset the raw interrupt */
+        | FIELD_SET(0, TIMER_CONTROL, RAWINT_ENABLE, ENABLE)   /* Enable raw interrupt to happen when time out */
+        | FIELD_VALUE(0, TIMER_CONTROL, DIV16, div16Enable)
+        | FIELD_SET(0, TIMER_CONTROL, ENABLE, ENABLE);           /* Start the timer */
+
+    pokeRegisterDWord(ulTimerAddr, ulTimerValue);
+
+    gTimerCounter[timer] = timerCounter;
+}
+
+/*
+ * This function checks if a timer's raw interrupt has been pending.
+ * When raw interrupt is detected with pending status, it indicate the
+ * countdown of timerStart() has been completed.
+ * 
+ * Return:
+ *        1 = Raw interrupt status is pending.
+ *        0 = Raw int is NOT pending.
+ */
+unsigned long timerRawIntPending(
+    timer_number_t timer         /* which timer: 0 to 3 */
+)
+{  
+    unsigned long ulTimerAddr, rawIntStatus;
+
+    /* Work out the timer's MMIO address 
+       Timer 0 address + ( timer number x 4 )
+    */
+    ulTimerAddr = TIMER_CONTROL + (timer << 2);
+    rawIntStatus = FIELD_GET(peekRegisterDWord(ulTimerAddr), TIMER_CONTROL, RAWINT_STATUS);
+
+    return(rawIntStatus);
+}
+
+/*
+ * This function clears the RAW interrupt status of the timer.
+ * 
+ * When a timer completes countdown, the raw interrupt bit will be set.
+ * It has to be cleared, in order to distinguish between different sessions of countdown.
+ * 
+ */
+void timerClearRawInt(
+    timer_number_t timer         /* which timer: 0 to 3 */
+)
+{  
+    unsigned long ulTimerAddr, ulTimerValue;
+
+    /* Work out the timer's MMIO address 
+       Timer 0 address + ( timer number x 4 )
+    */
+    ulTimerAddr = TIMER_CONTROL + (timer << 2);
+    ulTimerValue = peekRegisterDWord(ulTimerAddr)
+                 & FIELD_CLEAR(TIMER_CONTROL, COUNTER); /* We don't want the current counter value */
+
+    pokeRegisterDWord(ulTimerAddr,
+            ulTimerValue
+          | FIELD_VALUE(0, TIMER_CONTROL, COUNTER, gTimerCounter[timer]) /* When clearing raw int, we don't want to erase the original counter value */
+          | FIELD_SET(0, TIMER_CONTROL, RAWINT_STATUS, RESET));    /* Reset the raw interrupt */
+}
+
+/*
+ * This function stop the timer.
+ *
+ */
+void timerStop(
+    timer_number_t timer         /* which timer: 0 to 3 */
+)
+{  
+    unsigned long ulTimerAddr, ulTimerValue;
+
+    /* Work out the timer's MMIO address 
+       Timer 0 address + ( timer number x 4 )
+    */
+    ulTimerAddr = TIMER_CONTROL + (timer << 2);
+
+    ulTimerValue =
+          FIELD_SET(0, TIMER_CONTROL, RAWINT_STATUS, RESET)    /* Reset the raw interrupt */
+        | FIELD_SET(0, TIMER_CONTROL, ENABLE, DISABLE);        /* Stop the timer */
+
+    pokeRegisterDWord(ulTimerAddr, ulTimerValue);
+
+    gTimerCounter[timer] = 0;
+}
+
+/*
+ * This function read the current value in the timer counter.
+ *
+ * Note: When timer is disable, always read back 0.
+ */
+unsigned long timerGetCounter(
+    timer_number_t timer         /* which timer: 0 to 3 */
+)
+{  
+    unsigned long ulTimerAddr, ulCounter;
+
+    /* Work out the timer's MMIO address 
+       Timer 0 address + ( timer number x 4 )
+    */
+    ulTimerAddr = TIMER_CONTROL + (timer << 2);
+    ulCounter = FIELD_GET(peekRegisterDWord(ulTimerAddr), TIMER_CONTROL, COUNTER);
+
+    return(ulCounter);
+}
+
+/*
+ * This function gets the countdown setting stored in timer.
+ * Function timerGetCounter() can only get the current counter value.
+ * It cannot get the original countdown setting of timer.
+ *
+ * Note: When timer is disable, always read back 0.
+ */
+unsigned long timerGetCounterSetting(
+    timer_number_t timer         /* which timer: 0 to 3 */
+)
+{
+    /* The counter value put in timer cannot be read back from the register.
+       It has to keep in global variable.
+    */
+    return(gTimerCounter[timer]);
+}
+
+/* 
+ * This funciton uses the timer to wait a specific amount of time
+ * in micro-second.
+ */
+void timerWait(
+    timer_number_t timer,
+    unsigned long microSeconds
+)
+{
+    unsigned long ticks;
+
+    // Limit  max delay to 10 seconds 
+    if (microSeconds > 10000000)
+        microSeconds = 10000000;
+
+    ticks = calcTimerCounter(microSeconds);
+
+    //Tick count is based on enabling DIV 16.
+    //Third parameter to timerStart is 1.
+    timerStart(timer, ticks, 1);
+
+    while (!timerRawIntPending(timer));
+
+    timerStop(timer);
+}
+
+/* 
+ * This funciton uses the timer to wait a specific ticks of master clock
+ *
+ */
+void timerWaitTicks(
+    timer_number_t timer, /* Use timer 0, 1, 2 or 3 */
+    unsigned long ticks
+)
+{
+    //Counter is 28 bits only.
+    ticks &= 0xFFFFFFF;
+
+    timerStart(timer, ticks, 0);
+
+    while (!timerRawIntPending(timer));
+
+    timerStop(timer);
+}
+
+/* 
+ * This function returns the INT mask for a specific timer.
+ *
+ */
+unsigned long timerIntMask(
+    timer_number_t timer        /* Which timer: 0 to 3 */
+)
+{
+    unsigned long mask;
+
+    mask = 0;
+    switch (timer)
+    {
+        case 0:
+            mask |= FIELD_SET(0, INT_MASK, TIMER0, ENABLE);
+            break;
+        case 1:
+            mask |= FIELD_SET(0, INT_MASK, TIMER1, ENABLE);
+            break;
+        case 2:
+            mask |= FIELD_SET(0, INT_MASK, TIMER2, ENABLE);
+            break;
+        case 3:
+            mask |= FIELD_SET(0, INT_MASK, TIMER3, ENABLE);
+            break;
+        default:
+            break;
+    }
+
+    return mask;
+}
+
+/*
+ * This is a reference sample showing how to implement ISR for timers.
+ * It works together with libsrc\intr.c module.
+ * 
+ * Refer to Apps\timer\tstimer.c on how to hook up this function with system
+ * interrupt under WATCOM DOS extender.
+ * 
+ */
+void timerIsrTemplate(unsigned long status)
+{
+    if (FIELD_GET(status, INT_STATUS, TIMER0) == INT_STATUS_TIMER0_ACTIVE)
+    {
+        /* Perform ISR action for timer 0 here */
+        incTestCounter();
+
+        timerClearRawInt(0);
+    }            
+
+    if (FIELD_GET(status, INT_STATUS, TIMER1) == INT_STATUS_TIMER1_ACTIVE)
+    {
+        /* Perform ISR action for timer 1 here */
+        incTestCounter();
+
+        timerClearRawInt(1);
+    }            
+
+    if (FIELD_GET(status, INT_STATUS, TIMER2) == INT_STATUS_TIMER2_ACTIVE)
+    {
+        /* Perform ISR action for timer 2 here */
+        incTestCounter();
+
+        timerClearRawInt(2);
+    }            
+
+    if (FIELD_GET(status, INT_STATUS, TIMER3) == INT_STATUS_TIMER3_ACTIVE)
+    {
+        /* Perform ISR action for timer 3 here */
+        incTestCounter();
+
+        timerClearRawInt(3);
+    }            
+}
+
+
+void timerWaitMsec(
+    unsigned long milliSeconds
+)
+{
+    timer_number_t timer = TIMER3;
+    unsigned long ticks;
+
+    /* Calculate how many ticks are needed for the amount of time.   */
+    ticks = 168000 * milliSeconds;
+
+    timerStart(timer, ticks, 0);
+
+    while (!timerRawIntPending(timer));
+
+    timerStop(timer);
+}
+
+void timerWaitUsec(
+    unsigned long USeconds
+)
+{
+    timer_number_t timer = TIMER3;
+    unsigned long ticks;
+
+    /* Calculate how many ticks are needed for the amount of time.   */
+    ticks = 168 * USeconds;
+
+    timerStart(timer, ticks, 0);
+
+    while (!timerRawIntPending(timer));
+
+    timerStop(timer);
+}
+
+
+
+
+
+
diff --git a/drivers/gpu/drm/smi/ddk768/ddk768_timer.h b/drivers/gpu/drm/smi/ddk768/ddk768_timer.h
new file mode 100644
index 000000000000..f2f0420960cd
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk768/ddk768_timer.h
@@ -0,0 +1,150 @@
+/*******************************************************************
+*
+*         Copyright (c) 2014 by Silicon Motion, Inc. (SMI)
+*
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+*
+*  This file contains the definitions for the timer functions.
+*
+*******************************************************************/
+#ifndef _TIMER_H_
+#define _TIMER_H_
+
+
+
+typedef enum _timer_number_t
+{
+    TIMER0 = 0,
+    TIMER1 = 1,
+    TIMER2 = 2,
+    TIMER3 = 3,
+}
+timer_number_t;
+
+/*
+ * Calculate a value for timer counter according to input time in micro-second.
+ * Calculation is based on 168MHz master clock, and the counter decrements at every 16 ticks.
+ */
+unsigned long calcTimerCounter(
+    unsigned long microSeconds
+);
+
+/*
+ * This function start the timer with raw interrupt enabled.
+ * When the timer decrements to 0, timer raw interrupt will be generated.
+ *
+ * Raw interrupt of the timers can be used in one of 2 ways:
+ * 1. In pulling mode, detection of raw interrupt pending means timer is decremented to 0.
+ * 2. In interrupt mode, unlock the timer interrupt mask will generate a interrput to system.
+ *
+ */
+void timerStart(
+    timer_number_t timer,         /* which timer: 0 to 3 */
+    unsigned long timerCounter,      /* Timer counter: use calcTimerCounter() to work out a counter for a specific period. */
+    unsigned long div16Enable     /* Enable the 16 divisor, time out will be increased by 16 */
+);
+
+/*
+ * This function checks if a timer's raw interrupt has been pending.
+ * When raw interrupt is detected with pending status, it indicate the
+ * countdown of timerStart() has been completed.
+ *
+ * Return:
+ *        1 = Raw interrupt status is pending.
+ *        0 = Raw int is NOT pending.
+ */
+unsigned long timerRawIntPending(
+    timer_number_t timer         /* which timer: 0 to 3 */
+);
+
+/*
+ * This function clears the RAW interrupt status of the timer.
+ *
+ * When a timer completes countdown, the raw interrupt bit will be set.
+ * It has to be cleared, in order to distinguish between different sessions of countdown.
+ *
+ */
+void timerClearRawInt(
+    timer_number_t timer         /* which timer: 0 to 3 */
+);
+
+/*
+ * This function stop the timer.
+ *
+ */
+void timerStop(
+    timer_number_t timer         /* which timer: 0 to 3 */
+);
+
+/*
+ * This function read the current value in the timer counter.
+ *
+ * Note: When timer is disable, always read back 0.
+ */
+unsigned long timerGetCounter(
+    timer_number_t timer         /* which timer: 0 to 3 */
+);
+
+/*
+ * This function gets the countdown setting stored in timer.
+ * Function timerGetCounter() can only get the current counter value.
+ * It cannot get the original countdown setting of timer.
+ *
+ * Note: When timer is disable, always read back 0.
+ */
+unsigned long timerGetCounterSetting(
+    timer_number_t timer         /* which timer: 0 to 3 */
+);
+
+/* 
+ * This funciton uses the timer to wait a specific amount of time
+ * in micro-second.
+ */
+void timerWait(
+    timer_number_t timer,
+    unsigned long microSeconds
+);
+
+/* 
+ * This funciton uses the timer to wait a specific ticks of master clock
+ *
+ */
+void timerWaitTicks(
+    timer_number_t timer, /* Use timer 0, 1, 2 or 3 */
+    unsigned long ticks
+);
+
+/* 
+ * This function returns the INT mask for a specific timer.
+ *
+ */
+unsigned long timerIntMask(
+    timer_number_t timer        /* Which timer: 0 to 3 */
+);
+
+unsigned long getTestCounter(void);
+
+void setTestCounter(unsigned long value);
+
+/*
+ * This is a reference sample showing how to implement ISR for timers.
+ * It works together with libsrc\intr.c module.
+ * 
+ * Refer to Apps\timer\tstimer.c on how to hook up this function with system
+ * interrupt under WATCOM DOS extender.
+ * 
+ */
+void timerIsrTemplate(unsigned long status);
+
+void timerWaitMsec(
+    unsigned long milliSeconds
+);
+
+void timerWaitUsec(
+    unsigned long USeconds
+);
+#define sb_OS_WAIT_MSEC_POLL(ms) timerWaitMsec(ms)
+#define sb_OS_WAIT_USEC_POLL(us) timerWaitUsec(us)
+#endif /* _TIMER_H_ */
+
diff --git a/drivers/gpu/drm/smi/ddk768/ddk768_video.c b/drivers/gpu/drm/smi/ddk768/ddk768_video.c
new file mode 100644
index 000000000000..32738f6b9206
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk768/ddk768_video.c
@@ -0,0 +1,1076 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2007 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  Video.C --- Falcon SDK 
+*  This file contains the definitions for the Video functions.
+* 
+*******************************************************************/
+#include "ddk768_help.h"
+#include "ddk768_chip.h"
+#include "ddk768_mode.h"
+#include "ddk768_video.h"
+#include "ddk768_reg.h"
+
+
+/* New video function */
+
+#define SCALE_CONSTANT                      (1 << 12)
+
+/* Offset Adjustment for the window */
+static short gWidthAdjustment = 0;
+static short gHeightAdjustment = 0;
+
+/* Source Video Width and Height */
+static unsigned long gSrcVideoWidth = 0;
+static unsigned long gSrcVideoHeight = 0;
+
+/*
+ *  videoSetWindowAdjustment
+ *      This function sets the video window adjustment. There are usually
+ *      some garbage lines or pixels at the bottom and right of the video
+ *      window. These function will adjust the video window accordingly.
+ *
+ *  Input:
+ *      widthAdjustment     - Width adjustments in pixel
+ *      heightAdjustment    - Height adjustment in line        
+ */
+void videoSetWindowAdjustment(
+	unsigned dispCtrl,
+    short widthAdjustment,
+    short heightAdjustment
+)
+{
+    unsigned long width, height;
+    videoGetWindowSize(dispCtrl, &width, &height);
+    
+    gWidthAdjustment = widthAdjustment;
+    gHeightAdjustment = heightAdjustment;
+    
+    videoSetWindowSize(dispCtrl, width, height);
+}
+
+/*
+ *  videoGetWindowAdjustment
+ *      This function gets the video window adjustment.
+ *
+ *  Input:
+ *      widthAdjustment     - Width adjustments in pixel
+ *      heightAdjustment    - Height adjustment in line 
+ */
+void videoGetWindowAdjustment(
+    short *pWidthAdjustment,
+    short *pHeightAdjustment
+)
+{
+    if (pWidthAdjustment != ((short *)0))
+        *pWidthAdjustment = gWidthAdjustment;
+    
+    if (pHeightAdjustment != ((short *)0))
+        *pHeightAdjustment = gHeightAdjustment;
+}
+
+/*
+ * videoGetBufferStatus
+ *      This function gets the status of the video buffer, either the buffer
+ *      has been used or not.
+ *
+ *  Input:
+ *      bufferIndex     - The index of the buffer which size to be retrieved
+ *
+ *  Output:
+ *      0 - No flip pending
+ *      1 - Flip pending
+ */
+unsigned long videoGetBufferStatus(
+    unsigned long bufferIndex
+)
+{
+        return (FIELD_GET(peekRegisterDWord(VIDEO_FB_ADDRESS), VIDEO_FB_ADDRESS, STATUS));
+}
+
+/*
+ * videoGetPitch
+ *      This function gets the video plane pitch
+ *
+ * Output:
+ *      pitch   - Number of bytes per line of the video plane 
+ *                specified in 128-bit aligned bytes.
+ */
+unsigned short videoGetPitch()
+{
+    return (FIELD_GET(peekRegisterDWord(VIDEO_FB_WIDTH), VIDEO_FB_WIDTH, WIDTH));
+}
+
+/*
+ * videoGetLineOffset
+ *      This function gets the video plane line offset
+ *
+ * Output:
+ *      lineOffset  - Number of 128-bit aligned bytes per line 
+ *                    of the video plane.
+ */
+unsigned short videoGetLineOffset()
+{
+    return (FIELD_GET(peekRegisterDWord(VIDEO_FB_WIDTH), VIDEO_FB_WIDTH, OFFSET));
+}
+
+/*
+ * videoGetBufferSize
+ *      This function gets the buffer size
+ *
+ *  Input:
+ *      bufferIndex - The index of the buffer which size to be retrieved
+ */
+unsigned long videoGetBufferSize(
+    unsigned long bufferIndex
+)
+{
+    unsigned long value;
+    
+    if (bufferIndex == 0)
+    {
+        value = (unsigned long)
+            FIELD_GET(peekRegisterDWord(VIDEO_FB_ADDRESS), VIDEO_FB_ADDRESS, ADDRESS);
+    }
+    
+    return value;
+}
+
+
+/*
+ * videoGetBuffer
+ *      This function gets the video buffer
+ *
+ *  Input:
+ *      bufferIndex - The index of the buffer to get
+ *
+ *  Output:
+ *      The video buffer of the requested index.
+ */
+unsigned long videoGetBuffer(
+    unsigned char bufferIndex
+)
+{
+        return (FIELD_GET(peekRegisterDWord(VIDEO_FB_ADDRESS), VIDEO_FB_ADDRESS, ADDRESS));
+}
+
+/*
+ * videoSetBufferLastAddress
+ *      This function sets the video buffer last address.
+ *      The value can be calculated by subtracting one line offset 
+ *      from the buffer size (Total number of line offset * 
+ *      source video height).
+ *
+ *  Input:
+ *      bufferIndex         - The index of the buffer to be set
+ *      bufferSize          - Size of the video buffer.
+ */
+void videoSetBufferLastAddress(
+    unsigned char bufferIndex,          /* The index of the buffer to be set. */
+    unsigned long bufferStart,          /* Buffer start */
+    unsigned long bufferSize            /* Size of the video buffer */
+)
+{
+#if 0
+
+	if (getChipType() == SM750)    
+	{
+	    /* Substract with one line offset to get the last address value when added
+	       with the bufferStart. Somehow, this is only happen in SM750 chip */    
+	    bufferSize -= (unsigned long) videoGetLineOffset();
+	}
+
+    if (bufferIndex == 0)
+    {
+        /* Set Video Buffer 0 Last Address */
+        pokeRegisterDWord(VIDEO_FB_0_LAST_ADDRESS,
+            FIELD_VALUE(0, VIDEO_FB_0_LAST_ADDRESS, ADDRESS, bufferStart + bufferSize));
+    }
+    else
+    {   
+        /* Set Video Buffer 1 Last Address */ 
+        pokeRegisterDWord(VIDEO_FB_1_LAST_ADDRESS,
+            FIELD_VALUE(0, VIDEO_FB_1_LAST_ADDRESS, ADDRESS, bufferStart + bufferSize));
+    }
+#endif
+}
+
+/*
+ * videoGetBufferLastAddress
+ *      This function gets the video buffer last address.
+ *
+ *  Input:
+ *      bufferIndex         - The index of the buffer last address to be retrieved
+ */
+unsigned long videoGetBufferLastAddress(
+    unsigned char bufferIndex           /* The index of the buffer last address to be retrieved. */
+)
+{
+#if 0
+    if (bufferIndex == 0)
+    {
+        /* Get Video Buffer 0 Last Address */
+        return (unsigned long) (FIELD_GET(peekRegisterDWord(VIDEO_FB_0_LAST_ADDRESS), 
+                                          VIDEO_FB_0_LAST_ADDRESS, ADDRESS));
+    }
+    else
+    {   
+        /* Get Video Buffer 1 Last Address */ 
+        return (unsigned long) (FIELD_GET(peekRegisterDWord(VIDEO_FB_1_LAST_ADDRESS), 
+                                          VIDEO_FB_1_LAST_ADDRESS, ADDRESS));
+    }
+#endif
+	return 0;
+}
+
+/*
+ * videoSetBuffer
+ *      This function sets the video buffer
+ *
+ *  Input:
+ *      bufferIndex         - The index of the buffer to be set
+ *      bufferStartAddress  - The starting address of the buffer
+ */
+void videoSetBuffer(
+	unsigned dispCtrl,
+    unsigned char bufferIndex,          /* The index of the buffer to be set. */
+    unsigned long bufferStartAddress    /* Video buffer with 128-bit alignment */
+)
+{
+    unsigned long bufferSize, lastAddress;
+	unsigned long regFB;
+
+    /* Get the buffer size first */
+    bufferSize = videoGetBufferSize(bufferIndex);
+    
+    lastAddress = videoGetBufferLastAddress(bufferIndex);
+#if 0    
+	if (getChipType() == SM750)    
+	{
+	    if (lastAddress <= (bufferStartAddress + bufferSize - videoGetLineOffset()))
+	        videoSetBufferLastAddress(bufferIndex, bufferStartAddress, bufferSize);
+    }
+    else
+#endif
+    {
+		if (lastAddress <= (bufferStartAddress + bufferSize))
+	        videoSetBufferLastAddress(bufferIndex, bufferStartAddress, bufferSize);
+    }
+
+    if (bufferIndex == 0)
+    {
+		regFB = (dispCtrl == CHANNEL0_CTRL)? VIDEO_FB_ADDRESS : (VIDEO_FB_ADDRESS+CHANNEL_OFFSET);
+	    pokeRegisterDWord(regFB,
+	            FIELD_SET(0, VIDEO_FB_ADDRESS, STATUS, PENDING) |
+	            FIELD_VALUE(0, VIDEO_FB_ADDRESS, ADDRESS, bufferStartAddress));
+    }
+}
+/*
+ * videoSetUVBuffer
+ *      This function sets the video buffer
+ *
+ *  Input:
+ *      bufferIndex         - The index of the buffer to be set
+ *      bufferStartAddress  - The starting address of the buffer
+ */
+void videoSetUVBuffer(
+	unsigned dispCtrl,
+    unsigned long bufferStartUAddress,    /* Video buffer with 128-bit alignment */
+    unsigned long bufferStartVAddress    /* Video buffer with 128-bit alignment */
+)
+{
+    unsigned long bufferSize;
+	unsigned long regU, regV;
+
+	regU = (dispCtrl == CHANNEL0_CTRL)? VIDEO_FB_ADDRESS_U : (VIDEO_FB_ADDRESS_U+CHANNEL_OFFSET);
+	regV = (dispCtrl == CHANNEL0_CTRL)? VIDEO_FB_ADDRESS_V : (VIDEO_FB_ADDRESS_V+CHANNEL_OFFSET);
+    pokeRegisterDWord(regU,
+        FIELD_VALUE(0, VIDEO_FB_ADDRESS_U, ADDRESS, bufferStartUAddress));
+    pokeRegisterDWord(regV,
+        FIELD_VALUE(0, VIDEO_FB_ADDRESS_V, ADDRESS, bufferStartVAddress));
+}
+
+/*
+ * videoSetPitchOffset
+ *      This function sets the video plane pitch and offset
+ *
+ *  Input:
+ *      pitch           - Number of bytes per line of the video plane 
+ *                        specified in 128-bit aligned bytes.
+ *      lineOffset      - Number of 128-bit aligned bytes per line 
+ *                        of the video plane.
+ */
+void videoSetPitchOffset(
+	unsigned dispCtrl,
+    unsigned short pitch,
+    unsigned short lineOffset
+)
+{
+	unsigned long regWidth;
+
+    /* Set Video Buffer Offset (pitch) */
+	regWidth = (dispCtrl == CHANNEL0_CTRL)? VIDEO_FB_WIDTH : (VIDEO_FB_WIDTH+CHANNEL_OFFSET);
+	pokeRegisterDWord(regWidth,
+	    FIELD_VALUE(0, VIDEO_FB_WIDTH, WIDTH, pitch) |
+	    FIELD_VALUE(0, VIDEO_FB_WIDTH, OFFSET, lineOffset));
+}
+/*
+ * videoSetUVPitchOffset
+ *      This function sets the video plane pitch and offset of U and V
+ *
+ *  Input:
+ *      pitch           - Number of bytes per line of the video plane 
+ *                        specified in 128-bit aligned bytes.
+ *      lineOffset      - Number of 128-bit aligned bytes per line 
+ *                        of the video plane.
+ */
+void videoSetUVPitchOffset(
+	unsigned dispCtrl,
+    unsigned short pitch,
+    unsigned short lineOffset
+)
+{
+	unsigned long regWidthU, regWidthV;
+	regWidthU = (dispCtrl == CHANNEL0_CTRL)? VIDEO_FB_WIDTH_U : (VIDEO_FB_WIDTH_U+CHANNEL_OFFSET);
+	regWidthV =	(dispCtrl == CHANNEL0_CTRL)? VIDEO_FB_WIDTH_V : (VIDEO_FB_WIDTH_V+CHANNEL_OFFSET);
+	pokeRegisterDWord(regWidthU,
+	    FIELD_VALUE(0, VIDEO_FB_WIDTH_U, WIDTH, pitch) |
+	    FIELD_VALUE(0, VIDEO_FB_WIDTH_U, OFFSET, lineOffset));
+	pokeRegisterDWord(regWidthV,
+	    FIELD_VALUE(0, VIDEO_FB_WIDTH_V, WIDTH, pitch) |
+	    FIELD_VALUE(0, VIDEO_FB_WIDTH_V, OFFSET, lineOffset));
+}
+/*
+ *  videoSetLast 
+ *      This function sets the video source last lines and width.
+ *
+ *  Input:
+ *
+ *      width      - Video source width
+ *      height      - Video source height
+ */
+void videoSetLast(
+	unsigned dispCtrl,
+    unsigned long width,
+    unsigned long height
+)
+{
+#if 0 // SM768 don't have this register. Leave empty function here.
+    if (dispCtrl == CHANNEL0_CTRL)
+	{
+	    pokeRegisterDWord(CHANNEL0_VIDEO_LAST, 
+	        FIELD_VALUE(0, CHANNEL0_VIDEO_LAST, COLUMN, width) |
+	        FIELD_VALUE(0, CHANNEL0_VIDEO_LAST, ROW, height)); 
+	}
+	else
+	{
+	    pokeRegisterDWord(CHANNEL1_VIDEO_LAST, 
+	        FIELD_VALUE(0, CHANNEL1_VIDEO_LAST, COLUMN, width) |
+	        FIELD_VALUE(0, CHANNEL1_VIDEO_LAST, ROW, height)); 
+	}													   
+#endif
+}
+/*
+ *  videoSetWindowSize
+ *      This function sets the video window size.
+ *
+ *  Input:
+ *      width       - Video Window width
+ *      height      - Video Window height
+ */
+void videoSetWindowSize(
+	unsigned dispCtrl,
+    unsigned long width,
+    unsigned long height
+)
+{
+    unsigned long value, startX, startY;
+	unsigned long regTL, regBR;
+	regTL = (dispCtrl == CHANNEL0_CTRL)? VIDEO_PLANE_TL : (VIDEO_PLANE_TL+CHANNEL_OFFSET);
+	regBR = (dispCtrl == CHANNEL0_CTRL)? VIDEO_PLANE_BR : (VIDEO_PLANE_BR+CHANNEL_OFFSET);
+
+	value = peekRegisterDWord(regTL);
+	startX = FIELD_GET(value, VIDEO_PLANE_TL, LEFT);
+	startY = FIELD_GET(value, VIDEO_PLANE_TL, TOP);
+
+	/* Set bottom and right position */
+	pokeRegisterDWord(regBR,
+	    FIELD_VALUE(0, VIDEO_PLANE_BR, BOTTOM, startY + height - 1 - gHeightAdjustment) |
+	    FIELD_VALUE(0, VIDEO_PLANE_BR, RIGHT, startX + width - 1 - gWidthAdjustment)); 
+}
+
+/*
+ *  videoGetWindowSize
+ *      This function gets the video window size.
+ *
+ *  Output:
+ *      width       - Video Window width
+ *      height      - Video Window height
+ */
+void videoGetWindowSize(
+	unsigned dispCtrl,
+    unsigned long *pVideoWidth,
+    unsigned long *pVideoHeight
+)
+{
+    unsigned long positionTopLeft, positionRightBottom;
+    unsigned long videoWidth, videoHeight;
+	unsigned long regTL, regBR;
+	regTL = (dispCtrl == CHANNEL0_CTRL)? VIDEO_PLANE_TL : (VIDEO_PLANE_TL+CHANNEL_OFFSET);
+	regBR = (dispCtrl == CHANNEL0_CTRL)? VIDEO_PLANE_BR : (VIDEO_PLANE_BR+CHANNEL_OFFSET);
+
+	positionTopLeft = peekRegisterDWord(regTL);
+	positionRightBottom = peekRegisterDWord(regBR);
+	videoWidth  = FIELD_GET(positionRightBottom, VIDEO_PLANE_BR, RIGHT) - 
+	              FIELD_GET(positionTopLeft, VIDEO_PLANE_TL, LEFT) + 1 +
+	              gWidthAdjustment;
+	videoHeight = FIELD_GET(positionRightBottom, VIDEO_PLANE_BR, BOTTOM) - 
+	              FIELD_GET(positionTopLeft, VIDEO_PLANE_TL, TOP) + 1 +
+	              gHeightAdjustment;
+
+    if (pVideoWidth != ((unsigned long *)0))
+        *pVideoWidth = videoWidth;
+    
+    if (pVideoHeight != ((unsigned long *)0))
+        *pVideoHeight = videoHeight;
+}
+
+/*
+ *  videoSetPosition
+ *      This function sets the video starting coordinate position.
+ *
+ *  Input:
+ *      startX      - X Coordinate of the video window starting position
+ *      startY      - Y Coordinate of the video window starting position
+ */
+void videoSetPosition(
+	unsigned dispCtrl,
+    unsigned long startX,
+    unsigned long startY
+)
+{
+    unsigned long videoWidth, videoHeight;
+	unsigned long regTL;
+
+	regTL = (dispCtrl == CHANNEL0_CTRL)? VIDEO_PLANE_TL : (VIDEO_PLANE_TL+CHANNEL_OFFSET);
+
+	/* Get the video window width and height */
+    videoGetWindowSize(dispCtrl, &videoWidth, &videoHeight);
+
+	pokeRegisterDWord(regTL,
+	    FIELD_VALUE(0, VIDEO_PLANE_TL, TOP, startY) |
+	    FIELD_VALUE(0, VIDEO_PLANE_TL, LEFT, startX));
+
+    /* Set bottom and right position */    
+    videoSetWindowSize(dispCtrl, videoWidth, videoHeight);
+
+}
+
+/*
+ *  videoSetConstants
+ *      This function sets the video constants. The actual component will be
+ *      added by this constant to get the expected component value.
+ *
+ *  Input:
+ *      yConstant       - Y Constant Value
+ *      redConstant     - Red Constant Value
+ *      greenConstant   - Green Constant Value
+ *      blueConstant    - Blue Constant Value
+ */
+void videoSetConstants(
+    unsigned dispCtrl,
+    unsigned char  yConstant,               /* Y Adjustment */
+    unsigned char  redConstant,             /* Red Conversion constant */
+    unsigned char  greenConstant,           /* Green Conversion constant */
+    unsigned char  blueConstant             /* Blue Conversion constant */
+)
+{
+	unsigned long regYUV;
+
+	regYUV = (dispCtrl == CHANNEL0_CTRL)? VIDEO_YUV_CONSTANTS : (VIDEO_YUV_CONSTANTS+CHANNEL_OFFSET);
+	pokeRegisterDWord(regYUV,
+	    FIELD_VALUE(0, VIDEO_YUV_CONSTANTS, Y, yConstant) |
+	    FIELD_VALUE(0, VIDEO_YUV_CONSTANTS, R, redConstant) |
+	    FIELD_VALUE(0, VIDEO_YUV_CONSTANTS, G, greenConstant) |
+	    FIELD_VALUE(0, VIDEO_YUV_CONSTANTS, B, blueConstant));
+}
+
+/*
+ *  videoSetInitialScale
+ *      This function sets the video buffer initial vertical scale.
+ *
+ *  Input:
+ *      bufferIndex         - Index of the buffer which vertical scale value
+ *                            to be set.
+ *      bufferInitScale     - Buffer Initial vertical scale value
+ */
+void videoSetInitialScale(
+	unsigned dispCtrl,
+    unsigned short InitScaleHorizontal,
+    unsigned short InitScaleVertical
+)
+{
+    unsigned long value;
+	unsigned long regScale;
+
+	regScale = (dispCtrl == CHANNEL0_CTRL)? VIDEO_INITIAL_SCALE : (VIDEO_INITIAL_SCALE+CHANNEL_OFFSET);
+
+    value = peekRegisterDWord(regScale);
+    value = FIELD_VALUE(value, VIDEO_INITIAL_SCALE, VERTICAL, InitScaleVertical);
+    value = FIELD_VALUE(value, VIDEO_INITIAL_SCALE, HORIZONTAL, InitScaleHorizontal);
+    pokeRegisterDWord(regScale, value);
+}
+
+/*
+ *  videoGetInitialScale
+ *      This function gets the video buffer initial vertical scale.
+ *
+ *  Input:
+ *      pbuffer0InitScale   - Pointer to variable to store buffer 0 initial vertical scale
+ *      pbuffer1InitScale   - Pointer to variable to store buffer 1 initial vertical scale
+ */
+void videoGetInitialScale(
+	unsigned dispCtrl,
+    unsigned short *pBufferVInitScale,
+    unsigned short *pBufferHInitScale
+)
+{
+	unsigned long regScale;
+
+	regScale = (dispCtrl == CHANNEL0_CTRL)? VIDEO_INITIAL_SCALE : (VIDEO_INITIAL_SCALE+CHANNEL_OFFSET);
+
+    *pBufferHInitScale = (unsigned short)
+        FIELD_GET(peekRegisterDWord(regScale), VIDEO_INITIAL_SCALE, HORIZONTAL);
+    *pBufferVInitScale = (unsigned short)
+        FIELD_GET(peekRegisterDWord(regScale), VIDEO_INITIAL_SCALE, VERTICAL);
+}
+
+/*
+ *  videoScale
+ *      This function scales the video.
+ *
+ *  Input:
+ *      srcWidth     - The source video width
+ *      srcHeight    - The source video height
+ *      dstWidth     - The destination video width 
+ *      dstHeight    - The destination video height
+ */
+void videoScale(
+	unsigned dispCtrl,
+    unsigned long srcWidth,
+    unsigned long srcHeight,
+    unsigned long dstWidth,
+    unsigned long dstHeight
+)
+{
+    unsigned long value = 0;
+    unsigned long scaleFactor;
+	unsigned long regScale;
+
+	regScale = (dispCtrl == CHANNEL0_CTRL)? VIDEO_SCALE : (VIDEO_SCALE+CHANNEL_OFFSET);
+
+	if (dstHeight >= srcHeight)
+	{
+	    /* Calculate the factor */
+	    scaleFactor = (srcHeight-1) * SCALE_CONSTANT / dstHeight;
+	    value = FIELD_VALUE(value, VIDEO_SCALE , VERTICAL_SCALE, scaleFactor);
+	}
+	
+	/* Scale the horizontal size */
+	if (dstWidth >= srcWidth)
+	{
+	    /* Calculate the factor */
+	    scaleFactor = (srcWidth-1) * SCALE_CONSTANT / dstWidth;
+	    value = FIELD_VALUE(value, VIDEO_SCALE, HORIZONTAL_SCALE, scaleFactor);
+	}
+	
+	pokeRegisterDWord(regScale, value);
+}
+
+
+/*
+ *  videoSwapYUVByte
+ *      This function swaps the YUV data byte.
+ *
+ *  Input:
+ *      byteSwap    - Flag to enable/disable YUV data byte swap.
+ */
+void videoSwapYUVByte(
+	unsigned dispCtrl,
+   	video_byteswap_t byteSwap  
+)
+{
+    unsigned long value;
+	unsigned long regCtrl;
+
+	regCtrl = (dispCtrl == CHANNEL0_CTRL)? VIDEO_DISPLAY_CTRL : (VIDEO_DISPLAY_CTRL+CHANNEL_OFFSET);
+
+	value = peekRegisterDWord(regCtrl);
+	if (byteSwap == SWAP_BYTE)
+	    value = FIELD_SET(value, VIDEO_DISPLAY_CTRL, BYTE_SWAP, ENABLE);
+	else
+	    value = FIELD_SET(value, VIDEO_DISPLAY_CTRL, BYTE_SWAP, DISABLE);
+	
+	pokeRegisterDWord(regCtrl, value);
+}
+
+/*
+ *  videoSetInterpolation
+ *      This function enables/disables the horizontal and vertical interpolation.
+ *
+ *  Input:
+ *      enableHorzInterpolation   - Flag to enable/disable Horizontal interpolation
+ *      enableVertInterpolation   - Flag to enable/disable Vertical interpolation
+ */
+void videoSetInterpolation(
+	unsigned dispCtrl,
+    unsigned long enableHorzInterpolation,
+    unsigned long enableVertInterpolation
+)
+{
+    unsigned long value;
+	unsigned long regCtrl;
+
+	regCtrl = (dispCtrl == CHANNEL0_CTRL)? VIDEO_DISPLAY_CTRL : (VIDEO_DISPLAY_CTRL+CHANNEL_OFFSET);
+
+	value = peekRegisterDWord(regCtrl);
+	
+	if (enableHorzInterpolation)
+	    value = FIELD_SET(value, VIDEO_DISPLAY_CTRL, HORIZONTAL_MODE, INTERPOLATE);
+	else
+	    value = FIELD_SET(value, VIDEO_DISPLAY_CTRL, HORIZONTAL_MODE, REPLICATE);
+	    
+	if (enableVertInterpolation)
+	    value = FIELD_SET(value, VIDEO_DISPLAY_CTRL, VERTICAL_MODE, INTERPOLATE);
+	else
+	    value = FIELD_SET(value, VIDEO_DISPLAY_CTRL, VERTICAL_MODE, REPLICATE);
+	    
+	pokeRegisterDWord(regCtrl, value);
+}
+
+/*
+ *  videoGetInterpolation
+ *      This function gets the horizontal and vertical interpolation enable status.
+ *
+ *  Input:
+ *      pHorzInterpolationStatus	- Pointer to store the horizontal interpolation status
+ *      pVertInterpolationStatus	- Pointer to store the vertical interpolation status
+ */
+void videoGetInterpolation(
+    unsigned long *pHorzInterpolationStatus,
+    unsigned long *pVertInterpolationStatus
+)
+{
+    unsigned long value;
+    
+    value = peekRegisterDWord(VIDEO_DISPLAY_CTRL);
+    if (pHorzInterpolationStatus != (unsigned long *)0)
+	{
+		if (FIELD_GET(value, VIDEO_DISPLAY_CTRL, HORIZONTAL_MODE) == VIDEO_DISPLAY_CTRL_HORIZONTAL_MODE_INTERPOLATE)
+        	*pHorzInterpolationStatus = 1;
+		else
+			*pHorzInterpolationStatus = 0;
+	}
+        
+    if (pHorzInterpolationStatus != (unsigned long *)0)
+	{
+		if (FIELD_GET(value, VIDEO_DISPLAY_CTRL, VERTICAL_MODE) == VIDEO_DISPLAY_CTRL_VERTICAL_MODE_INTERPOLATE)
+			*pVertInterpolationStatus = 1;
+		else
+			*pVertInterpolationStatus = 0;
+	}
+}
+
+/*
+ *  videoSetStartPanningPixel
+ *      This function sets the starting pixel number for smooth pixel panning.
+ *
+ *  Input:
+ *      startPixel  - Starting pixel number for smooth pixel panning
+ */
+void videoSetStartPanningPixel(
+    unsigned char startPixel
+)
+{
+    pokeRegisterDWord(VIDEO_DISPLAY_CTRL, 
+                      peekRegisterDWord(VIDEO_DISPLAY_CTRL) | 
+                      FIELD_VALUE(0, VIDEO_DISPLAY_CTRL, PIXEL, startPixel));    
+}
+
+/*
+ *  videoSetGamma
+ *      This function enables/disables gamma control.
+ *
+ *  Input:
+ *      enableGammaCtrl - The gamma enable control
+ *
+ *  NOTE:
+ *      The gamma can only be enabled in RGB565 and RGB888. Enable this gamma
+ *      without proper format will have no effect.
+ */
+void videoSetGammaCtrl(
+    unsigned dispCtrl,
+    unsigned long enableGammaCtrl
+)
+{
+    unsigned long value;
+	unsigned long regCtrl;
+
+	regCtrl = (dispCtrl == CHANNEL0_CTRL)? VIDEO_DISPLAY_CTRL : (VIDEO_DISPLAY_CTRL+CHANNEL_OFFSET);
+
+	value = peekRegisterDWord(regCtrl);
+	
+	if (enableGammaCtrl)
+	    value = FIELD_SET(value, VIDEO_DISPLAY_CTRL, GAMMA, ENABLE);
+	else
+	    value = FIELD_SET(value, VIDEO_DISPLAY_CTRL, GAMMA, DISABLE);
+	    
+	pokeRegisterDWord(regCtrl, value);    
+}
+
+/*
+ *  isVideoEnable
+ *      This function check whether the video plane is already enabled or not.
+ *
+ *  Output:
+ *      0   - Disable
+ *      1   - Enable
+ */
+unsigned char isVideoEnable()
+{
+    unsigned long value;
+    
+    value = peekRegisterDWord(VIDEO_DISPLAY_CTRL);
+    
+    return ((FIELD_GET(value, VIDEO_DISPLAY_CTRL, PLANE) == VIDEO_DISPLAY_CTRL_PLANE_ENABLE) ? 1 : 0);
+}
+
+/*
+ *  videoSetCtrl
+ *      This function enable/disable the video plane.
+ *
+ *  Input:
+ *      videoCtrl   - Enable/Disable video
+ */
+static void videoSetCtrl(
+    disp_control_t dispCtrl,
+    video_ctrl_t videoCtrl
+)
+{
+    unsigned long value;
+	unsigned long regCtrl;
+
+	regCtrl = (dispCtrl == CHANNEL0_CTRL)? VIDEO_DISPLAY_CTRL : (VIDEO_DISPLAY_CTRL+CHANNEL_OFFSET);
+
+	value = peekRegisterDWord(regCtrl);
+	
+	if (videoCtrl == VIDEO_ON)
+	    value = FIELD_SET(value, VIDEO_DISPLAY_CTRL, PLANE, ENABLE);
+	else
+	    value = FIELD_SET(value, VIDEO_DISPLAY_CTRL, PLANE, DISABLE);
+	            
+	pokeRegisterDWord(regCtrl, value); 
+}
+
+/*
+ *  videoSetFormat
+ *      This function sets the video format.
+ *
+ *  Input:
+ *      videoFormat - The video content format
+ *                    * FORMAT_RGB565 - 16-bit RGB 5:6:5 mode
+ *                    * FORMAT_YUYV - 16-bit YUYV mode
+ */
+static void videoSetFormat(
+    unsigned dispCtrl,
+    video_format_t  videoFormat
+)
+{
+    unsigned long value;
+	unsigned long regCtrl;
+
+	regCtrl = (dispCtrl == CHANNEL0_CTRL)? VIDEO_DISPLAY_CTRL : (VIDEO_DISPLAY_CTRL+CHANNEL_OFFSET);
+
+	value = peekRegisterDWord(regCtrl);
+	switch (videoFormat)
+	{
+	    default:
+	    case FORMAT_RGB565:
+	        value = FIELD_SET(value,  VIDEO_DISPLAY_CTRL , FORMAT, 16);
+	        break;
+	    case FORMAT_RGB888:
+	        value = FIELD_SET(value,  VIDEO_DISPLAY_CTRL , FORMAT, 32);
+	        break;
+	    case FORMAT_YUYV:
+	        value = FIELD_SET(value,  VIDEO_DISPLAY_CTRL , FORMAT, YUV422);
+	        break;
+	    case FORMAT_YUV420:
+	        value = FIELD_SET(value,  VIDEO_DISPLAY_CTRL , FORMAT, YUV420);
+	        break;
+	}
+	
+	pokeRegisterDWord(regCtrl, value);
+}
+
+/*
+ *  videoSetEdgeDetection
+ *      This function enable/disable the edge detection and fill out the edge detection
+ *      value as well. This function only works in SM718. SM750 does not support this
+ *      feature.
+ *
+ *  Input:
+ *      enableEdgeDetect    - Enable/Disable Edge Detection (0 - disable, 1 = enable)
+ *      edgeDetectValue     - The Edge Detection value. This is the difference (delta)
+ *                            of the pixel colors to be considered as an edge.
+ *
+ *  Note:
+ *      This edge correction only works in up-scale video.
+ */
+void videoSetEdgeDetection(
+    unsigned long enableEdgeDetect,
+    unsigned long edgeDetectValue
+)
+{
+#if 0 //SM768 don't have this register. Just leave an empty function here.
+    unsigned long value;
+    
+    if (getChipType() == SM718)
+    {
+        if (enableEdgeDetect == 1)
+        {
+            value = FIELD_SET(0, VIDEO_EDGE_DETECTION, DETECT, ENABLE) |
+                    FIELD_VALUE(value, VIDEO_EDGE_DETECTION, VALUE, edgeDetectValue);
+            pokeRegisterDWord(VIDEO_EDGE_DETECTION, value); 
+        }
+        else
+        {
+            value = FIELD_SET(peekRegisterDWord(VIDEO_EDGE_DETECTION), VIDEO_EDGE_DETECTION, DETECT, DISABLE);
+            pokeRegisterDWord(VIDEO_EDGE_DETECTION, value);
+        }
+    }
+#endif
+}
+
+/*
+ *  videoGetEdgeDetection
+ *      This function gets the information whether the edge detection is enabled or not.
+ *      It also outputs the edge detection value if required.
+ *      This function only works in SM718. SM750 does not support this feature.
+ *
+ *  Input:
+ *      pEdgeDetectValue    - Pointer to a buffer to store the edge detection value.
+ *
+ *  Note:
+ *      0   - Edge Detection is disabled
+ *      1   - Edge Detection is enabled
+ */
+unsigned long videoGetEdgeDetection(
+    unsigned long *pEdgeDetectValue
+)
+{
+#if 0 //Not for SM768
+    unsigned long value;
+    
+    if (getChipType() == SM718)
+    {
+        value = peekRegisterDWord(VIDEO_EDGE_DETECTION);
+        
+        if (pEdgeDetectValue != (unsigned long *)0)
+            *pEdgeDetectValue = (unsigned long) FIELD_GET(value, VIDEO_EDGE_DETECTION, VALUE);
+            
+        if (FIELD_GET(value, VIDEO_EDGE_DETECTION, DETECT) == VIDEO_EDGE_DETECTION_DETECT_ENABLE)
+            return 1;
+        else
+            return 0; 
+    }
+#endif    
+    return 0;
+}
+
+/*
+ *  videoSetup
+ *      This function setups the video. This function only works in SM718. 
+ *      SM750 does not support edge detection feature. If calling this function
+ *      in SM750, set edgeDetect flag to 0
+ *
+ *  Input:
+ *      x               - X Coordinate of the video window
+ *      y               - Y Coordinate of the video window
+ *      srcWidth        - The source video width
+ *      srcHeight       - The source video height
+ *      dstWidth        - The destination video width
+ *      dstHeight       - The destination video height
+ *      doubleBuffer    - Double Buffer enable flag
+ *      srcAddress0     - The source of the video buffer 0 to display
+ *      srcAddress1     - The source of the video buffer 1 to display
+ *                        (only for double buffering).
+ *      srcPitch        - The source video plane pitch in bytes
+ *      srcLineOffset   - The source video plane line offset in bytes.
+ *                        In normal usage, set it the same as the srcBufferPitch
+ *      videoFormat     - Source video format
+ *      edgeDetect      - Edge Detection enable flag (can only works with vertical upscaling)
+ *                              0 - Disable
+ *                              1 - Always Enable (alwasy enabled regardless horizontal scaling condition)
+ *                              2 - Auto Enable (only enabled when no horizontal shrink)
+ *      edgeDetectValue - Edge Detection value
+ *
+ *  Output:
+ *      0   - Success
+ *     -1  - Fail
+ */
+unsigned char videoSetupEx(
+	unsigned dispCtrl,
+    unsigned long x,                /* X Coordinate of the video window */
+    unsigned long y,                /* Y Coordinate of the video window */
+    unsigned long srcWidth,         /* The source video width */
+    unsigned long srcHeight,        /* The source video height */
+    unsigned long dstWidth,         /* The destination video width */
+    unsigned long dstHeight,        /* The destination video height */
+    unsigned long doubleBuffer,     /* Double Buffer enable flag */
+    unsigned long srcAddress0,      /* The source of the video buffer 0 to display */
+    unsigned long sUAddress,            /* U Source Base Address (not used in RGB Space) */
+    unsigned long sVAddress,            /* V Source Base Address (not used in RGB Space) */
+    unsigned long sUVPitch,             /* UV plane pitch value in bytes (not used in */ 
+    unsigned long srcPitch,         /* The source video plane pitch in bytes */
+    unsigned long srcLineOffset,    /* The source video plane line offset in bytes.
+                                       Set it the same as srcPitch in normal
+                                       usage. */
+    video_format_t videoFormat,      /* Source video format */
+    unsigned long edgeDetect,       /* Edge Detection enable flag */
+    unsigned long edgeDetectValue   /* Edge Detection value. SM718 only use bit 9 to 0 */
+)
+{
+    unsigned long enableEdgeDetect;
+    /* Save the source video width and height */
+    gSrcVideoWidth = srcWidth;
+    gSrcVideoHeight = srcHeight;
+    /* Disable the video plane first */
+    videoSetCtrl(dispCtrl, VIDEO_OFF);
+    
+    /* Set the video position */
+    videoSetPosition(dispCtrl, x, y);
+    
+    /* Set the scale factor */
+    videoScale(dispCtrl, srcWidth, srcHeight, dstWidth, dstHeight);
+    
+    /* Set the video format */
+    videoSetFormat(dispCtrl, videoFormat);
+    
+    /* Set the buffer pitch */
+    videoSetPitchOffset(dispCtrl, srcPitch, srcLineOffset);
+    /* Set the UV buffer pitch */
+    videoSetUVPitchOffset(dispCtrl, sUVPitch, sUVPitch);
+    
+    /* Enable double buffer */
+//    videoEnableDoubleBuffer(doubleBuffer);
+    
+    /* Set the video buffer 0 and 1 */
+    videoSetBuffer(dispCtrl, 0, srcAddress0);
+//    videoSetBuffer(dispCtrl, 1, srcAddress1);
+   
+    /* Set the video buffer U and V */
+    videoSetUVBuffer(dispCtrl, sUAddress, sVAddress);
+        
+    /* Set the destination video window */
+    videoSetWindowSize(dispCtrl, dstWidth, dstHeight);
+
+    /* Set the last line */
+    videoSetLast(dispCtrl, srcWidth, srcHeight);
+    
+    /* Set the edge detection enable bit and its value (if applicable) */
+    if (edgeDetect == 0)
+        enableEdgeDetect = 0;
+    else if (edgeDetect == 1)
+        enableEdgeDetect = 1;
+    else
+    {
+        /* Only enable the edgeDetection when scaling up vertically and no 
+           shrinking on the horizontal. */
+        if ((dstHeight > srcHeight) && (dstWidth >= srcWidth))
+            enableEdgeDetect = 1;
+        else
+            enableEdgeDetect = 0;
+    }
+    videoSetEdgeDetection(enableEdgeDetect, edgeDetectValue);
+    
+    return 0;
+}
+
+/*
+ *  videoSetup
+ *      This function setups the video.
+ *
+ *  Input:
+ *      x               - X Coordinate of the video window
+ *      y               - Y Coordinate of the video window
+ *      srcWidth        - The source video width
+ *      srcHeight       - The source video height
+ *      dstWidth        - The destination video width
+ *      dstHeight       - The destination video height
+ *      doubleBuffer    - Double Buffer enable flag
+ *      srcAddress0     - The source of the video buffer 0 to display
+ *      srcAddress1     - The source of the video buffer 1 to display
+ *                        (only for double buffering).
+ *      srcPitch        - The source video plane pitch in bytes
+ *      srcLineOffset   - The source video plane line offset in bytes.
+ *                        In normal usage, set it the same as the srcBufferPitch
+ *      videoFormat     - Source video format
+ *
+ *  Output:
+ *      0   - Success
+ *     -1  - Fail
+ */
+unsigned char videoSetup(
+    disp_control_t dispCtrl,
+    unsigned long x,                /* X Coordinate of the video window */
+    unsigned long y,                /* Y Coordinate of the video window */
+    unsigned long srcWidth,         /* The source video width */
+    unsigned long srcHeight,        /* The source video height */
+    unsigned long dstWidth,         /* The destination video width */
+    unsigned long dstHeight,        /* The destination video height */
+    unsigned long doubleBuffer,     /* Double Buffer enable flag */
+    unsigned long srcAddress0,      /* The source of the video buffer 0 to display */
+    unsigned long srcAddress1,      /* The source of the video buffer 1 to display
+                                       (only for double buffering).
+                                     */
+    unsigned long srcPitch,         /* The source video plane pitch in bytes */
+    unsigned long srcLineOffset,    /* The source video plane line offset in bytes.
+                                       Set it the same as srcPitch in normal
+                                       usage. */
+    video_format_t videoFormat      /* Source video format */
+)
+{
+    return videoSetupEx(dispCtrl, x, y, srcWidth, srcHeight, dstWidth, dstHeight, doubleBuffer, 
+                        srcAddress0, 0, 0, 0,srcPitch, srcLineOffset, videoFormat,
+                        0, 0);
+    
+}
+
+/*
+ *  startVideo
+ *      This function starts the video.
+ */
+void startVideo( 
+unsigned dispCtrl
+)
+{
+    /* Enable the video plane */
+    videoSetCtrl(dispCtrl, VIDEO_ON);
+}
+
+/*
+ *  stopVideo
+ *      This function stops the video.
+ */
+void stopVideo(unsigned dispCtrl)
+{
+    /* Just disable the video plane */
+    videoSetCtrl(dispCtrl, VIDEO_OFF);
+}
+
+
+
diff --git a/drivers/gpu/drm/smi/ddk768/ddk768_video.h b/drivers/gpu/drm/smi/ddk768/ddk768_video.h
new file mode 100644
index 000000000000..286cf552fa29
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk768/ddk768_video.h
@@ -0,0 +1,564 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2007 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  Video.H --- SM768 DDK 
+*  This file contains the definitions for the Video functions.
+* 
+*******************************************************************/
+
+
+/****************************************************************************
+   Structure and data type definition 
+ ****************************************************************************/
+
+/* video format: 
+   - 16-bit RGB 5:6:5 mode
+   - 16-bit YUYV mode
+  
+   Note: The 8-bit index and RGB 8:8:8 formats are not supported
+ */
+typedef enum _video_format_t
+{
+    FORMAT_RGB565 = 0,
+    FORMAT_YUV420,
+    FORMAT_YUYV,
+	FORMAT_RGB888
+}
+video_format_t;
+
+/* YUV Data Byte Swap */
+typedef enum _video_byteswap_t
+{
+    NORMAL = 0,
+    SWAP_BYTE
+}
+video_byteswap_t;
+
+/* Turn on/off video */
+typedef enum _video_sync_source_t
+{
+    NORMAL_BUFFER = 0,
+    CAPTURE_BUFFER
+}
+video_sync_source_t;
+
+/* FIFO Request Level */
+typedef enum _video_fifo_t
+{
+    FIFO_LEVEL_1 = 0,
+    FIFO_LEVEL_3,
+    FIFO_LEVEL_7,
+    FIFO_LEVEL_11
+}
+video_fifo_t;
+
+/* Turn on/off video */
+typedef enum _video_ctrl_t
+{
+    VIDEO_OFF = 0,
+    VIDEO_ON
+}
+video_ctrl_t;
+
+
+/****************************************************************************
+   Function prototype 
+ ****************************************************************************/
+
+/*
+ *  videoSetWindowAdjustment
+ *      This function sets the video window adjustment. There are usually
+ *      some garbage lines or pixels at the bottom and right of the video
+ *      window. These function will adjust the video window accordingly.
+ *
+ *  Input:
+ *      widthAdjustment     - Width adjustments in pixel
+ *      heightAdjustment    - Height adjustment in line        
+ */
+void videoSetWindowAdjustment(
+	unsigned dispCtrl,
+    short widthAdjustment,
+    short heightAdjustment
+);
+
+/*
+ *  videoGetWindowAdjustment
+ *      This function gets the video window adjustment.
+ *
+ *  Input:
+ *      widthAdjustment     - Width adjustments in pixel
+ *      heightAdjustment    - Height adjustment in line 
+ */
+void videoGetWindowAdjustment(
+    short *pWidthAdjustment,
+    short *pHeightAdjustment
+);
+
+/*
+ * videoGetCurrentBufferDisplay
+ *      This function gets the current buffer used by SM50x to display on the screen
+ *
+ *  Return:
+ *      0   - Buffer 0
+ *      1   - Buffer 1 
+ */
+// unsigned char videoGetCurrentBufferDisplay();
+
+/*
+ * videoEnableDoubleBuffer
+ *      This function enables/disables the double buffer usage
+ *
+ *  Input:
+ *      enable  - Flag to enable/disable the double buffer. 
+ */
+#if 0
+void videoEnableDoubleBuffer(
+    unsigned long enable
+);
+#endif
+
+/*
+ * videoGetBufferStatus
+ *      This function gets the status of the video buffer, either the buffer
+ *      has been used or not.
+ *
+ *  Input:
+ *      bufferIndex     - The index of the buffer which size to be retrieved
+ *
+ *  Output:
+ *      0 - No flip pending
+ *      1 - Flip pending
+ */
+unsigned long videoGetBufferStatus(
+    unsigned long bufferIndex
+);
+
+/*
+ * videoGetBuffer
+ *      This function gets the video buffer
+ *
+ *  Input:
+ *      bufferIndex - The index of the buffer to get
+ *
+ *  Output:
+ *      The video buffer of the requested index.
+ */
+unsigned long videoGetBuffer(
+    unsigned char bufferIndex
+);
+
+/*
+ * videoSetBuffer
+ *      This function sets the video buffer
+ *
+ *  Input:
+ *      bufferIndex         - The index of the buffer to be set
+ *      bufferStartAddress  - The starting address of the buffer
+ */
+void videoSetBuffer(
+	unsigned dispCtrl,
+    unsigned char bufferIndex,          /* The index of the buffer to be set. */
+    unsigned long bufferStartAddress    /* Video buffer with 128-bit alignment */
+);
+/*
+ * videoSetUVBuffer
+ *      This function sets the video buffer of U and V
+ *
+ *  Input:
+ *      bufferIndex         - The index of the buffer to be set
+ *      bufferStartAddress  - The starting address of the buffer
+ */
+void videoSetUVBuffer(
+	unsigned dispCtrl,
+    unsigned long bufferStartUAddress,    /* Video buffer with 128-bit alignment */
+    unsigned long bufferStartVAddress    /* Video buffer with 128-bit alignment */
+);
+
+/*
+ * videoSetPitchOffset
+ *      This function sets the video plane pitch and offset
+ *
+ *  Input:
+ *      pitch           - Number of bytes per line of the video plane 
+ *                        specified in 128-bit aligned bytes.
+ *      lineOffset      - Number of 128-bit aligned bytes per line 
+ *                        of the video plane.
+ */
+void videoSetPitchOffset(
+	unsigned dispCtrl,
+    unsigned short pitch,
+    unsigned short lineOffset
+);
+
+/*
+ * videoSetUVPitchOffset
+ *      This function sets the video plane pitch and offset of U and V
+ *
+ *  Input:
+ *      pitch           - Number of bytes per line of the video plane 
+ *                        specified in 128-bit aligned bytes.
+ *      lineOffset      - Number of 128-bit aligned bytes per line 
+ *                        of the video plane.
+ */
+void videoSetUVPitchOffset(
+	unsigned dispCtrl,
+    unsigned short pitch,
+    unsigned short lineOffset
+);
+
+/*
+ * videoGetPitch
+ *      This function gets the video plane pitch
+ *
+ * Output:
+ *      pitch   - Number of bytes per line of the video plane 
+ *                specified in 128-bit aligned bytes.
+ */
+unsigned short videoGetPitch(void);
+
+/*
+ * videoGetLineOffset
+ *      This function gets the video plane line offset
+ *
+ * Output:
+ *      lineOffset  - Number of 128-bit aligned bytes per line 
+ *                    of the video plane.
+ */
+unsigned short videoGetLineOffset(void);
+/*
+ *  videoSetLast 
+ *      This function sets the video source last lines and width.
+ *
+ *  Input:
+ *
+ *      width      - Video source width
+ *      height      - Video source height
+ */
+void videoSetLast(
+	unsigned dispCtrl,
+    unsigned long width,
+    unsigned long height
+);
+
+/*
+ *  videoSetWindowSize
+ *      This function sets the video window size.
+ *
+ *  Input:
+ *      width       - Video Window width
+ *      height      - Video Window height
+ */
+void videoSetWindowSize(
+	unsigned dispCtrl,
+    unsigned long width,
+    unsigned long height
+);
+
+/*
+ *  videoGetWindowSize
+ *      This function gets the video window size.
+ *
+ *  Output:
+ *      width       - Video Window width
+ *      height      - Video Window height
+ */
+void videoGetWindowSize(
+	unsigned dispCtrl,
+    unsigned long *pWidth,
+    unsigned long *pHeight
+);
+
+/*
+ *  videoSetPosition
+ *      This function sets the video starting coordinate position.
+ *
+ *  Input:
+ *      startX      - X Coordinate of the video window starting position
+ *      startY      - Y Coordinate of the video window starting position
+ */
+void videoSetPosition(
+	unsigned dispCtrl,
+    unsigned long startX,
+    unsigned long startY
+);
+
+/*
+ *  videoSetConstants
+ *      This function sets the video constants. The actual component will be
+ *      added by this constant to get the expected component value.
+ *
+ *  Input:
+ *      yConstant       - Y Constant Value
+ *      redConstant     - Red Constant Value
+ *      greenConstant   - Green Constant Value
+ *      blueConstant    - Blue Constant Value
+ */
+void videoSetConstants(
+	unsigned dispCtrl,
+    unsigned char  yConstant,               /* Y Adjustment */
+    unsigned char  redConstant,             /* Red Conversion constant */
+    unsigned char  greenConstant,           /* Green Conversion constant */
+    unsigned char  blueConstant             /* Blue Conversion constant */
+);
+
+/*
+ *  videoSetInitialScale
+ *      This function sets the video buffer initial vertical scale.
+ *
+ *  Input:
+ *      bufferIndex         - Index of the buffer which vertical scale value
+ *                            to be set.
+ *      bufferInitScale     - Buffer Initial vertical scale value
+ */
+void videoSetInitialScale(
+	unsigned dispCtrl,
+    unsigned short InitScaleHorizontal,
+    unsigned short InitScaleVertical
+);
+
+/*
+ *  videoSetFIFOLevel
+ *      This function sets the video FIFO Request Level.
+ *
+ *  Input:
+ *      videoSource - Buffer source selection
+ */
+#if 0
+void videoSetFIFOLevel(
+    video_fifo_t videoFIFO
+);
+#endif
+/*
+ *  videoSetSourceBuffer
+ *      This function sets the video to use the capture buffer as the source.
+ *
+ *  Input:
+ *      videoSource - Buffer source selection
+ */
+#if 0
+void videoSetSourceBuffer(
+    video_sync_source_t videoSource
+);
+#endif
+
+/*
+ *  videoSwapYUVByte
+ *      This function swaps the YUV data byte.
+ *
+ *  Input:
+ *      byteSwap    - Flag to enable/disable YUV data byte swap.
+ */
+void videoSwapYUVByte(
+   unsigned dispCtrl,
+   video_byteswap_t byteSwap  
+);
+
+/*
+ *  videoSetInterpolation
+ *      This function enables/disables the horizontal and vertical interpolation.
+ *
+ *  Input:
+ *      enableHorzInterpolation   - Flag to enable/disable Horizontal interpolation
+ *      enableVertInterpolation   - Flag to enable/disable Vertical interpolation
+ */
+void videoSetInterpolation(
+	unsigned dispCtrl,
+    unsigned long enableHorzInterpolation,
+    unsigned long enableVertInterpolation
+);
+
+/*
+ *  videoGetInterpolation
+ *      This function gets the horizontal and vertical interpolation enable status.
+ *
+ *  Input:
+ *      pHorzInterpolationStatus	- Pointer to store the horizontal interpolation status
+ *      pVertInterpolationStatus	- Pointer to store the vertical interpolation status
+ */
+void videoGetInterpolation(
+    unsigned long *pHorzInterpolationStatus,
+    unsigned long *pVertInterpolationStatus
+);
+
+/*
+ *  videoSetStartPanningPixel
+ *      This function sets the starting pixel number for smooth pixel panning.
+ *
+ *  Input:
+ *      startPixel  - Starting pixel number for smooth pixel panning
+ */
+void videoSetStartPanningPixel(
+    unsigned char startPixel
+);
+
+/*
+ *  videoSetGamma
+ *      This function enables/disables gamma control.
+ *
+ *  Input:
+ *      enableGammaCtrl - The gamma enable control
+ *
+ *  NOTE:
+ *      The gamma can only be enabled in RGB565 and RGB888. Enable this gamma
+ *      without proper format will have no effect.
+ */
+void videoSetGammaCtrl(
+	unsigned dispCtrl,
+    unsigned long enableGammaCtrl
+);
+
+/*
+ *  isVideoEnable
+ *      This function check whether the video plane is already enabled or not.
+ *
+ *  Output:
+ *      0   - Disable
+ *      1   - Enable
+ */
+unsigned char isVideoEnable(void);
+
+/*
+ *  videoSetEdgeDetection
+ *      This function enable/disable the edge detection and fill out the edge detection
+ *      value as well. This function only works in SM718. SM750 does not support this
+ *      feature.
+ *
+ *  Input:
+ *      enableEdgeDetect    - Enable/Disable Edge Detection
+ *      edgeDetectValue     - The Edge Detection value. This is the difference (delta)
+ *                            of the pixel colors to be considered as an edge.
+ *
+ *  Note:
+ *      This edge correction only works in up-scale video.
+ */
+void videoSetEdgeDetection(
+    unsigned long enableEdgeDetect,
+    unsigned long edgeDetectValue
+);
+
+/*
+ *  videoGetEdgeDetection
+ *      This function gets the information whether the edge detection is enabled or not.
+ *      It also outputs the edge detection value if required.
+ *      This function only works in SM718. SM750 does not support this feature.
+ *
+ *  Input:
+ *      pEdgeDetectValue    - Pointer to a buffer to store the edge detection value.
+ *
+ *  Note:
+ *      0   - Edge Detection is disabled
+ *      1   - Edge Detection is enabled
+ */
+unsigned long videoGetEdgeDetection(
+    unsigned long *pEdgeDetectValue
+);
+
+/*
+ *  videoSetupEx
+ *      This function setups the video. It only applies in SM718
+ *
+ *  Input:
+ *      x               - X Coordinate of the video window
+ *      y               - Y Coordinate of the video window
+ *      srcWidth        - The source video width
+ *      srcHeight       - The source video height
+ *      dstWidth        - The destination video width
+ *      dstHeight       - The destination video height
+ *      doubleBuffer    - Double Buffer enable flag
+ *      srcAddress0     - The source of the video buffer 0 to display
+ *      srcAddress1     - The source of the video buffer 1 to display
+ *                        (only for double buffering).
+ *      srcPitch        - The source video plane pitch in bytes
+ *      srcLineOffset   - The source video plane line offset in bytes.
+ *                        In normal usage, set it the same as the srcBufferPitch
+ *      videoFormat     - Source video format
+ *      edgeDetect      - Edge Detection enable flag
+ *      edgeDetectValue - Edge Detection value
+ *
+ *  Output:
+ *      0   - Success
+ *     -1  - Fail
+ */
+unsigned char videoSetupEx(
+	unsigned dispCtrl,
+    unsigned long x,                /* X Coordinate of the video window */
+    unsigned long y,                /* Y Coordinate of the video window */
+    unsigned long srcWidth,         /* The source video width */
+    unsigned long srcHeight,        /* The source video height */
+    unsigned long dstWidth,         /* The destination video width */
+    unsigned long dstHeight,        /* The destination video height */
+    unsigned long doubleBuffer,     /* Double Buffer enable flag */
+    unsigned long srcAddress0,      /* The source of the video buffer 0 to display */
+    unsigned long sUAddress,            /* U Source Base Address (not used in RGB Space) */
+    unsigned long sVAddress,            /* V Source Base Address (not used in RGB Space) */
+    unsigned long sUVPitch,             /* UV plane pitch value in bytes (not used in */ 
+    unsigned long srcPitch,         /* The source video plane pitch in bytes */
+    unsigned long srcLineOffset,    /* The source video plane line offset in bytes.
+                                       Set it the same as srcPitch in normal
+                                       usage. */
+    video_format_t videoFormat,      /* Source video format */
+    unsigned long edgeDetect,       /* Edge Detection enable flag */
+    unsigned long edgeDetectValue   /* Edge Detection value. SM718 only use bit 9 to 0 */
+);
+
+/*
+ *  videoSetup
+ *      This function setups the video.
+ *
+ *  Input:
+ *      x               - X Coordinate of the video window
+ *      y               - Y Coordinate of the video window
+ *      srcWidth        - The source video width
+ *      srcHeight       - The source video height
+ *      dstWidth        - The destination video width
+ *      dstHeight       - The destination video height
+ *      doubleBuffer    - Double Buffer enable flag
+ *      srcAddress0     - The source of the video buffer 0 to display
+ *      srcAddress1     - The source of the video buffer 1 to display
+ *                        (only for double buffering).
+ *      srcPitch        - The source video plane pitch in bytes
+ *      srcLineOffset   - The source video plane line offset in bytes.
+ *                        In normal usage, set it the same as the srcBufferPitch
+ *      videoFormat     - Source video format
+ *
+ *  Output:
+ *      0   - Success
+ *     -1  - Fail
+ */
+unsigned char videoSetup(
+    disp_control_t dispCtrl,
+    unsigned long x,                /* X Coordinate of the video window */
+    unsigned long y,                /* Y Coordinate of the video window */
+    unsigned long srcWidth,         /* The source video width */
+    unsigned long srcHeight,        /* The source video height */
+    unsigned long dstWidth,         /* The destination video width */
+    unsigned long dstHeight,        /* The destination video height */
+    unsigned long doubleBuffer,     /* Double Buffer enable flag */
+    unsigned long srcAddress0,      /* The source of the video buffer 0 to display */
+    unsigned long srcAddress1,      /* The source of the video buffer 1 to display
+                                       (only for double buffering).
+                                     */
+    unsigned long srcPitch,         /* The source video plane pitch in bytes */
+    unsigned long srcLineOffset,    /* The source video plane line offset in bytes.
+                                       Set it the same as srcPitch in normal
+                                       usage. */
+    video_format_t videoFormat      /* Source video format */
+);
+
+/*
+ *  startVideo
+ *      This function starts the video.
+ */
+void startVideo(unsigned dispCtrl);
+
+/*
+ *  stopVideo
+ *      This function stops the video.
+ */
+void stopVideo(unsigned dispCtrl);
+
+
diff --git a/drivers/gpu/drm/smi/ddk768/ddkdebug.c b/drivers/gpu/drm/smi/ddk768/ddkdebug.c
new file mode 100644
index 000000000000..19cd6c195c52
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk768/ddkdebug.c
@@ -0,0 +1,227 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2007 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  ddkdebug.c --- DDK Debug Tool 
+*  This file contains the source code for the SMI DDK Debugging.
+* 
+*******************************************************************/
+#ifdef DDKDEBUG /* Don't enable debug flag in ARM yet */
+#include <stdio.h>
+#include <stdarg.h>
+#include <string.h>
+#include "ddkdebug.h"
+#include "os.h"
+
+/* COM Port index that is used for the debugging */
+#define DEBUG_COM_PORT_INDEX                0
+
+/* Buffer length */
+#define BUFFER_LENGTH                       1024
+
+static ddk_debug_output_t gDebugOutput = DEBUG_OUTPUT_SCREEN;
+static unsigned long gDebugLevelMask = 0;
+static FILE *gFileHandle = (FILE *)0;
+static short gCOMInit = 0;
+static unsigned char gEnableDebugMessage;
+
+/*
+ * This function initializes the debug print out system.
+ *  
+ *  Input:
+ *      debugOutput - Output where to print out the debug. It could be 
+ *                    screen, file, or serial port.
+ *      debugLevel  - Debugging level      
+ */
+void ddkDebugPrintInit(ddk_debug_output_t debugOutput, unsigned long debugLevelMask)
+{
+    gDebugOutput = debugOutput;
+    gDebugLevelMask = debugLevelMask;
+    gEnableDebugMessage = 1;
+    
+    /* Initialize the output media as necessary */
+    switch (gDebugOutput)
+    {
+        default:
+        case DEBUG_OUTPUT_SCREEN:
+            /* Do nothing */
+            break;
+        case DEBUG_OUTPUT_FILE:
+            /* Close the previous log file if opened */
+            if (gFileHandle != (FILE *)0)
+                fclose(gFileHandle);
+            
+            /* Create a LOG file */    
+            gFileHandle = fopen("ddkdebug.log", "w");
+            if (gFileHandle == NULL)
+                ddkDebugPrint(0, "Can not open log file\n");
+            break;
+        case DEBUG_OUTPUT_SERIAL:
+            /* Open COM Port */
+            if (comInit(DEBUG_COM_PORT_INDEX,
+                        COM_9600, 
+                        DATA_SIZE_8, 
+                        PARITY_NONE, 
+                        STOP_BIT_1,
+                        FLOW_CONTROL_NONE) == 0)
+                gCOMInit = 1;
+            else
+                ddkDebugPrint(0, "Can not open COM Port\n");            
+            break;
+    }
+}
+
+/*
+ *  This function enable or disable the debug message.
+ *  
+ *  Input:
+ *      enableDebugMessage  - Enable/disable the debug message
+ *                            0 - Disable Debug Message
+ *                            1 - Enable Debug Message
+ *
+ *  Note:
+ *      This function can be used to enable/disable the debug message
+ *      at certain point of software, so that the debug messages, that
+ *      are printed, are only the important ones.     
+ */
+void ddkDebugEnable(unsigned char enableDebugMessage)
+{
+    gEnableDebugMessage = enableDebugMessage;
+}
+
+/*
+ * This function prints out the formatted string.
+ *  
+ *  Input:
+ *      debugLevel  - The level of the debug of which the message is intended for.
+ *      pszFormat   - Format of the printed message      
+ */
+void ddkDebugPrint(unsigned long debugLevel, const char* pszFormat, ...)
+{
+	static char pszPrintBuffer[BUFFER_LENGTH];
+	unsigned long nWritten;
+
+    /* Do not print any messages when this variable is flagged. */
+    if (gEnableDebugMessage == 0)
+        return;
+        
+    /* Only process any ddkDebugPrint with the debugLevel less or equal the preset
+       debug Level during the init */
+    if (((debugLevel & gDebugLevelMask) != 0) || (debugLevel == 0))
+    {
+	    /* Format the string */
+	    va_list arg_ptr;
+	    va_start(arg_ptr, pszFormat);
+	    nWritten = (unsigned long) vsnprintf(pszPrintBuffer, BUFFER_LENGTH - 1, pszFormat, arg_ptr);
+	    va_end(arg_ptr);
+        
+        /* Check for buffer overflow */
+	    if (nWritten == (unsigned long)(-1))
+	    {
+		    ddkDebugPrint(0, "ddkDebugPrint(): BUFFER OVERFLOW DETECTED!!!\r\n" \
+			    "MAX STRING LENGTH = %d\n", BUFFER_LENGTH);
+		    return;
+	    }
+
+        /* Print out the data */
+        switch (gDebugOutput)
+        {
+            default:
+            case DEBUG_OUTPUT_SCREEN:
+                printf(pszPrintBuffer);
+                
+                /* 
+                 * Flush the stdout before the getch function. Otherwise the
+                 * previous printf will not be displayed correctly sometimes.
+                 */
+                fflush(stdout);
+                break;
+            case DEBUG_OUTPUT_FILE:
+                /* Print out the message to the log file */
+                if (gFileHandle != NULL)
+                {
+                    fprintf(gFileHandle, pszPrintBuffer);
+                    fflush(gFileHandle);
+                }
+                break;
+            case DEBUG_OUTPUT_SERIAL:
+                /* Send the data out to the COM Port */
+                if (gCOMInit)
+                {
+#if 1                
+                    char *pString1, *pString2;
+                    unsigned long length;
+                    char linefeed = '\r';
+
+                    length = 0;
+                    pString1 = pszPrintBuffer; 
+                    while(nWritten)
+                    {
+                        /* Search for all '\n' and add '\r' so that the serial port can display correctly. */
+                        pString2 = strchr(pString1, '\n');
+                        if (pString2 != (char *)0)
+                        {
+                            length = pString2 - pString1 + 1;
+                            
+                            /* Check the previous character and the next character */
+                            if ((*(pString2 - 1) != '\r') && (*(pString2 + 1) != '\r'))
+                            {
+                                /* Write the buffer with the '\r' */
+                                comWrite(pString1, length);
+                                comWrite(&linefeed, 1); 
+                            }
+                            else
+                                comWrite(pString1, length);
+                                
+                            /* Adjust the nWritten */
+                            nWritten -= length;
+                            
+                            /* Adjust the new string pointer */
+                            pString1 = pString2 + 1;
+                        }
+                        else
+                        {
+                            comWrite(pString1, nWritten);
+                            nWritten = 0;
+                        }
+                    }
+#else
+                    comWrite(pszPrintBuffer, nWritten);
+#endif
+                }
+                break;                
+        }
+    }
+}
+
+/*
+ * This function cleans up (such as closing the debug file, etc...) when
+ * exiting the debug module.      
+ */
+void ddkDebugPrintExit()
+{
+    /* Clean up the debug print module */
+    switch (gDebugOutput)
+    {
+        default:
+        case DEBUG_OUTPUT_SCREEN:
+            /* Do nothing */
+            break;
+        case DEBUG_OUTPUT_FILE:
+            /* Close the log file */
+            if (gFileHandle != (FILE *)0)
+                fclose(gFileHandle);
+            break;
+        case DEBUG_OUTPUT_SERIAL:
+            comClose();
+            break;
+    } 
+}
+
+#endif
+
+
+
diff --git a/drivers/gpu/drm/smi/ddk768/ddkdebug.h b/drivers/gpu/drm/smi/ddk768/ddkdebug.h
new file mode 100644
index 000000000000..aa1df840174f
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk768/ddkdebug.h
@@ -0,0 +1,141 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2007 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  ddkdebug.h --- DDK Debug module 
+*  This file contains the definitions for the SMI DDK debugging.
+* 
+*******************************************************************/
+#ifndef _DDKDEBUG_H_
+#define _DDKDEBUG_H_
+
+#ifdef DDKDEBUG
+
+/*********************
+ * Definition  
+ *********************/
+ 
+/* Debug Print Level definitions */
+/* Bit 16 ~ 31 are used by the library. Bit 0 ~ 15 can be used by application */
+#define ERROR_LEVEL                 0x00010000
+#define WARNING_LEVEL               0x00020000
+#define INIT_LEVEL                  0x00040000
+#define DISPLAY_LEVEL               0x00080000
+#define DMA_LEVEL                   0x00100000
+#define DE_LEVEL                    0x00200000
+#define CAPTURE_LEVEL               0x00400000
+#define SSP_LEVEL                   0x00800000
+#define RESERVED8_LEVEL             0x01000000
+#define RESERVED9_LEVEL             0x02000000
+#define RESERVED10_LEVEL            0x04000000
+#define RESERVED11_LEVEL            0x08000000
+#define RESERVED12_LEVEL            0x10000000
+#define RESERVED13_LEVEL            0x20000000
+#define RESERVED14_LEVEL            0x40000000
+#define RESERVED15_LEVEL            0x80000000
+
+#define SYSTEM_LEVEL_MASK           0xFFFF0000
+#define APPLICATION_LEVEL_MASK      0x0000FFFF
+
+/*********************
+ * Structure 
+ *********************/
+typedef enum _ddk_debug_output_t
+{
+    DEBUG_OUTPUT_SCREEN = 0,
+    DEBUG_OUTPUT_FILE,
+    DEBUG_OUTPUT_SERIAL
+} 
+ddk_debug_output_t;
+
+/*********************
+ * MACROS 
+ *********************/
+ 
+/* This function has to be called before calling other DEBUGPIRNT functions. */
+#define DDKDEBUGPRINTINIT(debugOutput, debugLevelMask) \
+    ddkDebugPrintInit(debugOutput, debugLevelMask)
+
+/* This function enable or disable the debug message. 
+ *  Note:
+ *      This function can be used to enable/disable the debug message
+ *      at certain point of software, so that the debug messages, that
+ *      are printed, are only the important ones.
+ */
+#define DDKDEBUGENABLE(arg)                           \
+    ddkDebugEnable(arg)
+
+/* Calling the DDKDEBUGPRINT needs to have the arg to be enclosed with
+   two of open and close brackets.
+   Example:
+            DDKDEBUGPRINT(("Hello World: %s\n", pszString));
+ */
+#define DDKDEBUGPRINT(arg)                             \
+    ddkDebugPrint arg
+    
+/* This function has to be called when exiting the application.
+   It is necessary to clean up the debug module. */
+#define DDKDEBUGPRINTEXIT()                            \
+    ddkDebugPrintExit()
+
+/*********************
+ * Function prototype 
+ *********************/
+ 
+/*
+ * This function initializes the debug print out system.
+ *  
+ *  Input:
+ *      debugOutput - Output where to print out the debug. It could be 
+ *                    screen, file, or serial port.
+ *      debugLevel  - Debugging level      
+ */
+void ddkDebugPrintInit(ddk_debug_output_t debugOutput, unsigned long debugLevelMask);
+
+/*
+ *  This function enable or disable the debug message.
+ *  
+ *  Input:
+ *      enableDebugMessage  - Enable/disable the debug message
+ *                            0 - Disable Debug Message
+ *                            1 - Enable Debug Message
+ *
+ *  Note:
+ *      This function can be used to enable/disable the debug message
+ *      at certain point of software, so that the debug messages, that
+ *      are printed, are only the important ones.     
+ */
+void ddkDebugEnable(unsigned char enableDebugMessage);
+
+/*
+ * This function prints out the formatted string.
+ *  
+ *  Input:
+ *      debugLevel  - The level of the debug of which the message is intended for.
+ *      pszFormat   - Format of the printed message      
+ */
+void ddkDebugPrint(unsigned long debugLevel, const char* pszFormat, ...);
+
+/*
+ * This function cleans up (such as closing the debug file, etc...) when
+ * exiting the debug module.      
+ */
+void ddkDebugPrintExit();
+
+#else
+
+/* 
+ * If there is no DEBUG definition, then treat the macro as an empty macro.
+ * Therefore all the debug print will be stripped out. 
+ */
+#define DDKDEBUGPRINTINIT(debugOutput, debugLevelMask)
+#define DDKDEBUGENABLE(arg)
+#define DDKDEBUGPRINT(arg)
+#define DDKDEBUGPRINTEXIT()
+
+#endif
+
+#endif /* _DDKDEBUG_H_ */
diff --git a/drivers/gpu/drm/smi/ddk768/hdmiregs.h b/drivers/gpu/drm/smi/ddk768/hdmiregs.h
new file mode 100644
index 000000000000..e158d82f5e86
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk768/hdmiregs.h
@@ -0,0 +1,945 @@
+#ifndef  _HDMIREGS_H_
+#define  _HDMIREGS_H_
+
+// SLI-204-06012 Rev.2.01a
+//-----------------------------------------------------------------------------
+// SLISHDMI13T Regsiter Defines         Addr        RW  init    Description
+//-----------------------------------------------------------------------------
+#define     X00_SYSTEM_CONTROL      0       //  RW  10h     Power save and interrupt output control
+	#define 		X00_SYSTEM_CONTROL_MODE													7:4
+	#define			X00_SYSTEM_CONTROL_MODE_A												1
+	#define			X00_SYSTEM_CONTROL_MODE_B												2
+	#define			X00_SYSTEM_CONTROL_MODE_D												4
+	#define			X00_SYSTEM_CONTROL_MODE_E												8
+	#define 		X00_SYSTEM_CONTROL_PLLB													3:3
+	#define			X00_SYSTEM_CONTROL_PLLB_RST			  						 	1
+	#define			X00_SYSTEM_CONTROL_PLLB_UNRST			  					  0
+	#define			X00_SYSTEM_CONTROL_INTOUT												1:1
+	#define			X00_SYSTEM_CONTROL_INTOUT_N	    								0						//Interrupt output mode
+	#define			X00_SYSTEM_CONTROL_INTOUT_PP	    							1						//Interrupt output mode
+	#define			X00_SYSTEM_CONTROL_INTOUT_POLARITY							0:0
+	#define			X00_SYSTEM_CONTROL_INTOUT_POLARITY_L	    			0						//Interrupt output polarity
+	#define			X00_SYSTEM_CONTROL_INTOUT_POLARITY_H	    		  1						//Interrupt output polarity
+
+#define     X01_N19_16            			  1       //  RW  00h     20-bit N used for cycle time stamp
+	#define			X01_N19_16_LRC_SWAP							7:4
+	#define			X01_N19_16_LRC_SWAP_NO					0						//L/R data swap
+	#define			X01_N19_16_LRC_SWAP_SP1					2
+	#define			X01_N19_16_LRC_SWAP_SP2					4
+	#define			X01_N19_16_LRC_SWAP_SP3					8
+	#define			X01_N19_16_AUDCLK								3:0
+#define     X02_N15_8               2       //  RW  00h
+#define     X03_N7_0                3       //  RW  00h
+#define     X04_SPDIF_FS            4       //  RO  00h     SPDIF sampling frequency/CTS[19:16] internal
+	#define			X04_SPDIF_FS_K							7:4
+	#define			X04_SPDIF_FS_K32						3
+	#define			X04_SPDIF_FS_K44_1					0
+	#define			X04_SPDIF_FS_K48						2
+	#define			X04_SPDIF_FS_K88_2					8
+	#define			X04_SPDIF_FS_K96			  		10
+	#define			X04_SPDIF_FS_K176_4		 			12
+	#define			X04_SPDIF_FS_K192						14
+	#define			X04_SPDIF_FS_CTSIN_19_16 		3:0
+
+#define     X05_CTS_INT             5       //  RO  00h     CTS[15:8] internal
+#define     X06_CTS_INT             6       //  RO  00h     CTS[7:0] internal
+#define     X07_CTS_EXT             7       //  RW  00h     CTS[19:16] external
+#define     X08_CTS_EXT             8       //  RW  00h     CTS[15:8] external
+#define     X09_CTS_EXT             9       //  RW  00h     CTS[7:0] external
+#define     X0A_AUDIO_SOURCE        10      //  RW  00h     Audio setting.1
+	#define			X0A_AUDIO_SOURCE_CTS						7:7
+	#define			X0A_AUDIO_SOURCE_CTS_INTERNAL					0
+	#define			X0A_AUDIO_SOURCE_CTS_EXTERNAL					1
+	#define			X0A_AUDIO_SOURCE_DS							6:5
+	#define			X0A_AUDIO_SOURCE_DS_NONE				0
+	#define			X0A_AUDIO_SOURCE_DS_2						1
+	#define			X0A_AUDIO_SOURCE_DS_4						2
+	#define			X0A_AUDIO_SOURCE_SEL						4:3
+	#define			X0A_AUDIO_SOURCE_SEL_I2S				0
+	#define			X0A_AUDIO_SOURCE_SEL_SPDIF			1
+	#define			X0A_AUDIO_SOURCE_SEL_DSD				2
+	#define			X0A_AUDIO_SOURCE_SEL_HBR				3
+	#define			X0A_AUDIO_SOURCE_MCLK						2:2
+	#define			X0A_AUDIO_SOURCE_MCLK_OFF				0
+	#define			X0A_AUDIO_SOURCE_MCLK_ON				1
+	#define			X0A_AUDIO_SOURCE_MRATIO				1:0
+	#define			X0A_AUDIO_SOURCE_MRATIO_128FS		0
+	#define			X0A_AUDIO_SOURCE_MRATIO_256FS		1
+	#define			X0A_AUDIO_SOURCE_MRATIO_384FS		2
+	#define			X0A_AUDIO_SOURCE_MRATIO_512FS		3
+	
+#define     X0B_AUDIO_SET2         			  11      //  RW  00h     Audio setting.2
+	#define			X0B_AUDIO_SET2_IDCLK					7:7
+	#define			X0B_AUDIO_SET2_IDCLK1					0						//BIT.7
+	#define			X0B_AUDIO_SET2_IDCLK1_2				1						//BIT.7
+	#define			X0B_AUDIO_SET2_PRI						6:6
+	#define			X0B_AUDIO_SET2_PRI_ASP				0
+	#define			X0B_AUDIO_SET2_PRI_ACR				1
+	#define			X0B_AUDIO_SET2_IDCLK_MODE					5:5
+	#define			X0B_AUDIO_SET2_IDCLK_MODE_AUTO			0						//BIT.5
+	#define			X0B_AUDIO_SET2_IDCLK_MODE_FIX  		1						//BIT.5
+	#define			X0B_AUDIO_SET2_FLATLINE				4:4
+	#define			X0B_AUDIO_SET2_FLATLINE_NORMAL  0
+	#define			X0B_AUDIO_SET2_FLATLINE_FLAT  	1
+	#define			X0B_AUDIO_SET2_CHANNEL				3:0         //NOT ALL LIST 
+	#define			X0B_AUDIO_SET2_CHANNEL_NOT		0
+	#define			X0B_AUDIO_SET2_CHANNEL_LEFT		8
+	#define			X0B_AUDIO_SET2_CHANNEL_RIGHT	4
+
+#define     X0C_I2S_MODE           					  12      //  RW  00h     I2S audio setting
+	#define			X0C_I2S_MODE_MCLKFQ									7:7	
+	#define			X0C_I2S_MODE_MCLKFQ_BY0AH						0
+	#define			X0C_I2S_MODE_MCLKFQ_OVERRIDE				1
+	#define			X0C_I2S_MODE_CHANNEL  							5:2
+	#define			X0C_I2S_MODE_CHANNEL_2							1
+	#define			X0C_I2S_MODE_CHANNEL_4							3
+	#define			X0C_I2S_MODE_CHANNEL_6						  7
+	#define			X0C_I2S_MODE_CHANNEL_8							15
+	#define			X0C_I2S_MODE_SEL										1:0
+	#define			X0C_I2S_MODE_SEL_STANDARD						0
+	#define			X0C_I2S_MODE_SEL_JSTF_RIGHT					1
+	#define			X0C_I2S_MODE_SEL_JSTF_LEFT					2
+
+#define     X0D_DSD_MODE            13      //  RW  00h     DSD audio setting
+	#define			X0D_DSD_MODE_CHANNEL						7:4
+	#define			X0D_DSD_MODE_CHANNEL_2					1
+	#define			X0D_DSD_MODE_CHANNEL_4					3
+	#define			X0D_DSD_MODE_CHANNEL_6					7
+	#define			X0D_DSD_MODE_CHANNEL_8					0XF		
+
+#define     X0E_DEBUG_MONITOR1      14      //  RO  00h     Reserved
+#define     X0F_DEBUG_MONITOR2      15      //  RO  00h     Reserved
+#define     X10_I2S_PINMODE         16      //  RW  00h     I2S input pin swap
+
+#define     X11_ASTATUS1            17      //  RW  00h     Audio status bits setting1
+	#define     X11_ASTATUS1_VALID          	  7:7
+	#define     X11_ASTATUS1_FREQ            		3:0
+	#define     X11_ASTATUS1_FREQ_44_1K       	15
+	#define     X11_ASTATUS1_FREQ_88_2K       	7
+	#define     X11_ASTATUS1_FREQ_22_05K     	  11
+	#define     X11_ASTATUS1_FREQ_176_4K     	  3
+	#define     X11_ASTATUS1_FREQ_48K       		13
+	#define     X11_ASTATUS1_FREQ_96K	       		5
+	#define     X11_ASTATUS1_FREQ_24K       		9
+	#define     X11_ASTATUS1_FREQ_192K       		1
+	#define     X11_ASTATUS1_FREQ_8K       			6
+	#define     X11_ASTATUS1_FREQ_11_025K    	  10
+	#define     X11_ASTATUS1_FREQ_12K       		2
+	#define     X11_ASTATUS1_FREQ_32K		       	12
+	#define     X11_ASTATUS1_FREQ_16K       		8
+	#define     X11_ASTATUS1_FREQ_DEFAUT       	0
+#define     X12_ASTATUS2            18      //  RW  00h     Audio status bits setting2
+	#define     X12_ASTATUS2_CS1		    			 	7:7
+	#define     X12_ASTATUS2_CS1_LPCM		 				0
+	#define     X12_ASTATUS2_CS1_NONLPCM				1
+	#define     X12_ASTATUS2_CS0								6:6
+	#define     X12_ASTATUS2_CS0_CONSUMER			0
+	#define     X12_ASTATUS2_CS0_PROFESSIONAL 	1
+	#define     X12_ASTATUS2_COPYRIGHT					5:5
+	#define     X12_ASTATUS2_ADDITION						4:2
+	#define     X12_ASTATUS2_ADDITION_PREM_NO		0
+	#define     X12_ASTATUS2_ADDITION_PREM_50US	1
+	#define     X12_ASTATUS2_CLKLEVEL						1:0
+	#define     X12_ASTATUS2_CLKLEVEL_II				0
+	#define     X12_ASTATUS2_CLKLEVEL_I					1
+	#define     X12_ASTATUS2_CLKLEVEL_III				2
+	
+#define     X13_CAT_CODE            19      //  RW  00h     Category code
+#define     X14_A_SOURCE            20      //  RW  00h     Source number/ Audio word length
+#define     X14_A_SOURCE_NUM        7:4
+	#define     X14_A_SOURCE_NUM_NOCOUNT             0
+	#define     X14_A_SOURCE_NUM_1			         1
+	#define     X14_A_SOURCE_NUM_2			         2
+	#define     X14_A_SOURCE_NUM_3			         3
+	#define     X14_A_SOURCE_NUM_4			         4
+	#define     X14_A_SOURCE_NUM_5			         5
+	#define     X14_A_SOURCE_NUM_6			         6
+	#define     X14_A_SOURCE_NUM_7			         7
+	#define     X14_A_SOURCE_NUM_8			         8
+	#define     X14_A_SOURCE_NUM_9			         9
+	#define     X14_A_SOURCE_NUM_10			         10
+	#define     X14_A_SOURCE_NUM_11			         11
+	#define     X14_A_SOURCE_NUM_12			         12
+	#define     X14_A_SOURCE_NUM_13			         13
+	#define     X14_A_SOURCE_NUM_14			         14
+	#define     X14_A_SOURCE_NUM_15			         15
+	#define     X14_A_SOURCE_LENGTH        		     3:0
+	#define     X14_A_SOURCE_LENGTH_16B				 2		
+	#define     X14_A_SOURCE_LENGTH_17B				 12
+	#define     X14_A_SOURCE_LENGTH_18B				 4
+	#define     X14_A_SOURCE_LENGTH_19B				 8
+	#define     X14_A_SOURCE_LENGTH_20B				 10
+	#define     X14_A_SOURCE_LENGTH_20BIT	  	     3
+	#define     X14_A_SOURCE_LENGTH_21B				 13
+	#define     X14_A_SOURCE_LENGTH_22B				 5
+	#define     X14_A_SOURCE_LENGTH_23B				 9
+	#define     X14_A_SOURCE_LENGTH_24B				 11
+	
+#define     X15_AVSET1              21      //  RW  00h     Audio/Video setting.1
+		#define			X15_AVSET1_AUDFREQ				 7:4
+		#define			X15_AVSET1_AUDFREQ_32K 		 3
+		#define			X15_AVSET1_AUDFREQ_44_1K	 0
+		#define			X15_AVSET1_AUDFREQ_48K		 2
+		#define			X15_AVSET1_AUDFREQ_88_2K	 8
+		#define			X15_AVSET1_AUDFREQ_96K		 10
+		#define			X15_AVSET1_AUDFREQ_176_4K	 12
+		#define			X15_AVSET1_AUDFREQ_192K	 	 14
+		#define			X15_AVSET1_AUDFREQ_768K	 	 9
+		#define			X15_AVSET1_VIDFORM							 								3:1				
+		#define			X15_AVSET1_VIDFORM_RGB_YCC444		        		  	 0
+		#define			X15_AVSET1_VIDFORM_YCC422				   			 			   1
+		#define			X15_AVSET1_VIDFORM_YCC422_SAVEAV           	     2
+		#define			X15_AVSET1_VIDFORM_SEPA_SYNCS		        		  	 3	
+		#define			X15_AVSET1_VIDFORM_EMBED_SYNCS	          	     4	
+		#define			X15_AVSET1_VIDFORM_RGB444_YCC444       		       5		
+		#define			X15_AVSET1_VIDFORM_DDR_YCC422				     				 6
+		#define			X15_AVSET1_DE																		 0:0
+		#define			X15_AVSET1_DE_INTERNAL				 	   				  		  0
+		#define			X15_AVSET1_DE_EXTERNAL					  						   1
+
+#define     X16_VIDEO1              22      //  RW  34h     Video setting.1
+		#define			X16_VIDEO1_OUT							 7:6
+		#define			X16_VIDEO1_OUT_RGB444				     0
+		#define			X16_VIDEO1_OUT_YCC444				     1
+		#define			X16_VIDEO1_OUT_YCC422				     2
+		#define			X16_VIDEO1_IN							 5:4
+		#define			X16_VIDEO1_IN_WID_12				     0
+		#define			X16_VIDEO1_IN_WID_10				     1
+		#define			X16_VIDEO1_IN_WID_8					     3
+		#define			X16_VIDEO1_SAV_EAV					     3:2
+		#define			X16_VIDEO1_SAV_EAV_CH0			         0
+		#define			X16_VIDEO1_SAV_EAV_CH1			         1
+		#define			X16_VIDEO1_SAV_EAV_CH2			         2
+		#define			X16_VIDEO1_IN_COLOR					     0:0
+		#define			X16_VIDEO1_IN_COLOR_RGB			         0
+		#define			X16_VIDEO1_IN_COLOR_YCC			         1
+
+#define     X17_DC_REG              23      //  RW  20h     Deep color setting
+		#define	X17_DC_REG_TMDS								 7:6
+		#define	X17_DC_REG_TMDS_8b						     0
+		#define	X17_DC_REG_TMDS_10b						     1
+		#define	X17_DC_REG_TMDS_12b						     2				
+		#define	X17_DC_REG_FIFO								 5:5
+		#define	X17_DC_REG_ESART							 4:4
+		#define	X17_DC_REG_ELAST							 3:3
+		#define	X17_DC_REG_EBYTE							 2:2
+		#define	X17_DC_REG_EXTCLR							 1:1
+		#define	X17_DC_REG_EXTCLR_SOF					     0
+		#define	X17_DC_REG_EXTCLR_SOH					     1
+		
+#define     X18_CSC_C0_HI           24      //  RW  04h     Color Space Conversion Parameters		
+#define     X19_CSC_C0_LO           25      //  RW  00h
+#define     X1A_CSC_C1_HI           26      //  RW  05h     Color Space Conversion Parameters
+#define     X1B_CSC_C1_LO           27      //  RW  09h
+#define     X1C_CSC_C2_HI           28      //  RW  00h
+#define     X1D_CSC_C2_LO           29      //  RW  00h
+#define     X1E_CSC_C3_HI           30      //  RW  02h
+#define     X1F_CSC_C3_LO           31      //  RW  A1h
+#define     X20_CSC_C4_HI           32      //  RW  04h
+#define     X21_CSC_C4_LO           33      //  RW  00h
+#define     X22_CSC_C5_HI           34      //  RW  12h
+#define     X23_CSC_C5_LO           35      //  RW  91h
+#define     X24_CSC_C6_HI           36      //  RW  11h
+#define     X25_CSC_C6_LO           37      //  RW  59h
+#define     X26_CSC_C7_HI           38      //  RW  00h
+#define     X27_CSC_C7_LO           39      //  RW  7Dh
+#define     X28_CSC_C8_HI           40      //  RW  04h
+#define     X29_CSC_C8_LO           41      //  RW  00h
+#define     X2A_CSC_C9_HI           42      //  RW  00h
+#define     X2B_CSC_C9_LO           43      //  RW  00h
+#define     X2C_CSC_C10_HI          44      //  RW  06h
+#define     X2D_CSC_C10_LO          45      //  RW  EFh
+#define     X2E_CSC_C11_HI          46      //  RW  02h
+#define     X2F_CSC_C11_LO          47      //  RW  DDh
+    
+#define X30_EXT_VPARAMS                                         48      //  RW  00h     External video parameter settings
+#define X30_EXT_VPARAMS_VSYNC_OFFSET               7:4
+#define X30_EXT_VPARAMS_VSYNC_PHASE                 3:3
+#define X30_EXT_VPARAMS_VSYNC_PHASE_NEG  	 0
+#define X30_EXT_VPARAMS_VSYNC_PHASE_POS		 1
+#define X30_EXT_VPARAMS_HSYNC_PHASE                 2:2
+#define X30_EXT_VPARAMS_HSYNC_PHASE_NEG 	 0
+#define X30_EXT_VPARAMS_HSYNC_PHASE_POS		 1
+#define X30_EXT_VPARAMS_PI                                     1:1
+#define X30_EXT_VPARAMS_PI_PROGRESSIVE             0
+#define X30_EXT_VPARAMS_PI_INTERLACE			 1
+#define X30_EXT_VPARAMS_USE                                  0:0
+#define X30_EXT_VPARAMS_USE_PRE_PROG                0
+#define X30_EXT_VPARAMS_USE_EXTERNAL                1
+
+#define     X31_EXT_HTOTAL          49      //  RW  00h     External horizontal total
+#define     X32_EXT_HTOTAL          50      //
+#define     X33_EXT_HBLANK          51      //  RW  00h     External horizontal blank
+#define     X34_EXT_HBLANK          52      //
+#define     X35_EXT_HDLY            53      //  RW  00h     External horizontal delay
+#define     X36_EXT_HDLY            54      //
+#define     X37_EXT_HS_DUR          55      //  RW  00h     External horizontal duration
+#define     X38_EXT_HS_DUR          56      //
+#define     X39_EXT_VTOTAL          57      //  RW  00h     External vertical total
+#define     X3A_EXT_VTOTAL          58      //
+#define     X3B_AVSET2                              59              //  RW                                          00h     Audio/Video setting.2
+		#define X3B_AVSET2_CTS_DEBUG				 7:7
+		#define X3B_AVSET2_CD_ZERO					 6:6	
+		#define X3B_AVSET2_EXT_DE					 5:5
+		#define X3B_AVSET2_DCC_I2C_RST			     4:4
+		#define X3B_AVSET2_VID_CODE39				 3:3
+		#define X3B_AVSET2_BLACK_FULL		 		 1:1
+		#define X3B_AVSET2_CSC		 				 0:0
+//				#define     CSC_ENABLE                                  0x01    //          R/W                                     1b  Color Space Conversion enable
+//        #define     SEL_FULL_RANGE                              0x02    //          R/W                                     1b  Select Full/Limited range for Send black video mode
+//        #define     EN_M0_LOAD                                  0x04    //          R/W                                     1b  Load M0 into Akey area
+//        #define     EXT_DE_CNT                                  0x20    //          R/W                                     1b  External DE control
+//        #define     CD_ZERO                                     0x40    //          R/W                                     1b  CD all zero override
+//        #define     CTS_DEBUG                                   0x80    //          R/W                                     1b  Debug bit for CTS timing
+#define     X3C_EX_VID              60      //  RW  00h     External input Video ID(VID)
+#define     X3D_EXT_VBLANK          61      //  RW  00h     External virtical blank
+#define     X3E_EXT_VDLY            62      //  RW  00h     External virtical delay
+#define     X3F_EXT_VS_DUR          63      //  RW  00h     External virtical duration
+//				#define     X40_CTRL_PKT_EN         64      //  RW  00h     Control packet enable
+	#define X40_CTRL_PKT_EN										   0X40
+		#define X40_CTRL_PKT_EN_GENE_CTRL					    						  7:7
+		#define X40_CTRL_PKT_EN_GENE_CTRL_DIS					 						   0
+		#define X40_CTRL_PKT_EN_GENE_CTRL_EN					  						  1
+		#define X40_CTRL_PKT_EN_MPEG                                6:6
+		#define X40_CTRL_PKT_EN_MPEG_DIS														0
+		#define X40_CTRL_PKT_EN_MPEG_EN															1
+		#define X40_CTRL_PKT_EN_PROD                                5:5
+		#define X40_CTRL_PKT_EN_PROD_DIS							 						   0
+		#define X40_CTRL_PKT_EN_PROD_EN						     						   1
+		#define X40_CTRL_PKT_EN_VENDOR                              4:4
+		#define X40_CTRL_PKT_EN_VENDOR_DIS					    						0
+		#define X40_CTRL_PKT_EN_VENDOR_EN														1
+		#define X40_CTRL_PKT_EN_GAMUT                               3:3
+		#define X40_CTRL_PKT_EN_GAMUT_DIS														0
+		#define X40_CTRL_PKT_EN_GAMUT_EN														1
+		#define X40_CTRL_PKT_EN_ISRC                                2:2
+		#define X40_CTRL_PKT_EN_ISRC_DIS														0
+		#define X40_CTRL_PKT_EN_ISRC_EN															1
+		#define X40_CTRL_PKT_EN_ACP	                                1:1
+		#define X40_CTRL_PKT_EN_ACP_DIS															0
+		#define X40_CTRL_PKT_EN_ACP_EN							 								1
+		#define X40_CTRL_PKT_EN_GENE                                0:0
+		#define X40_CTRL_PKT_EN_GENE_DIS															0
+		#define X40_CTRL_PKT_EN_GENE_EN																1
+
+#define     X41_SEND_CPKT_AUTO      65      //  RW  00h     HB0 for generic control packet
+		#define X41_SEND_CPKT_AUTO_GENE_CTRL                        7:7
+		#define X41_SEND_CPKT_AUTO_GENE_CTRL_DIS			    					0
+		#define X41_SEND_CPKT_AUTO_GENE_CTRL_EN					  				  1
+		#define X41_SEND_CPKT_AUTO_MPEG                             6:6
+		#define X41_SEND_CPKT_AUTO_MPEG_DIS													0
+		#define X41_SEND_CPKT_AUTO_MPEG_EN													1
+		#define X41_SEND_CPKT_AUTO_PROD                             5:5
+		#define X41_SEND_CPKT_AUTO_PROD_DIS													0
+		#define X41_SEND_CPKT_AUTO_PROD_EN													1
+		#define X41_SEND_CPKT_AUTO_VENDOR                           4:4
+		#define X41_SEND_CPKT_AUTO_VENDOR_DIS												0
+		#define X41_SEND_CPKT_AUTO_VENDOR_EN												1
+		#define X41_SEND_CPKT_AUTO_GAMUT                            3:3
+		#define X41_SEND_CPKT_AUTO_GAMUT_DIS												0
+		#define X41_SEND_CPKT_AUTO_GAMUT_EN													1
+		#define X41_SEND_CPKT_AUTO_ISRC                             2:2
+		#define X41_SEND_CPKT_AUTO_ISRC_DIS													0
+		#define X41_SEND_CPKT_AUTO_ISRC_EN													1
+		#define X41_SEND_CPKT_AUTO_ACP                              1:1
+		#define X41_SEND_CPKT_AUTO_ACP_DIS													0
+		#define X41_SEND_CPKT_AUTO_ACP_EN                           1
+		#define X41_SEND_CPKT_AUTO_GENERIC                          0:0
+		#define X41_SEND_CPKT_AUTO_GENERIC_DIS				    			  	0
+		#define X41_SEND_CPKT_AUTO_GENERIC_EN												1
+		
+#define     X42_AUTO_CHECKSUM       66      //  RW  00h     Auto checksum option
+#define X42_AUTO_CHECKSUM_OPT						0:0
+#define X42_AUTO_CHECKSUM_OPT_DIS	    	0
+#define X42_AUTO_CHECKSUM_OPT_EN		    1
+
+//  #define     RESERVED                67      //  RW  00h
+//  #define     RESERVED                68      //  RW  00h
+#define     X45_VIDEO2                              69              //  RW                                          00h     Video setting.2
+		#define X45_VIDEO2_CLR_AVMUTE						    7:7
+		#define X45_VIDEO2_CLR_AVMUTE_DIS				    	0
+		#define X45_VIDEO2_CLR_AVMUTE_EN				        1
+		#define X45_VIDEO2_SET_AVMUTE					    	6:6
+		#define X45_VIDEO2_SET_AVMUTE_DIS					    0
+		#define X45_VIDEO2_SET_AVMUTE_EN				    	1
+		#define X45_VIDEO2_AUDIO_RESET						    2:2
+		#define X45_VIDEO2_AUDIO_RESET_CLR			 	        0
+		#define X45_VIDEO2_AUDIO_RESET_SET			            1
+		#define X45_VIDEO2_NOAUDIO							    1:1
+		#define X45_VIDEO2_NOAUDIO_CLR			 	        0
+		#define X45_VIDEO2_NOAUDIO_SET			            1
+		#define X45_VIDEO2_NOVIDEO					        0:0
+		#define X45_VIDEO2_NOVIDEO_CLR			 	        0
+		#define X45_VIDEO2_NOVIDEO_SET			            1
+//				#define     NOVIDEO                                     0x01    //          R/W                                     1b  Send black video
+//        #define     NOAUDIO                                     0x02    //          R/W                                     1b  Send no audio
+//        #define     AUDIORST                                    0x04    //          R/W                                     1b  Audio capture logic reset
+//        #define     SET_AV_MUTE                                 0x40    //          R/W                                     1b  Send gSet AV muteh
+//        #define     CLEAR_AV_MUTE                               0x80    //          R/W                                     1b  Clear AV muteh
+//  #define     RESERVED                70      //  RW  00h     Reserved
+    #define     X46_OUTPUT_OPTION                70      //  RW  00h     Reserved
+//    #define     X47_VIDEO4              71      //  RW  00h     Video setting.4
+//    #define     X48_ACT_LN_STRT_LSB     72      //  RW  00h     Active Line Start LSB
+//    #define     X49_ACT_LN_STRT_MSB     73      //  RW  00h     Active Line Start MSB
+//    #define     X4A_ACT_LN_END_LSB      74      //  RW  00h     Active Line End LSB
+//    #define     X4B_ACT_LN_END_MSB      75      //  RW  00h     Active Line End MSB
+//    #define     X4C_ACT_PIX_STRT_LSB    76      //  RW  00h     Active Pixel Start LSB
+//    #define     X4D_ACT_PIX_STRT_MSB    77      //  RW  00h     Active Pixel Start MSB
+//    #define     X4E_ACT_PIX_END_LSB     78      //  RW  00h     Active Pixel End LSB
+//    #define     X4F_ACT_PIX_END_MSB     79      //  RW  00h     Active Pixel End MSB
+//    #define     X50_EXT_AUDIO_SET       80      //  RW  00h     Extra audio setting
+//SLI10131
+//    #define     X51_SPEAKER_MAP         81      //  RW  00h     speaker Mapping CA[7:0]
+//IP V2.11
+#define     X51_PHY_CTRL            81      //  RW  00h     Revervd[7:4],PHY_OPTION[3:0]
+
+#define     X52_HSYNC_PLACE_656     82      //  RW  00h     HSYNC placement at ITU656
+#define     X53_HSYNC_PLACE_656     83      //
+#define     X54_VSYNC_PLACE_656     84      //  RW  00h     VSYNC placement at ITU656
+#define     X55_VSYNC_PLACE_656     85      //
+	#define     X55_VSYNC_PLACE_656_EN     			             7:7
+	#define     X55_VSYNC_PLACE_656_EN_INACT                     0
+	#define     X55_VSYNC_PLACE_656_EN_ACT   	                 1
+#define     X56_PHY_CTRL            86      //  RW  0Fh     SLIPHDMIT parameter settings
+	#define X56_PHY_CTRL_DRV_TEST_IN							 7:7
+	#define X56_PHY_CTRL_DRV_TEST_EN							 6:6
+	#define X56_PHY_CTRL_PLLA_BYPAS								 4:4
+	#define X56_PHY_CTRL_SPEED_B									 3:2
+	#define X56_PHY_CTRL_SPEED_A					             1:0
+
+#define     X57_PHY_CTRL            87      //  RW  00h
+	#define	X57_PHY_CTRL_PLLB_CONFIG17					     	 2:2
+	#define	X57_PHY_CTRL_PLLA_CONFIG17					    	 1:1
+#define     X58_PHY_CTRL            88      //  RW  00h
+		#define X58_PHY_CTRL_BGR_DISC							 7:7
+		#define X58_PHY_CTRL_BGR_V_OFFSET						 6:4				//BIT6-4
+		#define X58_PHY_CTRL_BGR_I_OFFSET						 2:0				//BIT2-0
+				
+#define     X59_PHY_CTRL            89      //  RW  20h
+#define     X5A_PHY_CTRL            90      //  RW  00h
+#define     X5B_PHY_CTRL            91      //  RW  20h
+#define     X5C_PHY_CTRL            92      //  RW  00h
+
+#define     X5D_PHY_CTRL            93      //  RW  00h
+		#define	X5D_PHY_CTRL_DRV_CONFIG2_0			6:4																		//BIT6-4
+		#define	X5D_PHY_CTRL_PE_CNTRL2_0				         2:0					//BIT2-0				
+#define     X5E_PHY_CTRL         					             94      												//  RW  00h
+		#define	X5E_PHY_CTRL_PLLB_CONFIG16						 5:5
+		#define	X5E_PHY_CTRL_PLLA_CONFIG16						 4:4
+		#define	X5E_PHY_CTRL_AMON_SEL2_0					   	 2:0
+#define     X5F_PACKET_INDEX                        95              //  R/W                                         00h     Packet Buffer Index
+        #define     GENERIC_PACKET                              0x00    //          R/W                                     00h Generic packet
+        #define     ACP_PACKET                                  0x01    //          R/W                                     00h ACP packet
+        #define     ISRC1_PACKET                                0x02    //          R/W                                     00h ISRC1 packet
+        #define     ISRC2_PACKET                                0x03    //          R/W                                     00h ISRC2 packet
+        #define     GAMUT_PACKET                                0x04    //          R/W                                     00h Gamut metadata packet
+        #define     VENDOR_INFO_PACKET                          0x05    //          R/W                                     00h Vendor specific InfoFrame
+        #define     AVI_INFO_PACKET                             0x06    //          R/W                                     00h AVI InfoFrame
+        #define     PRODUCT_INFO_PACKET                         0x07    //          R/W                                     00h Source product descriptor InfoFrame
+        #define     AUDIO_INFO_PACKET                           0x08    //          R/W                                     00h Audio InfoFrame packet
+        #define     MPEG_SRC_INFO_PACKET                        0x09    //          R/W                                     00h MPEG source InfoFrame
+#define     X60_PACKET_HB0          96      //  RW  00h     HB0
+#define     X61_PACKET_HB1          97      //  RW  00h     HB1
+#define     X62_PACKET_HB2          98      //  RW  00h     HB2
+#define     X63_PACKET_PB0          99      //  RW  00h     PB0
+#define     X64_PACKET_PB1          100     //  RW  00h
+#define     X65_PACKET_PB2          101     //  RW  00h
+#define     X66_PACKET_PB3          102     //  RW  00h
+#define     X67_PACKET_PB4          103     //  RW  00h
+#define     X68_PACKET_PB5          104     //  RW  00h
+#define     X69_PACKET_PB6          105     //  RW  00h
+#define     X6A_PACKET_PB7          106     //  RW  00h
+#define     X6B_PACKET_PB8          107     //  RW  00h
+#define     X6C_PACKET_PB9          108     //  RW  00h
+#define     X6D_PACKET_PB10         109     //  RW  00h
+#define     X6E_PACKET_PB11         110     //  RW  00h
+#define     X6F_PACKET_PB12         111     //  RW  00h
+#define     X70_PACKET_PB13         112     //  RW  00h
+#define     X71_PACKET_PB14         113     //  RW  00h
+#define     X72_PACKET_PB15         114     //  RW  00h
+#define     X73_PACKET_PB16         115     //  RW  00h
+#define     X74_PACKET_PB17         116     //  RW  00h
+#define     X75_PACKET_PB18         117     //  RW  00h
+#define     X76_PACKET_PB19         118     //  RW  00h
+#define     X77_PACKET_PB20         119     //  RW  00h
+#define     X78_PACKET_PB21         120     //  RW  00h
+#define     X79_PACKET_PB22         121     //  RW  00h
+#define     X7A_PACKET_PB23         122     //  RW  00h
+#define     X7B_PACKET_PB24         123     //  RW  00h
+#define     X7C_PACKET_PB25         124     //  RW  00h
+#define     X7D_PACKET_PB26         125     //  RW  00h
+#define     X7E_PACKET_PB27         126     //  RW  00h     PB27
+//  #define     RESERVED                127     //  Reserved
+#define     X80_EDID                128     //  RO  -       Access window for EDID buffer
+#define     X81_ISRC2_PB0           129     //  RW  00h     ISRC2 PB0-15
+#define     X82_ISRC2_PB1           130     //  RW  00h
+
+
+//		#define     X83_ISRC2_PB2           131     //  RW  00h
+//    #define     X84_ISRC2_PB3           132     //  RW  00h
+//    #define     X85_ISRC2_PB4           133     //  RW  00h
+//    #define     X86_ISRC2_PB5           134     //  RW  00h
+//    #define     X87_ISRC2_PB6           135     //  RW  00h
+//    #define     X88_ISRC2_PB7           136     //  RW  00h
+//    #define     X89_ISRC2_PB8           137     //  RW  00h
+//    #define     X8A_ISRC2_PB9           138     //  RW  00h     ISRC2 PB0-15
+//    #define     X8B_ISRC2_PB10          139     //  RW  00h
+//    #define     X8C_ISRC2_PB11          140     //  RW  00h
+//    #define     X8D_ISRC2_PB12          141     //  RW  00h
+//    #define     X8E_ISRC2_PB13          142     //  RW  00h
+//    #define     X8F_ISRC2_PB14          143     //  RW  00h
+//    #define     X90_ISRC2_PB15          144     //  RW  00h
+//    #define     X91_ISRC1_HB1           145     //  RW  00h     ISRC2 HB1
+#define     X92_INT_MASK1                   146             //  RW                                          C0h     Mask for Interrupt Group1
+		#define X92_INT_MASK1_HPG										 7:7        //'1B' NO MASKED
+		#define X92_INT_MASK1_MSENS										 6:6				 //'1B' NO MASKED
+		#define X92_INT_MASK1_VSYNC										 5:5				 //'1B' NO MASKED
+		#define X92_INT_MASK1_AFIFO_FULL								 4:4				 //'1B' NO MASKED
+		#define X92_INT_MASK1_EDID_RDY									 2:2				 //'1B' NO MASKED
+		#define X92_INT_MASK1_EDID_ERR									 1:1				 //'1B' NO MASKED
+				
+
+//				#define     EDID_ERR_MSK                        0x02    //          R/W                                     1b  EDID error detect interrupt mask
+//        #define     EDID_RDY_MSK                        0x04    //          R/W                                     1b  EDID ready interrupt mask
+//        #define     AFIFO_FULL_MSK                      0x10    //          R/W                                     0b  Audio FIFO full detect interrupt mask
+//        #define     VSYNC_MSK                           0x20    //          R/W                                     0b  VSYNC detect interrupt mask
+//        #define     MSENS_MSK                           0x40    //          R/W                                     0b  MSENS detect interrupt mask
+//        #define     HPG_MSK                             0x80    //          R/W                                     0b  Hot plug detect interrupt mask
+#define     X93_INT_MASK2                   147             //  RW                                          78h     Mask for Interrupt Group2
+		#define X93_INT_MASK2_HDCP_ERR									 7:7				 //'1B' NO MASKED
+		#define X93_INT_MASK2_BKSV_RPRDY								 6:6				 //'1B' NO MASKED
+		#define X93_INT_MASK2_BKSV_RCRDY								 5:5				 //'1B' NO MASKED
+		#define X93_INT_MASK2_AUTH_DONE									 4:4				 //'1B' NO MASKED
+		#define X93_INT_MASK2_RDY_AUTH									 3:3				 //'1B' NO MASKED
+			
+
+//				#define     RDY_AUTH_MSK                        0x08    //          R/W                                     1b  Authentication ready interrupt mask
+//        #define     AUTH_DONE_MSK                       0x10    //          R/W                                     1b  HDCP authentication done interrupt mask
+//        #define     BKSV_RCRDY_MSK                      0x20    //          R/W                                     1b  BKSV ready from receiver interrupt mask
+//        #define     BKSV_RPRDY_MSK                      0x40    //          R/W                                     1b  BKSVs list ready from repeater interrupt mask
+//        #define     HDCP_ERR_MSK                        0x80    //          R/W                                     0b  HDCP error detect interrupt mask
+#define     X94_INT1_ST                     148             //  RW                                          00h     Interrupt status Group1
+		#define X94_INT1_ST_HPG											 7:7				// 1b means Interrupted
+		#define X94_INT1_ST_HPG_EN										 1
+		#define X94_INT1_ST_HPG_NO										 0
+		#define X94_INT1_ST_MSENS									 	 6:6				// 1b means Interrupted		
+		#define X94_INT1_ST_MSENS_EN									 1
+		#define X94_INT1_ST_MSENS_NO									 0
+		#define X94_INT1_ST_VSYNC										 5:5				// 1b means Interrupted	
+		#define X94_INT1_ST_VSYNC_EN									 1
+		#define X94_INT1_ST_VSYNC_NO									 0
+		#define X94_INT1_ST_AFIFO_FULL							         4:4				// 1b means Interrupted	
+		#define X94_INT1_ST_AFIFO_FULL_EN							     1
+		#define X94_INT1_ST_AFIFO_FULL_NO							     0
+		#define X94_INT1_ST_EDID_RDY								     2:2				// 1b means Interrupted	
+		#define X94_INT1_ST_EDID_RDY_EN								     1
+		#define X94_INT1_ST_EDID_RDY_NO								     0
+		#define X94_INT1_ST_EDID_ERR								     1:1				// 1b means Interrupted		
+		#define X94_INT1_ST_EDID_ERR_EN								     1
+		#define X94_INT1_ST_EDID_ERR_NO								     0
+		
+//				#define     EDID_ERR_INT                        0x02    //          R/W                                     0b  EDID error detect interrupt
+//        #define     EDID_RDY_INT                        0x04    //          R/W                                     0b  EDID ready interrupt
+//        #define     AFIFO_FULL_INT                      0x10    //          R/W                                     0b  Audio FIFO full detect interrupt
+//        #define     VSYNC_INT                           0x20    //          R/W                                     0b  VSYNC detect interrupt
+//        #define     MSENS_INT                           0x40    //          R/W                                     0b  MSENS detect interrupt
+//        #define     HPG_INT                             0x80    //          R/W                                     0b  Hot plug detect interrupt
+#define     X95_INT2_ST                     149             //  RW                                          00h     Interrupt status Group2
+		#define X95_INT2_ST_HDCP_ERR            		7:7 
+		#define X95_INT2_ST_BKSV_RPRDY            	    6:6
+		#define X95_INT2_ST_BKSV_RCRDY            	    5:5
+		#define X95_INT2_ST_AUTH_DONE            	 	4:4
+		#define X95_INT2_ST_RDY_AUTH            	 	3:3
+				
+//				#define     RDY_AUTH_INT                        0x08    //          R/W                                     0b  Authentication ready interrupt
+//        #define     AUTH_DONE_INT                       0x10    //          R/W                                     0b  HDCP authentication done interrupt
+//        #define     BKSV_RCRDY_INT                      0x20    //          R/W                                     0b  BKSV ready from receiver interrupt
+//        #define     BKSV_RPRDY_INT                      0x40    //          R/W                                     0b  BKSVs list ready from repeater interrupt
+//        #define     HDCP_ERR_INT                        0x80    //          R/W                                     0b  HDCP error detect interrupt
+#define     X96_INT_MASK3                   0X96
+#define     X97_INT_MASK3                   0X97
+#define     X98_INT3_ST                   	0X98
+		#define     X98_INT3_ST_SF_MODE_READY           7:7
+		#define     X98_INT3_ST_RI_READY     			6:6
+		#define     X98_INT3_ST_PJ_READY     			5:5
+		#define     X98_INT3_ST_AN_READY     			4:4
+		#define     X98_INT3_ST_SHA1_READY     		    3:3
+		#define     X98_INT3_ST_ENC_EN     				2:2
+		#define     X98_INT3_ST_ENC_DIS_AVMUTE 		    1:1
+		#define     X98_INT3_ST_ENC_DIS_NO_AVMUTE       0:0
+		
+#define     X99_INT4_ST               	    0X99
+		#define     X99_INT4_ST_I2C_ACK              7:7
+		#define     X99_INT4_ST_I2C_ERR_ACK          6:6
+		#define     X99_INT4_ST_RI_SAVE_READY        5:5
+		#define     X99_INT4_ST_PJ_SAVE_READY        4:4
+		#define     X99_INT4_ST_FR_CNT_UPDATE        3:3
+		
+#define     X9A_HDCP_CTRL1               	    0X9A
+		#define     X9A_HDCP_CTRL1_AUTH                7:7
+		#define     X9A_HDCP_CTRL1_AUTH_HWARE          0
+		#define     X9A_HDCP_CTRL1_AUTH_SWARE          1
+		#define     X9A_HDCP_CTRL1_SOFT				   5:5
+		#define     X9A_HDCP_CTRL1_SOFT_CLR            0
+		#define     X9A_HDCP_CTRL1_SOFT_SET            1
+		#define     X9A_HDCP_CTRL1_PREP_AN             4:4
+		#define     X9A_HDCP_CTRL1_REPEAT        	   2:2
+		#define     X9A_HDCP_CTRL1_REPEAT_CLR    	   0
+		#define     X9A_HDCP_CTRL1_REPEAT_SET    	   1
+		#define     X9A_HDCP_CTRL1_START_AUTH          1:1
+		#define     X9A_HDCP_CTRL1_CALC_SHA1   		   0:0
+		
+#define     X9C_FRAME_CNT              	    		0X9C
+#define     X9D_FRAME_CNT_RI              	        0X9D
+#define     X9E_DDC_ACS_LENGTH          	   	    0X9E
+#define     XA0_I2C_OFFSET             	    		0XA0
+#define     XA1_DDC_I2C_CTRL            	    	0XA1
+		#define     XA1_DDC_I2C_CTRL_SEL            	  2:2
+		#define     XA1_DDC_I2C_CTRL_SEL_BUF0_4           0
+		#define     XA1_DDC_I2C_CTRL_SEL_80H           	  1
+		#define     XA1_DDC_I2C_CTRL_W_START              1:1
+		#define     XA1_DDC_I2C_CTRL_R_START              0:0
+#define     XA2_DDC_I2C_RBUF0            	    	0XA2
+#define     XA3_DDC_I2C_RBUF1            	    	0XA3
+#define     XA4_DDC_I2C_RBUF2            	    	0XA4
+#define     XA5_DDC_I2C_RBUF3            	    	0XA5
+#define     XA6_DDC_I2C_RBUF4            	    	0XA6
+#define     XA7_DDC_I2C_WBUF0            	    	0XA7
+#define     XA8_DDC_I2C_WBUF1            	    	0XA8
+#define     XA9_DDC_I2C_WBUF2            	    	0XA9
+#define     XAA_DDC_I2C_WBUF3            	   		0XAA
+#define     XAB_DDC_I2C_WBUF4            	   		0XAB
+#define     XAC_DDC_I2C_WBUF5            	   		0XAC
+#define     XAD_DDC_I2C_WBUF6            	   		0XAD
+#define     XAE_DDC_I2C_WBUF7            	   		0XAE
+
+
+
+//  #define     VN1                     150     //  RW  00h     Generic control packet (PB1-PB23)
+//  #define     VN2                     151     //  RW  00h
+//  #define     VN3                     152     //  RW  00h
+//  #define     VN4                     153     //  RW  00h
+//  #define     VN5                     154     //  RW  00h
+//  #define     VN6                     155     //  RW  00h
+//  #define     VN7                     156     //  RW  00h
+//  #define     VN8                     157     //  RW  00h
+//  #define     PD1                     158     //  RW  00h
+//  #define     PD2                     159     //  RW  00h
+//  #define     PD3                     160     //  RW  00h
+//  #define     PD4                     161     //  RW  00h
+//  #define     PD5                     162     //  RW  00h
+//  #define     PD6                     163     //  RW  00h
+//  #define     PD7                     164     //  RW  00h
+//  #define     PD8                     165     //  RW  00h
+//  #define     PD9                     166     //  RW  00h
+//  #define     PD10                    167     //  RW  00h
+//  #define     PD11                    168     //  RW  00h
+//  #define     PD12                    169     //  RW  00h
+//  #define     PD13                    170     //  RW  00h
+//  #define     PD14                    171     //  RW  00h
+//  #define     PD15                    172     //  RW  00h
+//  #define     PD16                    173     //  RW  00h     Generic control packet (PB24-PB25)
+//  #define     SRC_DEV_INFO            174     //  RW  00h
+#define     XAF_HDCP_CTRL                   175             //  R/W                                         12h     HDCP Control Register
+		#define     XAF_HDCP_CTRL_HDCP_REQ          7:7
+		#define     XAF_HDCP_CTRL_BKSV_PASS         6:6
+		#define     XAF_HDCP_CTRL_BKSV_FAIL         5:5
+		#define     XAF_HDCP_CTRL_FRAME_ENC         4:4
+		#define     XAF_HDCP_CTRL_STOP_AUTH         3:3
+		#define     XAF_HDCP_CTRL_ADV_CIPHER        2:2
+		#define     XAF_HDCP_CTRL_MODE         		1:1
+		#define     XAF_HDCP_CTRL_MODE_DVI         	0
+		#define     XAF_HDCP_CTRL_MODE_HDMI         1
+		#define     XAF_HDCP_CTRL_RESET      		0:0
+
+//        #define     HDCP_RESET                          0x01    //          R/W                                     0b  Reset HDCP
+//        #define     HDMI_MODE_CTRL                      0x02    //          R/W                                     0b  HDMI/DVI mode
+//        #define     ADV_CIPHER                          0x04    //          R/W                                     0b  Advanced cipher mode
+//        #define     STOP_AUTH                           0x08    //          R/W                                     0b  Stop HDCP authentication
+//        #define     FRAME_ENC                           0x10    //          R/W                                     0b  Frame encrypt
+//        #define     BKSV_FAIL                           0x20    //          R/W                                     0b  BKSV check result (FAIL)
+//        #define     BKSV_PASS                           0x40    //          R/W                                     0b  BKSV check result (PASS)
+//        #define     HDCP_REQ                            0x80    //          R/W                                     0b  HDCP authentication start
+//  #define     AN                      176     //  RO  00h     An register
+//                                      177     //
+//                                      178     //
+//                                      179     //
+//                                      180     //
+//                                      181     //
+//                                      182     //
+//                                      183     //
+//    #define     XB0_HDCP_STATUS                 176             //  RO                                          00h     HDCP Status Register
+#define     XB2_RI_FRAME_CNT                 0XB2  
+#define     XB7_DDC_CTL                	 0XB7
+		#define     XB7_DDC_CTL_PRESCL            7:7
+		#define     XB7_DDC_CTL_PRESCL_Y          0
+		#define     XB7_DDC_CTL_PRESCL_NO         1
+		#define     XB7_DDC_CTL_SDA_DRV           6:6
+		#define     XB7_DDC_CTL_SDA_DRV_L         0
+		#define     XB7_DDC_CTL_SDA_DRV_H         1
+		#define     XB7_DDC_CTL_SCL_DRV           5:5
+		#define     XB7_DDC_CTL_SCL_DRV_L         0
+		#define     XB7_DDC_CTL_SCL_DRV_H         1
+		#define     XB7_DDC_CTL_OVERRIDE          4:4
+		#define     XB7_DDC_CTL_OVERRIDE_N        0
+		#define     XB7_DDC_CTL_OVERRIDE_Y        1
+		#define     XB7_DDC_CTL_SDA_ST        	  1:1
+		#define     XB7_DDC_CTL_SDA_ST_L          0
+		#define     XB7_DDC_CTL_SDA_ST_H          1
+		#define     XB7_DDC_CTL_SCL_ST        	  0:0
+		#define     XB7_DDC_CTL_SCL_ST_L          0
+		#define     XB7_DDC_CTL_SCL_ST_H          1
+		
+#define     XB8_HDCP_STATUS                 184             //  RO                                          00h     HDCP Status Register
+		#define     XB8_HDCP_STATUS_AUTH 					7:7
+		#define     XB8_HDCP_STATUS_AUTH_N 					0
+		#define     XB8_HDCP_STATUS_AUTH_Y 		 			1
+		#define     XB8_HDCP_STATUS_ENC 					6:6
+		#define     XB8_HDCP_STATUS_ENC_N 				    0
+		#define     XB8_HDCP_STATUS_ENC_Y 				    1
+		#define     XB8_HDCP_STATUS_MODE 			 		5:5
+		#define     XB8_HDCP_STATUS_MODE_DVI 			    0
+		#define     XB8_HDCP_STATUS_MODE_HDMI 		        1
+		#define     XB8_HDCP_STATUS_IDLE 	 				4:4
+		#define     XB8_HDCP_STATUS_IDLE_N 	 			    0
+		#define     XB8_HDCP_STATUS_IDLE_Y 	 			    1
+		#define 		XB8_HDCP_STATUS_ADV_CIPHER		    3:3
+		#define 		XB8_HDCP_STATUS_ADV_CIPHER_N		0
+		#define 		XB8_HDCP_STATUS_ADV_CIPHER_Y		1				
+//        #define     ADV_CIPHERI_STATUS                  0x08    //          R                                       0b  Advanced cipher status
+//        #define     HDCP_IDLE                           0x10    //          R                                       0b  HDCP state machine status
+//        #define     HDMI_STATUS                         0x20    //          R                                       0b  HDMI/DVI status
+//        #define     ENC                                 0x40    //          R                                       0b  Encryption status
+//        #define     AUTH                                0x80    //          R                                       0b  HDCP authentication status
+//  #define     SHA_DISP0               185     //  RO  00h     SHA1 value
+//  #define     SHA_DISP1               186     //  RO  00h
+//  #define     SHA_DISP2               187     //  RO  00h
+//  #define     SHA_DISP3               188     //  RO  00h
+//  #define     SHA_DISP4               189     //  RO  00h
+#define     XB9_SHA0								0XB9
+#define     XBA_SHA1								0XBA
+#define     XBB_SHA2								0XBB
+#define     XBC_SHA3								0XBC
+#define     XBD_SHA4								0XBD
+//		#define     XBE_BCAPS								0XBE
+
+
+
+#define     XBE_BCAPS               190     //  RO  00h     BCAPS value
+#define     XBF_KSV7_0              191     //  RO  00h     KSV[7:0] - AKSV/BKSV monitor registers
+#define     XC0_KSV15_8             192     //  RO  00h     KSV[15:8] - AKSV/BKSV monitor registers
+#define     XC1_KSV23_16            193     //  RO  00h     KSV[23:16] - AKSV/BKSV monitor registers
+#define     XC2_KSV31_24            194     //  RO  00h     KSV[31:24] - AKSV/BKSV monitor registers
+#define     XC3_KSV39_32            195     //  RO  00h     KSV[39:32] - AKSV/BKSV monitor registers
+#define     XC4_SEG_PTR             196     //  RW  00h     EDID segment pointer
+#define     XC5_EDID_WD_ADDR        197     //  RW  00h     EDID word address
+#define     XC6_GEN_PB26            198     //  RW  00h     Generic control packet (PB26)
+#define     XC7_NUM_DEV							0XC7
+
+//  #define     NUM_DEV                 199     //  RO  00h     HDCP BKSV Size
+#define     XC8_HDCP_ERR            200     //  RO  00h     HDCP error
+#define     BAD_BKSV                            0x01    //          R/W                                     0b  BKSV does not contain 20 0's and 20 1's
+#define     XC9_TIMER               201     //  RW  46h     Timer value for 100ms
+#define     XCA_TIMER               202     //  RW  2ch     Timer value for 5sec
+#define     XCB_READ_RI_CNT         203     //  RW  12h     Ri read count
+#define     XCC_AN_SEED             204     //  RW  00h     An Seed
+#define     XCD_MAX_REC_NUM         205     //  RW  16d     maximum number of receivers allowed
+#define     XCE_HDCP_MEM_CNTL1        0XCE
+#define     XCE_HDCP_MEM_CNTL1_SHORT   7:7
+#define     XCE_HDCP_MEM_CNTL1_W4_DATA 6:0
+
+
+//  #define     //RESERVED              206     //      RO      00h
+#define     XCF_HDCP_MEM_CTRL2             207             //  RW                                          0Oh     [1:0] ID_FAX_KEY, ID_HDCP_KEY
+	#define     XCF_HDCP_MEM_CTRL2_LD_HDCP   1:1
+	#define     XCF_HDCP_MEM_CTRL2_LD_FAX    0:0
+
+//        #define     LD_HDCP_KEY                         0x01    //          R/W                                     0b  Trigger for loading HDCP key from external memory
+//        #define     LD_FAX_KEY                          0x02    //          R/W                                     0b  Trigger for loading fax HDCP key
+#define     XD0_HDCP_CTRL2                  208             //  R/W                                         08h     HDCP Control 2
+#define     XD0_HDCP_CTRL2_DIS_127_CHK      7:7
+#define     XD0_HDCP_CTRL2_BKSV_CHK					6:6
+#define     XD0_HDCP_CTRL2_EN_PJ_CALC				5:5
+#define     XD0_HDCP_CTRL2_DIS_0LEN_HASH		4:4
+#define     XD0_HDCP_CTRL2_DELAY_RI_CHK 		3:3
+#define     XD0_HDCP_CTRL2_USE_PRESENT_AN		2:2
+#define     XD0_HDCP_CTRL2_SEL_PRESENT_AN		1:0
+
+
+//        #define     DELAY_RI_CHK                        0x08    //          R/W                                     0b  Set this bit to compare Ri at 129th frame instead of 128th frame for slower receivers.
+//        #define     DIS_0LEN_HASH                       0x10    //          R/W                                     0b  Some early repeaters may not load Hash value if number of devices is 0. Set this bit to skip Hash comparison when number of devices in Bstatus equals 0.
+//        #define     EN_PJ_CALC                          0x20    //          R/W                                     0b  Even though this bit is set, Pj calculation is enabled only if adv_cipher mode is selected.
+//        #define     DIS_127_CHK                         0x80    //          R/W                                     0b  This bit must be set to disable 127th Ri check if Ri check frequency is altered by ri_frame_cnt (B2h).
+//  #define     //RESERVED              209     //      RO      00h
+#define     XD2_HDCP_KEY_CTRL               210             //  R/W                                         00h     HDCP KEY memory control
+#define     XD2_HDCP_KEY_CTRL_USE_KSV1   		6:6
+#define     XD2_HDCP_KEY_CTRL_USE_KSV2			5:5
+#define     XD2_HDCP_KEY_CTRL_LOAD_AKSV			4:4
+#define     XD2_HDCP_KEY_CTRL_KSV_SEL			3:3
+#define     XD2_HDCP_KEY_CTRL_KSV_VALID			2:2
+#define     XD2_HDCP_KEY_CTRL_KEY_VALID			1:1
+#define     XD2_HDCP_KEY_CTRL_KEY_READY			0:0
+//				#define     KEY_READY                           0x01    //          R                                       0b  This bit shows that HDCP key load has finished.
+//        #define     KEY_VALID                           0x02    //          R                                       0b  This bit shows whether HDCP key loaded from HDCP memory is valid.
+//        #define     KSV_VALID                           0x04    //          R                                       0b  This bit shows whether the loaded KSV is valid (has 20 1fs and 0fs).
+//        #define     KSV_SEL                             0x08    //          R                                       0b  This bit shows which KSV was actually loaded into memory from HDCP memory.
+//        #define     LOAD_AKSV                           0x10    //          R/W                                     0b  Select which KSV to be loaded into AKSV/BKSV register (BFh~C3h). Write 1 to load AKSV.
+//        #define     USE_KSV2                            0x20    //          R/W                                     0b  If this bit is set, load the 2nd KSV written in the HDCP memory. If both usv_ksv1 and use_ksv2 are 0, hardware loads whichever that has 20 1fs and 0fs.
+//        #define     USE_KSV1                            0x40    //          R/W                                     0b  If this bit is set, load the 1st KSV written in the HDCP memory.
+#define     XD3_CSC_CONFIG1       			  211     //  RW  81h     CSC/Video Config.1
+#define     XD3_CSC_CONFIG1_MODE					7:7
+#define     XD3_CSC_CONFIG1_MODE_MANU			    0
+#define     XD3_CSC_CONFIG1_MODE_AUTO			    1
+#define     XD3_CSC_CONFIG1_COEF					6:3
+#define     XD3_CSC_CONFIG1_COEF_SDTV_LIM		    8
+#define     XD3_CSC_CONFIG1_COEF_SDTV_FUL		    4
+#define     XD3_CSC_CONFIG1_COEF_HDTV				2
+#define     XD3_CSC_CONFIG1_COEF_HDTV_50HZ	        1
+#define     XD3_CSC_CONFIG1_CSC						2:2
+#define     XD3_CSC_CONFIG1_CSC_OFF					0
+#define     XD3_CSC_CONFIG1_CSC_ON					1
+#define     XD3_CSC_CONFIG1_VID_ID				    1:1
+#define     XD3_CSC_CONFIG1_VID_ID_5_19			    0
+#define     XD3_CSC_CONFIG1_VID_ID_28_29		    1
+#define     XD3_CSC_CONFIG1_SWAP_BR					0:0
+#define     XD3_CSC_CONFIG1_SWAP_BR_DONE		    0
+#define     XD3_CSC_CONFIG1_SWAP_BR_NOT			    1
+
+
+
+#define     XD4_VIDEO3              212     //  RW  00h     Video setting 3
+//  #define     RI                      213     //  RO  00h     Ri
+//                                      214     //  RO  00h     Pj
+//  #define     PJ                      215     //  Dir.    Reset       Descriptions
+//  #define     SHA_RD                  216     //  RW  00h     SHA index for read
+
+#define     XD5_RI_N7_0							0XD5
+#define     XD6_RI_N15_8						0XD6
+#define     XD7_PJ								0XD7
+#define     XD8_SHA_RD							0XD8
+
+#define     XD9_GEN_PB27            217     //  RW  00h     Generic InfoFrame PB27
+//  #define     MPEG_B0                 218     //  RW  00h     MPEG source InfoFrame
+//  #define     MPEG_B1                 219     //  RW  00h
+//  #define     MPEG_B2                 220     //  RW  00h
+//  #define     MPEG_B3                 221     //  RW  00h
+//  #define     MPEG_FR_MF              222     //  RW  00h
+#define     XDA_RI_N15_8_SAV				    0XDA
+#define     XDB_PJ_SAV							0XDB
+#define     XDC_NUM_DEVICE					    0XDC
+
+
+#define     XDF_HPG_STATUS                  223             //  R                                           00h     Hot plug/MSENS status
+		#define     XDF_HPG_STATUS_HPG_PRT					7:7
+		#define     XDF_HPG_STATUS_HPG_PRT_L				 0
+		#define     XDF_HPG_STATUS_HPG_PRT_H				 1
+		#define     XDF_HPG_STATUS_MSENS_PRT				6:6
+		#define     XDF_HPG_STATUS_MSENS_PRT_L			     0
+		#define     XDF_HPG_STATUS_MSENS_PRT_H			     1
+		#define     XDF_HPG_STATUS_BIST						1:0
+		#define     XDF_HPG_STATUS_BIST_PASS				 2
+		#define     XDF_HPG_STATUS_BIST_FAIL		         1
+
+//        #define     BIST_FAIL                           0x01    //          R                                       0b  Dual port RAM BIST result fail
+//        #define     BIST_PASS                           0x02    //          R                                       0b  Dual port RAM BIST result passed
+//        #define     MSENS_PRT                           0x40    //          R                                       0b  MSENS input port status
+//        #define     HPG_PRT                             0x80    //          R                                       0b  Hot plug input port status
+#define     XE0_GAMUT_HB1           224     //  RW  00h     gamut metadata HB1
+#define     XE1_GAMUT_HB2           225     //  RW  00h     gamut metadata HB2
+//  #define     GAMUT_PB0               226     //  RW  00h     gamut metadata PB0
+//  #define     GAMUT_PB1               227     //  RW  00h     gamut metadata PB1
+//  #define     GAMUT_PB2               228     //  RW  00h     gamut metadata PB2
+//  #define     GAMUT_PB3               229     //  RW  00h     gamut metadata PB3
+//  #define     GAMUT_PB4               230     //  RW  00h     gamut metadata PB4
+//  #define     GAMUT_PB5               231     //  RW  00h     gamut metadata PB5
+#define     XE3_BKSV_N7_0						0XE3
+#define     XE4_BKSV_N15_8					    0XE4
+#define     XE5_BKSV_N23_16					    0XE5
+#define     XE6_BKSV_N31_24					    0XE6
+#define     XE7_BKSV_N39_32					    0XE7
+//		#define     XE8_AN_N7_0							0XE8
+
+
+#define     XE8_AN0                 232     //  RW  00h     An[7:0]
+#define     XE9_AN1									0XE9
+#define     XEA_AN2							 		0XEA
+#define     XEB_AN3									0XEB
+#define     XEC_AN4									0XEC 
+#define     XED_AN5									0XED 
+#define     XEE_AN6									0XEE 
+#define     XEF_AN7									0XEF
+
+#define     XF0_PROD_ID							    0XF0
+#define     XF1_REVS_ID							    0XF1
+#define     XF3_START_BLK1_LSB			            0XF3
+#define     XF4_START_BLK1_MSB			            0XF4
+#define     XF5_DURA_BLK1						    0XF5
+#define     XF6_DURA_BLK2_LSB				        0XF6
+#define     XF7_DURA_BLK2_MSB			        	0XF7
+#define     XF8_DURA_BLK2						    0XF8
+#define     XF9_START_BLK3_LSB			            0XF9
+#define     XFA_START_BLK3_MSB			            0XFA
+#define     XFB_DURA_BLK3					    	0XFB
+#define     XFC_VID_INPUT					    	0XFC
+	#define     XFC_VID_INPUT_HSYNC					1:1
+	#define     XFC_VID_INPUT_HSYNC_ADJ_Y		    0
+	#define     XFC_VID_INPUT_HSYNC_ADJ_N	    	1
+	#define     XFC_VID_INPUT_VSYNC					0:0
+	#define     XFC_VID_INPUT_VSYNC_ADJ_Y		    0
+	#define     XFC_VID_INPUT_VSYNC_ADJ_N		    1
+#define     XFD_RDAT_OUTPUT						    0XFD
+#define     XFE_TEST								0XFE
+#define     XFE_TEST_FBCK							7:7
+#define     XFE_TEST_FBCK_DIS					    0
+#define     XFE_TEST_FBCK_EN				    	1
+#define     XFE_TEST_FBCK20					    	5:5
+#define     XFE_TEST_FBCK20_DIS				        0
+#define     XFE_TEST_FBCK20_EN				        1
+#define     XFE_TEST_FBCK10						    4:4
+#define     XFE_TEST_FBCK10_DIS				        0
+#define     XFE_TEST_FBCK10_EN				        1
+#define     XFE_TEST_BIST_FLAG				        3:3
+#define     XFE_TEST_BIST_FLAG_END		            0
+#define     XFE_TEST_BIST_FLAG_WORK		            1
+#define     XFE_TEST_PHY_ONLY				    	2:2
+#define     XFE_TEST_PHY_ONLY_DIS		        	0
+#define     XFE_TEST_PHY_ONLY_EN			        1
+#define     XFE_TEST_AUTO_LB				    	1:1
+#define     XFE_TEST_AUTO_LB_MANUAL			        0
+#define     XFE_TEST_AUTO_LB_RANDOM			        1
+#define     XFE_TEST_LB 							0:0
+#define     XFE_TEST_LB_DIS 						0
+#define     XFE_TEST_LB_EN 							1
+
+//  #define     GAMUT_PB7               233     //  RW  00h     gamut metadata PB7
+//  #define     GAMUT_PB8               234     //  RW  00h     gamut metadata PB8
+//  #define     GAMUT_PB9               235     //  RW  00h     gamut metadata PB9
+//  #define     GAMUT_PB10              236     //  RW  00h     gamut metadata PB10
+//  #define     GAMUT_PB11              237     //  RW  00h     gamut metadata PB11
+//  #define     GAMUT_PB12              238     //  RW  00h     gamut metadata PB12
+//  #define     GAMUT_PB13              239     //  RW  00h     gamut metadata PB13
+//  #define     GAMUT_PB14              240     //  RW  00h     gamut metadata PB14
+//  #define     GAMUT_PB15              241     //  RW  00h     gamut metadata PB15
+//  #define     GAMUT_PB16              242     //  RW  00h     gamut metadata PB16
+//  #define     GAMUT_PB17              243     //  RW  00h     gamut metadata PB17
+//  #define     GAMUT_PB18              244     //  RW  00h     gamut metadata PB18
+//  #define     GAMUT_PB19              245     //  RW  00h     gamut metadata PB19
+//  #define     GAMUT_PB20              246     //  RW  00h     gamut metadata PB20
+//  #define     GAMUT_PB21              247     //  RW  00h     gamut metadata PB21
+//  #define     GAMUT_PB22              248     //  RW  00h     gamut metadata PB22
+//  #define     GAMUT_PB23              249     //  RW  00h     gamut metadata PB23
+//  #define     GAMUT_PB24              250     //  RW  00h     gamut metadata PB24
+//  #define     GAMUT_PB25              251     //  RW  00h     gamut metadata PB25
+//  #define     GAMUT_PB26              252     //  RW  00h     gamut metadata PB26
+//  #define     GAMUT_PB27              253     //  RW  00h     gamut metadata PB27
+//  #define     TEST_MODE               254     //  RW  00h     test mode register
+//    #define     XFF_IP_COM_CONTROL              255             //  R/W                                         40h     I/P conversion control
+//        #define     IP_CONV_PIX_REP                     0x01    //          R/W                                     0b  I/P conversion control
+//        #define     IP_CONV_EN                          0x02    //          R/W                                     0b  I/P conversion mode control
+//        #define     PRE_COLOR_CONV_ON                   0x10    //          R/W                                     0b  Pre-color space converter (RGB->YCbCr) control
+//        #define     PRE_DOWN_CONV_ON                    0x20    //          R/W                                     0b  Pre-pixel encoding converter (down sampler) control
+//        #define     STGAM_OFF                           0x40    //          R/W                                     1b  Gamma correction control
+//        #define     IP_REG_OFFSET                       0x80    //          R/W                                     0b  I/P conversion control register access control
+
+
+#endif  /* _HDMIREGS_H_ */
diff --git a/drivers/gpu/drm/smi/ddk768/l3.c b/drivers/gpu/drm/smi/ddk768/l3.c
new file mode 100644
index 000000000000..e68c371ce307
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk768/l3.c
@@ -0,0 +1,65 @@
+
+#include "l3.h"
+
+/*
+ * Send one byte of data to the chip.  Data is latched into the chip on
+ * the rising edge of the clock.
+ */
+static void sendbyte(struct l3_pins *adap, unsigned int byte)
+{
+	int i;
+
+	for (i = 0; i < 8; i++) {
+		adap->setclk(0);
+		sb_OS_WAIT_USEC_POLL(adap->data_hold);
+		adap->setdat(byte & 1);
+		sb_OS_WAIT_USEC_POLL(adap->data_setup);
+		adap->setclk(1);
+		sb_OS_WAIT_USEC_POLL(adap->clock_high);
+		byte >>= 1;
+	}
+}
+
+/*
+ * Send a set of bytes to the chip.  We need to pulse the MODE line
+ * between each byte, but never at the start nor at the end of the
+ * transfer.
+ */
+static void sendbytes(struct l3_pins *adap, const u8 *buf,
+		      int len)
+{
+	int i;
+
+	for (i = 0; i < len; i++) {
+		if (i) {
+			sb_OS_WAIT_USEC_POLL(adap->mode_hold);
+			adap->setmode(0);
+			sb_OS_WAIT_USEC_POLL(adap->mode);
+		}
+		adap->setmode(1);
+		sb_OS_WAIT_USEC_POLL(adap->mode_setup);
+		sendbyte(adap, buf[i]);
+	}
+}
+
+int l3_write(struct l3_pins *adap, u8 addr, u8 *data, int len)
+{
+	adap->setclk(1);
+	adap->setdat(1);
+	adap->setmode(1);
+	sb_OS_WAIT_USEC_POLL(adap->mode);
+
+	adap->setmode(0);
+	sb_OS_WAIT_USEC_POLL(adap->mode_setup);
+	sendbyte(adap, addr);
+	sb_OS_WAIT_USEC_POLL(adap->mode_hold);
+
+	sendbytes(adap, data, len);
+
+	adap->setclk(1);
+	adap->setdat(1);
+	adap->setmode(0);
+
+	return len;
+}
+
diff --git a/drivers/gpu/drm/smi/ddk768/l3.h b/drivers/gpu/drm/smi/ddk768/l3.h
new file mode 100644
index 000000000000..227d9753c4a5
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk768/l3.h
@@ -0,0 +1,22 @@
+#ifndef _L3_H_
+#define _L3_H_ 
+
+#include <linux/string.h>
+#include "ddk768_timer.h"
+
+
+struct l3_pins {
+	void (*setdat)(int);
+	void (*setclk)(int);
+	void (*setmode)(int);
+	int data_hold;
+	int data_setup;
+	int clock_high;
+	int mode_hold;
+	int mode;
+	int mode_setup;
+};
+
+int l3_write(struct l3_pins *adap, u8 addr, u8 *data, int len);
+
+#endif
diff --git a/drivers/gpu/drm/smi/ddk768/uda1345.c b/drivers/gpu/drm/smi/ddk768/uda1345.c
new file mode 100644
index 000000000000..16ca7bbd32e8
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk768/uda1345.c
@@ -0,0 +1,368 @@
+#include <linux/string.h>
+#include "ddk768_reg.h"
+#include "ddk768_help.h"
+#include "uda1345.h"
+
+static void setdat(int v);
+static void setclk(int v);
+static void setmode(int v);
+
+static const u8 uda1346_reg[UDA1345_REGS_NUM] =
+{
+    /* Status, data regs */
+    0x00, 0x00, 0x80, 0xc1,
+};
+
+static u8 cache[sizeof(uda1346_reg)];
+
+static struct uda1345_data falcon_uda1345 =
+{
+    .l3 = {
+        .setdat = setdat,
+        .setclk = setclk,
+        .setmode = setmode,
+        .data_hold = 1,
+        .data_setup = 1,
+        .clock_high = 1,
+        .mode_hold = 1,
+        .mode = 1,
+        .mode_setup = 1,
+    },
+    .reg_cache_default = (void*)uda1346_reg,
+    .cache_init = 0,
+};
+
+static void setdat(int v)
+{
+    unsigned long value;
+
+    value = peekRegisterDWord(GPIO_DATA);
+    pokeRegisterDWord(GPIO_DATA, 0 < v ? (value | (1 << GPIO_DATA_GPIO_CODEC_DATA_SHIFT)) : \
+                      (value & ~(1 << GPIO_DATA_GPIO_CODEC_DATA_SHIFT)));
+
+}
+
+static void setclk(int v)
+{
+    unsigned long value;
+
+		value = peekRegisterDWord(GPIO_DATA);
+		pokeRegisterDWord(GPIO_DATA, 0 < v ? (value | (1 << GPIO_DATA_GPIO_CODEC_CLK_SHIFT)) : \
+						  (value & ~(1 << GPIO_DATA_GPIO_CODEC_CLK_SHIFT)));
+
+
+}
+
+static void setmode(int v)
+{
+    unsigned long value;
+
+		value = peekRegisterDWord(GPIO_DATA);
+		pokeRegisterDWord(GPIO_DATA, 0 < v ? (value | (1 << GPIO_DATA_GPIO_CODEC_MODE_SHIFT)) : \
+						  (value & ~(1 << GPIO_DATA_GPIO_CODEC_MODE_SHIFT)));
+
+}
+
+static void uda1345_GPIOInit(void)
+{
+    unsigned long value;
+   		 /*l3 mode control pins*/
+
+		value = peekRegisterDWord(GPIO_MUX);
+		value &= ~(1 << GPIO_MUX_GPIO_CODEC_MODE_SHIFT);
+		value &= ~(1 << GPIO_MUX_GPIO_CODEC_CLK_SHIFT);
+		value &= ~(1 << GPIO_MUX_GPIO_CODEC_DATA_SHIFT);
+		pokeRegisterDWord(GPIO_MUX, value);
+
+		/*set 3 pins as input*/
+		value = peekRegisterDWord(GPIO_DATA_DIRECTION);
+		value |= (1 << GPIO_DATA_DIRECTION_GPIO_CODEC_MODE_SHIFT);
+		value |= (1 << GPIO_DATA_DIRECTION_GPIO_CODEC_CLK_SHIFT);
+		value |= (1 << GPIO_DATA_DIRECTION_GPIO_CODEC_DATA_SHIFT);
+		pokeRegisterDWord(GPIO_DATA_DIRECTION, value);
+
+
+}
+
+static inline unsigned int uda1345_read_reg_cache(struct uda1345_data *codec,
+        unsigned int reg)
+{
+    u8 *cache = (u8 *)codec->reg_cache;
+
+    if (reg >= UDA1345_REGS_NUM)
+        return -1;
+	
+    return cache[reg];
+}
+
+/*
+ * Write the register cache
+ */
+static inline int uda1345_write_reg_cache(struct uda1345_data *codec,
+        u8 reg, unsigned int value)
+{
+    u8 *cache = (u8 *)codec->reg_cache;
+
+    if (reg >= UDA1345_REGS_NUM)
+        return -1;
+    cache[reg] = value;
+    return 0;
+}
+
+
+/*
+ * Write to the uda134x registers
+ *
+ */
+static int uda1345_write(unsigned int reg,
+                         unsigned int value)
+{
+    int ret;
+    u8 addr;
+    u8 data = value;
+
+    if (reg >= UDA1345_REGS_NUM)
+    {
+
+        return -1;
+    }
+
+    uda1345_write_reg_cache(&falcon_uda1345, reg, value);
+
+    switch (reg)
+    {
+    case UDA1345_STATUS:
+        addr = UDA1345_STATUS_ADDR;
+        break;
+    case UDA1345_DATA_VOLUME:
+    case UDA1345_DATA_DE_MUTE:
+    case UDA1345_DATA_POWER:
+        addr = UDA1345_DATA_ADDR;
+        break;
+    default:
+        break;
+    }
+
+    ret = l3_write(&falcon_uda1345.l3,
+                   addr, &data, 1);
+   
+   if (ret != 1)
+        return -1;
+
+    return 0;
+}
+
+int uda1345_setsysclkfs(enum uda1345_sysclkf sysclk)
+{
+    u8 data;
+	
+    data = uda1345_read_reg_cache(&falcon_uda1345,UDA1345_STATUS);
+	
+    data &= ~UDA1345_SYSCLKF_MASK;
+    switch(sysclk)
+    {
+    case SYSCLKF_512FS:
+        data |= UDA1345_SYSCLKF_512FS;
+        break;
+    case SYSCLKF_384FS:
+        data |= UDA1345_SYSCLKF_384FS;
+        break;
+    case SYSCLKF_256FS:
+        data |= UDA1345_SYSCLKF_256FS;
+        break;
+    default:
+        return -1;
+    }
+	
+    return uda1345_write(UDA1345_STATUS,data);
+
+}
+
+int uda1345_setformat(enum uda1345_input_format informat)
+{
+
+    u8 data;
+    data = uda1345_read_reg_cache(&falcon_uda1345,UDA1345_STATUS);
+    data &= ~UDA1345_FORMAT_MASK;
+    switch(informat)
+    {
+    case I2S_BUS:
+        data |= UDA1345_I2S_BUS;
+        break;
+    case LSB_16BITS:
+        data |= UDA1345_LSB_16BITS;
+        break;
+    case LSB_18BITS:
+        data |= UDA1345_LSB_18BITS;
+        break;
+    case	LSB_20BITS:
+        data |= UDA1345_LSB_20BITS;
+        break;
+    case	MSB_JUSTIFIED:
+        data |= UDA1345_MSB_JUSTIFIED;
+        break;
+    case	MSB_OUTPUT_LSB_16BITS_INPUT:
+        data |= UDA1345_MSB_OUTPUT_LSB_16BITS_INPUT;
+        break;
+    case	MSB_OUTPUT_LSB_18BITS_INPUT:
+        data |= UDA1345_MSB_OUTPUT_LSB_18BITS_INPUT;
+        break;
+    case	MSB_OUTPUT_LSB_20BITS_INPUT:
+        data |= UDA1345_MSB_OUTPUT_LSB_20BITS_INPUT;
+        break;
+    default:
+        return -1;
+    }
+    return  uda1345_write(UDA1345_STATUS,data);
+
+}
+
+
+int uda1345_setdcfilter(enum uda1345_dc_filter onoff)
+{
+
+    u8 data;
+    data = uda1345_read_reg_cache(&falcon_uda1345,UDA1345_STATUS);
+    data &= ~UDA1345_DC_MASK;
+    switch(onoff)
+    {
+    case NO_DC_FILTERING:
+        data |= UDA1345_NO_DC_FILTERING;
+        break;
+    case DC_FILTERING:
+        data |= UDA1345_DC_FILTERING;
+        break;
+    default:
+        return -1;
+    }
+    return  uda1345_write(UDA1345_STATUS,data);
+
+}
+
+
+int uda1345_setvolume(u8 dB)
+{
+
+    u8 data;
+    data = uda1345_read_reg_cache(&falcon_uda1345,UDA1345_DATA_VOLUME);
+    data &= ~UDA1345_VOLUME_MASK;
+    data |= (dB&UDA1345_VOLUME_MASK);
+    return  uda1345_write(UDA1345_DATA_VOLUME,data);
+
+}
+
+
+int uda1345_setdemphasis(enum uda1345_de_emphasis emphasis)
+{
+    u8 data;
+    data = uda1345_read_reg_cache(&falcon_uda1345,UDA1345_DATA_DE_MUTE);
+    data &= ~UDA1345_DE_EMPHASIS_MASK;
+    switch(emphasis)
+    {
+    case NO_DE_EMPHASIS:
+        data |= UDA1345_NO_DE_EMPHASIS;
+        break;
+    case DE_EMPHASIS_32KHZ:
+        data |= UDA1345_DE_EMPHASIS_32KHZ;
+        break;
+    case DE_EMPHASIS_44KHZ:
+        data |= UDA1345_DE_EMPHASIS_44KHZ;
+        break;
+    case DE_EMPHASIS_48KHZ:
+        data |= UDA1345_DE_EMPHASIS_48KHZ;
+        break;
+    default:
+
+        return -1;
+    }
+    return uda1345_write(UDA1345_DATA_DE_MUTE,data);
+
+}
+
+int uda1345_setmute(enum uda1345_mute onoff)
+{
+    u8 data;
+    data = uda1345_read_reg_cache(&falcon_uda1345,UDA1345_DATA_DE_MUTE);
+    data &= ~UDA1345_MUTE_MASK;
+    switch(onoff)
+    {
+    case NO_MUTE:
+        data |= UDA1345_NO_MUTE;
+        break;
+    case MUTE:
+        data |= UDA1345_MUTE;
+        break;
+    default:
+        return -1;
+    }
+    return  uda1345_write(UDA1345_DATA_DE_MUTE,data);
+
+}
+
+int uda1345_setpower(enum uda1345_power onoff)
+{
+    u8 data;
+    data = uda1345_read_reg_cache(&falcon_uda1345,UDA1345_DATA_POWER);
+    data &= ~UDA1345_ADC_DAC_MASK;
+    switch(onoff)
+    {
+    case ADCOFF_DACOFF:
+        data |= UDA1345_ADCOFF_DACOFF;
+        break;
+    case ADCOFF_DACON:
+        data |= UDA1345_ADCOFF_DACON;
+        break;
+    case ADCON_DACOFF:
+        data |= UDA1345_ADCON_DACOFF;
+        break;
+    case ADCON_DACON:
+        data |= UDA1345_ADCON_DACON;
+        break;
+    default:
+        return -1;
+    }
+    return  uda1345_write(UDA1345_DATA_POWER,data);
+
+}
+
+int uda1345_init(void)
+{
+    uda1345_GPIOInit();    
+
+    if(0 ==  falcon_uda1345.cache_init)
+    {
+        falcon_uda1345.cache_size = sizeof(uda1346_reg);
+        falcon_uda1345.reg_cache = cache;
+        memcpy(falcon_uda1345.reg_cache, falcon_uda1345.reg_cache_default,falcon_uda1345.cache_size );
+        falcon_uda1345.cache_init = 1;
+    }
+
+    if(uda1345_setsysclkfs(SYSCLKF_384FS))
+        return -1;
+    if(uda1345_setformat(I2S_BUS))
+        return -1;
+    if(uda1345_setdcfilter(NO_DC_FILTERING))
+        return -1;
+    if(uda1345_setdemphasis(NO_DE_EMPHASIS))
+        return -1;
+    if(uda1345_setvolume(0))
+        return -1;
+    if(uda1345_setmute(MUTE))
+        return -1;
+    if(uda1345_setpower(ADCOFF_DACOFF))
+        return -1;
+
+    return 0;
+}
+
+int uda1345_deinit(void)
+{
+    uda1345_setpower(ADCOFF_DACOFF);
+    if(falcon_uda1345.cache_init&&falcon_uda1345.reg_cache)
+    {
+        falcon_uda1345.reg_cache = NULL;
+        falcon_uda1345.cache_init =  0;
+    }
+    return 0;
+}
+
diff --git a/drivers/gpu/drm/smi/ddk768/uda1345.h b/drivers/gpu/drm/smi/ddk768/uda1345.h
new file mode 100644
index 000000000000..926b2c72f2a6
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk768/uda1345.h
@@ -0,0 +1,131 @@
+#ifndef _UDA1345_CODEC_H
+#define _UDA1345_CODEC_H
+#include "l3.h"
+
+
+#define UDA1345_L3ADDR	5
+#define UDA1345_DATA_ADDR	((UDA1345_L3ADDR << 2) | 0)
+#define UDA1345_STATUS_ADDR	((UDA1345_L3ADDR << 2) | 2)
+
+
+/* UDA1345 registers */
+#define UDA1345_STATUS 0
+#define UDA1345_DATA_VOLUME 1
+#define UDA1345_DATA_DE_MUTE 2
+#define UDA1345_DATA_POWER 3
+
+#define UDA1345_REGS_NUM 4
+
+/*UDA1345 System clock frequency*/
+#define UDA1345_SYSCLKF_MASK (3 << 4)
+#define UDA1345_SYSCLKF_512FS  (0 << 4)
+#define UDA1345_SYSCLKF_384FS  (1 << 4)
+#define UDA1345_SYSCLKF_256FS  (2 << 4)
+enum uda1345_sysclkf
+{
+    SYSCLKF_512FS = 0,
+    SYSCLKF_384FS,
+    SYSCLKF_256FS,
+};
+
+/*UDA1345 data input format*/
+#define UDA1345_FORMAT_MASK (7 << 1)
+#define  UDA1345_I2S_BUS (0 << 1)
+#define  UDA1345_LSB_16BITS (1 << 1)
+#define  UDA1345_LSB_18BITS (2 << 1)
+#define  UDA1345_LSB_20BITS (3 << 1)
+#define  UDA1345_MSB_JUSTIFIED (4 << 1)
+#define  UDA1345_MSB_OUTPUT_LSB_16BITS_INPUT (5 << 1)
+#define  UDA1345_MSB_OUTPUT_LSB_18BITS_INPUT (6 << 1)
+#define  UDA1345_MSB_OUTPUT_LSB_20BITS_INPUT (7 << 1)
+enum uda1345_input_format
+{
+    I2S_BUS = 0,
+    LSB_16BITS,
+    LSB_18BITS,
+    LSB_20BITS,
+    MSB_JUSTIFIED,
+    MSB_OUTPUT_LSB_16BITS_INPUT,
+    MSB_OUTPUT_LSB_18BITS_INPUT,
+    MSB_OUTPUT_LSB_20BITS_INPUT,
+};
+
+/*UDA1345 dc filter*/
+#define UDA1345_DC_MASK 1
+#define UDA1345_DC_FILTERING 1
+#define UDA1345_NO_DC_FILTERING 0
+enum uda1345_dc_filter
+{
+    NO_DC_FILTERING = 0,
+    DC_FILTERING,
+};
+
+/*UDA1345 volume*/
+#define UDA1345_VOLUME_MASK 0x3f
+#define UDA1345_VOLUME_N5DB 6
+#define UDA1345_VOLUME_N10DB 0xB
+
+/*UDA1345 DE-EMPHASIS*/
+#define UDA1345_DE_EMPHASIS_MASK (3 << 3)
+#define UDA1345_NO_DE_EMPHASIS (0 << 3)
+#define UDA1345_DE_EMPHASIS_32KHZ (1 << 3)
+#define UDA1345_DE_EMPHASIS_44KHZ (2 << 3)
+#define UDA1345_DE_EMPHASIS_48KHZ (3 << 3)
+enum uda1345_de_emphasis
+{
+    NO_DE_EMPHASIS = 0,
+    DE_EMPHASIS_32KHZ,
+    DE_EMPHASIS_44KHZ,
+    DE_EMPHASIS_48KHZ,
+};
+
+/*UDA1345 mute*/
+#define UDA1345_MUTE_MASK (1 << 2)
+#define UDA1345_NO_MUTE (0 << 2)
+#define UDA1345_MUTE (1 << 2)
+enum uda1345_mute
+{
+    NO_MUTE = 0,
+    MUTE,
+};
+
+/*UDA1345 power control*/
+#define UDA1345_ADC_DAC_MASK 3
+#define UDA1345_ADCOFF_DACOFF 0
+#define UDA1345_ADCOFF_DACON 1
+#define UDA1345_ADCON_DACOFF 2
+#define UDA1345_ADCON_DACON 3
+enum uda1345_power
+{
+    ADCOFF_DACOFF = 0,
+    ADCOFF_DACON,
+    ADCON_DACOFF,
+    ADCON_DACON,
+};
+
+
+struct uda1345_data
+{
+    struct l3_pins l3;
+    void * reg_cache_default;
+    void * reg_cache;
+    unsigned int cache_size;
+    unsigned int cache_init : 1;
+
+};
+
+
+
+
+
+int uda1345_setsysclkfs(enum uda1345_sysclkf sysclk);
+int uda1345_setformat(enum uda1345_input_format informat);
+int uda1345_setdcfilter(enum uda1345_dc_filter onoff);
+int uda1345_setvolume(u8 dB);
+int uda1345_setdemphasis(enum uda1345_de_emphasis emphasis);
+int uda1345_setmute(enum uda1345_mute onoff);
+int uda1345_setpower(enum uda1345_power onoff);
+int uda1345_init(void);
+int uda1345_deinit(void);
+#endif
+
diff --git a/drivers/gpu/drm/smi/ddk768/vdif.h b/drivers/gpu/drm/smi/ddk768/vdif.h
new file mode 100644
index 000000000000..36d11d6daa54
--- /dev/null
+++ b/drivers/gpu/drm/smi/ddk768/vdif.h
@@ -0,0 +1,63 @@
+/*******************************************************************
+* 
+*         Copyright (c) 2009 by Silicon Motion, Inc. (SMI)
+* 
+*  All rights are reserved. Reproduction or in part is prohibited
+*  without the written consent of the copyright owner.
+* 
+*  vdif.h --- SMI DDK 
+*  This file contains the video display information format structure
+* 
+*******************************************************************/
+#ifndef _VDIF_H_
+#define _VDIF_H_
+
+/* Sync polarity */
+typedef enum _vdif_sync_polarity_t
+{
+    VDIF_SYNC_NEGATIVE = 0,
+    VDIF_SYNC_POSITIVE
+} vdif_sync_polarity_t; 
+
+/* Scan type */
+typedef enum _vdif_scan_type_t
+{
+    VDIF_NONINTERLACED = 0,
+    VDIF_INTERLACED
+} vdif_scan_type_t;
+
+/* Monitor Timing Information */
+typedef struct _video_display_information_format_t
+{
+    unsigned long pixelClock;
+    unsigned long characterWidth;
+    vdif_scan_type_t scanType; 
+    
+    unsigned long horizontalFrequency;
+    vdif_sync_polarity_t horizontalSyncPolarity;
+    unsigned long horizontalTotal;
+    unsigned long horizontalActive;
+    unsigned long horizontalBlankStart;
+    unsigned long horizontalBlankTime;
+    unsigned long horizontalSyncStart;
+    unsigned long horizontalRightBorder;
+    unsigned long horizontalFrontPorch;
+    unsigned long horizontalSyncWidth;
+    unsigned long horizontalBackPorch;
+    unsigned long horizontalLeftBorder;
+    
+    unsigned long verticalFrequency;
+    vdif_sync_polarity_t verticalSyncPolarity; 
+    unsigned long verticalTotal;
+    unsigned long verticalActive;
+    unsigned long verticalBlankStart;
+    unsigned long verticalBlankTime;
+    unsigned long verticalSyncStart;
+    unsigned long verticalBottomBorder;
+    unsigned long verticalFrontPorch;
+    unsigned long verticalSyncHeight;
+    unsigned long verticalBackPorch;
+    unsigned long verticalTopBorder;
+} vdif_t;
+
+#endif  /* _VDIF_H_ */
diff --git a/drivers/gpu/drm/smi/hw750.c b/drivers/gpu/drm/smi/hw750.c
new file mode 100644
index 000000000000..1027896814f0
--- /dev/null
+++ b/drivers/gpu/drm/smi/hw750.c
@@ -0,0 +1,292 @@
+/*
+ * Copyright 2016 SiliconMotion Inc.
+ *
+ * This file is subject to the terms and conditions of the GNU General
+ * Public License version 2. See the file COPYING in the main
+ * directory of this archive for more details.
+ *
+ */
+
+
+#include "ddk750/ddk750_mode.h"
+#include "ddk750/ddk750_help.h"
+#include "ddk750/ddk750_regdc.h"	
+#include "ddk750/ddk750_defs.h"
+#include "ddk750/ddk750_display.h"
+#include "ddk750/ddk750_2d.h"
+#include "ddk750/ddk750_power.h"
+#include "ddk750/ddk750_edid.h"
+#include "ddk750/ddk750_cursor.h"
+//#include "smi_drv.h"
+//#include "hw750.h"
+#ifdef USE_HDMICHIP
+#include "ddk750/ddk750_sii9022.h"
+#endif
+
+
+struct smi_750_register{
+	/* registers for save */
+	uint32_t system_ctrl, misc_ctrl,gpio_mux, localmem_arbitration;
+	uint32_t pcimem_arbitration, raw_int, int_status, int_mask;
+	uint32_t current_gate, mode0_gate, mode1_gate, power_mode_ctrl;
+	uint32_t pci_master_base, primary_pll_ctrl,	secondary_pll_ctrl,	vga_pll0_ctrl;
+	uint32_t vga_pll1_ctrl,	mxclk_pll_ctrl,	vga_configuration;
+	
+	uint32_t de_stretch_format, de_masks, de_window_width, de_control;
+
+	uint32_t primary_display_ctrl,primary_pan_ctrl,primary_color_key,primary_fb_address;
+	uint32_t primary_fb_width, primary_window_width,primary_window_height, primary_plane_tl;
+	uint32_t primary_plane_br, primary_horizontal_total, primary_horizontal_sync, primary_vertical_total;
+	uint32_t primary_vertical_sync, primary_current_line;
+	
+	uint32_t secondary_display_ctrl, secondary_fb_address, secondary_fb_width;
+	uint32_t secondary_horizontal_total, secondary_horizontal_sync;
+	uint32_t secondary_vertical_total, secondary_vertical_sync;
+	uint32_t secondary_auto_centering_tl, secondary_auto_centering_br;
+	uint32_t secondary_scale, secondary_hwc_address, secondary_hwc_location;
+	uint32_t secondary_hwc_color_12, secondary_hwc_color_3;
+};
+
+
+
+void hw750_suspend(struct smi_750_register * pSave)
+{
+
+		/* save mmio registers */
+
+		pSave->system_ctrl = PEEK32(SYSTEM_CTRL);
+		pSave->misc_ctrl = PEEK32(MISC_CTRL);
+		pSave->gpio_mux = PEEK32(GPIO_MUX);
+		pSave->localmem_arbitration = PEEK32(LOCALMEM_ARBITRATION);
+		pSave->pcimem_arbitration = PEEK32(PCIMEM_ARBITRATION);
+		pSave->raw_int = PEEK32(RAW_INT);
+		pSave->int_status = PEEK32(INT_STATUS);
+		pSave->int_mask = PEEK32(INT_MASK);
+		pSave->current_gate = PEEK32(CURRENT_GATE);
+		pSave->mode0_gate = PEEK32(MODE0_GATE);
+		pSave->mode1_gate = PEEK32(MODE1_GATE);
+		pSave->power_mode_ctrl = PEEK32(POWER_MODE_CTRL);
+		pSave->pci_master_base = PEEK32(PCI_MASTER_BASE);
+		pSave->primary_pll_ctrl = PEEK32(PRIMARY_PLL_CTRL);
+		pSave->secondary_pll_ctrl = PEEK32(SECONDARY_PLL_CTRL);
+		pSave->vga_pll0_ctrl = PEEK32(VGA_PLL0_CTRL);
+		pSave->vga_pll1_ctrl = PEEK32(VGA_PLL1_CTRL);
+		pSave->mxclk_pll_ctrl = PEEK32(MXCLK_PLL_CTRL);
+		pSave->vga_configuration = PEEK32(VGA_CONFIGURATION);
+
+#if 0// for 2d, JUST HOLD IT.
+		pSave->de_stretch_format = PEEK32(DE_STRETCH_FORMAT);
+		pSave->de_masks = PEEK32(DE_MASKS);
+		pSave->de_window_width = PEEK32(DE_WINDOW_WIDTH);
+		pSave->de_control = PEEK32(DE_CONTROL);
+#endif	
+		pSave->primary_display_ctrl = PEEK32(PRIMARY_DISPLAY_CTRL);
+		pSave->primary_pan_ctrl = PEEK32(PRIMARY_PAN_CTRL);
+		pSave->primary_color_key = PEEK32(PRIMARY_COLOR_KEY);
+		pSave->primary_fb_address = PEEK32(PRIMARY_FB_ADDRESS);
+		pSave->primary_fb_width = PEEK32(PRIMARY_FB_WIDTH);
+		pSave->primary_window_width= PEEK32(PRIMARY_WINDOW_WIDTH);
+		pSave->primary_window_height= PEEK32(PRIMARY_WINDOW_HEIGHT);
+		pSave->primary_plane_tl= PEEK32(PRIMARY_PLANE_TL);
+		pSave->primary_plane_br= PEEK32(PRIMARY_PLANE_BR);
+		pSave->primary_horizontal_total = PEEK32(PRIMARY_HORIZONTAL_TOTAL);
+		pSave->primary_horizontal_sync = PEEK32(PRIMARY_HORIZONTAL_SYNC);
+		pSave->primary_vertical_total = PEEK32(PRIMARY_VERTICAL_TOTAL);
+		pSave->primary_vertical_sync = PEEK32(PRIMARY_VERTICAL_SYNC);
+		pSave->primary_current_line = PEEK32(PRIMARY_CURRENT_LINE);
+#if 0	//for hw cursor, JUST HOLD IT.
+		pSave->primary_hwc_address = PEEK32(PRIMARY_HWC_ADDRESS);
+		pSave->primary_hwc_location = PEEK32(PRIMARY_HWC_LOCATION);
+		pSave->primary_hwc_color_12 = PEEK32(PRIMARY_HWC_COLOR_12);
+		pSave->primary_hwc_color_3 = PEEK32(PRIMARY_HWC_COLOR_3);
+#endif	
+	
+		pSave->secondary_display_ctrl = PEEK32(SECONDARY_DISPLAY_CTRL);
+		pSave->secondary_fb_address = PEEK32(SECONDARY_FB_ADDRESS);
+		pSave->secondary_fb_width = PEEK32(SECONDARY_FB_WIDTH);
+		pSave->secondary_horizontal_total = PEEK32(SECONDARY_HORIZONTAL_TOTAL);
+		pSave->secondary_horizontal_sync = PEEK32(SECONDARY_HORIZONTAL_SYNC);
+		pSave->secondary_vertical_total = PEEK32(SECONDARY_VERTICAL_TOTAL);
+		pSave->secondary_vertical_sync = PEEK32(SECONDARY_VERTICAL_SYNC);
+		pSave->secondary_scale = PEEK32(SECONDARY_SCALE);
+		pSave->secondary_hwc_address = PEEK32(SECONDARY_HWC_ADDRESS);
+		pSave->secondary_hwc_location = PEEK32(SECONDARY_HWC_LOCATION);
+		pSave->secondary_hwc_color_12 = PEEK32(SECONDARY_HWC_COLOR_12);
+		pSave->secondary_hwc_color_3 = PEEK32(SECONDARY_HWC_COLOR_3);
+		pSave->secondary_auto_centering_tl = PEEK32(SECONDARY_AUTO_CENTERING_TL);
+		pSave->secondary_auto_centering_br = PEEK32(SECONDARY_AUTO_CENTERING_BR);
+
+}
+
+void hw750_resume(struct smi_750_register * pSave)
+{
+	/* restore mmio registers */
+	POKE32(SYSTEM_CTRL, pSave->system_ctrl);
+	POKE32(MISC_CTRL, pSave->misc_ctrl);
+	POKE32(GPIO_MUX, pSave->gpio_mux);
+	POKE32(LOCALMEM_ARBITRATION, pSave->localmem_arbitration);
+	POKE32(PCIMEM_ARBITRATION, pSave->pcimem_arbitration);
+	POKE32(RAW_INT, pSave->raw_int);
+	POKE32(INT_STATUS, pSave->int_status);
+	POKE32(INT_MASK, pSave->int_mask);
+	POKE32(CURRENT_GATE, pSave->current_gate);
+
+	POKE32(MODE0_GATE, pSave->mode0_gate);
+	POKE32(MODE1_GATE, pSave->mode1_gate);
+	POKE32(POWER_MODE_CTRL, pSave->power_mode_ctrl);
+	POKE32(PCI_MASTER_BASE, pSave->pci_master_base);
+	POKE32(PRIMARY_PLL_CTRL, pSave->primary_pll_ctrl);
+	POKE32(SECONDARY_PLL_CTRL, pSave->secondary_pll_ctrl);
+	POKE32(VGA_PLL0_CTRL, pSave->vga_pll0_ctrl);
+	POKE32(VGA_PLL1_CTRL, pSave->vga_pll1_ctrl);
+	POKE32(MXCLK_PLL_CTRL, pSave->mxclk_pll_ctrl);
+	POKE32(VGA_CONFIGURATION, pSave->vga_configuration);
+	
+    POKE32(PRIMARY_DISPLAY_CTRL, pSave->primary_display_ctrl);
+	POKE32(PRIMARY_PAN_CTRL, pSave->primary_pan_ctrl);
+	POKE32(PRIMARY_COLOR_KEY, pSave->primary_color_key );
+    POKE32(PRIMARY_FB_ADDRESS, pSave->primary_fb_address);
+    POKE32(PRIMARY_FB_WIDTH, pSave->primary_fb_width);
+	POKE32(PRIMARY_WINDOW_WIDTH, pSave->primary_window_width);
+	POKE32(PRIMARY_WINDOW_HEIGHT, pSave->primary_window_height);
+	POKE32(PRIMARY_PLANE_TL, pSave->primary_plane_tl);
+	POKE32(PRIMARY_PLANE_BR, pSave->primary_plane_br);
+    POKE32(PRIMARY_HORIZONTAL_TOTAL, pSave->primary_horizontal_total);
+    POKE32(PRIMARY_HORIZONTAL_SYNC, pSave->primary_horizontal_sync);
+    POKE32(PRIMARY_VERTICAL_TOTAL, pSave->primary_vertical_total);
+    POKE32(PRIMARY_VERTICAL_SYNC, pSave->primary_vertical_sync);
+    POKE32(PRIMARY_CURRENT_LINE, pSave->primary_current_line);
+
+    POKE32(SECONDARY_DISPLAY_CTRL, pSave->secondary_display_ctrl);	
+    POKE32(SECONDARY_FB_ADDRESS,  pSave->secondary_fb_address);
+    POKE32(SECONDARY_FB_WIDTH, pSave->secondary_fb_width);
+    POKE32(SECONDARY_HORIZONTAL_TOTAL, pSave->secondary_horizontal_total);
+
+    POKE32(SECONDARY_HORIZONTAL_SYNC,    pSave->secondary_horizontal_sync);
+    POKE32(SECONDARY_VERTICAL_TOTAL, pSave->secondary_vertical_total);
+    POKE32(SECONDARY_VERTICAL_SYNC, pSave->secondary_vertical_sync);
+    POKE32(SECONDARY_SCALE, pSave->secondary_scale);
+
+#if 0
+	POKE32(SECONDARY_HWC_ADDRESS, pSave->secondary_hwc_address);
+    POKE32(SECONDARY_HWC_LOCATION, pSave->secondary_hwc_location);
+    POKE32(SECONDARY_HWC_COLOR_12, pSave->secondary_hwc_color_12);
+    POKE32(SECONDARY_HWC_COLOR_3, pSave->secondary_hwc_color_3);
+#endif
+    POKE32(SECONDARY_AUTO_CENTERING_TL, pSave->secondary_auto_centering_tl);
+    POKE32(SECONDARY_AUTO_CENTERING_BR, pSave->secondary_auto_centering_br);
+
+
+#if 0	//HOLD FOR 2D
+    POKE32(DE_STRETCH_FORMAT, pSave->de_stretch_format);
+    POKE32(DE_MASKS, pSave->de_masks);
+    POKE32(DE_WINDOW_WIDTH, pSave->de_window_width);
+    POKE32(DE_CONTROL, pSave->de_control);
+#endif
+
+}
+
+void hw750_set_base(int display,int pitch,int base_addr)
+{	
+
+	if(display == 0)
+	{
+		pokeRegisterDWord(PRIMARY_FB_WIDTH,
+		          FIELD_VALUE(0, PRIMARY_FB_WIDTH, WIDTH, pitch)
+		        | FIELD_VALUE(0, PRIMARY_FB_WIDTH, OFFSET, pitch));
+		setDisplayBaseAddress(PRIMARY_CTRL, base_addr);
+	}
+	else
+	{
+		pokeRegisterDWord(SECONDARY_FB_WIDTH,
+		          FIELD_VALUE(0, SECONDARY_FB_WIDTH, WIDTH, pitch)
+		        | FIELD_VALUE(0, SECONDARY_FB_WIDTH, OFFSET, pitch));
+		setDisplayBaseAddress(SECONDARY_CTRL, base_addr);
+	}
+}
+
+void hw750_set_dpms(int display,int state)
+{
+	if(display == 0)
+	{
+		setDisplayControl(PRIMARY_CTRL, state);           /* Turn on Primary Control */
+		setPath(PANEL_PATH, PRIMARY_CTRL, state); 
+	}
+	else
+	{
+		setDisplayControl(SECONDARY_CTRL, state);         /* Turn on Secondary control */
+		setPath(CRT_PATH, SECONDARY_CTRL, state);
+	}
+}
+int hw750_en_dis_interrupt(int status, int pipe)
+{
+	if(status == 0)
+	{
+		pokeRegisterDWord(INT_MASK, 	(pipe == SECONDARY_CTRL) ? 
+		FIELD_SET(0, INT_MASK, SECONDARY_VSYNC, DISABLE):
+		FIELD_SET(0, INT_MASK, PRIMARY_VSYNC, DISABLE));
+	}
+	else
+	{
+		pokeRegisterDWord(INT_MASK, 	(pipe == SECONDARY_CTRL) ? 
+		FIELD_SET(0, INT_MASK, SECONDARY_VSYNC, ENABLE):
+		FIELD_SET(0, INT_MASK, PRIMARY_VSYNC, ENABLE));
+	}
+	return 0;
+}
+
+
+
+int hw750_check_vsync_interrupt(int path)
+{
+
+	unsigned long value1,value2;
+	
+	value1 = peekRegisterDWord(RAW_INT);
+	value2 = peekRegisterDWord(INT_MASK);
+	
+	if(path == PRIMARY_CTRL)
+	{
+	    if ((FIELD_GET(value1, RAW_INT, PRIMARY_VSYNC) == RAW_INT_PRIMARY_VSYNC_ACTIVE)
+			&&(FIELD_GET(value2, INT_MASK, PRIMARY_VSYNC) == INT_MASK_PRIMARY_VSYNC_ENABLE))
+	    {
+			return true;
+		}
+	}else{
+		if ((FIELD_GET(value1, RAW_INT, SECONDARY_VSYNC) == RAW_INT_SECONDARY_VSYNC_ACTIVE)
+			&&(FIELD_GET(value2, INT_MASK, SECONDARY_VSYNC) == INT_MASK_SECONDARY_VSYNC_ENABLE))
+		{
+			return true;
+		}
+	}
+	return false;
+}
+
+
+
+void hw750_clear_vsync_interrupt(int path)
+{
+
+	unsigned long value;
+		
+	value = peekRegisterDWord(RAW_INT);
+	
+	if(path == PRIMARY_CTRL)
+	{
+	    
+		pokeRegisterDWord(RAW_INT, FIELD_SET(value, RAW_INT, PRIMARY_VSYNC, CLEAR));
+
+	}else{
+		
+		pokeRegisterDWord(RAW_INT, FIELD_SET(value, RAW_INT, SECONDARY_VSYNC, CLEAR));	
+		
+	}
+
+}
+
+void ddk750_disable_IntMask(void)
+{
+	
+    pokeRegisterDWord(INT_MASK, 0);
+}
+
diff --git a/drivers/gpu/drm/smi/hw750.h b/drivers/gpu/drm/smi/hw750.h
new file mode 100644
index 000000000000..2ae35abea3b4
--- /dev/null
+++ b/drivers/gpu/drm/smi/hw750.h
@@ -0,0 +1,154 @@
+/*
+ * Copyright 2016 SiliconMotion Inc.
+ *
+ * This file is subject to the terms and conditions of the GNU General
+ * Public License version 2. See the file COPYING in the main
+ * directory of this archive for more details.
+ *
+ */
+
+
+#ifndef LYNX_HW750_H__
+#define LYNX_HW750_H__
+
+#include "hw_com.h"
+
+
+
+
+void ddk750_set_mmio(volatile unsigned char * addr,unsigned short devId,char revId);
+unsigned long ddk750_getFrameBufSize(void);
+long ddk750_initChip(void);
+void ddk750_deInit(void);
+long ddk750_detectCRTMonitor(unsigned char redValue, unsigned char greenValue,
+	unsigned char blueValue);
+
+long ddk750_edidHeaderReadMonitorExHwI2C(void);
+long ddk750_edidHeaderReadMonitorEx(
+    unsigned char sclGpio,
+    unsigned char sdaGpio
+);	
+
+/*
+ *  edidReadMonitor
+ *      This function reads the EDID structure from the attached monitor
+ *
+ *  Input:
+ *      displayPath - Display device which EDID to be read from.
+ *      pEDIDBuffer - Buffer that contains the EDID structure of the monitor
+ *      bufferSize  - The EDID Buffer size index (usually 128-bytes)
+ *      edidExtNo   - Extension Index of the EDID Structure to be read
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long ddk750_edidReadMonitor(
+    disp_path_t displayPath,
+    unsigned char *pEDIDBuffer,
+    unsigned long bufferSize,
+    unsigned char edidExtNo
+);
+
+/*
+ *  edidReadMonitor
+ *      This function reads the EDID structure from the attached monitor
+ *
+ *  Input:
+ *      displayPath - Display device which EDID to be read from.
+ *      pEDIDBuffer - Buffer that contains the EDID structure of the monitor
+ *      bufferSize  - The EDID Buffer size index (usually 128-bytes)
+ *      edidExtNo   - Extension Index of the EDID Structure to be read
+ *      sclGpio     - GPIO pin used as the I2C Clock (SCL)
+ *      sdaGpio     - GPIO pin used as the I2C Data (SDA)
+ *
+ *  Output:
+ *      0   - Success
+ *     -1   - Fail
+ */
+long ddk750_edidReadMonitorEx(
+    disp_path_t displayPath,
+    unsigned char *pEDIDBuffer,
+    unsigned long bufferSize,
+    unsigned char edidExtNo,
+    unsigned char sclGpio,
+    unsigned char sdaGpio
+);
+
+
+long ddk750_edidReadMonitorEx_HW(
+    disp_path_t displayPath,
+    unsigned char *pEDIDBuffer,
+    unsigned long bufferSize,
+    unsigned char edidExtNo
+);
+
+
+/*
+ * This function initializes the cursor attributes.
+ */
+void ddk750_initCursor(
+    disp_control_t dispControl,     /* Display control (PRIMARY_CTRL or SECONDARY_CTRL) */
+    unsigned long base,             /* Base Address */ 
+    unsigned long color1,           /* Cursor color 1 in RGB 5:6:5 format */
+    unsigned long color2,           /* Cursor color 2 in RGB 5:6:5 format */
+    unsigned long color3            /* Cursor color 3 in RGB 5:6:5 format */
+);
+
+/*
+ * This function sets the cursor position.
+ */
+void ddk750_setCursorPosition(
+    disp_control_t dispControl,     /* Display control (PRIMARY_CTRL or SECONDARY_CTRL) */
+    unsigned long dx,               /* X Coordinate of the cursor */
+    unsigned long dy,               /* Y Coordinate of the cursor */
+    unsigned char topOutside,       /* Top Boundary Select: either partially outside (= 1) 
+                                       or within the screen top boundary (= 0) */
+    unsigned char leftOutside       /* Left Boundary Select: either partially outside (= 1) 
+                                       or within the screen left boundary (= 0) */
+);
+
+/*
+ * This function enables/disables the cursor.
+ */
+void ddk750_enableCursor(
+    disp_control_t dispControl,     /* Display control (PRIMARY_CTRL or SECONDARY_CTRL) */
+    unsigned long enable
+);
+
+
+
+void hw750_set_base(int display,int pitch,int base_addr);
+
+long setMode(
+	logicalMode_t *pLogicalMode
+);
+void setDisplayControl(disp_control_t dispControl, disp_state_t dispState);
+void setPath(
+    disp_path_t dispPath, 
+    disp_control_t dispControl, 
+    disp_state_t dispState
+);
+
+void swPanelPowerSequence(disp_state_t dispState, unsigned long vsync_delay);
+void setDAC(disp_state_t state);
+void setDPMS(DPMS_t state);
+
+
+
+void hw750_set_dpms(int display,int state);
+void hw750_suspend(struct smi_750_register * pSave);
+void hw750_resume(struct smi_750_register * pSave);
+int hw750_check_vsync_interrupt(int path);
+void hw750_clear_vsync_interrupt(int path);
+
+int hw750_en_dis_interrupt(int status, int pipe);
+
+void ddk750_disable_IntMask(void);
+
+int sii9022xInitChip(void);
+int sii9022xSetMode(int);
+unsigned char sii9022xIsConnected(void);
+
+
+#endif
diff --git a/drivers/gpu/drm/smi/hw768.c b/drivers/gpu/drm/smi/hw768.c
new file mode 100644
index 000000000000..04c25db2b6fc
--- /dev/null
+++ b/drivers/gpu/drm/smi/hw768.c
@@ -0,0 +1,255 @@
+/*
+ * Copyright 2016 SiliconMotion Inc.
+ *
+ * This file is subject to the terms and conditions of the GNU General
+ * Public License version 2. See the file COPYING in the main
+ * directory of this archive for more details.
+ *
+ */
+
+
+#include "ddk768/ddk768_mode.h"
+#include "ddk768/ddk768_help.h"
+#include "ddk768/ddk768_reg.h"	
+#include "ddk768/ddk768_display.h"
+#include "ddk768/ddk768_2d.h"
+#include "ddk768/ddk768_power.h"
+#include "ddk768/ddk768_cursor.h"
+#include "ddk768/ddk768_video.h"
+#include "ddk768/ddk768_hdmi.h"
+
+struct smi_768_register{
+	/* registers for save, copyed from struct smi_750_register in hw750.c */
+	uint32_t system_ctrl, misc_ctrl,gpio_mux, localmem_arbitration;
+	uint32_t pcimem_arbitration, raw_int, int_status, int_mask;
+	uint32_t current_gate, mode0_gate, mode1_gate, power_mode_ctrl;
+	uint32_t pci_master_base, primary_pll_ctrl,	secondary_pll_ctrl,	vga_pll0_ctrl;
+	uint32_t vga_pll1_ctrl,	mxclk_pll_ctrl,	vga_configuration;
+	
+	uint32_t de_stretch_format, de_masks, de_window_width, de_control;
+
+	uint32_t primary_display_ctrl,primary_pan_ctrl,primary_color_key,primary_fb_address;
+	uint32_t primary_fb_width, primary_window_width,primary_window_height, primary_plane_tl;
+	uint32_t primary_plane_br, primary_horizontal_total, primary_horizontal_sync, primary_vertical_total;
+	uint32_t primary_vertical_sync, primary_current_line;
+	
+	uint32_t secondary_display_ctrl, secondary_fb_address, secondary_fb_width;
+	uint32_t secondary_horizontal_total, secondary_horizontal_sync;
+	uint32_t secondary_vertical_total, secondary_vertical_sync;
+	uint32_t secondary_auto_centering_tl, secondary_auto_centering_br;
+	uint32_t secondary_scale, secondary_hwc_address, secondary_hwc_location;
+	uint32_t secondary_hwc_color_12, secondary_hwc_color_3;
+};
+
+void hw768_enable_lvds(int channels)
+{
+	if(channels == 1){
+		pokeRegisterDWord(0x80020,0x31E30000);
+		pokeRegisterDWord(0x8002C,0x74001200);
+	}else{
+		pokeRegisterDWord(0x80020,0x31E3F71D);
+		pokeRegisterDWord(0x8002C,0x750FED02);
+		unsigned long value = peekRegisterDWord(DISPLAY_CTRL);
+		value = FIELD_SET(value, DISPLAY_CTRL, LVDS_OUTPUT_FORMAT, CHANNEL0_48BIT);
+		value = FIELD_SET(value, DISPLAY_CTRL, PIXEL_CLOCK_SELECT, HALF);
+		value = FIELD_SET(value, DISPLAY_CTRL, DOUBLE_PIXEL_CLOCK, ENABLE);
+		pokeRegisterDWord(DISPLAY_CTRL,value);
+
+		value = peekRegisterDWord(DISPLAY_CTRL + CHANNEL_OFFSET);
+		value = FIELD_SET(value, DISPLAY_CTRL, LVDS_OUTPUT_FORMAT, CHANNEL0_48BIT);
+		pokeRegisterDWord(DISPLAY_CTRL + CHANNEL_OFFSET,value);
+	}
+}
+
+void hw768_suspend(struct smi_768_register * pSave)
+{
+	printk("sm768 suspend\n");; 
+}
+
+void hw768_resume(struct smi_768_register * pSave)
+{
+	printk("sm768 resume\n");
+}
+void hw768_set_base(int display,int pitch,int base_addr)
+{	
+
+	if(display == 0)
+	{
+		/* Frame buffer base */
+	    pokeRegisterDWord((FB_ADDRESS),
+	          FIELD_SET(0, FB_ADDRESS, STATUS, PENDING)
+	        | FIELD_VALUE(0, FB_ADDRESS, ADDRESS, base_addr));
+
+	    /* Pitch value (Hardware people calls it Offset) */
+    	pokeRegisterDWord((FB_WIDTH), FIELD_VALUE(peekRegisterDWord(FB_WIDTH), FB_WIDTH, OFFSET, pitch));
+	}
+	else
+	{
+		/* Frame buffer base */
+	    pokeRegisterDWord((FB_ADDRESS+CHANNEL_OFFSET),
+	          FIELD_SET(0, FB_ADDRESS, STATUS, PENDING)
+	        | FIELD_VALUE(0, FB_ADDRESS, ADDRESS, base_addr));
+
+		
+	    /* Pitch value (Hardware people calls it Offset) */	
+	    pokeRegisterDWord((FB_WIDTH+CHANNEL_OFFSET),FIELD_VALUE(peekRegisterDWord(FB_WIDTH+CHANNEL_OFFSET), FB_WIDTH, OFFSET, pitch));
+
+	}
+}
+
+
+void hw768_init_hdmi(void)
+{
+	HDMI_Init();
+}
+
+int hw768_set_hdmi_mode(logicalMode_t *pLogicalMode, bool isHDMI)
+{
+	int ret = 1;
+	if(pLogicalMode->x == 3840)
+	{
+		printk("Use 4K Mode!\n");
+		pLogicalMode->hz = 30;
+	}
+	else
+		pLogicalMode->hz = 60;
+	// set HDMI parameters
+	HDMI_Disable_Output();
+	ret = HDMI_Set_Mode(pLogicalMode, isHDMI);
+	return ret;
+}
+
+int hw768_en_dis_interrupt(int status, int pipe)
+{
+	if(status == 0)
+	{
+		pokeRegisterDWord(INT_MASK, 	(pipe == CHANNEL0_CTRL) ? 
+		FIELD_SET(0, INT_MASK, CHANNEL1_VSYNC, DISABLE):
+		FIELD_SET(0, INT_MASK, CHANNEL0_VSYNC, DISABLE));
+	}
+	else
+	{
+		pokeRegisterDWord(INT_MASK, 	(pipe == CHANNEL1_CTRL) ? 
+		FIELD_SET(0, INT_MASK, CHANNEL1_VSYNC, ENABLE):
+		FIELD_SET(0, INT_MASK, CHANNEL0_VSYNC, ENABLE));
+	}
+	return 0;
+}
+void hw768_HDMI_Enable_Output(void)
+{
+	HDMI_Enable_Output();
+}
+
+void hw768_HDMI_Disable_Output(void)
+{
+	HDMI_Disable_Output();
+}
+
+
+int hw768_get_hdmi_edid(unsigned char *pEDIDBuffer)
+{
+    int ret;
+    enableHdmI2C(1);
+    ret = HDMI_Read_Edid(pEDIDBuffer, 128);
+    enableHdmI2C(0);
+
+    return ret;
+}
+
+int hw768_check_iis_interrupt(void)
+{
+
+	unsigned long value;
+		
+	value = peekRegisterDWord(INT_STATUS);
+
+	
+    if (FIELD_GET(value, INT_STATUS, I2S) == INT_STATUS_I2S_ACTIVE)
+		return true;
+	else	
+		return false;
+}
+
+
+int hw768_check_vsync_interrupt(int path)
+{
+
+	unsigned long value1,value2;
+		
+	value1 = peekRegisterDWord(RAW_INT);
+	value2 = peekRegisterDWord(INT_MASK);
+
+	if(path == CHANNEL0_CTRL)
+	{
+	    if ((FIELD_GET(value1, RAW_INT, CHANNEL0_VSYNC) == RAW_INT_CHANNEL0_VSYNC_ACTIVE)
+			&&(FIELD_GET(value2, INT_MASK, CHANNEL0_VSYNC) == INT_MASK_CHANNEL0_VSYNC_ENABLE))
+	    {
+			return true;
+		}
+	}else{
+		if ((FIELD_GET(value1, RAW_INT, CHANNEL1_VSYNC) == RAW_INT_CHANNEL1_VSYNC_ACTIVE)
+			&&(FIELD_GET(value2, INT_MASK, CHANNEL1_VSYNC) == INT_MASK_CHANNEL1_VSYNC_ENABLE))
+		{
+			return true;
+		}
+	}
+	
+	return false;
+}
+
+
+void hw768_clear_vsync_interrupt(int path)
+{
+	
+	unsigned long value;
+	
+	value = peekRegisterDWord(RAW_INT);
+
+	if(path == CHANNEL0_CTRL)
+	{   
+		pokeRegisterDWord(RAW_INT, FIELD_SET(value, RAW_INT, CHANNEL0_VSYNC, CLEAR));
+			
+	}else{	
+		pokeRegisterDWord(RAW_INT, FIELD_SET(value, RAW_INT, CHANNEL1_VSYNC, CLEAR));	
+	}
+	
+}
+
+
+
+int hdmi_int_status = 0;
+
+inline int hdmi_hotplug_detect(void)
+{
+		unsigned int intMask = peekRegisterDWord(INT_MASK);
+    	intMask = FIELD_SET(intMask, INT_MASK, HDMI, ENABLE);
+    	pokeRegisterDWord(INT_MASK, intMask);
+
+
+		int ret = hdmi_detect();
+
+		if (ret == 1) {
+			hdmi_int_status = 1;
+		}
+		else if(ret == 0){
+			hdmi_int_status = 0;
+		}
+		else{	
+			hdmi_int_status = hdmi_int_status & ret;		
+		}	
+
+		intMask = peekRegisterDWord(INT_MASK);
+    	intMask = FIELD_SET(intMask, INT_MASK, HDMI, DISABLE);
+    	pokeRegisterDWord(INT_MASK, intMask);
+
+		return hdmi_int_status;
+
+}
+
+void ddk768_disable_IntMask(void)
+{
+	
+    pokeRegisterDWord(INT_MASK, 0);
+}
+
+
diff --git a/drivers/gpu/drm/smi/hw768.h b/drivers/gpu/drm/smi/hw768.h
new file mode 100644
index 000000000000..2c06d65c9420
--- /dev/null
+++ b/drivers/gpu/drm/smi/hw768.h
@@ -0,0 +1,149 @@
+/*
+ * Copyright 2016 SiliconMotion Inc.
+ *
+ * This file is subject to the terms and conditions of the GNU General
+ * Public License version 2. See the file COPYING in the main
+ * directory of this archive for more details.
+ *
+ */
+
+
+#ifndef LYNX_HW768_H__
+#define LYNX_HW768_H__
+#include "hw_com.h"
+
+void hw768_enable_lvds(int channels);
+
+void ddk768_set_mmio(volatile unsigned char * addr,unsigned short devId,char revId);
+unsigned long ddk768_getFrameBufSize(void);
+long ddk768_initChip(void);
+void ddk768_deInit(void);
+
+void ddk768_swPanelPowerSequence(disp_control_t dispControl, disp_state_t dispState, unsigned long vSyncDelay);
+
+
+long ddk768_edidHeaderReadMonitorEx(
+    unsigned char sclGpio,
+    unsigned char sdaGpio
+);
+
+long ddk768_edidHeaderReadMonitorExHwI2C(
+    unsigned char i2cNumber
+);
+
+
+long ddk768_detectCRTMonitor(disp_control_t dispControl, unsigned char redValue, 
+	unsigned char greenValue, unsigned char blueValue);
+
+long ddk768_edidReadMonitor(
+    unsigned char *pEDIDBuffer,
+    unsigned long bufferSize,
+    unsigned char edidExtNo,
+    unsigned char i2cNumber
+);
+
+
+
+long ddk768_edidReadMonitorEx(
+    unsigned char *pEDIDBuffer,
+    unsigned long bufferSize,
+    unsigned char edidExtNo,
+    unsigned char sclGpio,
+    unsigned char sdaGpio
+);
+
+
+int hw768_get_hdmi_edid(unsigned char *pEDIDBuffer);
+
+
+long ddk768_edidReadMonitorExHwI2C(
+    unsigned char *pEDIDBuffer,
+    unsigned long bufferSize,
+    unsigned char edidExtNo,
+    unsigned char i2cNumber
+);
+
+/*
+ * Disable double pixel clock. 
+ * This is a teporary function, used to patch for the random fuzzy font problem. 
+ */
+void EnableDoublePixel(disp_control_t dispControl);
+void DisableDoublePixel(disp_control_t dispControl);
+
+/*
+ * This function initializes the cursor attributes.
+ */
+void ddk768_initCursor(
+    disp_control_t dispControl,     /* Display control (CHANNEL0_CTRL or CHANNEL1_CTRL) */
+    unsigned long base,             /* Base Address */ 
+    unsigned long color1,           /* Cursor color 1 in RGB 5:6:5 format */
+    unsigned long color2,           /* Cursor color 2 in RGB 5:6:5 format */
+    unsigned long color3            /* Cursor color 3 in RGB 5:6:5 format */
+);
+
+/*
+ * This function sets the cursor position.
+ */
+void ddk768_setCursorPosition(
+    disp_control_t dispControl,     /* Display control (CHANNEL0_CTRL or CHANNEL1_CTRL) */
+    unsigned long dx,               /* X Coordinate of the cursor */
+    unsigned long dy,               /* Y Coordinate of the cursor */
+    unsigned char topOutside,       /* Top Boundary Select: either partially outside (= 1) 
+                                       or within the screen top boundary (= 0) */
+    unsigned char leftOutside       /* Left Boundary Select: either partially outside (= 1) 
+                                       or within the screen left boundary (= 0) */
+);
+ 
+void hw768_set_base(int display,int pitch,int base_addr);
+ 
+/*
+ * This function enables/disables the cursor.
+ */
+void ddk768_enableCursor(
+    disp_control_t dispControl,     /* Display control (CHANNEL0_CTRL or CHANNEL1_CTRL) */
+    unsigned long enable
+);
+
+void hw768_HDMI_Enable_Output(void);
+
+void hw768_HDMI_Disable_Output(void);
+
+ 
+long ddk768_setMode(
+    logicalMode_t *pLogicalMode
+);
+long setSingleViewOn(disp_control_t dispOutput);
+
+void setDisplayDPMS(
+   disp_control_t dispControl, /* Channel 0 or Channel 1) */
+   DISP_DPMS_t state /* DPMS state */
+   );
+
+void hw768_init_hdmi(void);
+int hw768_set_hdmi_mode(logicalMode_t *pLogicalMode, bool isHDMI);
+
+void ddk768_setDisplayEnable(disp_control_t dispControl, /* Channel 0 or Channel 1) */
+disp_state_t dispState /* ON or OFF */);
+
+int hw768_check_iis_interrupt(void);
+
+int hw768_check_vsync_interrupt(int path);
+void hw768_clear_vsync_interrupt(int path);
+
+
+int hw768_en_dis_interrupt(int status, int pipe);
+
+int hdmi_detect(void);
+
+inline int hdmi_hotplug_detect(void);
+
+void HDMI_Audio_Mute (void);
+
+void HDMI_Audio_Unmute (void);
+
+void ddk768_disable_IntMask(void);
+
+void hw768_suspend(struct smi_768_register * pSave);
+void hw768_resume(struct smi_768_register * pSave);
+
+#endif
diff --git a/drivers/gpu/drm/smi/hw_com.h b/drivers/gpu/drm/smi/hw_com.h
new file mode 100644
index 000000000000..72abf3f3f885
--- /dev/null
+++ b/drivers/gpu/drm/smi/hw_com.h
@@ -0,0 +1,86 @@
+/*
+ * Copyright 2016 SiliconMotion Inc.
+ *
+ * This file is subject to the terms and conditions of the GNU General
+ * Public License version 2. See the file COPYING in the main
+ * directory of this archive for more details.
+ *
+ */
+
+
+
+#ifndef LYNX_HW_COM_H__
+#define LYNX_HW_COM_H__
+
+typedef enum _disp_path_t
+{
+    SMI0_PATH = 0,
+    SMI1_PATH  = 1,
+}
+disp_path_t;
+
+typedef enum _disp_control_t
+{
+    SMI0_CTRL = 0,
+    SMI1_CTRL = 1,
+    SMI2_CTRL = 2,
+    ERROR_CTRL = 3,
+}
+disp_control_t;
+
+typedef enum _disp_state_t
+{
+    DISP_OFF = 0,
+    DISP_ON  = 1,
+}
+disp_state_t;
+typedef enum _DPMS_t
+{
+    DPMS_ON,
+    DPMS_STANDBY,
+    DPMS_SUSPEND,
+    DPMS_OFF
+}
+DPMS_t;
+
+typedef enum _DISP_DPMS_t
+{
+    DISP_DPMS_ON,
+    DISP_DPMS_STANDBY,
+    DISP_DPMS_SUSPEND,
+    DISP_DPMS_OFF
+}
+DISP_DPMS_t;
+
+
+
+typedef struct _logicalMode_t
+{
+    unsigned long x;            /* X resolution */
+    unsigned long y;            /* Y resolution */
+    unsigned long bpp;          /* Bits per pixel */
+    unsigned long hz;           /* Refresh rate */
+
+    unsigned long baseAddress;  /* Offset from beginning of frame buffer.
+                                   It is used to control the starting location of a mode.
+                                   Calling function must initialize this field.
+                                 */
+
+    unsigned long pitch;        /* Mode pitch in byte.
+                                   If initialized to 0, setMode function will set
+                                   up this field.
+                                   If not zero, setMode function will use this value.
+                                 */
+
+    disp_control_t dispCtrl;    /* SECONDARY or PRIMARY display control channel */
+    
+    /* These two parameters are used in the setModeEx. */
+    unsigned long xLCD;         /* Panel width */
+    unsigned long yLCD;         /* Panel height */
+    
+    void *userData;             /* Not used now, set it to 0 (for future used only) */
+}
+logicalMode_t;
+
+#endif
+
diff --git a/drivers/gpu/drm/smi/smi_drv.c b/drivers/gpu/drm/smi/smi_drv.c
new file mode 100644
index 000000000000..d3a25f42a3d5
--- /dev/null
+++ b/drivers/gpu/drm/smi/smi_drv.c
@@ -0,0 +1,510 @@
+/*
+ * Copyright 2016 SiliconMotion Inc.
+ *
+ * This file is subject to the terms and conditions of the GNU General
+ * Public License version 2. See the file COPYING in the main
+ * directory of this archive for more details.
+ *
+ */
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/console.h>
+#include <drm/drmP.h>
+#include <drm/drm_crtc_helper.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,1,0)
+#include <drm/drm_probe_helper.h>
+#endif
+
+#include "smi_drv.h"
+#include "hw750.h"
+#include "hw768.h"
+
+int smi_modeset = -1;
+int smi_indent = 0;
+int smi_bpp = 32;
+int force_connect = 0;
+int g_specId;
+int smi_pat = 0xff;
+int lvds_channel = 0;
+
+extern void hw750_suspend(struct smi_750_register * pSave);
+extern void hw750_resume(struct smi_750_register * pSave);
+
+module_param(smi_pat, int, S_IWUSR | S_IRUSR);
+
+MODULE_PARM_DESC(modeset, "Enable/Disable modesetting");
+module_param_named(modeset, smi_modeset, int, 0400);
+MODULE_PARM_DESC(bpp, "Max bits-per-pixel (default:32)");
+module_param_named(bpp, smi_bpp, int, 0400);
+MODULE_PARM_DESC(nopnp, "Force conncet to the monitor without monitor EDID (default:0)");
+module_param_named(nopnp, force_connect, int, 0400);
+MODULE_PARM_DESC(lvds, "LVDS Channel, 0=disable 1=single_channel, 2=dual_channel (default:0)");
+module_param_named(lvds, lvds_channel, int, 0400);
+
+/*
+ * This is the generic driver code. This binds the driver to the drm core,
+ * which then performs further device association and calls our graphics init
+ * functions
+ */
+#define PCI_VENDOR_ID_SMI 	0x126f
+#define PCI_DEVID_SM750	0x0750
+#define PCI_DEVID_SM768	0x0768
+
+static struct drm_driver driver;
+
+/* only bind to the smi chip in qemu */
+static const struct pci_device_id pciidlist[] = {
+	{PCI_VENDOR_ID_SMI,PCI_DEVID_SM750,PCI_ANY_ID,PCI_ANY_ID,0,0,0},
+	{PCI_VENDOR_ID_SMI,PCI_DEVID_SM768,PCI_ANY_ID,PCI_ANY_ID,0,0,0},
+	{0,}
+};
+
+
+static int smi_kick_out_firmware_fb(struct pci_dev *pdev)
+{
+	struct apertures_struct *ap;
+	bool primary = false;
+
+	ap = alloc_apertures(1);
+	if (!ap)
+		return -ENOMEM;
+
+	ap->ranges[0].base = pci_resource_start(pdev, 0);
+	ap->ranges[0].size = pci_resource_len(pdev, 0);
+
+#ifdef CONFIG_X86
+	primary = pdev->resource[PCI_ROM_RESOURCE].flags & IORESOURCE_ROM_SHADOW;
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,9,0)
+	drm_fb_helper_remove_conflicting_framebuffers(ap, "smidrmfb", primary);
+#else
+	remove_conflicting_framebuffers(ap, "smidrmfb", primary);
+#endif
+
+
+	kfree(ap);
+
+	return 0;
+}
+
+static void claim(void)
+{
+	printk("+-------------SMI Driver Information------------+\n");
+	printk("Release type: " RELEASE_TYPE "\n");
+	printk("Driver version: v" _version_ "\n");
+	printk("Support products: " SUPPORT_CHIP "\n");
+	printk("Support OS: " SUPPORT_XVERSION "\n");
+	printk("Support ARCH: " SUPPORT_ARCH "\n");
+	printk("+-----------------------------------------------+\n");
+}
+
+
+static int smi_pci_probe(struct pci_dev *pdev,
+			    const struct pci_device_id *ent)
+{
+	int ret;
+
+	ret = smi_kick_out_firmware_fb(pdev);
+	if (ret)
+		return ret;
+
+	claim();
+
+	switch (ent->device){
+		case PCI_DEVID_LYNX_EXP:
+			g_specId = SPC_SM750;
+			break;
+		case PCI_DEVID_SM768:
+			g_specId = SPC_SM768;
+			break;
+		default:
+			break;
+	}
+	dbg_msg("ent->device:0x%x\n", ent->device);
+	dbg_msg("g_specId:0x%x\n", g_specId);
+	
+	return drm_get_pci_dev(pdev, ent, &driver);
+}
+
+static void smi_pci_remove(struct pci_dev *pdev)
+{
+	struct drm_device *dev = pci_get_drvdata(pdev);
+
+	drm_put_dev(dev);
+}
+
+
+
+static int smi_drm_freeze(struct drm_device *dev)
+{
+	ENTER();
+
+	struct smi_device *sdev = dev->dev_private;
+	
+	drm_kms_helper_poll_disable(dev);
+
+	pci_save_state(dev->pdev);
+
+	if (sdev->mode_info.gfbdev) {
+		console_lock();
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,3,0)			
+		fb_set_suspend(sdev->mode_info.gfbdev->helper.fbdev, 1);
+#else
+		drm_fb_helper_set_suspend(&sdev->mode_info.gfbdev->helper, 1);
+#endif
+		console_unlock();
+	}
+
+	if(g_specId == SPC_SM750)
+         hw750_suspend(sdev->regsave);
+    else if(g_specId == SPC_SM768)
+         hw768_suspend(sdev->regsave_768);
+
+	LEAVE(0);
+
+}
+
+static int smi_drm_thaw(struct drm_device *dev)
+{	
+	ENTER();
+	struct smi_device *sdev = dev->dev_private;
+	
+
+	drm_mode_config_reset(dev);
+	drm_helper_resume_force_mode(dev);
+
+	if (sdev->mode_info.gfbdev) {
+		console_lock();
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,3,0)		
+		fb_set_suspend(sdev->mode_info.gfbdev->helper.fbdev, 0);
+#else
+		drm_fb_helper_set_suspend(&sdev->mode_info.gfbdev->helper, 0);
+#endif
+		smi_fb_zfill(dev, sdev->mode_info.gfbdev);
+
+		console_unlock();
+	}
+
+	
+	if(g_specId == SPC_SM750)
+			hw750_resume(sdev->regsave);
+	else if(g_specId == SPC_SM768)
+			hw768_resume(sdev->regsave_768);
+
+	LEAVE(0);
+}
+
+
+static int smi_drm_resume(struct drm_device *dev)
+{	
+	ENTER();
+	
+	struct smi_device *sdev = dev->dev_private;
+	int ret;
+
+	if (pci_enable_device(dev->pdev))
+		return -EIO;
+
+	ret = smi_drm_thaw(dev);
+	if (ret)
+		return ret;
+
+	drm_kms_helper_poll_enable(dev);
+
+	LEAVE(0);
+}
+
+
+static int smi_pm_suspend(struct device *dev)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+	struct drm_device *ddev = pci_get_drvdata(pdev);
+	int error;
+
+	error = smi_drm_freeze(ddev);
+	if (error)
+		return error;
+
+	pci_disable_device(pdev);
+	pci_set_power_state(pdev, PCI_D3hot);
+	return 0;
+
+}
+
+
+static int smi_pm_resume(struct device *dev)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+	struct drm_device *ddev = pci_get_drvdata(pdev);
+	return smi_drm_resume(ddev);
+}
+
+
+
+
+static int smi_pm_freeze(struct device *dev)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+	struct drm_device *ddev = pci_get_drvdata(pdev);
+
+	if (!ddev || !ddev->dev_private)
+		return -ENODEV;
+	return smi_drm_freeze(ddev);
+
+}
+
+
+static int smi_pm_thaw(struct device *dev)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+	struct drm_device *ddev = pci_get_drvdata(pdev);
+	return smi_drm_thaw(ddev);
+
+}
+
+
+static int smi_pm_poweroff(struct device *dev)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+	struct drm_device *ddev = pci_get_drvdata(pdev);
+
+	return smi_drm_freeze(ddev);
+
+
+}
+
+static int smi_enable_vblank(struct drm_device *dev, unsigned int pipe)
+{
+	if(g_specId == SPC_SM750)
+	{
+		hw750_en_dis_interrupt(1, pipe);
+	}else if(g_specId == SPC_SM768)
+	{
+		hw768_en_dis_interrupt(1, pipe);
+	}
+	return 0;
+}
+
+
+static void smi_disable_vblank(struct drm_device *dev, unsigned int pipe)
+{
+	if(g_specId == SPC_SM750)
+	{
+		hw750_en_dis_interrupt(0, pipe);
+	}else if(g_specId == SPC_SM768)
+	{
+		hw768_en_dis_interrupt(0, pipe);
+	}
+}
+
+
+static void smi_irq_preinstall(struct drm_device *dev)
+{
+	//To Do....
+	/* Disable *all* interrupts */
+
+	/* Clear bits if they're already high */
+
+}
+
+static int smi_irq_postinstall(struct drm_device *dev)
+{
+	return 0;
+}
+
+static void smi_irq_uninstall(struct drm_device *dev)
+{
+
+	/* Disable *all* interrupts */
+	if(g_specId == SPC_SM750)
+	{
+		ddk750_disable_IntMask();
+	}else if(g_specId == SPC_SM768)
+	{
+		ddk768_disable_IntMask();
+	}
+
+}
+
+
+irqreturn_t smi_drm_interrupt(int irq, void *arg)
+{
+	struct drm_device *dev = (struct drm_device *) arg;
+	
+	int handled = 0;
+	
+	if(g_specId == SPC_SM750)
+	{
+	    if (hw750_check_vsync_interrupt(0))
+	    {
+	        /* Clear the panel VSync Interrupt */	
+			drm_handle_vblank(dev, 0);		
+			handled = 1;
+			hw750_clear_vsync_interrupt(0);
+	    }   
+		if (hw750_check_vsync_interrupt(1)) {			
+			drm_handle_vblank(dev, 1);
+			handled = 1;
+			hw750_clear_vsync_interrupt(1);
+		}
+	}else if(g_specId == SPC_SM768)
+	{
+		if (hw768_check_vsync_interrupt(0))
+		{
+			/* Clear the panel VSync Interrupt */
+			drm_handle_vblank(dev, 0);
+			handled = 1;
+			hw768_clear_vsync_interrupt(0);
+		}	
+		if (hw768_check_vsync_interrupt(1)) {		
+			drm_handle_vblank(dev, 1);
+			handled = 1;
+			hw768_clear_vsync_interrupt(1);
+		}
+	}
+	
+	if (handled)
+		return IRQ_HANDLED;
+	return IRQ_NONE;
+}
+
+
+
+static const struct file_operations smi_driver_fops = {
+	.owner = THIS_MODULE,
+	.open = drm_open,
+	.release = drm_release,
+	.unlocked_ioctl = drm_ioctl,
+	.mmap = smi_mmap,
+	.poll = drm_poll,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl = drm_compat_ioctl,
+#endif
+	.read = drm_read,
+	.llseek = no_llseek,
+};
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,1,0)
+#define DRIVER_IRQ_SHARED 0
+#endif
+
+static struct drm_driver driver = {
+#ifdef PRIME
+	.driver_features = DRIVER_HAVE_IRQ | DRIVER_IRQ_SHARED |DRIVER_GEM |DRIVER_PRIME | DRIVER_MODESET,
+#else
+	.driver_features = DRIVER_HAVE_IRQ | DRIVER_IRQ_SHARED |DRIVER_GEM | DRIVER_MODESET,
+#endif
+	.load = smi_driver_load,
+	.unload = smi_driver_unload,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,17,0)) && (LINUX_VERSION_CODE < KERNEL_VERSION(4,14,0))
+	.set_busid = drm_pci_set_busid,
+#endif	
+	.fops = &smi_driver_fops,
+	.name = DRIVER_NAME,
+	.desc = DRIVER_DESC,
+	.date = DRIVER_DATE,
+	.major = DRIVER_MAJOR,
+	.minor = DRIVER_MINOR,
+	.patchlevel = DRIVER_PATCHLEVEL,
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(3,12,0)	
+	.gem_init_object = smi_gem_init_object,
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,7,0)
+	.gem_free_object = smi_gem_free_object,
+#else
+	.gem_free_object_unlocked = smi_gem_free_object,
+#endif
+	.dumb_create = smi_dumb_create,
+	.dumb_map_offset = smi_dumb_mmap_offset,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,12,0)
+	.dumb_destroy = smi_dumb_destroy,
+#else
+	.dumb_destroy = drm_gem_dumb_destroy,
+#endif
+	
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,4,0)) && (LINUX_VERSION_CODE < KERNEL_VERSION(4,12,0))
+	.get_vblank_counter	= drm_vblank_no_hw_counter,
+#endif
+	.enable_vblank		= smi_enable_vblank,
+	.disable_vblank		= smi_disable_vblank,
+	.irq_preinstall = smi_irq_preinstall,
+	.irq_postinstall = smi_irq_postinstall,
+	.irq_uninstall = smi_irq_uninstall,
+	.irq_handler		= smi_drm_interrupt,
+#ifdef PRIME
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3,14,0)
+	.prime_handle_to_fd	= drm_gem_prime_handle_to_fd,
+	.prime_fd_to_handle	= drm_gem_prime_fd_to_handle,
+
+	.gem_prime_import	= drm_gem_prime_import,
+	.gem_prime_export	= drm_gem_prime_export,
+
+	.gem_prime_get_sg_table	= smi_gem_prime_get_sg_table,
+	.gem_prime_import_sg_table = smi_gem_prime_import_sg_table,
+	.gem_prime_vmap		= smi_gem_prime_vmap,
+	.gem_prime_vunmap	= smi_gem_prime_vunmap,
+	.gem_prime_pin		= smi_gem_prime_pin,
+	.gem_prime_unpin 	= smi_gem_prime_unpin,	
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,17,0) && LINUX_VERSION_CODE < KERNEL_VERSION(5,4,0)
+	.gem_prime_res_obj = smi_gem_prime_res_obj,
+#endif
+#endif
+
+};
+
+static const struct dev_pm_ops smi_pm_ops = {
+	.suspend = smi_pm_suspend,
+	.resume = smi_pm_resume,
+	.freeze = smi_pm_freeze,
+	.thaw = smi_pm_thaw,
+	.poweroff = smi_pm_poweroff,
+	.restore = smi_pm_resume,
+};
+
+static struct pci_driver smi_pci_driver = {
+	.name = DRIVER_NAME,
+	.id_table = pciidlist,
+	.probe = smi_pci_probe,
+	.remove = smi_pci_remove,
+	.driver.pm = &smi_pm_ops,
+};
+
+static int __init smi_init(void)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,7,0)
+#ifdef CONFIG_VGA_CONSOLE
+	if (vgacon_text_force() && smi_modeset == -1)
+		return -EINVAL;
+#endif
+#else
+	if (vgacon_text_force() && smi_modeset == -1)
+		return -EINVAL;
+
+#endif
+	if (smi_modeset == 0)
+		return -EINVAL;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,13,0)
+	return drm_pci_init(&driver, &smi_pci_driver);
+#else
+	return pci_register_driver(&smi_pci_driver);
+#endif
+}
+
+static void __exit smi_exit(void)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,13,0)
+	drm_pci_exit(&driver, &smi_pci_driver);
+#else
+	pci_unregister_driver(&smi_pci_driver);
+#endif
+}
+
+module_init(smi_init);
+module_exit(smi_exit);
+
+MODULE_DEVICE_TABLE(pci, pciidlist);
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/smi/smi_drv.h b/drivers/gpu/drm/smi/smi_drv.h
new file mode 100644
index 000000000000..de03573dbea9
--- /dev/null
+++ b/drivers/gpu/drm/smi/smi_drv.h
@@ -0,0 +1,419 @@
+/*
+ * Copyright 2016 SiliconMotion Inc.
+ *
+ * This file is subject to the terms and conditions of the GNU General
+ * Public License version 2. See the file COPYING in the main
+ * directory of this archive for more details.
+ *
+ */
+
+#ifndef __SMI_DRV_H__
+#define __SMI_DRV_H__
+
+#include <video/vga.h>
+#include <linux/version.h>
+#include <drm/drm_fb_helper.h>
+#include <drm/drm_edid.h>
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,9,0)
+#include <drm/drm_encoder.h>
+#endif
+
+#include <drm/ttm/ttm_bo_api.h>
+#include <drm/ttm/ttm_bo_driver.h>
+#include <drm/ttm/ttm_placement.h>
+#include <drm/ttm/ttm_memory.h>
+#include <drm/ttm/ttm_module.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,17,0)
+#include <drm/drm_gem.h>
+#endif
+
+#define DRIVER_AUTHOR		"SiliconMotion"
+
+#define DRIVER_NAME		"smifb"
+#define DRIVER_DESC		"SiliconMotion GPU DRM Driver"
+#define DRIVER_DATE		"20180723"
+
+#define DRIVER_MAJOR		1
+#define DRIVER_MINOR		2
+#define DRIVER_PATCHLEVEL	5
+
+#define SMIFB_CONN_LIMIT 3
+
+#define RELEASE_TYPE "Linux DRM Display Driver Release"
+#define SUPPORT_ARCH "x64, x86, mips"
+#define SUPPORT_CHIP "SM750, SM768"
+#define SUPPORT_XVERSION "All Linux distribution"
+
+#define _version_	"1.2.5.0"
+
+#ifdef CONFIG_CPU_LOONGSON3
+#define NO_WC
+#endif
+
+#define HW_I2C 1
+
+extern int g_specId;
+
+extern int smi_pat;
+
+#define DEBUG 0
+#define PFX "[smi] "
+extern int smi_indent;
+
+#if (DEBUG == 0)
+#define ENTER()
+#define LEAVE(...) return __VA_ARGS__;
+#define dbg_msg(fmt,args...)
+#define err_msg(fmt,args...) 
+#define war_msg(fmt,args...) 
+#define inf_msg(fmt,args...) 
+
+#elif(DEBUG == 1)
+/* debug level == 1 */
+#warning "debug=1 build"
+#define ENTER()	printk(KERN_DEBUG PFX "%*c %s\n",smi_indent++,'>',__func__)
+#define LEAVE(...) printk(KERN_DEBUG PFX "%*c %s\n",--smi_indent,'<',__func__);return __VA_ARGS__;
+#define dbg_msg(fmt,args...)	printk(KERN_DEBUG "[%s]:" fmt,__func__,## args)
+#define err_msg(fmt,args...) printk(KERN_ERR  fmt, ## args)
+#define war_msg(fmt,args...) printk(KERN_WARNING fmt, ## args)
+#define inf_msg(fmt,args...) printk(KERN_INFO fmt, ## args)
+
+#elif(DEBUG == 2)
+/* debug level == 2 */
+#warning "debug=2 build"
+#define dbg_msg(fmt,args...) printk(KERN_DEBUG PFX fmt, ## args)
+#define ENTER()	printk(KERN_DEBUG PFX "%*c %s\n",smi_indent++,'>',__func__)
+#define LEAVE()	\//LEAVE(...)
+	do{				\
+	printk(KERN_DEBUG PFX "%*c %s\n",--smi_indent,'<',__func__); \
+	return __VA_ARGS__; \
+	}while(0)
+#define dbg_msg(fmt,args...) printk(KERN_DEBUG "[%s]:" fmt,__func__,## args)
+#define err_msg(fmt,args...) printk(KERN_ERR  fmt, ## args)
+#define war_msg(fmt,args...) printk(KERN_WARNING fmt, ## args)
+#define inf_msg(fmt,args...) printk(KERN_INFO fmt, ## args)
+	
+#endif
+
+#define SMI_MAX_FB_HEIGHT 8192
+#define SMI_MAX_FB_WIDTH 8192
+
+#define smi_DPMS_CLEARED (-1)
+
+extern int smi_bpp;
+extern int force_connect;
+extern int lvds_channel;
+
+struct smi_fbdev;
+
+struct smi_crtc {
+	struct drm_crtc			base;
+	u8				lut_r[256], lut_g[256], lut_b[256];
+	int				last_dpms;
+	bool				enabled;
+	int crtc_index;
+	int CursorOffset;
+};
+
+#define to_smi_crtc(x) container_of(x, struct smi_crtc, base)
+#define to_smi_encoder(x) container_of(x, struct smi_encoder, base)
+#define to_smi_framebuffer(x) container_of(x, struct smi_framebuffer, base)
+
+
+#define MAX_CRTC	2	
+#define MAX_ENCODER 3
+
+
+#define smi_LUT_SIZE 256
+#define PALETTE_INDEX 0x8
+#define PALETTE_DATA 0x9
+
+
+#define USE_DVI 1
+#define USE_VGA (1<<1)
+#define USE_HDMI (1<<2)
+#define USE_DVI_VGA (USE_DVI|USE_VGA)
+#define USE_DVI_HDMI (USE_DVI | USE_HDMI)
+#define USE_VGA_HDMI (USE_VGA | USE_HDMI)
+#define USE_ALL (USE_DVI |USE_VGA | USE_HDMI)
+
+
+struct smi_mode_info {
+	bool				mode_config_initialized;
+	struct smi_crtc		*crtc;
+	/* pointer to fbdev info structure */
+	struct smi_fbdev		*gfbdev;
+};
+
+struct smi_encoder {
+	struct drm_encoder		base;
+	int				last_dpms;
+};
+
+struct smi_connector {
+	struct drm_connector		base;
+};
+
+struct smi_framebuffer {
+	struct drm_framebuffer		base;
+	struct drm_gem_object *obj;
+	void * vmapping;
+};
+
+struct smi_mc {
+	resource_size_t			vram_size;
+	resource_size_t			vram_base;
+};
+
+struct smi_750_register;
+struct smi_768_register;
+
+struct smi_device {
+	struct drm_device		*dev;
+	unsigned long			flags;	
+
+	resource_size_t			rmmio_base;
+	resource_size_t			rmmio_size;
+	void __iomem			*rmmio;
+
+	struct smi_mc			mc;
+	struct smi_mode_info		mode_info;
+
+	int				num_crtc;
+	int fb_mtrr;	
+	bool				need_dma32;
+	struct {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,0,0)
+		struct drm_global_reference mem_global_ref;
+		struct ttm_bo_global_ref bo_global_ref;
+#endif
+		struct ttm_bo_device bdev;
+	} ttm;
+	bool mm_inited;
+	struct smi_750_register *regsave;
+	struct smi_768_register *regsave_768;
+	struct edid dvi_edid[2];
+	struct edid vga_edid[2];
+	struct edid hdmi_edid[2];
+	bool is_hdmi;
+};
+
+
+struct smi_fbdev {
+	struct drm_fb_helper helper; /* must be first */
+	struct smi_framebuffer gfb;
+	struct list_head fbdev_list;
+	int size;
+	int x1, y1, x2, y2; /* dirty rect */
+	spinlock_t dirty_lock;
+};
+
+struct smi_bo {
+	struct ttm_buffer_object bo;
+	struct ttm_placement placement;
+	struct ttm_bo_kmap_obj kmap;
+	struct drm_gem_object gem;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0) // Loongson backport from 3.18
+	struct ttm_place placements[3];
+#else
+	u32 placements[3];
+#endif	
+	int pin_count;
+	struct ttm_bo_kmap_obj dma_buf_vmap;
+};
+#define gem_to_smi_bo(gobj) container_of((gobj), struct smi_bo, gem)
+
+static inline struct smi_bo *
+smi_bo(struct ttm_buffer_object *bo)
+{
+	return container_of(bo, struct smi_bo, bo);
+}
+
+
+#define to_smi_obj(x) container_of(x, struct smi_gem_object, base)
+#define DRM_FILE_PAGE_OFFSET (0x100000000ULL >> PAGE_SHIFT)
+
+				/* smi_mode.c */
+void smi_crtc_fb_gamma_set(struct drm_crtc *crtc, u16 red, u16 green,
+			     u16 blue, int regno);
+void smi_crtc_fb_gamma_get(struct drm_crtc *crtc, u16 *red, u16 *green,
+			     u16 *blue, int regno);
+
+int smi_calc_hdmi_ctrl(int m_connector);
+
+
+				/* smi_main.c */
+int smi_device_init(struct smi_device *cdev,
+		      struct drm_device *ddev,
+		      struct pci_dev *pdev,
+		      uint32_t flags);
+void smi_device_fini(struct smi_device *cdev);
+int smi_gem_init_object(struct drm_gem_object *obj);
+void smi_gem_free_object(struct drm_gem_object *obj);
+int smi_dumb_mmap_offset(struct drm_file *file,
+			    struct drm_device *dev,
+			    uint32_t handle,
+			    uint64_t *offset);
+int smi_gem_create(struct drm_device *dev,
+		   u32 size, bool iskernel,
+		   struct drm_gem_object **obj);
+int smi_dumb_create(struct drm_file *file,
+		    struct drm_device *dev,
+		    struct drm_mode_create_dumb *args);
+int smi_dumb_destroy(struct drm_file *file,
+		     struct drm_device *dev,
+		     uint32_t handle);
+
+int smi_framebuffer_init(struct drm_device *dev,
+			   struct smi_framebuffer *gfb,
+			    const struct drm_mode_fb_cmd2 *mode_cmd,
+			    struct drm_gem_object *obj);
+
+				/* smi_display.c */
+int smi_modeset_init(struct smi_device *cdev);
+void smi_modeset_fini(struct smi_device *cdev);
+
+				/* smi_fbdev.c */
+int smi_fbdev_init(struct smi_device *cdev);
+void smi_fbdev_fini(struct smi_device *cdev);
+void smi_fb_zfill(struct drm_device *dev, struct smi_fbdev *gfbdev);
+
+
+				/* smi_irq.c */
+void smi_driver_irq_preinstall(struct drm_device *dev);
+int smi_driver_irq_postinstall(struct drm_device *dev);
+void smi_driver_irq_uninstall(struct drm_device *dev);
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3,14,0)		
+irqreturn_t smi_driver_irq_handler(int irq, void *arg);
+#else
+irqreturn_t smi_driver_irq_handler(DRM_IRQ_ARGS);
+#endif
+				/* smi_kms.c */
+int smi_driver_load(struct drm_device *dev, unsigned long flags);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,11,0)
+void smi_driver_unload(struct drm_device *dev);
+#else
+int smi_driver_unload(struct drm_device *dev);
+#endif
+extern struct drm_ioctl_desc smi_ioctls[];
+extern int smi_max_ioctl;
+
+int smi_mm_init(struct smi_device *smi);
+void smi_mm_fini(struct smi_device *smi);
+void smi_ttm_placement(struct smi_bo *bo, int domain);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,18,0)
+int smi_bo_create(struct drm_device *dev, int size, int align,
+		  uint32_t flags, struct sg_table *sg, struct smi_bo **psmibo);
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(5,4,0)
+int smi_bo_create(struct drm_device *dev, int size, int align,
+		  uint32_t flags, struct sg_table *sg, struct reservation_object *resv, struct smi_bo **psmibo);
+#else
+int smi_bo_create(struct drm_device *dev, int size, int align,
+		  uint32_t flags, struct sg_table *sg, struct dma_resv *resv, struct smi_bo **psmibo);
+#endif
+
+void smi_bo_ttm_destroy(struct ttm_buffer_object *tbo);
+
+int smi_mmap(struct file *filp, struct vm_area_struct *vma);
+
+void hw750_suspend(struct smi_750_register * pSave);
+void hw750_resume(struct smi_750_register * pSave);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,15,0)
+struct drm_plane *smi_plane_init(struct smi_device *cdev, unsigned int possible_crtcs);
+#else
+struct drm_plane *smi_plane_init(struct smi_device *cdev, unsigned int possible_crtcs, enum drm_plane_type type);
+#endif
+
+static inline int smi_bo_reserve(struct smi_bo *bo, bool no_wait)
+{
+	int ret;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,7,0)
+	ret = ttm_bo_reserve(&bo->bo, true, no_wait, false, NULL);
+#else
+	ret = ttm_bo_reserve(&bo->bo, true, no_wait, NULL);
+#endif
+	if (ret) {
+		if (ret != -ERESTARTSYS && ret != -EBUSY)
+			DRM_ERROR("reserve failed %p\n", bo);
+		return ret;
+	}
+	return 0;
+}
+
+static inline void smi_bo_unreserve(struct smi_bo *bo)
+{
+	ttm_bo_unreserve(&bo->bo);
+}
+
+
+void smi_fb_output_poll_changed(struct smi_device *sdev);
+
+
+
+int smi_bo_pin(struct smi_bo *bo, u32 pl_flag, u64 *gpu_addr);
+int smi_bo_unpin(struct smi_bo *bo);
+
+
+
+struct sg_table *smi_gem_prime_get_sg_table(struct drm_gem_object *obj);
+void *smi_gem_prime_vmap(struct drm_gem_object *obj);
+void smi_gem_prime_vunmap(struct drm_gem_object *obj, void *vaddr);
+
+
+struct drm_gem_object *smi_gem_prime_import_sg_table(struct drm_device *dev,
+							struct dma_buf_attachment *attach,
+							struct sg_table *sg);
+
+int smi_gem_prime_pin(struct drm_gem_object *obj);
+void smi_gem_prime_unpin(struct drm_gem_object *obj);
+
+struct reservation_object *smi_gem_prime_res_obj(struct drm_gem_object *obj);
+
+#if KERNEL_VERSION(4, 12, 0) > LINUX_VERSION_CODE
+int smi_crtc_page_flip(struct drm_crtc *crtc,struct drm_framebuffer *fb,
+	struct drm_pending_vblank_event *event, uint32_t page_flip_flags);
+#else
+int smi_crtc_page_flip(struct drm_crtc *crtc,struct drm_framebuffer *fb,
+	struct drm_pending_vblank_event *event, uint32_t page_flip_flags, struct drm_modeset_acquire_ctx *ctx);
+#endif
+
+int smi_audio_init(struct drm_device *dev);
+void smi_audio_remove(struct drm_device *dev);
+
+/* please use revision id to distinguish sm750le and sm750*/
+#define SPC_SM750 	0
+#define SPC_SM712 	1
+#define SPC_SM502   2
+#define SPC_SM768   3
+//#define SPC_SM750LE 8
+
+#define PCI_VENDOR_ID_SMI 	0x126f
+#define PCI_DEVID_LYNX_EXP	0x0750
+#define PCI_DEVID_SM768		0x0768
+
+extern int g_specId;
+
+#define BPP32_RED    0x00ff0000
+#define BPP32_GREEN  0x0000ff00
+#define BPP32_BLUE   0x000000ff
+#define BPP32_WHITE  0x00ffffff
+#define BPP32_GRAY   0x00808080
+#define BPP32_YELLOW 0x00ffff00
+#define BPP32_CYAN   0x0000ffff
+#define BPP32_PINK   0x00ff00ff
+#define BPP32_BLACK  0x00000000
+
+
+#define BPP16_RED    0x0000f800
+#define BPP16_GREEN  0x000007e0
+#define BPP16_BLUE   0x0000001f
+#define BPP16_WHITE  0x0000ffff
+#define BPP16_GRAY   0x00008410
+#define BPP16_YELLOW 0x0000ffe0
+#define BPP16_CYAN   0x000007ff
+#define BPP16_PINK   0x0000f81f
+#define BPP16_BLACK  0x00000000
+
+#endif				/* __SMI_DRV_H__ */
diff --git a/drivers/gpu/drm/smi/smi_fbdev.c b/drivers/gpu/drm/smi/smi_fbdev.c
new file mode 100644
index 000000000000..950109a53efb
--- /dev/null
+++ b/drivers/gpu/drm/smi/smi_fbdev.c
@@ -0,0 +1,403 @@
+/*
+ * Copyright 2016 SiliconMotion Inc.
+ *
+ * This file is subject to the terms and conditions of the GNU General
+ * Public License version 2. See the file COPYING in the main
+ * directory of this archive for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <drm/drmP.h>
+#include <drm/drm_fb_helper.h>
+#include <drm/drm_crtc_helper.h>
+#include <linux/fb.h>
+#include "smi_drv.h"
+
+
+static int smifb_mmap(struct fb_info *info,
+			struct vm_area_struct *vma)
+{
+	struct smi_fbdev *afbdev = info->par;
+	struct drm_gem_object *obj;
+	struct smi_bo *bo;
+	obj = afbdev->gfb.obj;
+	bo = gem_to_smi_bo(obj);	
+
+	return ttm_fbdev_mmap(vma, &bo->bo);
+}
+
+
+static struct fb_ops smifb_ops = {
+	.owner = THIS_MODULE,
+	.fb_check_var = drm_fb_helper_check_var,
+	.fb_set_par = drm_fb_helper_set_par,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,3,0)
+	.fb_fillrect = cfb_fillrect,
+	.fb_copyarea = cfb_copyarea,
+	.fb_imageblit = cfb_imageblit,
+#else
+	.fb_fillrect = drm_fb_helper_cfb_fillrect,
+	.fb_copyarea = drm_fb_helper_cfb_copyarea,
+	.fb_imageblit = drm_fb_helper_cfb_imageblit,
+#endif
+	.fb_pan_display = drm_fb_helper_pan_display,
+	.fb_blank = drm_fb_helper_blank,
+	.fb_setcmap = drm_fb_helper_setcmap,
+	.fb_mmap = smifb_mmap,
+};
+
+static int smifb_create_object(struct smi_fbdev *afbdev,
+			       const struct drm_mode_fb_cmd2 *mode_cmd,
+			       struct drm_gem_object **gobj_p)
+{
+	struct drm_device *dev = afbdev->helper.dev;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3,14,0)	
+	struct smi_device *cdev = dev->dev_private;
+#endif	
+	u32 size;
+	struct drm_gem_object *gobj;
+
+	int ret = 0;
+	size = mode_cmd->pitches[0] * mode_cmd->height;
+	ret = smi_gem_create(dev, size, true, &gobj);
+	if (ret)
+		return ret;
+
+	*gobj_p = gobj;
+	return ret;
+}
+
+
+
+void
+smi_fb_zfill(struct drm_device *dev, struct smi_fbdev *gfbdev)
+{
+	struct fb_info *info = gfbdev->helper.fbdev;
+	struct fb_fillrect rect;
+
+	/* Clear the entire fbcon.  The drm will program every connector
+	 * with it's preferred mode.  If the sizes differ, one display will
+	 * quite likely have garbage around the console.
+	 */
+	rect.dx = rect.dy = 0;
+	rect.width = info->var.xres_virtual;
+	rect.height = info->var.yres_virtual;
+	rect.color = 0;
+	rect.rop = ROP_COPY;
+	info->fbops->fb_fillrect(info, &rect);
+}
+
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,9,0)
+static int smifb_create(struct drm_fb_helper *helper,
+			   struct drm_fb_helper_surface_size *sizes)
+#else
+static int smifb_create(struct smi_fbdev *gfbdev,
+			   struct drm_fb_helper_surface_size *sizes)
+#endif
+{
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3,14,0)
+	struct smi_fbdev *gfbdev = container_of(helper, struct smi_fbdev, helper);
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(3,9,0)
+	struct smi_fbdev *gfbdev = (struct smi_fbdev *)helper;
+#endif
+
+	struct drm_device *dev = gfbdev->helper.dev;
+	struct smi_device *cdev = gfbdev->helper.dev->dev_private;
+	struct fb_info *info;
+	struct drm_framebuffer *fb;
+	struct drm_mode_fb_cmd2 mode_cmd;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,3,0)
+	struct device *device = &dev->pdev->dev;
+#endif
+	struct drm_gem_object *gobj = NULL;
+	struct smi_bo *bo = NULL;
+	int size, ret;
+
+	mode_cmd.width = sizes->surface_width;
+	mode_cmd.height = sizes->surface_height;	
+	mode_cmd.pitches[0] = ((mode_cmd.width) * (sizes->surface_bpp) / 8 + 15) & ~15;
+	mode_cmd.pixel_format = drm_mode_legacy_fb_format(sizes->surface_bpp,
+							  sizes->surface_depth);
+	size = mode_cmd.pitches[0] * mode_cmd.height;
+
+	ret = smifb_create_object(gfbdev, &mode_cmd, &gobj);
+	if (ret) {
+		DRM_ERROR("failed to create fbcon backing object %d\n", ret);
+		return ret;
+	}
+
+	bo = gem_to_smi_bo(gobj);
+	ret = smi_bo_reserve(bo, false);
+	if (ret)
+		return ret;
+
+	ret = smi_bo_pin(bo, TTM_PL_FLAG_VRAM, NULL);
+	if (ret) {
+		DRM_ERROR("failed to pin fbcon\n");
+		smi_bo_unreserve(bo);
+		return ret;
+	}
+
+	ret = ttm_bo_kmap(&bo->bo, 0, bo->bo.num_pages,
+			  &bo->kmap);
+	if (ret) {
+		DRM_ERROR("failed to kmap fbcon\n");
+		smi_bo_unreserve(bo);
+		return ret;
+	}
+
+	ttm_bo_unreserve(&bo->bo);
+
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,3,0)
+	info = framebuffer_alloc(0, device);
+	if (info == NULL)
+		return -ENOMEM;
+#else
+	info = drm_fb_helper_alloc_fbi(helper);
+	if (IS_ERR(info))
+		return PTR_ERR(info);
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,2,0)
+	info->par = gfbdev;
+#endif
+
+	ret = smi_framebuffer_init(cdev->dev, &gfbdev->gfb, &mode_cmd, gobj);
+	if (ret)
+		return ret;
+
+	
+	gfbdev->size = size;
+
+	fb = &gfbdev->gfb.base;
+	if (!fb) {
+		DRM_INFO("fb is NULL\n");
+		return -EINVAL;
+	}
+
+	/* setup helper */
+	gfbdev->helper.fb = fb;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,3,0)	
+	gfbdev->helper.fbdev = info;
+#endif
+
+	memset_io(bo->kmap.virtual, 0x0, size);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,2,0)
+	strcpy(info->fix.id, "smidrmfb");
+#endif
+
+	info->flags = FBINFO_DEFAULT;
+	info->fbops = &smifb_ops;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,11,0)
+	drm_fb_helper_fill_fix(info, fb->pitches[0], fb->depth);
+	drm_fb_helper_fill_var(info, &gfbdev->helper, sizes->fb_width,
+			       sizes->fb_height);
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(5,2,0)
+	drm_fb_helper_fill_fix(info, fb->pitches[0], fb->format->depth);
+	drm_fb_helper_fill_var(info, &gfbdev->helper, sizes->fb_width,
+			       sizes->fb_height);
+#else
+	drm_fb_helper_fill_info(info, &gfbdev->helper, sizes);
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,3,0)
+	/* setup aperture base/size for vesafb takeover */
+	info->apertures = alloc_apertures(1);
+	if (!info->apertures) {
+		ret = -ENOMEM;
+		goto out_iounmap;
+	}
+#endif
+	info->apertures->ranges[0].base = cdev->dev->mode_config.fb_base;
+	info->apertures->ranges[0].size = cdev->mc.vram_size;
+
+	info->fix.smem_start = cdev->dev->mode_config.fb_base;
+	info->fix.smem_len = cdev->mc.vram_size;
+
+	info->screen_base = bo->kmap.virtual; 
+	info->screen_size = size;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,4,0)
+	drm_vma_offset_remove(&bo->bo.bdev->vma_manager, &bo->bo.base.vma_node);
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0)
+	drm_vma_offset_remove(&bo->bo.bdev->vma_manager, &bo->bo.vma_node);
+#endif
+	
+	info->fix.mmio_start = 0;
+	info->fix.mmio_len = size;
+	
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,3,0)
+	ret = fb_alloc_cmap(&info->cmap, 256, 0);
+	if (ret) {
+		DRM_ERROR("%s: can't allocate color map\n", info->fix.id);
+		ret = -ENOMEM;
+		goto out_iounmap;
+	}
+#endif
+
+	smi_fb_zfill(dev, gfbdev);
+
+	DRM_INFO("fb mappable at 0x%lX\n", info->fix.smem_start);
+	DRM_INFO("vram aper at 0x%lX\n", (unsigned long)info->fix.smem_start);
+	DRM_INFO("size %lu\n", (unsigned long)info->fix.smem_len);
+#if KERNEL_VERSION(4, 11, 0) > LINUX_VERSION_CODE
+	DRM_INFO("fb depth is %d\n", fb->depth);
+#else
+	DRM_INFO("fb depth is %d\n", fb->format->depth);
+#endif
+	DRM_INFO("   pitch is %d\n", fb->pitches[0]);
+
+	return 0;
+	
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,3,0)
+out_iounmap:
+	return ret;
+#endif	
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,9,0)
+static int smifb_find_or_create_single(struct drm_fb_helper *helper,
+			   struct drm_fb_helper_surface_size *sizes)
+{
+	struct smi_fbdev *gfbdev = (struct smi_fbdev *)helper;
+	int new_fb = 0;
+	int ret;
+
+	if (!helper->fb) {
+		ret = smifb_create(gfbdev, sizes);
+		if (ret)
+			return ret;
+		new_fb = 1;
+	}
+	return new_fb;
+}
+#endif
+
+void
+smi_fb_output_poll_changed(struct smi_device *sdev)
+{
+	if (sdev->mode_info.gfbdev)
+		drm_fb_helper_hotplug_event(&sdev->mode_info.gfbdev->helper);
+}
+
+
+static int smi_fbdev_destroy(struct drm_device *dev,
+				struct smi_fbdev *gfbdev)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,3,0)
+	struct fb_info *info;
+	struct smi_framebuffer *gfb = &gfbdev->gfb;
+
+	if (gfbdev->helper.fbdev) {
+		info = gfbdev->helper.fbdev;
+
+		unregister_framebuffer(info);
+		if (info->cmap.len)
+			fb_dealloc_cmap(&info->cmap);
+		framebuffer_release(info);
+	}
+#else
+	struct smi_framebuffer *gfb = &gfbdev->gfb;
+
+	drm_fb_helper_unregister_fbi(&gfbdev->helper);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,12,0)
+	drm_fb_helper_release_fbi(&gfbdev->helper);
+#endif
+#endif
+	if (gfb->obj) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4,12,0)
+		drm_gem_object_put_unlocked(gfb->obj);
+#else
+		drm_gem_object_unreference_unlocked(gfb->obj);
+#endif
+		gfb->obj = NULL;
+	}
+
+
+	drm_fb_helper_fini(&gfbdev->helper);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,9,0)
+	drm_framebuffer_unregister_private(&gfb->base);
+#endif
+	drm_framebuffer_cleanup(&gfb->base);
+
+	return 0;
+}
+
+static const struct drm_fb_helper_funcs smi_fb_helper_funcs = {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,14,0)
+	.gamma_set = smi_crtc_fb_gamma_set,
+	.gamma_get = smi_crtc_fb_gamma_get,
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,9,0)
+	.fb_probe = smifb_create,
+#else
+	.fb_probe = smifb_find_or_create_single,
+#endif
+};
+
+int smi_fbdev_init(struct smi_device *cdev)
+{
+	int ret = 0;
+
+	struct smi_fbdev *gfbdev;
+	int bpp_sel = smi_bpp;
+	
+	gfbdev = kzalloc(sizeof(struct smi_fbdev), GFP_KERNEL);
+	if (!gfbdev)
+		return -ENOMEM;
+
+	cdev->mode_info.gfbdev = gfbdev;
+#if KERNEL_VERSION(3, 17, 0) > LINUX_VERSION_CODE
+	gfbdev->helper.funcs = &smi_fb_helper_funcs;
+#endif	
+	spin_lock_init(&gfbdev->dirty_lock);
+#if KERNEL_VERSION(3, 17, 0) <= LINUX_VERSION_CODE
+	drm_fb_helper_prepare(cdev->dev, &gfbdev->helper,
+								  &smi_fb_helper_funcs);
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,11,0)
+		ret = drm_fb_helper_init(cdev->dev, &gfbdev->helper,
+									SMIFB_CONN_LIMIT);
+#else
+		ret = drm_fb_helper_init(cdev->dev, &gfbdev->helper,
+					 cdev->num_crtc, SMIFB_CONN_LIMIT);
+#endif
+
+	if (ret)
+		goto free;
+
+	ret = drm_fb_helper_single_add_all_connectors(&gfbdev->helper);
+	if(ret)
+		goto fini;
+	/* disable all the possible outputs/crtcs before entering KMS mode */
+	drm_helper_disable_unused_functions(cdev->dev);
+	ret = drm_fb_helper_initial_config(&gfbdev->helper, bpp_sel);
+	if(ret)
+		goto fini;
+
+	return 0;
+
+fini:
+	drm_fb_helper_fini(&gfbdev->helper);
+free:
+	kfree(gfbdev);
+	
+	return ret;
+
+
+}
+
+void smi_fbdev_fini(struct smi_device *cdev)
+{
+	if (!cdev->mode_info.gfbdev)
+		return;
+
+	smi_fbdev_destroy(cdev->dev, cdev->mode_info.gfbdev);
+	kfree(cdev->mode_info.gfbdev);
+	cdev->mode_info.gfbdev = NULL;
+}
diff --git a/drivers/gpu/drm/smi/smi_main.c b/drivers/gpu/drm/smi/smi_main.c
new file mode 100644
index 000000000000..7ee406c2ca3d
--- /dev/null
+++ b/drivers/gpu/drm/smi/smi_main.c
@@ -0,0 +1,639 @@
+/*
+ * Copyright 2016 SiliconMotion Inc.
+ *
+ * This file is subject to the terms and conditions of the GNU General
+ * Public License version 2. See the file COPYING in the main
+ * directory of this archive for more details.
+ *
+ */
+
+#include <drm/drmP.h>
+#include <drm/drm_crtc_helper.h>
+#include <linux/dma-buf.h>
+
+#include "smi_drv.h"
+
+#include "hw750.h"
+#include "hw768.h"
+
+#define MB(x) (x<<20) /* Macro for Mega Bytes */
+
+#ifdef PRIME
+
+int smi_handle_damage(struct smi_framebuffer *fb, int x, int y,
+						int width, int height)
+{
+	bool kmap = false;
+	int i, ret = 0;
+	unsigned long offset = 0;
+	void *dst = NULL;
+	struct smi_bo *dst_bo = NULL;
+	
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,11,0)
+	unsigned bytesPerPixel = fb->base.format->cpp[0];
+#else
+	unsigned bytesPerPixel = (fb->base.bits_per_pixel >> 3);
+#endif
+
+	
+	if (!fb->obj->import_attach) {
+		return -EINVAL;
+	}
+	
+	if (!fb->vmapping) {
+		fb->vmapping = dma_buf_vmap(fb->obj->import_attach->dmabuf);
+		if (!fb->vmapping)
+			return 0;
+	}
+
+	dst_bo = gem_to_smi_bo(fb->obj);
+	ret = smi_bo_reserve(dst_bo, true);
+	if (ret){
+		dbg_msg("smi_bo_reserve failed\n");
+		smi_bo_unreserve(dst_bo);
+		goto error;
+	}
+
+	if (!dst_bo->dma_buf_vmap.virtual) {
+		ret = ttm_bo_kmap(&dst_bo->bo, 0, dst_bo->bo.num_pages, &dst_bo->dma_buf_vmap);
+		if (ret) {
+			DRM_ERROR("failed to kmap fbcon\n");
+			goto error;
+		}
+		kmap = true;
+	}
+	dst = dst_bo->dma_buf_vmap.virtual;
+
+	dbg_msg("src: %p, dst: %p, x=%d, y=%d, fbwidth=%d, fbheight=%d, width=%d, height=%d, bpp = %u, pitch=%d\n",
+		fb->vmapping, dst, x, y, fb->base.width, fb->base.height, width,height, (bytesPerPixel << 3), fb->base.pitches[0]);
+
+#if 1
+	for (i = y; i < y + height; i++) {
+		offset = i * fb->base.pitches[0] + (x * bytesPerPixel);
+		memcpy_toio(dst + offset, fb->vmapping + offset, width * bytesPerPixel);
+	}
+#else
+	//copy whole screen
+	memcpy_toio(dst, fb->vmapping, fb->base.pitches[0] * fb->base.height);
+#endif
+	if (kmap)
+		ttm_bo_kunmap(&dst_bo->dma_buf_vmap);
+	smi_bo_unreserve(dst_bo);
+
+error:
+	return 0;
+}
+#endif
+
+static void smi_user_framebuffer_destroy(struct drm_framebuffer *fb)
+{
+	struct smi_framebuffer *smi_fb = to_smi_framebuffer(fb);
+
+	if (smi_fb->obj) {
+		if (smi_fb->obj->import_attach) {
+			if(smi_fb->vmapping)
+				dma_buf_vunmap(smi_fb->obj->import_attach->dmabuf, smi_fb->vmapping);
+		}
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4,12,0)
+		drm_gem_object_put_unlocked(smi_fb->obj);
+#else
+		drm_gem_object_unreference_unlocked(smi_fb->obj);
+#endif
+	}
+	drm_framebuffer_cleanup(fb);
+	kfree(fb);
+}
+
+#ifdef PRIME
+
+static int smi_user_framebuffer_dirty(struct drm_framebuffer *fb,
+                                        struct drm_file *file,
+                                        unsigned flags, unsigned color,
+                                        struct drm_clip_rect *clips,
+                                        unsigned num_clips)
+{
+	struct smi_framebuffer *smi_fb = to_smi_framebuffer(fb);
+	int i, ret = 0;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,9,0)
+	drm_modeset_lock_all(fb->dev);
+#else
+	mutex_lock(&fb->dev->mode_config.mutex);
+#endif
+
+	if (smi_fb->obj->import_attach) {
+		ret = dma_buf_begin_cpu_access(smi_fb->obj->import_attach->dmabuf,
+#if KERNEL_VERSION(4, 6, 0) > LINUX_VERSION_CODE
+						0, smi_fb->obj->size,
+#endif
+						DMA_FROM_DEVICE);
+		if (ret)
+			goto unlock;
+	}	
+
+	for (i = 0; i < num_clips; i++) {
+		ret = smi_handle_damage(smi_fb, clips[i].x1, clips[i].y1,
+                            clips[i].x2 - clips[i].x1, clips[i].y2 - clips[i].y1);
+		if (ret)
+			break;
+	}
+	
+	if (smi_fb->obj->import_attach) {
+		dma_buf_end_cpu_access(smi_fb->obj->import_attach->dmabuf,
+#if KERNEL_VERSION(4, 6, 0) > LINUX_VERSION_CODE
+					0, smi_fb->obj->size,
+#endif
+					DMA_FROM_DEVICE);
+	}
+	
+unlock:
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,9,0)
+	drm_modeset_unlock_all(fb->dev);
+#else
+	mutex_unlock(&fb->dev->mode_config.mutex);
+#endif
+
+	return ret;
+}
+
+#endif
+
+
+static int smi_user_framebuffer_create_handle(struct drm_framebuffer *fb,
+						  struct drm_file *file_priv,
+						  unsigned int *handle)
+{
+	struct smi_framebuffer *smi_fb = to_smi_framebuffer(fb);
+	return drm_gem_handle_create(file_priv, smi_fb->obj, handle);
+}
+
+
+static const struct drm_framebuffer_funcs smi_fb_funcs = {
+	.create_handle = smi_user_framebuffer_create_handle,
+	.destroy = smi_user_framebuffer_destroy,
+#ifdef PRIME
+	.dirty = smi_user_framebuffer_dirty,
+#endif
+};
+
+int smi_framebuffer_init(struct drm_device *dev,
+			    struct smi_framebuffer *gfb,
+			    const struct drm_mode_fb_cmd2 *mode_cmd,
+			    struct drm_gem_object *obj)
+{
+	int ret;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,11,0)
+		drm_helper_mode_fill_fb_struct(dev, &gfb->base, mode_cmd);
+#else
+		drm_helper_mode_fill_fb_struct(&gfb->base, mode_cmd);
+#endif
+	gfb->obj = obj;
+	ret = drm_framebuffer_init(dev, &gfb->base, &smi_fb_funcs);
+	if (ret) {
+		DRM_ERROR("drm_framebuffer_init failed: %d\n", ret);
+		return ret;
+	}
+	return 0;
+}
+
+static struct drm_framebuffer *
+smi_user_framebuffer_create(struct drm_device *dev,
+			       struct drm_file *filp,
+			       const struct drm_mode_fb_cmd2 *mode_cmd)
+{
+	struct drm_gem_object *obj;
+	struct smi_framebuffer *smi_fb;
+	int ret;
+	
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,7,0)
+	obj = drm_gem_object_lookup(dev, filp, mode_cmd->handles[0]);
+#else
+	obj = drm_gem_object_lookup(filp, mode_cmd->handles[0]);
+#endif
+	if (obj == NULL)
+		return ERR_PTR(-ENOENT);
+
+	smi_fb = kzalloc(sizeof(*smi_fb), GFP_KERNEL);
+	if (!smi_fb) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4,12,0)
+		drm_gem_object_put_unlocked(obj);
+#else
+		drm_gem_object_unreference_unlocked(obj);
+#endif
+		return ERR_PTR(-ENOMEM);
+	}
+
+	ret = smi_framebuffer_init(dev, smi_fb, mode_cmd, obj);
+	if (ret) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4,12,0)
+		drm_gem_object_put_unlocked(obj);
+#else
+		drm_gem_object_unreference_unlocked(obj);
+#endif
+		kfree(smi_fb);
+		return ERR_PTR(ret);
+	}
+	return &smi_fb->base;
+}
+
+
+static void smi_output_poll_changed(struct drm_device *dev)
+{
+	struct smi_device *sdev = dev->dev_private;
+	smi_fb_output_poll_changed(sdev);
+}
+
+
+static const struct drm_mode_config_funcs smi_mode_funcs = {
+	.fb_create = smi_user_framebuffer_create,
+	.output_poll_changed = smi_output_poll_changed,
+};
+
+/* Unmap the framebuffer from the core and release the memory */
+static void smi_vram_fini(struct smi_device *cdev)
+{
+	iounmap(cdev->rmmio);
+	cdev->rmmio = NULL;
+	if (cdev->mc.vram_base)
+		release_mem_region(cdev->mc.vram_base, cdev->mc.vram_size);
+}
+
+/* Map the framebuffer from the card and configure the core */
+static int smi_vram_init(struct smi_device *cdev)
+{
+	/* BAR 0 is VRAM */
+	cdev->mc.vram_base = pci_resource_start(cdev->dev->pdev, 0);
+
+	/* VRAM Size */
+	if(g_specId == SPC_SM750)
+		cdev->mc.vram_size = ddk750_getFrameBufSize();
+	else
+		cdev->mc.vram_size = ddk768_getFrameBufSize();
+
+	if (!request_mem_region(cdev->mc.vram_base, cdev->mc.vram_size,
+				"smidrmfb_vram")) {
+		DRM_ERROR("can't reserve VRAM\n");
+		return -ENXIO;
+	}
+
+	return 0;
+}
+
+/*
+ * SMI Graphics has two sets of memory. One is video RAM and can
+ * simply be used as a linear framebuffer - the other provides mmio access
+ * to the display registers. The latter can also be accessed via IO port
+ * access, but we map the range and use mmio to program them instead
+ */
+
+int smi_device_init(struct smi_device *cdev,
+		       struct drm_device *ddev,
+		       struct pci_dev *pdev, uint32_t flags)
+{
+	int ret,dma_bits;
+
+	cdev->dev = ddev;
+	cdev->flags = flags;
+
+	/* Hardcode the number of CRTCs to 2 */
+	cdev->num_crtc = 2;
+
+	dma_bits = 40;
+	cdev->need_dma32 = false;
+	ret = pci_set_dma_mask(cdev->dev->pdev, DMA_BIT_MASK(dma_bits));
+	if (ret) {
+		cdev->need_dma32 = true;
+		dma_bits = 32;
+		printk(KERN_WARNING "smifb: No suitable DMA available.\n");
+	}
+
+#if 0
+	ret = pci_set_consistent_dma_mask(cdev->dev->pdev, DMA_BIT_MASK(dma_bits));
+	if (ret) {
+		pci_set_consistent_dma_mask(cdev->dev->pdev, DMA_BIT_MASK(32));
+		printk(KERN_WARNING "smifb: No coherent DMA available.\n");
+	}
+#endif
+
+	/* BAR 0 is the framebuffer, BAR 1 contains registers */
+	cdev->rmmio_base = pci_resource_start(cdev->dev->pdev, 1);
+	cdev->rmmio_size = pci_resource_len(cdev->dev->pdev, 1);
+
+	if (!request_mem_region(cdev->rmmio_base, cdev->rmmio_size,
+				"smidrmfb_mmio")) {
+		DRM_ERROR("can't reserve mmio registers\n");
+		return -ENOMEM;
+	}
+
+	cdev->rmmio = ioremap(cdev->rmmio_base, cdev->rmmio_size);
+
+	if (cdev->rmmio == NULL)
+		return -ENOMEM;
+
+	if(g_specId == SPC_SM750)
+		ddk750_set_mmio(cdev->rmmio,pdev->device,pdev->revision);
+	else
+		ddk768_set_mmio(cdev->rmmio,pdev->device,pdev->revision);
+
+
+	ret = smi_vram_init(cdev);
+	if (ret) {
+		release_mem_region(cdev->rmmio_base, cdev->rmmio_size);
+		return ret;
+	}
+
+	return 0;
+}
+
+void smi_device_fini(struct smi_device *cdev)
+{
+	release_mem_region(cdev->rmmio_base, cdev->rmmio_size);
+	smi_vram_fini(cdev);
+}
+
+/*
+ * Functions here will be called by the core once it's bound the driver to
+ * a PCI device
+ */
+void drm_kms_helper_poll_init(struct drm_device *dev);
+int smi_driver_load(struct drm_device *dev, unsigned long flags)
+{
+	struct smi_device *cdev;
+	int r;
+
+	cdev = kzalloc(sizeof(struct smi_device), GFP_KERNEL);
+	if (cdev == NULL)
+		return -ENOMEM;
+	dev->dev_private = (void *)cdev;
+
+	pci_enable_device(dev->pdev);
+
+	r = smi_device_init(cdev, dev, dev->pdev, flags);
+	if (r) {
+		dev_err(&dev->pdev->dev, "Fatal error during GPU init: %d\n", r);
+		goto out;
+	}
+
+	if(g_specId == SPC_SM750)
+	{
+		ddk750_initChip();
+		ddk750_deInit();
+		
+#ifdef USE_HDMICHIP
+		if((r = sii9022xInitChip()) < 0)
+		{	
+			printk("Init HDMI-Tx chip failed!");
+			r = 0;	
+		}
+#endif
+
+	}
+	else
+	{
+		ddk768_initChip();
+		ddk768_deInit();
+		hw768_init_hdmi();
+#ifdef AUDIO_EN
+		smi_audio_init(dev);
+#endif
+	}
+	
+	r = smi_mm_init(cdev);
+	if (r){
+		dev_err(&dev->pdev->dev, "fatal err on mm init\n");
+		goto out;
+	}
+
+	drm_vblank_init(dev, dev->mode_config.num_crtc);
+
+	int ret;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,16,0)	
+		ret = drm_irq_install(dev, dev->pdev->irq);
+#else
+		ret = drm_irq_install(dev);
+#endif
+		if (ret)
+			DRM_ERROR("install irq failed , ret = %d\n", ret);
+	
+	dev->mode_config.funcs = (void *)&smi_mode_funcs;
+	r = smi_modeset_init(cdev);
+	if (r){
+		dev_err(&dev->pdev->dev, "Fatal error during modeset init: %d\n", r);
+		goto out;
+	}
+
+	cdev->regsave = vmalloc(1024);
+	if(!cdev->regsave)
+	{
+		printk("cannot allocate regsave\n");
+		//return -ENOMEM;
+	}
+
+	drm_kms_helper_poll_init(dev);
+
+	return 0;
+out:
+	if (r)
+		smi_driver_unload(dev);
+	return r;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,11,0)
+void smi_driver_unload(struct drm_device *dev)
+#else
+int smi_driver_unload(struct drm_device *dev)
+#endif
+
+{
+	struct smi_device *cdev = dev->dev_private;
+
+	if (dev->irq_enabled)
+		drm_irq_uninstall(dev);
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,17,0)) && (LINUX_VERSION_CODE < KERNEL_VERSION(4,14,0)) 
+		drm_vblank_cleanup(dev);
+#endif
+
+	if (cdev == NULL)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,11,0)
+		return;
+#else
+		return 0;
+#endif
+
+	smi_modeset_fini(cdev);
+	smi_mm_fini(cdev);
+	smi_device_fini(cdev);
+
+#ifdef AUDIO_EN
+	if(g_specId == SPC_SM768)
+		smi_audio_remove(dev);
+#endif
+		
+	vfree(cdev->regsave);
+	kfree(cdev);
+	dev->dev_private = NULL;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,11,0)
+	return 0;
+#endif
+
+}
+
+int smi_gem_create(struct drm_device *dev,
+		   u32 size, bool iskernel,
+		   struct drm_gem_object **obj)
+{
+	struct smi_bo *smibo;
+	int ret;
+
+	*obj = NULL;
+
+	size = roundup(size, PAGE_SIZE);
+	if (size == 0)
+		return -EINVAL;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,18,0)
+	ret = smi_bo_create(dev, size, 0, 0, NULL, &smibo);
+#else
+	ret = smi_bo_create(dev, size, 0, 0, NULL, NULL, &smibo);
+#endif
+	if (ret) {
+		if (ret != -ERESTARTSYS)
+			DRM_ERROR("failed to allocate GEM object\n");
+		return ret;
+	}
+	*obj = &smibo->gem;
+	return 0;
+}
+
+int smi_dumb_create(struct drm_file *file,
+		    struct drm_device *dev,
+		    struct drm_mode_create_dumb *args)
+{
+	int ret;
+	struct drm_gem_object *gobj;
+	u32 handle;
+
+	args->pitch = ((args->width) * (args->bpp) / 8 + 15) & ~15; 
+	
+	args->size = args->pitch * args->height;
+
+	ret = smi_gem_create(dev, args->size, false,
+			     &gobj);
+	if (ret)
+		return ret;
+
+	ret = drm_gem_handle_create(file, gobj, &handle);
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4,12,0)
+	drm_gem_object_put_unlocked(gobj);
+#else
+	drm_gem_object_unreference_unlocked(gobj);
+#endif
+	if (ret)
+		return ret;
+
+	args->handle = handle;
+	return 0;
+}
+
+int smi_gem_init_object(struct drm_gem_object *obj)
+{
+	BUG();
+	return 0;
+}
+
+void smi_bo_unref(struct smi_bo **bo)
+{
+	struct ttm_buffer_object *tbo;
+
+	if ((*bo) == NULL)
+		return;
+
+	tbo = &((*bo)->bo);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,1,0)
+	ttm_bo_put(tbo);
+#else
+	ttm_bo_unref(&tbo);
+#endif
+	if (tbo == NULL)
+		*bo = NULL;
+
+}
+
+void smi_gem_free_object(struct drm_gem_object *obj)
+{
+	struct smi_bo *smi_bo = gem_to_smi_bo(obj);
+
+	if (smi_bo){
+		if (smi_bo->gem.import_attach)
+			drm_prime_gem_destroy(&smi_bo->gem, smi_bo->bo.sg);
+		smi_bo_unref(&smi_bo);
+	}
+}
+
+
+static inline u64 smi_bo_mmap_offset(struct smi_bo *bo)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,12,0)
+	return bo->bo.addr_space_offset;
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(5,4,0)
+	return drm_vma_node_offset_addr(&bo->bo.vma_node);
+#else
+	return drm_vma_node_offset_addr(&bo->bo.base.vma_node);
+#endif
+}
+
+int
+smi_dumb_mmap_offset(struct drm_file *file,
+		     struct drm_device *dev,
+		     uint32_t handle,
+		     uint64_t *offset)
+{
+	struct drm_gem_object *obj;
+	struct smi_bo *bo;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,7,0)
+	obj = drm_gem_object_lookup(file, handle);
+	if (obj == NULL) 
+		return -ENOENT;
+
+	bo = gem_to_smi_bo(obj);
+	*offset = smi_bo_mmap_offset(bo);
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4,12,0)
+	drm_gem_object_put_unlocked(obj);
+#else
+	drm_gem_object_unreference_unlocked(obj);
+#endif
+	return 0;
+#else
+	int ret;
+
+	mutex_lock(&dev->struct_mutex);
+	obj = drm_gem_object_lookup(dev, file, handle);
+	if (obj == NULL) {
+		ret = -ENOENT;
+		goto out_unlock;
+	}
+	bo = gem_to_smi_bo(obj);
+	*offset = smi_bo_mmap_offset(bo);
+	drm_gem_object_unreference(obj);
+	ret = 0;
+out_unlock:
+	mutex_unlock(&dev->struct_mutex);
+	return ret;
+#endif
+
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,12,0)
+int smi_dumb_destroy(struct drm_file *file,
+		     struct drm_device *dev,
+		     uint32_t handle)
+{
+       return drm_gem_handle_delete(file, handle);
+}
+#endif
diff --git a/drivers/gpu/drm/smi/smi_mode.c b/drivers/gpu/drm/smi/smi_mode.c
new file mode 100644
index 000000000000..8b16c4e149da
--- /dev/null
+++ b/drivers/gpu/drm/smi/smi_mode.c
@@ -0,0 +1,1177 @@
+/*
+ * Copyright 2016 SiliconMotion Inc.
+ *
+ * This file is subject to the terms and conditions of the GNU General
+ * Public License version 2. See the file COPYING in the main
+ * directory of this archive for more details.
+ *
+ */
+
+#include <drm/drmP.h>
+#include <drm/drm_crtc_helper.h>
+
+#include <linux/version.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,17,0)
+#include <drm/drm_gem.h>
+#include <drm/drm_plane_helper.h>
+#include <drm/drm_atomic_helper.h>
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,1,0)
+#include <drm/drm_probe_helper.h>
+#endif
+#include "smi_drv.h"
+#include "hw750.h"
+#include "hw768.h"
+#include "ddk768/ddk768_video.h"
+
+
+struct smi_crtc * smi_crtc_tab[MAX_CRTC];
+struct drm_encoder * smi_enc_tab[MAX_ENCODER];
+
+int g_m_connector = 0;//bit 0: DVI, bit 1: VGA, bit 2: HDMI.
+
+int smi_calc_hdmi_ctrl(int m_connector)
+{
+		int smi_ctrl = 0;
+
+		if(m_connector==USE_DVI_HDMI) // //vga is empty, dvi is occupied , HDMI use ctrl 1;
+			smi_ctrl = 1;
+		else
+			smi_ctrl = 0;
+			
+		return smi_ctrl;
+
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,14,0)
+
+/*
+ * This file contains setup code for the CRTC.
+ */
+static void smi_crtc_load_lut(struct drm_crtc *crtc)
+{
+}
+#endif
+
+/*
+ * The DRM core requires DPMS functions, but they make little sense in our
+ * case and so are just stubs
+ */
+
+static void smi_crtc_dpms(struct drm_crtc *crtc, int mode)
+{
+	ENTER();
+	LEAVE();
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+
+/*
+ * The core passes the desired mode to the CRTC code to see whether any
+ * CRTC-specific modifications need to be made to it. We're in a position
+ * to just pass that straight through, so this does nothing
+ */
+static bool smi_crtc_mode_fixup(struct drm_crtc *crtc,
+				   const struct drm_display_mode *mode,
+				   struct drm_display_mode *adjusted_mode)
+{
+	return true;
+}
+#endif
+ 
+/* smi is different - we will force move buffers out of VRAM */
+static int smi_crtc_do_set_base(struct drm_crtc *crtc,
+				struct drm_framebuffer *old_fb,
+				int x, int y, int atomic, int dst_ctrl)
+{
+	int ret, pitch;
+	u64 gpu_addr;
+	struct smi_bo *bo;
+	struct smi_framebuffer *smi_fb;
+	struct smi_crtc *smi_crtc = to_smi_crtc(crtc);
+
+	ENTER();
+	if (old_fb) {
+		smi_fb = to_smi_framebuffer(old_fb);
+		bo = gem_to_smi_bo(smi_fb->obj);
+		ret = smi_bo_reserve(bo, false);
+		if (ret) {
+			DRM_ERROR("failed to reserve old_fb bo\n");
+		} else {
+			smi_bo_unpin(bo);
+			smi_bo_unreserve(bo);
+		}
+	}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3,14,0)	
+	smi_fb = to_smi_framebuffer(crtc->primary->fb);
+#else
+	smi_fb = to_smi_framebuffer(crtc->fb);
+#endif
+	bo = gem_to_smi_bo(smi_fb->obj);
+	dbg_msg("bo addr:0x%x\n",bo);	
+	ret = smi_bo_reserve(bo, false);
+	if (ret)
+	{
+		dbg_msg("smi_bo_reserve failed\n");
+		LEAVE(ret);
+	}
+	ret = smi_bo_pin(bo, TTM_PL_FLAG_VRAM, &gpu_addr);
+	if (ret) {
+		dbg_msg("smi_bo_pin failed\n");
+		smi_bo_unreserve(bo);
+		LEAVE(ret);
+	}
+
+	smi_bo_unreserve(bo);
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3,14,0)	
+	pitch = crtc->primary->fb->pitches[0];
+#else
+	pitch = crtc->fb->pitches[0] ;
+#endif
+	// Known issue: when setting 4K+1080p or 2K+1080p, the total pitch exceeds 4096.
+	// The max pitch SM768's register supports is 4096, the issue will cause screen garbage.
+	int win_width = x * smi_bpp/8;
+	int align_width = (win_width + 15)&~15; 	
+	int align_offset = align_width - win_width;
+	unsigned long base_addr = gpu_addr + y*pitch + align_width;
+
+	
+	 if(g_specId == SPC_SM750)
+	{
+		
+		if(crtc == smi_enc_tab[0]->crtc)
+		{
+			hw750_set_base(SMI0_CTRL,pitch,base_addr);
+		}
+		if(crtc == smi_enc_tab[1]->crtc)
+		{
+			hw750_set_base(SMI1_CTRL,pitch,base_addr);
+		}
+	}
+	else
+	{
+		hw768_set_base(dst_ctrl,pitch,base_addr);
+	}
+
+	smi_crtc->CursorOffset = align_offset/(smi_bpp/8);
+	
+	LEAVE(0);
+}
+static int smi_crtc_mode_set_base(struct drm_crtc *crtc, int x, int y,
+			     struct drm_framebuffer *old_fb)
+{
+	int i, ctrl_index, dst_ctrl, ret, max_index;
+
+	ENTER();
+	ret = 0;
+	ctrl_index = 0;
+	dst_ctrl = 0;
+	if(g_specId == SPC_SM750)
+		max_index = 2;
+	else
+		max_index = MAX_ENCODER;
+	for(i = 0;i < MAX_ENCODER; i++)
+	{
+		if(crtc == smi_enc_tab[i]->crtc)
+		{
+			ctrl_index = i;
+			break;
+		}
+	}
+	
+	dst_ctrl = (ctrl_index == SMI1_CTRL)?SMI1_CTRL:SMI0_CTRL;
+
+	if(ctrl_index > SMI1_CTRL)
+	{
+		printk("Reset HDMI base");
+		dst_ctrl= smi_calc_hdmi_ctrl(g_m_connector);
+	}
+	dbg_msg("set base: dst[%d], con[%d]\n", dst_ctrl, ctrl_index);
+
+	ret = smi_crtc_do_set_base(crtc, old_fb, x, y, 0, dst_ctrl);
+	LEAVE(ret);
+}
+
+/*
+ * The meat of this driver. The core passes us a mode and we have to program
+ * it. The modesetting here is the bare minimum required to satisfy the qemu
+ * emulation of this hardware, and running this against a real device is
+ * likely to result in an inadequately programmed mode. We've already had
+ * the opportunity to modify the mode, so whatever we receive here should
+ * be something that can be correctly programmed and displayed
+ */
+static int smi_crtc_mode_set(struct drm_crtc *crtc,
+				struct drm_display_mode *mode,
+				struct drm_display_mode *adjusted_mode,
+				int x, int y, struct drm_framebuffer *old_fb)
+{
+	u32 refresh_rate = drm_mode_vrefresh(mode);
+	struct smi_device *sdev = crtc->dev->dev_private;
+	logicalMode_t logicalMode;
+
+	ENTER();
+	dbg_msg("***crtc addr:0x%x\n",crtc);
+	dbg_msg("x:%d,y:%d\n",x,y);
+	
+	dbg_msg("encode 0->crtc:[0x%x], 1->crtc:[0x%x] \n",smi_enc_tab[0]->crtc, smi_enc_tab[1]->crtc);
+	dbg_msg("Printf g_m_connector = %d,  DVI [%d], VGA[%d], HDMI[%d] \n",g_m_connector, g_m_connector&0x1, g_m_connector&0x2, g_m_connector&0x4);
+	
+	dbg_msg("wxh:%dx%d@%dHz\n",adjusted_mode->hdisplay,adjusted_mode->vdisplay,refresh_rate);
+
+	if(adjusted_mode->hdisplay == 3840)
+		refresh_rate = 30;
+
+	if(g_specId == SPC_SM750)
+	{
+		if(crtc == smi_enc_tab[0]->crtc)
+		{
+			logicalMode.baseAddress = 0;
+			logicalMode.x = adjusted_mode->hdisplay;
+			logicalMode.y = adjusted_mode->vdisplay;
+			logicalMode.bpp = smi_bpp;
+			logicalMode.dispCtrl = SMI0_CTRL;
+			logicalMode.hz = refresh_rate;
+			logicalMode.pitch = 0;
+
+			setMode(&logicalMode);
+
+			setDisplayControl(SMI0_CTRL, DISP_ON);           /* Turn on Primary Control */
+			setPath(SMI0_PATH, SMI0_CTRL, DISP_ON);     /* Turn on Panel Path and use Primary data */
+			smi_crtc_do_set_base(crtc, old_fb, x, y, 0, SMI0_CTRL);	
+		}
+		if(crtc == smi_enc_tab[1]->crtc)
+		{
+			logicalMode.baseAddress = 0;
+			logicalMode.x = adjusted_mode->hdisplay;
+			logicalMode.y = adjusted_mode->vdisplay;
+			logicalMode.bpp = smi_bpp;
+			logicalMode.dispCtrl = SMI1_CTRL;
+			logicalMode.hz = refresh_rate;
+			logicalMode.pitch = 0;
+			setMode(&logicalMode);
+
+			setDisplayControl(SMI1_CTRL, DISP_ON);         /* Turn on Secondary control */
+			setPath(SMI1_PATH, SMI1_CTRL, DISP_ON);     /* Turn on CRT Path and use Secondary data */
+			smi_crtc_do_set_base(crtc, old_fb, x, y, 0, SMI1_CTRL);
+		}
+		
+		swPanelPowerSequence(DISP_ON, 4);                   /* Turn on Panel */
+		setDAC(DISP_ON);                                    /* Turn on DAC */
+
+#ifdef USE_HDMICHIP
+		printk("HDMI set mode\n");
+		sii9022xSetMode(5);
+#endif
+
+	 }
+	else
+	{
+		int i, ctrl_index, dst_ctrl;
+		ctrl_index = 0;
+		dst_ctrl = 0;
+		for(i = 0;i < MAX_ENCODER; i++)
+		{
+			if(crtc == smi_enc_tab[i]->crtc)
+			{
+				ctrl_index = i;
+				break;
+			}
+		}
+
+		dst_ctrl = (ctrl_index == SMI1_CTRL)?SMI1_CTRL:SMI0_CTRL;
+		
+		if(ctrl_index > SMI1_CTRL)
+		{
+			dst_ctrl=smi_calc_hdmi_ctrl(g_m_connector);
+			dbg_msg("hdmi use channel %d\n",dst_ctrl);
+	
+		}
+		
+		logicalMode.baseAddress = 0;
+		logicalMode.x = adjusted_mode->hdisplay;
+		logicalMode.y = adjusted_mode->vdisplay;
+		logicalMode.bpp = smi_bpp;
+		logicalMode.hz = refresh_rate;
+		logicalMode.pitch = 0;
+		logicalMode.dispCtrl = dst_ctrl;
+		ddk768_setMode(&logicalMode);
+		DisableDoublePixel(0);
+		DisableDoublePixel(1);
+		smi_crtc_do_set_base(crtc, old_fb, x, y, 0, dst_ctrl);
+		setSingleViewOn(dst_ctrl);
+
+		if((g_m_connector & USE_HDMI)&&(ctrl_index > SMI1_CTRL))
+		{
+			printk("starting init HDMI!dst=[%d]\n", dst_ctrl);
+			int ret=hw768_set_hdmi_mode(&logicalMode, sdev->is_hdmi);
+			if (ret != 0)
+			{
+				printk("HDMI Mode not supported!\n");
+			}
+		}
+
+		if(lvds_channel == 1)
+			hw768_enable_lvds(1);
+		else if(lvds_channel == 2){
+			hw768_enable_lvds(2);
+			EnableDoublePixel(0);
+		}
+
+		if(force_connect)
+		{
+			logicalMode.dispCtrl = 0;
+			printk("starting init HDMI!dst=[%d]\n", dst_ctrl);
+			int ret=hw768_set_hdmi_mode(&logicalMode, true);
+			if (ret != 0)
+			{
+				printk("HDMI Mode not supported!\n");
+			}
+		}
+
+	}
+	LEAVE(0);
+ }
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,17,0)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,12,0)
+int smi_crtc_page_flip(struct drm_crtc *crtc,struct drm_framebuffer *fb,
+	struct drm_pending_vblank_event *event, uint32_t page_flip_flags)
+#else
+int smi_crtc_page_flip(struct drm_crtc *crtc,struct drm_framebuffer *fb,
+	struct drm_pending_vblank_event *event, uint32_t page_flip_flags, struct drm_modeset_acquire_ctx *ctx)
+#endif
+{	
+	struct drm_device *dev = crtc->dev;
+	unsigned long flags;
+	struct drm_framebuffer *old_fb = crtc->primary->fb;
+	
+	smi_crtc_mode_set_base(crtc, 0, 0, old_fb);
+	
+	spin_lock_irqsave(&dev->event_lock, flags);
+	if (event)
+			drm_crtc_send_vblank_event(crtc, event);
+	spin_unlock_irqrestore(&dev->event_lock, flags);
+	
+	crtc->primary->fb = fb;
+	
+	return 0;
+}
+
+#endif
+
+/*
+ * This is called before a mode is programmed. A typical use might be to
+ * enable DPMS during the programming to avoid seeing intermediate stages,
+ * but that's not relevant to us
+ */
+static void smi_crtc_prepare(struct drm_crtc *crtc)
+{
+}
+
+/*
+ * This is called after a mode is programmed. It should reverse anything done
+ * by the prepare function
+ */
+static void smi_crtc_commit(struct drm_crtc *crtc)
+{
+}
+
+/* Simple cleanup function */
+static void smi_crtc_destroy(struct drm_crtc *crtc)
+{
+	struct smi_crtc *smi_crtc = to_smi_crtc(crtc);
+
+	drm_crtc_cleanup(crtc);
+	kfree(smi_crtc);
+}
+
+/* These provide the minimum set of functions required to handle a CRTC */
+static const struct drm_crtc_funcs smi_crtc_funcs = {
+ 	.set_config = drm_crtc_helper_set_config,//kernel: deprecated. will be instead of drm_atomic_helper_set_config
+	.destroy = smi_crtc_destroy,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,17,0)	
+	.page_flip = smi_crtc_page_flip,
+#endif
+};
+
+static const struct drm_crtc_helper_funcs smi_helper_funcs = {
+	.dpms = smi_crtc_dpms,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)		
+	.mode_fixup = smi_crtc_mode_fixup,
+#endif	
+	.mode_set = smi_crtc_mode_set,
+	.mode_set_base = smi_crtc_mode_set_base,
+	.prepare = smi_crtc_prepare,
+	.commit = smi_crtc_commit,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,14,0)
+	.load_lut = smi_crtc_load_lut,
+#endif
+};
+
+
+/* CRTC setup */
+static struct smi_crtc * smi_crtc_init(struct drm_device *dev, int crtc_id)
+{
+	struct smi_device *cdev = dev->dev_private;
+	struct smi_crtc *smi_crtc;
+	struct drm_plane *primary, *cursor = NULL;
+	int r;
+	
+ 	smi_crtc = kzalloc(sizeof(struct smi_crtc) +
+			      sizeof(struct drm_connector *),
+			      GFP_KERNEL);
+ 	if (smi_crtc == NULL)
+		return NULL;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,15,0)
+	primary = smi_plane_init(cdev, 1 << crtc_id);
+#else
+	primary = smi_plane_init(cdev, 1 << crtc_id, DRM_PLANE_TYPE_PRIMARY);
+#endif
+	if (IS_ERR(primary)) {
+		r = -ENOMEM;
+		goto free_mem;
+	}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,2,0)
+	cursor = smi_plane_init(cdev, 1 << crtc_id, DRM_PLANE_TYPE_CURSOR);
+	if (IS_ERR(cursor)) {
+		r = -ENOMEM;
+		goto clean_primary;
+	}
+#endif
+	smi_crtc->CursorOffset = 0;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,15,0)
+	r = drm_crtc_init(dev, &smi_crtc->base, &smi_crtc_funcs);
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(4,5,0)
+	r = drm_crtc_init_with_planes(dev, &smi_crtc->base, primary, cursor,
+				      &smi_crtc_funcs);
+#else
+	r = drm_crtc_init_with_planes(dev, &smi_crtc->base, primary, cursor,
+				      &smi_crtc_funcs, NULL);
+#endif
+
+	if (r)
+		goto clean_cursor;
+	
+ 	drm_crtc_helper_add(&smi_crtc->base, &smi_helper_funcs);
+	return smi_crtc;
+
+clean_cursor:
+	drm_plane_cleanup(cursor);
+	kfree(cursor);
+clean_primary:
+	drm_plane_cleanup(primary);
+	kfree(primary);
+free_mem:
+	kfree(smi_crtc);
+	return NULL;
+}
+
+/** Sets the color ramps on behalf of fbcon */
+void smi_crtc_fb_gamma_set(struct drm_crtc *crtc, u16 red, u16 green,
+			      u16 blue, int regno)
+{
+	struct smi_crtc *smi_crtc = to_smi_crtc(crtc);
+
+	smi_crtc->lut_r[regno] = red;
+	smi_crtc->lut_g[regno] = green;
+	smi_crtc->lut_b[regno] = blue;
+}
+
+/** Gets the color ramps on behalf of fbcon */
+void smi_crtc_fb_gamma_get(struct drm_crtc *crtc, u16 *red, u16 *green,
+			      u16 *blue, int regno)
+{
+	struct smi_crtc *smi_crtc = to_smi_crtc(crtc);
+
+	*red = smi_crtc->lut_r[regno];
+	*green = smi_crtc->lut_g[regno];
+	*blue = smi_crtc->lut_b[regno];
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+static bool smi_encoder_mode_fixup(struct drm_encoder *encoder,
+				      const struct drm_display_mode *mode,
+				      struct drm_display_mode *adjusted_mode)
+{
+	return true;
+}
+#endif
+static void smi_encoder_mode_set(struct drm_encoder *encoder,
+				struct drm_display_mode *mode,
+				struct drm_display_mode *adjusted_mode)
+{
+
+}
+
+static void smi_encoder_dpms(struct drm_encoder *encoder, int mode)
+{
+	int index =0;
+
+	ENTER();
+	if (encoder->encoder_type  == DRM_MODE_ENCODER_LVDS)
+		index = 0;
+	else if (encoder->encoder_type  == DRM_MODE_ENCODER_DAC)
+		index = 1;
+	else if (encoder->encoder_type  == DRM_MODE_ENCODER_TMDS)
+		index = 2;
+	
+	dbg_msg("The current connect group = [%d], we deal with con=[%d], mode=[%s]\n", g_m_connector,index, (mode == DRM_MODE_DPMS_OFF)?"Off":"ON");
+	if(g_specId == SPC_SM750)
+	{	
+		if (mode == DRM_MODE_DPMS_OFF) {
+			dbg_msg("disable dpms, index=%d\n",index);
+			setDisplayControl(index, DISP_OFF); 
+		}else
+		{
+			setDisplayControl(index, DISP_ON); 
+			swPanelPowerSequence(DISP_ON, 4); 
+			dbg_msg("enable dpms ,index=%d\n",index);
+		}
+	}else if(g_specId == SPC_SM768)
+	{
+		if(encoder->encoder_type  == DRM_MODE_ENCODER_LVDS) 
+		{
+			if(g_m_connector == USE_VGA_HDMI||g_m_connector==USE_HDMI)
+			{
+				dbg_msg("DVI connector off\n");
+				LEAVE(0);
+			}
+			dbg_msg("DVI connector: index=%d\n",index);
+	
+		}
+		else if(encoder->encoder_type  == DRM_MODE_ENCODER_DAC)
+		{
+			if(g_m_connector == USE_DVI_HDMI)
+			{
+				dbg_msg("VGA connector off\n");
+				LEAVE(0);
+			}
+			dbg_msg("VGA connector: index=%d\n",index);
+		}
+		else if(encoder->encoder_type  == DRM_MODE_ENCODER_TMDS)
+		{	
+			if(force_connect)
+				LEAVE(0);
+			if (mode == DRM_MODE_DPMS_OFF)	
+				hw768_HDMI_Disable_Output();
+			else
+				hw768_HDMI_Enable_Output();
+			if(g_m_connector == USE_DVI_HDMI){
+				index = SMI1_CTRL;
+			 	dbg_msg("HDMI connector: index=%d\n",index);
+			}
+			else if(g_m_connector == USE_VGA_HDMI || g_m_connector==USE_HDMI){
+				index = SMI0_CTRL;
+			 	dbg_msg("HDMI connector: index=%d\n",index);
+			}else{
+				dbg_msg("HDMI connector not set dpms\n");
+				LEAVE(0);
+			}
+		}
+		
+		if (mode == DRM_MODE_DPMS_OFF){
+			setDisplayDPMS(index, DISP_DPMS_OFF);
+			ddk768_swPanelPowerSequence(index, 0, 4);
+		}else{
+			setDisplayDPMS(index, DISP_DPMS_ON);
+			ddk768_swPanelPowerSequence(index, 1, 4);
+		}
+
+		if(lvds_channel == 2)
+			EnableDoublePixel(0);
+	}
+	
+	LEAVE();
+}
+
+static void smi_encoder_prepare(struct drm_encoder *encoder)
+{
+	smi_encoder_dpms(encoder, DRM_MODE_DPMS_OFF);
+
+}
+
+static void smi_encoder_commit(struct drm_encoder *encoder)
+{
+	smi_encoder_dpms(encoder, DRM_MODE_DPMS_ON);
+
+}
+
+void smi_encoder_destroy(struct drm_encoder *encoder)
+{
+	struct smi_encoder *smi_encoder = to_smi_encoder(encoder);
+	drm_encoder_cleanup(encoder);
+	kfree(smi_encoder);
+}
+
+static const struct drm_encoder_helper_funcs smi_encoder_helper_funcs = {
+	.dpms = smi_encoder_dpms,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+	.mode_fixup = smi_encoder_mode_fixup,
+#endif
+	.mode_set = smi_encoder_mode_set,
+	.prepare = smi_encoder_prepare,
+	.commit = smi_encoder_commit,
+};
+
+static const struct drm_encoder_funcs smi_encoder_encoder_funcs = {
+	.destroy = smi_encoder_destroy,
+};
+
+static struct drm_encoder *smi_encoder_init(struct drm_device *dev, int index)
+{
+	struct drm_encoder *encoder;
+	struct smi_encoder *smi_encoder;
+
+	smi_encoder = kzalloc(sizeof(struct smi_encoder), GFP_KERNEL);
+	if (!smi_encoder)
+		return NULL;
+
+	encoder = &smi_encoder->base;
+	encoder->possible_crtcs = (1 << index);
+
+	switch (index)
+	{
+		case 0:
+			drm_encoder_init(dev, encoder, &smi_encoder_encoder_funcs,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,5,0)		
+			 DRM_MODE_ENCODER_LVDS);//DVI,LVDS,
+#else
+			 DRM_MODE_ENCODER_LVDS, NULL);
+#endif	
+			break;
+		case 1:
+			drm_encoder_init(dev, encoder, &smi_encoder_encoder_funcs,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,5,0)		
+			 DRM_MODE_ENCODER_DAC);//VGA
+#else
+			 DRM_MODE_ENCODER_DAC, NULL);
+#endif
+			break;
+		case 2:
+            encoder->possible_crtcs = 0x3;
+			drm_encoder_init(dev, encoder, &smi_encoder_encoder_funcs,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,5,0)		
+			 DRM_MODE_ENCODER_TMDS);//HDMI.
+#else
+			 DRM_MODE_ENCODER_TMDS, NULL);
+#endif	
+			break;
+		default:
+			printk("error index of Connector\n");
+	}
+
+	drm_encoder_helper_add(encoder, &smi_encoder_helper_funcs);
+ 	return encoder;
+}
+
+int smi_connector_get_modes(struct drm_connector *connector)
+{
+	int ret, count;
+	void *edid_buf;
+	struct smi_device *sdev = connector->dev->dev_private;
+
+	ENTER();
+	dbg_msg("print connector type: [%d], DVI=%d, VGA=%d, HDMI=%d\n",
+			connector->connector_type, DRM_MODE_CONNECTOR_DVII, DRM_MODE_CONNECTOR_VGA, DRM_MODE_CONNECTOR_HDMIA);
+	
+	if(g_specId == SPC_SM750)
+	{
+		if(connector->connector_type == DRM_MODE_CONNECTOR_DVII)
+		{
+#ifdef USE_HDMICHIP
+			count = drm_add_modes_noedid(connector, 1920, 1080);
+			drm_set_preferred_mode(connector, 1024, 768);
+#else
+			edid_buf = sdev->dvi_edid;
+			ret = ddk750_edidReadMonitorEx_HW(SMI0_CTRL, edid_buf, 256, 0);
+			dbg_msg("DVI edid size= %d\n",ret);
+			if (ret) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4,18,0)
+				drm_connector_update_edid_property(connector, sdev->dvi_edid);
+#else
+				drm_mode_connector_update_edid_property(connector, sdev->dvi_edid);
+#endif
+				count = drm_add_edid_modes(connector, sdev->dvi_edid);
+			}
+			if (ret == 0 || count == 0) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4,18,0)
+				drm_connector_update_edid_property(connector, NULL);
+#else
+				drm_mode_connector_update_edid_property(connector, NULL);
+#endif
+				count = drm_add_modes_noedid(connector, 1920, 1080);
+				drm_set_preferred_mode(connector, 1024, 768);
+			}
+#endif
+		}
+		if(connector->connector_type == DRM_MODE_CONNECTOR_VGA)
+		{
+			edid_buf = sdev->vga_edid;
+			ret = ddk750_edidReadMonitorEx(SMI1_CTRL, edid_buf, 256, 0, 17, 18);
+
+			if (ret) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4,18,0)
+				drm_connector_update_edid_property(connector, sdev->vga_edid);
+#else
+				drm_mode_connector_update_edid_property(connector, sdev->vga_edid);
+#endif
+				count = drm_add_edid_modes(connector, sdev->vga_edid);
+			}
+			if (ret == 0 || count == 0) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4,18,0)
+				drm_connector_update_edid_property(connector, NULL);
+#else
+				drm_mode_connector_update_edid_property(connector, NULL);
+#endif
+				count = drm_add_modes_noedid(connector, 1920, 1080);
+				drm_set_preferred_mode(connector, 1024, 768);
+			}
+
+		}
+	}
+
+	else
+	{ //SM768 Part
+		if(connector->connector_type == DRM_MODE_CONNECTOR_DVII)
+		{
+			if (lvds_channel) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4,18,0)
+				drm_connector_update_edid_property(connector, NULL);
+#else
+				drm_mode_connector_update_edid_property(connector, NULL);
+#endif
+				count = drm_add_modes_noedid(connector, 1920, 1080);
+				drm_set_preferred_mode(connector, 1920, 1080);
+			} else {
+				edid_buf = sdev->dvi_edid;
+#ifdef HW_I2C
+				ret = ddk768_edidReadMonitorExHwI2C(edid_buf, 256, 0, 0);
+				dbg_msg("DVI edid size= %d\n",ret);
+#else
+				ddk768_edidReadMonitorEx(edid_buf, 256, 0, 30, 31); // GPIO 30,31 for DVI, HW I2C0
+#endif
+				if (ret) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4,18,0)
+					drm_connector_update_edid_property(connector, sdev->dvi_edid);
+#else
+					drm_mode_connector_update_edid_property(connector, sdev->dvi_edid);
+#endif
+					count = drm_add_edid_modes(connector, sdev->dvi_edid);
+				}
+				if (ret == 0 || count == 0) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4,18,0)
+					drm_connector_update_edid_property(connector, NULL);
+#else
+					drm_mode_connector_update_edid_property(connector, NULL);
+#endif
+					count = drm_add_modes_noedid(connector, 1920, 1080);
+					drm_set_preferred_mode(connector, 1024, 768);
+				}
+			}
+		}
+		if(connector->connector_type == DRM_MODE_CONNECTOR_VGA)
+		{
+			edid_buf = sdev->vga_edid;
+#ifdef HW_I2C		
+			ret = ddk768_edidReadMonitorExHwI2C(edid_buf, 256, 0, 1);
+			dbg_msg("VGA edid size= %d\n",ret);
+#else
+			ddk768_edidReadMonitorEx(edid_buf, 256, 0, 6, 7);//GPIO 6,7 for VGA, HW I2C1
+#endif			
+		       
+			if (ret) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4,18,0)
+				drm_connector_update_edid_property(connector, sdev->vga_edid);
+#else
+				drm_mode_connector_update_edid_property(connector, sdev->vga_edid);
+#endif
+				count = drm_add_edid_modes(connector, sdev->vga_edid);
+			}
+			if (ret == 0 || count == 0) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4,18,0)
+				drm_connector_update_edid_property(connector, NULL);
+#else
+				drm_mode_connector_update_edid_property(connector, NULL);
+#endif
+				count = drm_add_modes_noedid(connector, 1920, 1080);
+				drm_set_preferred_mode(connector, 1024, 768);
+			}
+
+		}
+		if(connector->connector_type == DRM_MODE_CONNECTOR_HDMIA)
+		{
+			edid_buf = sdev->hdmi_edid;
+			ret = ddk768_edidReadMonitorEx(edid_buf, 256, 0, 8, 9); //use GPIO8/9 for HDMI
+			dbg_msg("HDMI edid size= %d\n",ret);
+
+			if (ret) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4,18,0)
+				drm_connector_update_edid_property(connector, sdev->hdmi_edid);
+#else
+				drm_mode_connector_update_edid_property(connector, sdev->hdmi_edid);
+#endif
+				count = drm_add_edid_modes(connector, sdev->hdmi_edid);
+				sdev->is_hdmi = drm_detect_hdmi_monitor(sdev->hdmi_edid);
+				dbg_msg("HDMI connector is %s\n",(sdev->is_hdmi ? "HDMI monitor" : "DVI monitor"));
+			}
+			if (ret == 0 || count == 0) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4,18,0)
+				drm_connector_update_edid_property(connector, NULL);
+#else
+				drm_mode_connector_update_edid_property(connector, NULL);
+#endif
+				count = drm_add_modes_noedid(connector, 1920, 1080);
+				drm_set_preferred_mode(connector, 1024, 768);
+				sdev->is_hdmi = true;
+			}
+		}
+	}
+	
+	LEAVE(count);
+}
+
+static int smi_connector_mode_valid(struct drm_connector *connector,
+				 struct drm_display_mode *mode)
+{
+	u32 refresh, vrefresh = drm_mode_vrefresh(mode);
+	
+	/* Only support and use 30Hz or 60Hz mode currently. */
+	switch (vrefresh) {
+	case 30:
+	case 30-1:
+	case 30+1:
+		refresh = 30;
+		break;
+	case 60:
+	case 60-1:
+	case 60+1:
+		refresh = 60;
+		break;
+	default:
+		return MODE_NOMODE;
+	}
+
+	/* Bandwidth: 2K-32bpp@60Hz / 4K-16bpp@60Hz / 4K-32bpp@30Hz / 8K-16bpp@30Hz */
+	if ((mode->hdisplay * smi_bpp * refresh) > (1920 * 32 * 60))
+		return MODE_NOMODE;
+
+#ifdef CONFIG_CPU_LOONGSON3
+	if ((mode->hdisplay == 1360) && (mode->vdisplay == 768))
+		return MODE_NOMODE;
+	if ((mode->hdisplay == 1366) && (mode->vdisplay == 768))
+		return MODE_NOMODE;
+#endif
+
+	return MODE_OK;
+}
+
+struct drm_encoder *smi_connector_best_encoder(struct drm_connector
+						  *connector)
+{
+	int enc_id = connector->encoder_ids[0];
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(3,14,0)
+	struct drm_mode_object *obj;
+	struct drm_encoder *encoder;
+
+	/* pick the encoder ids */
+	if (enc_id) {
+		obj =
+		    drm_mode_object_find(connector->dev, enc_id,
+					 DRM_MODE_OBJECT_ENCODER);
+		if (!obj)
+			return NULL;
+		encoder = obj_to_encoder(obj);
+		return encoder;
+	}
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(4,15,0)
+	if(enc_id)
+		return drm_encoder_find(connector->dev, enc_id);
+#else
+	if(enc_id)
+		return drm_encoder_find(connector->dev, NULL, enc_id);
+#endif
+	return NULL;
+}
+
+
+static enum drm_connector_status smi_connector_detect(struct drm_connector
+						   *connector, bool force)
+{
+	if(force_connect){
+		if(connector->connector_type == DRM_MODE_CONNECTOR_HDMIA){
+			g_m_connector = g_m_connector&(~USE_HDMI);
+			return connector_status_disconnected;
+		}
+		else{
+			g_m_connector = USE_DVI_VGA;
+			return connector_status_connected;
+		}
+	}
+	if(g_specId == SPC_SM750)
+	{		
+		if(connector->connector_type == DRM_MODE_CONNECTOR_DVII)
+		{
+
+#ifdef USE_HDMICHIP
+			if(sii9022xIsConnected())
+				return connector_status_connected;
+#endif
+			if(ddk750_edidHeaderReadMonitorExHwI2C()<0)	
+			{
+				dbg_msg("detect DVI/Panel DO NOT connected.\n");
+				return connector_status_disconnected;
+			}
+			else
+			{
+				dbg_msg("detect DVI/Panel connected.\n");
+				return connector_status_connected;
+			}
+		}
+		
+		if(connector->connector_type == DRM_MODE_CONNECTOR_VGA)
+		{
+			if(ddk750_edidHeaderReadMonitorEx(17,18)<0)	
+			{
+				dbg_msg("detect CRT DO NOT connected.\n");
+				return connector_status_disconnected;
+			}
+			else
+			{
+				dbg_msg("detect CRT connected.\n");
+				return connector_status_connected;
+			}
+		}
+	}
+	else  //SM768 Part
+	{
+		if(connector->connector_type == DRM_MODE_CONNECTOR_DVII)
+		{
+			if (lvds_channel) {
+				g_m_connector =g_m_connector | USE_DVI;
+				return connector_status_connected;
+			}
+#ifdef HW_I2C	
+			if(ddk768_edidHeaderReadMonitorExHwI2C(0)<0)						
+#else
+			if(ddk768_edidHeaderReadMonitorEx(30,31)<0)	
+#endif
+			{				
+				dbg_msg("detect DVI DO NOT connected. \n");
+				g_m_connector = g_m_connector & (~USE_DVI);
+				return connector_status_disconnected; 
+			}
+			else
+			{
+				dbg_msg("detect DVI connected(GPIO30,31)\n");
+				g_m_connector =g_m_connector |USE_DVI;
+				return connector_status_connected;
+			}
+		}
+		
+		if(connector->connector_type == DRM_MODE_CONNECTOR_VGA)
+		{
+#ifdef HW_I2C	
+			if(ddk768_edidHeaderReadMonitorExHwI2C(1)<0)						
+#else
+			if(ddk768_edidHeaderReadMonitorEx(6,7)<0) 
+#endif
+			{				
+				dbg_msg("detect CRT DO NOT connected. \n");
+				g_m_connector =g_m_connector&(~USE_VGA);
+				return connector_status_disconnected;
+			}
+			else
+			{
+				dbg_msg("detect CRT connected(GPIO 6, 7)\n");
+				g_m_connector = g_m_connector|USE_VGA;
+				return connector_status_connected;
+			}
+		
+		}
+		if(connector->connector_type == DRM_MODE_CONNECTOR_HDMIA)
+		{
+
+			if (g_m_connector == USE_DVI_VGA || g_m_connector == USE_ALL){
+				hw768_HDMI_Disable_Output();
+				dbg_msg("set HDMI connector_status_disconnected because of VGA+DVI\n");
+				g_m_connector = g_m_connector&(~USE_HDMI);
+				return connector_status_disconnected;  //If VGA and DVI are both connected, disable HDMI
+			}
+#if 0//ndef AUDIO_EN
+			if (hdmi_hotplug_detect()){
+#else
+			if(ddk768_edidHeaderReadMonitorEx(8,9)==0){ 
+#endif
+				dbg_msg("detect HDMI connected(GPIO 6,7) \n");
+				g_m_connector = g_m_connector|USE_HDMI;
+				return connector_status_connected; 
+			}
+			else{
+				dbg_msg("detect HDMI DO NOT connected. \n");
+				g_m_connector = g_m_connector&(~USE_HDMI);
+				return connector_status_disconnected;
+			}
+		
+		}
+	}
+}
+
+static void smi_connector_destroy(struct drm_connector *connector)
+{
+#if KERNEL_VERSION(3, 17, 0) <= LINUX_VERSION_CODE
+	drm_connector_unregister(connector);
+#else
+	drm_sysfs_connector_remove(connector);
+#endif
+	drm_connector_cleanup(connector);
+	kfree(connector);
+}
+
+
+static const struct drm_connector_helper_funcs smi_vga_connector_helper_funcs = {
+	.get_modes = smi_connector_get_modes,
+	.mode_valid = smi_connector_mode_valid,
+	.best_encoder = smi_connector_best_encoder,
+};
+
+static const struct drm_connector_funcs smi_vga_connector_funcs = {
+	.dpms = drm_helper_connector_dpms,
+	.detect = smi_connector_detect,
+	.fill_modes = drm_helper_probe_single_connector_modes,
+	.destroy = smi_connector_destroy,
+};
+static struct drm_connector *smi_connector_init(struct drm_device *dev, int index)
+{
+	struct drm_connector *connector;
+	struct smi_connector *smi_connector;
+
+	smi_connector = kzalloc(sizeof(struct smi_connector), GFP_KERNEL);
+	if (!smi_connector)
+		return NULL;
+
+	connector = &smi_connector->base;
+
+	switch (index)
+	{
+		case 0:
+			drm_connector_init(dev, connector, &smi_vga_connector_funcs, DRM_MODE_CONNECTOR_DVII);
+			break;
+		case 1:
+			drm_connector_init(dev, connector, &smi_vga_connector_funcs, DRM_MODE_CONNECTOR_VGA);
+			break;
+		case 2:
+			drm_connector_init(dev, connector, &smi_vga_connector_funcs, DRM_MODE_CONNECTOR_HDMIA);
+			break;
+		default:
+			printk("error index of Connector\n");
+	}
+	drm_connector_helper_add(connector, &smi_vga_connector_helper_funcs);
+	connector->polled = DRM_CONNECTOR_POLL_CONNECT | DRM_CONNECTOR_POLL_DISCONNECT;
+
+#if KERNEL_VERSION(3, 17, 0) <= LINUX_VERSION_CODE
+	drm_connector_register(connector);
+#else
+	drm_sysfs_connector_add(connector);
+#endif
+
+	
+	return connector;
+}
+
+
+int smi_modeset_init(struct smi_device *cdev)
+{
+	int ret, index, max_index;
+	struct drm_encoder *encoder;
+	struct drm_connector *connector;
+	struct smi_crtc *smi_crtc;
+
+	if(smi_bpp >= 24)
+		smi_bpp = 32;
+
+	//in multi-card with Intel, we can only use 32bpp
+#ifdef PRIME
+	smi_bpp = 32;
+#endif
+
+	drm_mode_config_init(cdev->dev);
+	cdev->mode_info.mode_config_initialized = true;
+
+	cdev->dev->mode_config.min_width = 0;
+	cdev->dev->mode_config.min_height = 0;
+	cdev->dev->mode_config.max_width = SMI_MAX_FB_WIDTH;
+	cdev->dev->mode_config.max_height = SMI_MAX_FB_HEIGHT;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,14,0)
+	cdev->dev->mode_config.cursor_width = 64;
+	cdev->dev->mode_config.cursor_height = 64;
+#endif
+
+	cdev->dev->mode_config.fb_base = cdev->mc.vram_base;
+#ifdef PRIME
+	cdev->dev->mode_config.preferred_depth = smi_bpp;
+#else
+	cdev->dev->mode_config.preferred_depth = min(24, smi_bpp);
+#endif
+	cdev->dev->mode_config.prefer_shadow = 1;
+
+	for(index = 0; index < MAX_CRTC ; index ++)
+	{
+		smi_crtc = smi_crtc_init(cdev->dev, index);
+		smi_crtc->crtc_index = index;
+		smi_crtc_tab[index] = smi_crtc;
+		dbg_msg("******smi_crtc_tab[%d]:0x%x******\n",index, smi_crtc_tab[index]);
+
+	}
+	if(g_specId == SPC_SM750)
+		max_index = 2;
+	else
+		max_index = MAX_ENCODER;
+	for(index = 0; index < max_index ; index ++)
+	{
+		encoder = smi_encoder_init(cdev->dev, index);
+		if (!encoder) {
+			DRM_ERROR("smi_encoder_tmds_init failed\n");
+			return -1;
+		}
+		smi_enc_tab[index] = encoder;
+
+		connector = smi_connector_init(cdev->dev, index);
+		if (!connector) {
+			DRM_ERROR("smi_%s_init failed\n", index?"VGA":"DVI");
+			return -1;
+		}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4,18,0)
+		drm_connector_attach_encoder(connector, encoder);
+#else
+		drm_mode_connector_attach_encoder(connector, encoder);
+#endif
+	}
+
+	ret = smi_fbdev_init(cdev);
+	if (ret) {
+		DRM_ERROR("smi_fbdev_init failed\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+void smi_modeset_fini(struct smi_device *cdev)
+{
+	smi_fbdev_fini(cdev);
+
+	if (cdev->mode_info.mode_config_initialized) {
+		drm_mode_config_cleanup(cdev->dev);
+		cdev->mode_info.mode_config_initialized = false;
+	}
+}
+
diff --git a/drivers/gpu/drm/smi/smi_plane.c b/drivers/gpu/drm/smi/smi_plane.c
new file mode 100644
index 000000000000..41c54a92b0f4
--- /dev/null
+++ b/drivers/gpu/drm/smi/smi_plane.c
@@ -0,0 +1,488 @@
+/*
+ * Copyright 2016 SiliconMotion Inc.
+ *
+ * This file is subject to the terms and conditions of the GNU General
+ * Public License version 2. See the file COPYING in the main
+ * directory of this archive for more details.
+ *
+ */
+#include <drm/drmP.h>
+#include <drm/drm_crtc_helper.h>
+#include "smi_drv.h"
+#include "hw750.h"
+#include "hw768.h"
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,15,0)
+#include <drm/drm_plane_helper.h>
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,19,0)
+#include <drm/drm_atomic_helper.h>
+#endif
+
+extern struct smi_crtc * smi_crtc_tab[MAX_CRTC];
+extern struct drm_encoder * smi_enc_tab[MAX_ENCODER];
+extern int g_m_connector;//bit 0: DVI, bit 1: VGA, bit 2: HDMI.
+
+void colorcur2monocur(void * data)
+{
+	unsigned int * col = (unsigned int *)data;
+	unsigned char * mono = (unsigned char *)data;
+	unsigned char pixel;
+	char bit_values;
+
+	int i;
+	for(i=0;i<64*64;i++)
+	{
+		if(*col >>24 < 0xe0)
+		{
+			bit_values = 0;
+		}
+		else
+		{
+			int val = *col & 0xff;
+
+			if(val<0x80)
+			{
+				bit_values = 1;
+			}
+			else	{
+				bit_values = 2;
+			}
+ 		}
+ 		col++;
+		/* Copy bits into cursor byte */
+		switch (i & 3)
+		{
+		  case 0:
+		    pixel = bit_values;
+		    break;
+
+		  case 1:
+		    pixel |= bit_values << 2;
+		    break;
+
+		  case 2:
+		    pixel |= bit_values  << 4;
+		    break;
+
+		  case 3:
+		    pixel |= bit_values  << 6;
+		    *mono = pixel;
+		    mono++;
+		    pixel = 0;
+		    break;
+		}
+	}
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,19,0)
+
+int smi_plane_atomic_check(struct drm_plane *plane,
+			   struct drm_plane_state *state)
+{
+	return 0;
+}
+
+static void smi_cursor_atomic_update(struct drm_plane *plane,struct drm_plane_state *old_state)
+{
+
+	//ENTER();
+	struct drm_crtc *crtc = plane->state->crtc;
+	struct drm_framebuffer *fb = plane->state->fb;
+	struct smi_bo *bo;
+	struct drm_gem_object *obj;
+	int ret = 0;
+	int x, y;
+	struct smi_crtc * smi_crtc = to_smi_crtc(crtc);	
+	disp_control_t disp_crtc;
+	int i, ctrl_index, max_enc;
+	ctrl_index = 0;
+
+	if (!plane->state->crtc || !plane->state->fb)
+		return;
+	
+
+	if(g_specId == SPC_SM750)
+		max_enc = MAX_CRTC;
+	else
+		max_enc = MAX_ENCODER;
+
+	for(i = 0;i < max_enc; i++)
+	{
+		if(crtc == smi_enc_tab[i]->crtc)
+		{
+			ctrl_index = i;
+			break;
+		}
+	}
+	disp_crtc = (ctrl_index == SMI1_CTRL)?SMI1_CTRL:SMI0_CTRL;
+
+	if(ctrl_index >= MAX_CRTC)  //calc which path should we use for HDMI.
+	{
+		disp_crtc= (disp_control_t)smi_calc_hdmi_ctrl(g_m_connector);
+	}
+
+
+	if (fb != old_state->fb) {
+		dbg_msg("cursor:change the cursor fb\n");
+		obj = to_smi_framebuffer(fb)->obj;
+		bo = gem_to_smi_bo(obj);
+		ret = smi_bo_reserve(bo, false);
+		if (ret)
+		{
+			dbg_msg("smi_bo_reserve failed\n");
+			//LEAVE();
+		}
+	
+		if(g_specId == SPC_SM750)
+		{
+			ret = ttm_bo_kmap(&bo->bo, 0, bo->bo.num_pages, &bo->kmap);
+			if (ret)
+				dbg_msg("failed to kmap fbcon\n");
+			else
+			{
+				colorcur2monocur(bo->kmap.virtual);
+				//memset(bo->kmap.virtual,smi_pat,gem->size);
+			}
+		}
+		smi_bo_unreserve(bo);
+	}	
+
+	x = plane->state->crtc_x - smi_crtc->CursorOffset;
+	y = plane->state->crtc_y;
+
+	if(g_specId == SPC_SM750)
+	{
+		ddk750_enableCursor(disp_crtc, 1);
+		ddk750_setCursorPosition(disp_crtc, x<0?-x:x, y<0?-y:y, y<0?1:0,x<0?1:0);
+	}
+	else
+	{
+		ddk768_enableCursor(disp_crtc, 3);
+		ddk768_setCursorPosition(disp_crtc, x<0?-x:x, y<0?-y:y, y<0?1:0,x<0?1:0);
+	}
+
+	//LEAVE();
+}
+
+void smi_cursor_atomic_disable(struct drm_plane *plane,
+			       struct drm_plane_state *old_state)
+{
+
+	struct drm_crtc *crtc = plane->state->crtc;
+	
+	disp_control_t disp_crtc;
+	int i, ctrl_index, max_enc;
+	ctrl_index = 0;
+
+	
+	if (!old_state || !old_state->crtc)
+		return;
+
+
+	if(g_specId == SPC_SM750)
+	{
+		ddk750_enableCursor(SMI0_CTRL, 0);
+		ddk750_enableCursor(SMI1_CTRL, 0);
+	}
+	else
+	{
+		ddk768_enableCursor(SMI0_CTRL, 0);
+		ddk768_enableCursor(SMI1_CTRL, 0);
+	}	
+
+
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,9,0)
+static int smi_plane_prepare_fb(struct drm_plane *plane, const struct drm_plane_state *new_state)
+#else
+static int smi_plane_prepare_fb(struct drm_plane *plane, struct drm_plane_state *new_state)
+#endif
+{
+	ENTER();
+
+	struct drm_gem_object *obj;
+	struct smi_bo *user_bo;
+	struct drm_crtc *crtc = new_state->crtc;
+	int ret;
+	u64 gpu_addr;
+
+
+	disp_control_t disp_crtc;
+	int i, ctrl_index, max_enc;
+	ctrl_index = 0;
+
+	if(g_specId == SPC_SM750)
+		max_enc = MAX_CRTC;
+	else
+		max_enc = MAX_ENCODER;
+
+	for(i = 0;i < max_enc; i++)
+	{
+		if(crtc == smi_enc_tab[i]->crtc)
+		{
+			ctrl_index = i;
+			break;
+		}
+	}
+	disp_crtc = (ctrl_index == SMI1_CTRL)?SMI1_CTRL:SMI0_CTRL;
+
+	if(ctrl_index >= MAX_CRTC)  //calc which path should we use for HDMI.
+	{
+		disp_crtc= (disp_control_t)smi_calc_hdmi_ctrl(g_m_connector);
+	}
+
+
+	if (!new_state->fb)
+		return 0;
+
+	obj = to_smi_framebuffer(new_state->fb)->obj;
+	user_bo = gem_to_smi_bo(obj);
+	ret = smi_bo_reserve(user_bo, false);
+	if (ret)
+	{
+		dbg_msg("smi_bo_reserve failed\n");
+		LEAVE(ret);
+	}
+
+	ret = smi_bo_pin(user_bo, TTM_PL_FLAG_VRAM, &gpu_addr);
+
+	if (ret) {
+		dbg_msg("smi_bo_pin failed\n");
+		smi_bo_unreserve(user_bo);
+		LEAVE(ret);
+	}
+
+	smi_bo_unreserve(user_bo);
+
+	
+	if(g_specId == SPC_SM750)
+	{
+		ddk750_initCursor(disp_crtc,(u32)gpu_addr,BPP16_BLACK,BPP16_WHITE,BPP16_BLUE);
+	}
+	else
+	{
+		ddk768_initCursor(disp_crtc,(u32)gpu_addr,BPP32_BLACK,BPP32_WHITE,BPP32_BLUE);
+	}	
+
+	LEAVE(0);
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,9,0)
+static void smi_plane_cleanup_fb(struct drm_plane *plane, const struct drm_plane_state *old_state)
+#else
+static void smi_plane_cleanup_fb(struct drm_plane *plane, struct drm_plane_state *old_state)
+#endif
+{
+	ENTER();
+	struct drm_gem_object *obj;
+	struct smi_bo *user_bo;
+	struct drm_crtc *crtc = plane->state->crtc;
+	
+	if(g_specId == SPC_SM750)
+	{
+		ddk750_enableCursor(SMI0_CTRL, 0);
+		ddk750_enableCursor(SMI1_CTRL, 0);
+	}
+	else
+	{
+		ddk768_enableCursor(SMI0_CTRL, 0);
+		ddk768_enableCursor(SMI1_CTRL, 0);
+	}	
+
+	if (!plane->state->fb) {
+		LEAVE();
+	}
+	
+	obj = to_smi_framebuffer(plane->state->fb)->obj;
+	user_bo = gem_to_smi_bo(obj);
+	smi_bo_unpin(user_bo);	
+	
+	LEAVE();
+}
+
+#endif
+
+static const uint32_t smi_cursor_plane_formats[] = {DRM_FORMAT_RGB565, DRM_FORMAT_BGR565, DRM_FORMAT_ARGB8888};
+
+static const uint32_t smi_formats[] = {DRM_FORMAT_RGB565, DRM_FORMAT_BGR565, DRM_FORMAT_RGB888,
+	DRM_FORMAT_BGR888, DRM_FORMAT_XRGB8888, DRM_FORMAT_XBGR8888,
+	DRM_FORMAT_RGBA8888, DRM_FORMAT_BGRA8888, DRM_FORMAT_ARGB8888,
+	DRM_FORMAT_ABGR8888 };
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,12,0)
+static int smi_plane_update(struct drm_plane *plane, struct drm_crtc *crtc, struct drm_framebuffer *fb,
+			int crtc_x, int crtc_y, unsigned int crtc_w, unsigned int crtc_h,
+			uint32_t src_x, uint32_t src_y, uint32_t src_w, uint32_t src_h)
+#else
+static int smi_plane_update(struct drm_plane *plane, struct drm_crtc *crtc, struct drm_framebuffer *fb,
+			int crtc_x, int crtc_y, unsigned int crtc_w, unsigned int crtc_h,
+			uint32_t src_x, uint32_t src_y, uint32_t src_w, uint32_t src_h, struct drm_modeset_acquire_ctx *ctx)
+#endif
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,15,0)
+	return 0;
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0)
+	return drm_primary_helper_update(plane, crtc, fb,
+			crtc_x, crtc_y, crtc_w, crtc_h, src_x, src_y, src_w, src_h);
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(4,12,0)
+	if (plane->type == DRM_PLANE_TYPE_PRIMARY)
+		return drm_primary_helper_update(plane, crtc, fb,
+			crtc_x, crtc_y, crtc_w, crtc_h, src_x, src_y, src_w, src_h);
+	else
+		return drm_plane_helper_update(plane, crtc, fb,
+			crtc_x, crtc_y, crtc_w, crtc_h, src_x, src_y, src_w, src_h);
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(4,19,0)
+	if (plane->type == DRM_PLANE_TYPE_PRIMARY)
+		return drm_primary_helper_update(plane, crtc, fb,
+			crtc_x, crtc_y, crtc_w, crtc_h, src_x, src_y, src_w, src_h, ctx);
+	else
+		return drm_plane_helper_update(plane, crtc, fb,
+			crtc_x, crtc_y, crtc_w, crtc_h, src_x, src_y, src_w, src_h);
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(5,0,0)
+	if (plane->type == DRM_PLANE_TYPE_PRIMARY)
+		return drm_primary_helper_update(plane, crtc, fb,
+			crtc_x, crtc_y, crtc_w, crtc_h, src_x, src_y, src_w, src_h, ctx);
+	else
+		return drm_plane_helper_update(plane, crtc, fb,
+			crtc_x, crtc_y, crtc_w, crtc_h, src_x, src_y, src_w, src_h, ctx);
+#else
+	return drm_atomic_helper_update_plane(plane, crtc, fb,
+			crtc_x, crtc_y, crtc_w, crtc_h, src_x, src_y, src_w, src_h, ctx);
+#endif
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,12,0)
+static int smi_plane_disable(struct drm_plane *plane)
+#else
+static int smi_plane_disable(struct drm_plane *plane, struct drm_modeset_acquire_ctx *ctx)
+#endif
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,15,0)
+	return -EINVAL;
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0)
+	return drm_primary_helper_disable(plane);
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(4,12,0)
+	if (plane->type == DRM_PLANE_TYPE_PRIMARY)
+		return drm_primary_helper_disable(plane);
+	else
+		return drm_plane_helper_disable(plane);
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(4,19,0)
+	if (plane->type == DRM_PLANE_TYPE_PRIMARY)
+		return drm_primary_helper_disable(plane, ctx);
+	else
+		return drm_plane_helper_disable(plane);
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(5,0,0)
+	if (plane->type == DRM_PLANE_TYPE_PRIMARY)
+		return drm_primary_helper_disable(plane, ctx);
+	else
+		return drm_plane_helper_disable(plane, ctx);
+#else
+	return drm_atomic_helper_disable_plane(plane, ctx);
+#endif
+}
+
+static void smi_plane_destroy(struct drm_plane *plane)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,12,0)
+	smi_plane_disable(plane);
+#else
+	smi_plane_disable(plane, NULL);
+#endif
+	drm_plane_cleanup(plane);
+	kfree(plane);
+}
+
+static struct drm_plane_funcs smi_plane_funcs = {
+	.update_plane	= smi_plane_update,
+	.disable_plane	= smi_plane_disable,
+	.destroy	= smi_plane_destroy,
+};
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,19,0)
+static const struct drm_plane_helper_funcs smi_cursor_helper_funcs = {
+	.atomic_check = smi_plane_atomic_check,
+	.atomic_update = smi_cursor_atomic_update,
+	.atomic_disable = smi_cursor_atomic_disable,
+	.prepare_fb = smi_plane_prepare_fb,
+	.cleanup_fb = smi_plane_cleanup_fb,
+};
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,15,0)
+struct drm_plane *smi_plane_init(struct smi_device *cdev,unsigned int possible_crtcs)
+#else
+struct drm_plane *smi_plane_init(struct smi_device *cdev,unsigned int possible_crtcs, enum drm_plane_type type)
+#endif
+{
+	int err;
+	int num_formats;
+	const uint32_t *formats;
+	struct drm_plane *plane;
+	const struct drm_plane_funcs *funcs;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,19,0)
+	const struct drm_plane_helper_funcs *helper_funcs;
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,19,0)
+	funcs = &smi_plane_funcs;
+	formats = smi_formats;
+	num_formats = ARRAY_SIZE(smi_formats);
+#else
+	switch (type) {
+	case DRM_PLANE_TYPE_PRIMARY:
+		funcs = &smi_plane_funcs;
+		formats = smi_formats;
+		num_formats = ARRAY_SIZE(smi_formats);
+		helper_funcs = NULL;
+		break;
+	case DRM_PLANE_TYPE_CURSOR:
+		funcs = &smi_plane_funcs;
+		formats = smi_cursor_plane_formats;
+		num_formats = ARRAY_SIZE(smi_cursor_plane_formats);
+		helper_funcs = &smi_cursor_helper_funcs;
+		break;
+	default:
+		return ERR_PTR(-EINVAL);
+	}
+#endif
+	
+	plane = kzalloc(sizeof(*plane), GFP_KERNEL);
+	if (!plane)
+		return ERR_PTR(-ENOMEM);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,15,0)
+	err = drm_plane_init(cdev->dev, plane, possible_crtcs,
+						   funcs, formats, num_formats,
+						   false);
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(4,5,0)
+	err = drm_universal_plane_init(cdev->dev, plane, possible_crtcs,
+						   funcs, formats, num_formats,
+						   type);
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(4,14,0)
+	err = drm_universal_plane_init(cdev->dev, plane, possible_crtcs,
+						   funcs, formats, num_formats,
+						   type, NULL);
+#else
+	err = drm_universal_plane_init(cdev->dev, plane, possible_crtcs,
+						   funcs, formats, num_formats,
+						   NULL, type, NULL);
+#endif
+
+	if (err)
+		goto free_plane;
+	
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,19,0)
+	drm_plane_helper_add(plane, helper_funcs);
+#endif
+	
+	return plane;
+	
+free_plane:
+	kfree(plane);
+	return ERR_PTR(-EINVAL);
+
+}
+
+
diff --git a/drivers/gpu/drm/smi/smi_prime.c b/drivers/gpu/drm/smi/smi_prime.c
new file mode 100644
index 000000000000..792717896a75
--- /dev/null
+++ b/drivers/gpu/drm/smi/smi_prime.c
@@ -0,0 +1,108 @@
+/*
+ * Copyright 2016 SiliconMotion Inc.
+ *
+ * This file is subject to the terms and conditions of the GNU General
+ * Public License version 2. See the file COPYING in the main
+ * directory of this archive for more details.
+ *
+ */
+
+#include <drm/drmP.h>
+#include <linux/dma-buf.h>
+
+#include "smi_drv.h"
+
+
+struct sg_table *smi_gem_prime_get_sg_table(struct drm_gem_object *obj)
+{
+	struct smi_bo *bo = gem_to_smi_bo(obj);
+	int npages = bo->bo.num_pages;
+
+	return drm_prime_pages_to_sg(bo->bo.ttm->pages, npages);
+}
+
+void *smi_gem_prime_vmap(struct drm_gem_object *obj)
+{
+	struct smi_bo *bo = gem_to_smi_bo(obj);
+	int ret;
+
+	ret = ttm_bo_kmap(&bo->bo, 0, bo->bo.num_pages,
+			  &bo->dma_buf_vmap);
+	if (ret)
+		return ERR_PTR(ret);
+
+	return bo->dma_buf_vmap.virtual;
+}
+
+void smi_gem_prime_vunmap(struct drm_gem_object *obj, void *vaddr)
+{
+	struct smi_bo *bo = gem_to_smi_bo(obj);
+
+	ttm_bo_kunmap(&bo->dma_buf_vmap);
+}
+
+struct drm_gem_object *smi_gem_prime_import_sg_table(struct drm_device *dev,
+							struct dma_buf_attachment *attach,
+							struct sg_table *sg)
+{
+	struct smi_device *sdev = dev->dev_private;
+	struct smi_bo *bo;
+	int ret;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,17,0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,4,0)
+	struct reservation_object *resv = attach->dmabuf->resv;
+#else
+	struct dma_resv *resv = attach->dmabuf->resv;
+#endif
+	ww_mutex_lock(&resv->lock, NULL);
+	ret = smi_bo_create(dev, attach->dmabuf->size, PAGE_SIZE, 0, sg, resv, &bo);
+	ww_mutex_unlock(&resv->lock);
+#else
+	ret = smi_bo_create(dev, attach->dmabuf->size, PAGE_SIZE, 0, sg, &bo);
+#endif
+	if (ret)
+		return ERR_PTR(ret);
+
+	return &bo->gem;
+}
+
+int smi_gem_prime_pin(struct drm_gem_object *obj)
+{
+	ENTER();
+
+	struct smi_bo *bo  = gem_to_smi_bo(obj);
+	int ret = 0;
+
+	ret = smi_bo_reserve(bo, false);
+	if (unlikely(ret != 0))
+		LEAVE(ret);
+
+	/* pin buffer into GTT */
+	ret = smi_bo_pin(bo, TTM_PL_FLAG_SYSTEM, NULL);
+	smi_bo_unreserve(bo);
+	LEAVE(ret);
+}
+
+
+void smi_gem_prime_unpin(struct drm_gem_object *obj)
+{
+	struct smi_bo *bo = gem_to_smi_bo(obj);
+	int ret = 0;
+
+	ret = smi_bo_reserve(bo, false);
+	if (unlikely(ret != 0))
+		return;
+
+	smi_bo_unpin(bo);
+	smi_bo_unreserve(bo);
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,17,0) && LINUX_VERSION_CODE < KERNEL_VERSION(5,4,0)
+struct reservation_object *smi_gem_prime_res_obj(struct drm_gem_object *obj)
+{
+	struct smi_bo *bo = gem_to_smi_bo(obj);
+
+	return bo->bo.resv;
+}
+#endif
+
diff --git a/drivers/gpu/drm/smi/smi_snd.c b/drivers/gpu/drm/smi/smi_snd.c
new file mode 100644
index 000000000000..e6cc85338204
--- /dev/null
+++ b/drivers/gpu/drm/smi/smi_snd.c
@@ -0,0 +1,673 @@
+/*
+ * Copyright (C) 2016 SiliconMotion Inc.
+ *
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License v2. See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+
+
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <linux/slab.h>
+
+#include <linux/fs.h>
+#include <linux/uaccess.h>
+#include <linux/jiffies.h>
+#include <linux/timer.h>
+
+
+#include "smi_snd.h"
+#include "ddk768/uda1345.h"
+#include "ddk768/ddk768_reg.h"
+#include "ddk768/ddk768_iis.h"
+#include "ddk768/ddk768_intr.h"
+#include "ddk768/ddk768_power.h"
+
+#include <drm/drmP.h>
+#include <drm/drm_crtc_helper.h>
+
+#include "smi_drv.h"
+#include "hw768.h"
+
+char sramTxSection = 0; /* updated section by firmware, Start with section 0 of SRAM */
+struct sm768chip *chip_irq_id=NULL;/*chip_irq_id is use for request and free irq*/
+
+static int SM768_AudioInit(unsigned long wordLength, unsigned long sampleRate)
+{
+
+	// Set up I2S and GPIO registers to transmit/receive data.
+    iisOpen(wordLength, sampleRate);
+    //Set I2S to DMA 256 DWord from SRAM starting at location 0 of SRAM
+    iisTxDmaSetup(0,SRAM_SECTION_SIZE);
+
+	// Init audio codec
+    if(uda1345_init())
+    {
+        uda1345_deinit();
+        return -1;
+    }
+
+    return 0;
+}
+
+/*
+ * This function call iis driver interface iisStart() to start play audio. 
+ */
+static int SM768_AudioStart(void)
+{
+    
+    iisStart();
+    uda1345_setpower(ADCOFF_DACON);
+	uda1345_setmute(NO_MUTE);
+	HDMI_Audio_Unmute();
+    return 0;
+}
+
+/*
+ * Stop audio. 
+ */
+static int SM768_AudioStop(void)
+{
+	uda1345_setmute(MUTE);
+    uda1345_setpower(ADCOFF_DACOFF);
+	HDMI_Audio_Mute();
+    iisStop();
+	
+    return 0;
+}
+
+
+
+static int SM768_AudioDeinit(void)
+{
+	sb_IRQMask(SB_IRQ_VAL_I2S);
+	uda1345_deinit();
+	iisClose();
+
+    return 0;
+}
+
+
+
+
+
+static u8  VolAuDrvToCodec(u16 audrv)
+{
+	u8 codecdb,map;
+    if(audrv == 0x8000)
+        return 0x3b;
+
+    codecdb = (audrv >> 8);
+
+    if(codecdb < 0x80)
+        map = (0x1f - (codecdb >> 2));
+    else
+        map = (0x5f - (codecdb >> 2));
+    return map;
+}
+
+
+static int snd_falconi2s_info_hw_volume(struct snd_kcontrol *kcontrol,
+				     struct snd_ctl_elem_info *uinfo)
+{
+	dbg_msg("snd_falconi2s_info_hw_volume\n");
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 0x1f;
+	return 0;
+}
+
+static int snd_falconi2s_get_hw_play_volume(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *ucontrol)
+{
+	dbg_msg("snd_falconi2s_get_hw_volume\n");
+
+	struct sm768chip *chip = kcontrol->private_data;
+	
+	ucontrol->value.integer.value[0] = chip->playback_vol;
+	
+	return 0;
+}
+static int snd_falconi2s_put_hw_play_volume(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *ucontrol)
+{
+	dbg_msg("snd_falconi2s_put_hw_volume:%d\n",ucontrol->value.integer.value[0]);
+
+	struct sm768chip *chip = kcontrol->private_data;
+	int changed = 0;
+	unsigned short Reg_Vol;
+	u8 vol;
+
+
+	if (chip->playback_vol!= ucontrol->value.integer.value[0]) {
+		vol = chip->playback_vol = ucontrol->value.integer.value[0];
+		uda1345_setvolume(VolAuDrvToCodec(vol));
+		changed = 1;
+	}
+
+	return changed;
+
+}
+
+
+static int snd_falconi2s_get_hw_capture_volume(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *ucontrol)
+{
+	dbg_msg("snd_falconi2s_get_hw_volume\n");
+
+	struct sm768chip *chip = kcontrol->private_data;
+	
+	ucontrol->value.integer.value[0] = chip->capture_vol;
+	
+	return 0;
+}
+static int snd_falconi2s_put_hw_capture_volume(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *ucontrol)
+{
+	dbg_msg("snd_falconi2s_put_hw_volume:%d\n",ucontrol->value.integer.value[0]);
+
+
+	struct sm768chip *chip = kcontrol->private_data;
+	int changed = 0;
+	unsigned short Reg_Vol;
+	u8 vol;
+
+
+	if (chip->capture_vol!= ucontrol->value.integer.value[0]) {
+		vol = chip->capture_vol = ucontrol->value.integer.value[0];
+		uda1345_setvolume(VolAuDrvToCodec(vol));
+		changed = 1;
+		}
+
+	return changed;
+	
+}
+
+
+static struct snd_kcontrol_new falconi2s_vol[] = {
+ {
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Playback Volume",
+		.info = snd_falconi2s_info_hw_volume,
+		.get = snd_falconi2s_get_hw_play_volume,
+		.put = snd_falconi2s_put_hw_play_volume,
+		.private_value = 0,
+
+},
+{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Capture Volume",
+		.info = snd_falconi2s_info_hw_volume,
+		.get = snd_falconi2s_get_hw_capture_volume,
+		.put = snd_falconi2s_put_hw_capture_volume,
+		.private_value = 0,
+},
+};
+  
+/* hardware definition */
+static struct snd_pcm_hardware snd_falconi2s_playback_hw = {
+	.info = (SNDRV_PCM_INFO_MMAP |
+                   SNDRV_PCM_INFO_INTERLEAVED |
+                   SNDRV_PCM_INFO_BLOCK_TRANSFER |
+                   SNDRV_PCM_INFO_MMAP_VALID),
+	.formats =		  SNDRV_PCM_FMTBIT_S16_LE,
+	.rates =			  SNDRV_PCM_RATE_8000_48000,//this value means both of 44100 and 48000 can work 
+	.rate_min =		  48000,
+	.rate_max =		  48000,
+	.channels_min =	  2,
+	.channels_max =	  2,
+	.buffer_bytes_max = P_PERIOD_BYTE*P_PERIOD_MAX,//actually total length should less than 4096*1024.
+	.period_bytes_min = P_PERIOD_BYTE ,
+	.period_bytes_max = P_PERIOD_BYTE,
+	.periods_min =	  P_PERIOD_MIN,
+	.periods_max =	  P_PERIOD_MAX,
+};
+
+  /* hardware definition */
+static struct snd_pcm_hardware snd_falconi2s_capture_hw = {
+	.info = (SNDRV_PCM_INFO_MMAP |
+                   SNDRV_PCM_INFO_INTERLEAVED |
+                   SNDRV_PCM_INFO_BLOCK_TRANSFER |
+                   SNDRV_PCM_INFO_MMAP_VALID),
+	.formats =          SNDRV_PCM_FMTBIT_S16_LE,
+	.rates =            SNDRV_PCM_RATE_8000_48000,
+	.rate_min =         8000,
+	.rate_max =         48000,
+	.channels_min =     2,
+	.channels_max =     2,
+	.buffer_bytes_max = 32768,
+	.period_bytes_min = 4096,
+	.period_bytes_max = 32768,
+	.periods_min =      1,
+	.periods_max =      1024,
+};
+
+  /* open callback */
+static int snd_falconi2s_playback_open(struct snd_pcm_substream *substream)
+{
+	dbg_msg("snd_falconi2s_playback_open\n");
+		
+	struct sm768chip *chip = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	spin_lock(&chip->lock);
+	runtime->hw = snd_falconi2s_playback_hw;
+	/* set the pointer value of substream field in the chip record at open callback to hold the current running substream pointer */
+	chip->substream = substream;
+	spin_unlock(&chip->lock);
+	
+	return 0;
+}
+
+  /* close callback */
+static int snd_falconi2s_playback_close(struct snd_pcm_substream *substream)
+{
+	struct sm768chip *chip = snd_pcm_substream_chip(substream);
+	/* the hardware-specific codes will be here */
+	dbg_msg("snd_falconi2s_playback_close\n");
+	/* reset the pointer value of substream field in the chip record at close callback */
+	chip->substream = NULL;			 
+	return 0;
+
+}
+
+  /* open callback */
+static int snd_falconi2s_capture_open(struct snd_pcm_substream *substream)
+{
+	struct sm768chip *chip = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	runtime->hw = snd_falconi2s_capture_hw;
+	spin_lock(&chip->lock);
+	/* set the pointer value of substream field in the chip record at open callback to hold the current running substream pointer */
+	chip->substream = substream;
+	spin_unlock(&chip->lock);
+	
+	return 0;
+}
+
+  /* close callback */
+static int snd_falconi2s_capture_close(struct snd_pcm_substream *substream)
+{
+	struct sm768chip *chip = snd_pcm_substream_chip(substream);
+	/* the hardware-specific codes will be here */
+	/* reset the pointer value of substream field in the chip record at close callback */
+	chip->substream = NULL;
+	return 0;
+
+}
+
+  /* hw_params callback */
+static int snd_falconi2s_pcm_hw_params(struct snd_pcm_substream *substream,
+                               struct snd_pcm_hw_params *hw_params)
+{
+	dbg_msg("snd_falconi2s_pcm_hw_params,malloc:%d\n",params_buffer_bytes(hw_params));
+	   
+	return snd_pcm_lib_malloc_pages(substream,
+                                     params_buffer_bytes(hw_params));
+}
+
+  /* hw_free callback */
+static int snd_falconi2s_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+	dbg_msg("snd_falconi2s_pcm_hw_free\n");
+	return snd_pcm_lib_free_pages(substream);
+}
+
+  /* prepare callback */
+static int snd_falconi2s_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct sm768chip *chip = snd_pcm_substream_chip(substream);
+	int i=0;
+	dbg_msg("snd_falconi2s_pcm_prepare\n");
+
+	chip->pos = 0;
+
+	dbg_msg("runtime->rate:%d\n",runtime->rate);
+	dbg_msg("runtime->buffer_size:%d\n",runtime->buffer_size);
+	dbg_msg("runtime->periods:%d\n",runtime->periods);
+	dbg_msg("runtime->period_size:%d\n",runtime->period_size);
+	dbg_msg("runtime->frame_bits:%d\n",runtime->frame_bits);
+	dbg_msg("runtime->dma_bytes:%d\n",runtime->dma_bytes);
+
+	return 0;
+}
+
+/* trigger callback */
+static int snd_falconi2s_pcm_playback_trigger(struct snd_pcm_substream *substream,
+                                    int cmd)
+{
+	struct sm768chip *chip = snd_pcm_substream_chip(substream);
+	dbg_msg("snd_falconi2s_pcm_trigger\n");
+	dbg_msg("substream:0x%x\n",substream);
+
+	spin_lock(&chip->lock);
+	
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:		
+		dbg_msg("SNDRV_PCM_TRIGGER_START\n");
+	
+		chip->pos = 0;	
+		memset_io(chip->pvReg + SRAM_OUTPUT_BASE, 0, SRAM_OUTPUT_SIZE);
+		
+		/*enable IIS*/    
+		sramTxSection = 0;
+		SM768_AudioStart();
+		
+		sramTxSection = 1;
+
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		dbg_msg("SNDRV_PCM_TRIGGER_STOP\n");
+		
+		/*disable IIS*/    
+		SM768_AudioStop();
+
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	spin_unlock(&chip->lock);
+	
+	return 0;
+}
+
+
+ static int snd_falconi2s_pcm_capture_trigger(struct snd_pcm_substream *substream,
+									  int cmd)
+ {
+  	return 0;
+ }
+
+ static int snd_falconi2s_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
+ {
+	 
+	  if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		  return snd_falconi2s_pcm_playback_trigger(substream, cmd);
+	  else
+		  return snd_falconi2s_pcm_capture_trigger(substream, cmd);
+ }
+
+
+
+  /* pointer callback */
+  static snd_pcm_uframes_t
+snd_falconi2s_pcm_pointer(struct snd_pcm_substream *substream)
+{
+	struct sm768chip *chip = snd_pcm_substream_chip(substream);
+	snd_pcm_uframes_t value = 0;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		value = bytes_to_frames(substream->runtime, chip->pos);
+		
+	return value;
+}
+
+  /* operators */
+static struct snd_pcm_ops snd_falconi2s_playback_ops = {
+          .open =        snd_falconi2s_playback_open,
+          .close =       snd_falconi2s_playback_close,
+          .ioctl =       snd_pcm_lib_ioctl,
+          .hw_params =   snd_falconi2s_pcm_hw_params,
+          .hw_free =     snd_falconi2s_pcm_hw_free,
+          .prepare =     snd_falconi2s_pcm_prepare,
+          .trigger =     snd_falconi2s_pcm_trigger,
+          .pointer =     snd_falconi2s_pcm_pointer,
+  };
+
+  /* operators */
+static struct snd_pcm_ops snd_falconi2s_capture_ops = {
+          .open =        snd_falconi2s_capture_open,
+          .close =       snd_falconi2s_capture_close,
+          .ioctl =       snd_pcm_lib_ioctl,
+          .hw_params =   snd_falconi2s_pcm_hw_params,
+          .hw_free =     snd_falconi2s_pcm_hw_free,
+          .prepare =     snd_falconi2s_pcm_prepare,
+          .trigger =     snd_falconi2s_pcm_trigger,
+          .pointer =     snd_falconi2s_pcm_pointer,
+  };
+
+
+
+
+static int snd_falconi2s_free(struct sm768chip *chip)
+{
+	/* will be implemented later... */
+	dbg_msg("snd_falconi2s_free!\n");
+
+	return 0;
+}
+
+/* component-destructor
+* (see "Management of Cards and Components")
+*/
+static int snd_falconi2s_dev_free(struct snd_device *device)
+{
+	return snd_falconi2s_free(device->device_data);
+}
+
+/*
+ * interrupt handler
+ */
+static irqreturn_t snd_smi_interrupt(int irq, void *dev_id)
+{
+	
+	struct sm768chip *chip = dev_id;
+	struct snd_pcm_runtime *runtime;
+	struct snd_pcm_substream *substream;
+
+	if(hw768_check_iis_interrupt())
+	{
+		iisClearRawInt();//clear int
+
+		substream = chip->substream;
+		if(substream == NULL){
+			printk("substream == NULL\n");
+			return IRQ_NONE;
+		}
+		runtime = substream->runtime;
+		if (runtime->dma_area == NULL) {
+			printk("runtime->dma_area == NULL\n");
+			return IRQ_NONE;
+		}
+		
+		/*Now the hardware will automatically swtich to next section when it finished
+		So directly increase the sramTxSection in ISR to point to the next next section and start to prepare address and data */
+		sramTxSection++;
+		sramTxSection %= OUTPUT_SRAM_SECTIONS_NUM;
+		
+		/* put data of next section */  
+		/* only support SRAM_SECTION_NUM = 2 */
+		memcpy_fromio(chip->pvReg + SRAM_OUTPUT_BASE + SRAM_SECTION_SIZE * sramTxSection, runtime->dma_area + chip->pos, P_PERIOD_BYTE);
+		
+		chip->pos += P_PERIOD_BYTE;
+		chip->pos %= ((runtime->periods) * (P_PERIOD_BYTE));
+		
+		snd_pcm_period_elapsed(substream);
+		
+		return IRQ_HANDLED;
+	}
+	else
+		return IRQ_NONE;
+}
+
+  /* chip-specific constructor
+   * (see "Management of Cards and Components")
+   */
+static int snd_falconi2s_create(struct snd_card *card,
+                                         struct drm_device *dev,
+                                         struct sm768chip **rchip)
+{
+	int err;
+	struct pci_dev *pci = dev->pdev;
+	struct smi_device *smi_device = dev->dev_private;
+	struct sm768chip *chip;
+	static struct snd_device_ops ops = {
+		.dev_free = snd_falconi2s_dev_free,
+	};
+
+	*rchip = NULL;
+
+	/* allocate a chip-specific data with zero filled */
+	chip = kzalloc(sizeof(*chip), GFP_KERNEL);
+	if (chip == NULL)
+		return -ENOMEM;
+
+	chip->card = card;
+
+	err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops);
+	if (err < 0) {
+		snd_falconi2s_free(chip);
+		return err;
+	}
+	
+	//map register
+	chip->vidreg_start = smi_device->rmmio_base;
+	chip->vidreg_size = smi_device->rmmio_size;
+	dbg_msg("Audio MMIO phyAddr = 0x%x\n",chip->vidreg_start);
+
+	chip->pvReg = smi_device->rmmio;
+	dbg_msg("Audio MMIO virtual addr = %p\n",chip->pvReg);
+
+	//map video memory.
+	chip->vidmem_start = smi_device->mc.vram_base;
+	chip->vidmem_size = 0x200000;   // change the video memory temperarily
+	dbg_msg("video memory phyAddr = 0x%x, size = (Dec)%d bytes\n",
+	chip->vidmem_start,chip->vidmem_size);
+	chip->pvMem = ioremap_wc(chip->vidmem_start,chip->vidmem_size);
+
+	if(!chip->pvMem){
+		err_msg("Map video memory failed\n");
+		snd_falconi2s_free(chip);
+		err = -EFAULT;
+		return err;
+	}else{
+		dbg_msg("Audio video memory virtual addr = %p\n",chip->pvMem);
+	}
+	//above 
+
+	chip->irq = pci->irq;
+
+	dbg_msg("Audio pci irq :%d\n",chip->irq);
+
+
+	if(SM768_AudioInit(SAMPLE_BITS, SAMPLE_RATE)) {
+		err_msg("Audio init failed!\n");	
+		snd_falconi2s_free(chip);
+		return -1;
+	}
+
+	chip_irq_id=chip;/*Record chip_irq_id which will use in free_irq*/
+	dbg_msg("chip_irq_id=%d\n", chip_irq_id);
+
+	iisClearRawInt();//clear int
+
+	//Setup ISR. The ISR will move more data from DDR to SRAM.
+	
+	if (request_irq(pci->irq, snd_smi_interrupt, IRQF_SHARED,
+		KBUILD_MODNAME, chip_irq_id)) {
+		err_msg("unable to grab IRQ %d\n", pci->irq);
+		snd_falconi2s_free(chip);
+		return -EBUSY;
+	}
+	sb_IRQUnmask(SB_IRQ_VAL_I2S); 
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(3,18,0)
+	snd_card_set_dev(card, &pci->dev);
+#endif
+
+	*rchip = chip;
+	return 0;
+}
+
+
+int smi_audio_init(struct drm_device *dev)
+{
+
+	int idx, ret, err;
+	struct pci_dev *pci = dev->pdev;
+	struct snd_pcm *pcm;
+	struct snd_card *card;
+	struct sm768chip *chip;
+	
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,16,0)
+	err = snd_card_new(&pci->dev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1, THIS_MODULE, 0, &card);
+#else
+	err = snd_card_create(-1, 0, THIS_MODULE, 0, &card);
+#endif
+	
+	if (err < 0)
+		return err;
+
+	err = snd_falconi2s_create(card, dev, &chip);
+	if (err < 0) {
+		snd_card_free(card);
+      		return err;
+	}
+
+	strcpy(card->driver, "SiliconMotion Audio");
+	strcpy(card->shortname, "SMI Audio");
+	strcpy(card->longname, "SiliconMotion Audio");
+
+	snd_pcm_new(card,"smiaudio_pcm",0,1,0,&pcm);
+	pcm->private_data = chip;
+
+      
+	/* set operators */
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,
+                          &snd_falconi2s_playback_ops);
+	  
+	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
+                                                snd_dma_pci_data(pci),
+						P_PERIOD_BYTE*P_PERIOD_MIN, P_PERIOD_BYTE*P_PERIOD_MAX);
+
+	strcpy(card->mixername, "SiliconMotion Audio Mixer Control");
+	
+	for (idx = 0; idx < ARRAY_SIZE(falconi2s_vol); idx++) {
+		if ((err = snd_ctl_add(card,snd_ctl_new1(&falconi2s_vol[idx], chip))) < 0)
+		{
+			return err;
+		}
+	}
+
+	
+	err = snd_card_register(card);
+	if (err < 0) {
+		snd_card_free(card);
+		return err;
+	}
+
+	pci_set_drvdata(pci, card);
+
+	return 0;
+
+}
+
+void smi_audio_remove(struct drm_device *dev)
+{
+	struct pci_dev *pci = dev->pdev;
+	struct snd_card *card;
+
+	inf_msg("smi_pci_remove\n");
+	card = pci_get_drvdata(pci);
+	
+	dbg_msg("perpare to free irq, pci irq :%d, chip_irq_id=%d\n", pci->irq, chip_irq_id);
+	if(pci->irq){				
+		free_irq(pci->irq, chip_irq_id);
+		dbg_msg("free irq\n");
+	}
+
+	SM768_AudioDeinit();
+	
+	snd_card_free(card);
+	pci_set_drvdata(pci, NULL);
+	iounmap(chip_irq_id->pvMem);
+}
+
diff --git a/drivers/gpu/drm/smi/smi_snd.h b/drivers/gpu/drm/smi/smi_snd.h
new file mode 100644
index 000000000000..fa3c6f2c7354
--- /dev/null
+++ b/drivers/gpu/drm/smi/smi_snd.h
@@ -0,0 +1,90 @@
+/*
+ * Copyright (C) 2016 SiliconMotion Inc.
+ *
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License v2. See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+#ifndef __SMI_SOUND_H__
+#define __SMI_SOUND_H__
+
+#include <linux/ioport.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <sound/control.h>
+#include <sound/pcm.h>
+#include <sound/core.h>
+#include <sound/initval.h>
+
+
+//#define SAVE_AUDIO_DATA
+
+
+/* definition of the chip-specific record */
+struct sm768chip {
+	struct snd_card *card;
+	struct pci_dev *pci;
+
+	unsigned long port;
+	int irq;
+
+	struct snd_pcm_substream *substream;
+	unsigned long pos;
+	
+	volatile unsigned char __iomem *pvReg;
+	unsigned char __iomem *pvMem;
+
+	unsigned long vidreg_start;
+	unsigned long vidreg_size;	
+	unsigned long vidmem_start;
+	unsigned long vidmem_size;
+
+	spinlock_t lock;
+
+	//master playback volume and capture volume
+	u8 playback_vol;//only record one channel, right=left
+	u8 capture_vol;
+	u8 playback_switch;//only record one channel, right=left
+	u8 capture_switch;
+	
+};
+
+#if 0
+struct sm768_runtime_data_father{
+	struct sm768_runtime_data * play_data;
+	struct sm768_runtime_data * capture_data;
+};
+
+struct sm768_runtime_data {
+	spinlock_t lock;
+	struct sm768chip *params;
+	struct snd_pcm_substream *psubstream;
+	unsigned long ppointer; /* playback pointer in bytes */
+	struct snd_pcm_substream *csubstream;
+	unsigned long cpointer; /* capture buffer pointer in bytes */
+};
+#endif
+
+/* For playback hw parameter*/
+#define P_PERIOD_BYTE 		  1024
+#define P_PERIOD_MIN 		  16
+#define P_PERIOD_MAX 		  256
+
+#define FEATURES	          2/* 1:only output; 2:output and input */
+#define SRAM_TOTAL_SIZE	  	  0x1000
+#define SAMPLE_RATE		  	  44100
+#define SAMPLE_BITS		  	  16
+#define SECTIONS_NUM	  	  2
+#define STEREO			  	  2
+#define MONO				  1
+
+#define SRAM_OUTPUT_SIZE	  (SRAM_TOTAL_SIZE/FEATURES)
+#define SRAM_INPUT_SIZE	  	  (SRAM_TOTAL_SIZE/FEATURES)
+#define SRAM_SECTION_SIZE     (SRAM_OUTPUT_SIZE/OUTPUT_SRAM_SECTIONS_NUM)
+#define SRAM_SECTION_SIZE_DWORDS  ((SRAM_SECTION_SIZE/4)-1)
+#define OUTPUT_SRAM_SECTIONS_NUM  SECTIONS_NUM
+
+
+#endif				/* __SMI_DRV_H__ */
diff --git a/drivers/gpu/drm/smi/smi_ttm.c b/drivers/gpu/drm/smi/smi_ttm.c
new file mode 100644
index 000000000000..06a1d7c07b38
--- /dev/null
+++ b/drivers/gpu/drm/smi/smi_ttm.c
@@ -0,0 +1,561 @@
+/*
+ * Copyright 2016 SiliconMotion Inc.
+ *
+ * This file is subject to the terms and conditions of the GNU General
+ * Public License version 2. See the file COPYING in the main
+ * directory of this archive for more details.
+ *
+ */
+ 
+#include <drm/drmP.h>
+#include <ttm/ttm_page_alloc.h>
+#include "smi_drv.h"
+
+static inline struct smi_device *
+smi_bdev(struct ttm_bo_device *bd)
+{
+	return container_of(bd, struct smi_device, ttm.bdev);
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,0,0)
+static int
+smi_ttm_mem_global_init(struct drm_global_reference *ref)
+{
+	return ttm_mem_global_init(ref->object);
+}
+
+static void
+smi_ttm_mem_global_release(struct drm_global_reference *ref)
+{
+	ttm_mem_global_release(ref->object);
+}
+
+static int smi_ttm_global_init(struct smi_device *smi)
+{
+	struct drm_global_reference *global_ref;
+	int r;
+
+	global_ref = &smi->ttm.mem_global_ref;
+	global_ref->global_type = DRM_GLOBAL_TTM_MEM;
+	global_ref->size = sizeof(struct ttm_mem_global);
+	global_ref->init = &smi_ttm_mem_global_init;
+	global_ref->release = &smi_ttm_mem_global_release;
+	r = drm_global_item_ref(global_ref);
+	if (r != 0) {
+		DRM_ERROR("Failed setting up TTM memory accounting "
+			  "subsystem.\n");
+		return r;
+	}
+
+	smi->ttm.bo_global_ref.mem_glob =
+		smi->ttm.mem_global_ref.object;
+	global_ref = &smi->ttm.bo_global_ref.ref;
+	global_ref->global_type = DRM_GLOBAL_TTM_BO;
+	global_ref->size = sizeof(struct ttm_bo_global);
+	global_ref->init = &ttm_bo_global_init;
+	global_ref->release = &ttm_bo_global_release;
+	r = drm_global_item_ref(global_ref);
+	if (r != 0) {
+		DRM_ERROR("Failed setting up TTM BO subsystem.\n");
+		drm_global_item_unref(&smi->ttm.mem_global_ref);
+		return r;
+	}
+	return 0;
+}
+
+void
+smi_ttm_global_release(struct smi_device *smi)
+{
+	if (smi->ttm.mem_global_ref.release == NULL)
+		return;
+
+	drm_global_item_unref(&smi->ttm.bo_global_ref.ref);
+	drm_global_item_unref(&smi->ttm.mem_global_ref);
+	smi->ttm.mem_global_ref.release = NULL;
+}
+#endif
+
+void smi_bo_ttm_destroy(struct ttm_buffer_object *tbo)
+{
+	struct smi_bo *bo;
+
+	bo = container_of(tbo, struct smi_bo, bo);
+
+	drm_gem_object_release(&bo->gem);
+	kfree(bo);
+}
+
+bool smi_ttm_bo_is_smi_bo(struct ttm_buffer_object *bo)
+{
+	if (bo->destroy == &smi_bo_ttm_destroy)
+		return true;
+	return false;
+}
+
+static int
+smi_bo_init_mem_type(struct ttm_bo_device *bdev, uint32_t type,
+		     struct ttm_mem_type_manager *man)
+{
+	switch (type) {
+	case TTM_PL_SYSTEM:
+		man->flags = TTM_MEMTYPE_FLAG_MAPPABLE;
+		man->available_caching = TTM_PL_MASK_CACHING;
+		man->default_caching = TTM_PL_FLAG_CACHED;
+		break;
+	case TTM_PL_VRAM:
+		man->func = &ttm_bo_manager_func;
+		man->flags = TTM_MEMTYPE_FLAG_FIXED |
+			TTM_MEMTYPE_FLAG_MAPPABLE;
+#ifdef NO_WC
+		man->available_caching = TTM_PL_FLAG_UNCACHED;
+		man->default_caching = TTM_PL_FLAG_UNCACHED;
+#else
+		man->available_caching = TTM_PL_FLAG_UNCACHED |
+			TTM_PL_FLAG_WC;
+		man->default_caching = TTM_PL_FLAG_WC;
+#endif
+		break;
+	default:
+		DRM_ERROR("Unsupported memory type %u\n", (unsigned)type);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static void
+smi_bo_evict_flags(struct ttm_buffer_object *bo, struct ttm_placement *pl)
+{
+	struct smi_bo *smibo = smi_bo(bo);
+
+	if (!smi_ttm_bo_is_smi_bo(bo))
+		return;
+
+	smi_ttm_placement(smibo, TTM_PL_FLAG_SYSTEM);
+	*pl = smibo->placement;
+}
+
+static int smi_bo_verify_access(struct ttm_buffer_object *bo, struct file *filp)
+{
+	struct smi_bo *smibo = smi_bo(bo);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,12,0)
+	return 0;
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(4,9,0)
+	return drm_vma_node_verify_access(&smibo->gem.vma_node, filp);
+#else
+	return drm_vma_node_verify_access(&smibo->gem.vma_node, filp->private_data);
+#endif
+}
+
+static int smi_ttm_io_mem_reserve(struct ttm_bo_device *bdev,
+				  struct ttm_mem_reg *mem)
+{
+	struct ttm_mem_type_manager *man = &bdev->man[mem->mem_type];
+	struct smi_device *smi = smi_bdev(bdev);
+
+	mem->bus.addr = NULL;
+	mem->bus.offset = 0;
+	mem->bus.size = mem->num_pages << PAGE_SHIFT;
+	mem->bus.base = 0;
+	mem->bus.is_iomem = false;
+	if (!(man->flags & TTM_MEMTYPE_FLAG_MAPPABLE))
+		return -EINVAL;
+	switch (mem->mem_type) {
+	case TTM_PL_SYSTEM:
+		/* system memory */
+		return 0;
+	case TTM_PL_VRAM:
+		mem->bus.offset = mem->start << PAGE_SHIFT;
+		mem->bus.base = pci_resource_start(smi->dev->pdev, 0);
+		mem->bus.is_iomem = true;
+		break;
+	default:
+		return -EINVAL;
+		break;
+	}
+	return 0;
+}
+
+static void smi_ttm_io_mem_free(struct ttm_bo_device *bdev, struct ttm_mem_reg *mem)
+{
+}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,8,0)
+static int smi_bo_move(struct ttm_buffer_object *bo,
+		       bool evict, bool interruptible,
+		       bool no_wait_gpu,
+		       struct ttm_mem_reg *new_mem)
+{
+	int r;
+	r = ttm_bo_move_memcpy(bo, evict, no_wait_gpu, new_mem);
+	return r;
+}
+#endif
+
+static void smi_ttm_backend_destroy(struct ttm_tt *tt)
+{
+	ttm_tt_fini(tt);
+	kfree(tt);
+}
+
+static struct ttm_backend_func smi_tt_backend_func = {
+	.destroy = &smi_ttm_backend_destroy,
+};
+
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4,16,0)
+struct ttm_tt *smi_ttm_tt_create(struct ttm_buffer_object *bo, uint32_t page_flags)
+#else
+struct ttm_tt *smi_ttm_tt_create(struct ttm_bo_device *bdev, unsigned long size,
+				 uint32_t page_flags, struct page *dummy_read_page)
+#endif
+{
+	struct ttm_tt *tt;
+
+	tt = kzalloc(sizeof(struct ttm_tt), GFP_KERNEL);
+	if (tt == NULL)
+		return NULL;
+	tt->func = &smi_tt_backend_func;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4,16,0)
+	if (ttm_tt_init(tt, bo, page_flags)) {
+#else
+	if (ttm_tt_init(tt, bdev, size, page_flags, dummy_read_page)) {
+#endif
+		kfree(tt);
+		return NULL;
+	}
+	return tt;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,15,0)
+static int smi_ttm_tt_populate(struct ttm_tt *ttm)
+#else
+static int smi_ttm_tt_populate(struct ttm_tt *ttm, struct ttm_operation_ctx *ctx)
+#endif
+{
+	bool slave = !!(ttm->page_flags & TTM_PAGE_FLAG_SG);
+
+	if (ttm->state != tt_unpopulated)
+ 		return 0;
+
+	if (slave && ttm->sg) {
+		drm_prime_sg_to_page_addr_arrays(ttm->sg, ttm->pages,
+						 NULL, ttm->num_pages);
+		ttm->state = tt_unbound;
+		return 0;
+	}
+	
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,15,0)
+	return ttm_pool_populate(ttm);
+#else
+	return ttm_pool_populate(ttm, ctx);
+#endif
+}
+
+static void smi_ttm_tt_unpopulate(struct ttm_tt *ttm)
+{
+	bool slave = !!(ttm->page_flags & TTM_PAGE_FLAG_SG);
+
+	if (slave)
+		return;
+
+	ttm_pool_unpopulate(ttm);
+}
+
+struct ttm_bo_driver smi_bo_driver = {
+	.ttm_tt_create = smi_ttm_tt_create,
+	.ttm_tt_populate = smi_ttm_tt_populate,
+	.ttm_tt_unpopulate = smi_ttm_tt_unpopulate,
+	.init_mem_type = smi_bo_init_mem_type,
+	.evict_flags = smi_bo_evict_flags,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,10,0)
+	.eviction_valuable = ttm_bo_eviction_valuable,
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,8,0)
+	.move = smi_bo_move,
+#else
+	.move = NULL,
+#endif
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,7,0) && LINUX_VERSION_CODE < KERNEL_VERSION(4,11,0))
+	.lru_tail = &ttm_bo_default_lru_tail,
+	.swap_lru_tail = &ttm_bo_default_swap_lru_tail,
+#endif
+	.verify_access = smi_bo_verify_access,
+	.io_mem_reserve = &smi_ttm_io_mem_reserve,
+	.io_mem_free = &smi_ttm_io_mem_free,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,11,0) && LINUX_VERSION_CODE < KERNEL_VERSION(4,15,0))
+	.io_mem_pfn = ttm_bo_default_io_mem_pfn,
+#endif
+};
+
+int smi_mm_init(struct smi_device *smi)
+{
+	int ret;
+	struct drm_device *dev = smi->dev;
+	struct ttm_bo_device *bdev = &smi->ttm.bdev;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,0,0)
+	ret = smi_ttm_global_init(smi);
+	if (ret)
+		return ret;
+#endif
+
+	ret = ttm_bo_device_init(&smi->ttm.bdev,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,0,0)
+				 smi->ttm.bo_global_ref.ref.object,
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,14,0)
+				 &smi_bo_driver, DRM_FILE_PAGE_OFFSET,
+				 smi->need_dma32);
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(5,2,0)
+				 &smi_bo_driver, dev->anon_inode->i_mapping,
+				 DRM_FILE_PAGE_OFFSET,smi->need_dma32);
+#else
+				 &smi_bo_driver, dev->anon_inode->i_mapping,
+				 smi->need_dma32);
+#endif				 
+	if (ret) {
+		DRM_ERROR("Error initialising bo driver; %d\n", ret);
+		return ret;
+	}
+
+	if(g_specId == SPC_SM750)  //SM750 has only 16MB vram. We have to report 64MB vram for the prime function.
+		ret = ttm_bo_init_mm(bdev, TTM_PL_VRAM,
+			     0x4000000 >> PAGE_SHIFT);
+	else
+		ret = ttm_bo_init_mm(bdev, TTM_PL_VRAM,
+			     smi->mc.vram_size >> PAGE_SHIFT);
+
+	if (ret) {
+		DRM_ERROR("Failed ttm VRAM init: %d\n", ret);
+		return ret;
+	}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,9,0)
+	arch_io_reserve_memtype_wc(pci_resource_start(dev->pdev, 0),
+				   pci_resource_len(dev->pdev, 0));
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,11,0)
+ 	smi->fb_mtrr = arch_phys_wc_add(pci_resource_start(dev->pdev, 0),
+					   pci_resource_len(dev->pdev, 0));
+#endif
+ 	smi->mm_inited = true;
+	return 0;
+}
+
+void smi_mm_fini(struct smi_device *smi)
+{
+	struct drm_device *dev = smi->dev;
+	
+	if (!smi->mm_inited)
+		return;
+ 	ttm_bo_device_release(&smi->ttm.bdev);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,0,0)
+ 	smi_ttm_global_release(smi);
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,9,0)
+	arch_io_free_memtype_wc(pci_resource_start(dev->pdev, 0),
+				pci_resource_len(dev->pdev, 0));
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,11,0)
+ 	arch_phys_wc_del(smi->fb_mtrr);
+#endif
+	smi->fb_mtrr = 0;
+}
+
+void smi_ttm_placement(struct smi_bo *bo, int domain)
+{
+	u32 c = 0;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0) // Loongson backport from 3.18
+	unsigned i;
+	bo->placement.placement = bo->placements;
+	bo->placement.busy_placement = bo->placements;
+	if (domain & TTM_PL_FLAG_VRAM)
+#ifdef NO_WC
+		bo->placements[c++].flags = TTM_PL_FLAG_UNCACHED | TTM_PL_FLAG_VRAM;
+#else
+		bo->placements[c++].flags = TTM_PL_FLAG_WC | TTM_PL_FLAG_UNCACHED | TTM_PL_FLAG_VRAM;
+#endif
+	if (domain & TTM_PL_FLAG_SYSTEM)
+		bo->placements[c++].flags = TTM_PL_MASK_CACHING | TTM_PL_FLAG_SYSTEM;
+	if (!c)
+		bo->placements[c++].flags = TTM_PL_MASK_CACHING | TTM_PL_FLAG_SYSTEM;
+	bo->placement.num_placement = c;
+	bo->placement.num_busy_placement = c;
+	for (i = 0; i < c; ++i) {
+		bo->placements[i].fpfn = 0;
+		bo->placements[i].lpfn = 0;
+	}
+#else	
+	bo->placement.fpfn = 0;
+	bo->placement.lpfn = 0;
+	bo->placement.placement = bo->placements;
+	bo->placement.busy_placement = bo->placements;
+	if (domain & TTM_PL_FLAG_VRAM)
+#ifdef NO_WC
+		bo->placements[c++] = TTM_PL_FLAG_UNCACHED | TTM_PL_FLAG_VRAM;
+#else
+		bo->placements[c++] = TTM_PL_FLAG_WC | TTM_PL_FLAG_UNCACHED | TTM_PL_FLAG_VRAM;
+#endif
+	if (domain & TTM_PL_FLAG_SYSTEM)
+		bo->placements[c++] = TTM_PL_MASK_CACHING | TTM_PL_FLAG_SYSTEM;
+	if (!c)
+		bo->placements[c++] = TTM_PL_MASK_CACHING | TTM_PL_FLAG_SYSTEM;
+	bo->placement.num_placement = c;
+	bo->placement.num_busy_placement = c;
+#endif
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,18,0)
+int smi_bo_create(struct drm_device *dev, int size, int align,
+		  uint32_t flags, struct sg_table *sg, struct smi_bo **psmibo)
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(5,4,0)
+int smi_bo_create(struct drm_device *dev, int size, int align,
+		  uint32_t flags, struct sg_table *sg, struct reservation_object *resv, struct smi_bo **psmibo)
+#else
+int smi_bo_create(struct drm_device *dev, int size, int align,
+		  uint32_t flags, struct sg_table *sg, struct dma_resv *resv, struct smi_bo **psmibo)
+#endif
+{
+	struct smi_device *smi = dev->dev_private;
+	struct smi_bo *smibo;
+	size_t acc_size;
+	enum ttm_bo_type type;
+	int ret;
+
+	*psmibo = NULL;
+
+	if (sg) {
+		type = ttm_bo_type_sg;
+	} else {
+		type = ttm_bo_type_device;
+	}
+
+
+	smibo = kzalloc(sizeof(struct smi_bo), GFP_KERNEL);
+	if (!smibo)
+		return -ENOMEM;
+
+	ret = drm_gem_object_init(dev, &smibo->gem, size);
+	if (ret)
+		goto error;
+	
+
+	smibo->bo.bdev = &smi->ttm.bdev;
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(3,14,0)	
+	smibo->bo.bdev->dev_mapping = dev->dev_mapping;
+#endif
+	smi_ttm_placement(smibo, TTM_PL_FLAG_VRAM | TTM_PL_FLAG_SYSTEM);
+
+	acc_size = ttm_bo_dma_acc_size(&smi->ttm.bdev, size,
+				       sizeof(struct smi_bo));
+
+	ret = ttm_bo_init(&smi->ttm.bdev, &smibo->bo, size,
+			  type, &smibo->placement,
+			  align >> PAGE_SHIFT, false,
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(4,16,0)
+			  NULL,
+#endif
+			  acc_size, sg,
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3,18,0)
+			  resv,
+#endif
+			  smi_bo_ttm_destroy);
+	if (ret)
+		goto error;
+	
+
+	*psmibo = smibo;
+	 return 0;
+
+error:
+	kfree(smibo);
+	return ret;
+}
+
+static inline u64 smi_bo_gpu_offset(struct smi_bo *bo)
+{
+	return bo->bo.offset;
+}
+
+int smi_bo_pin(struct smi_bo *bo, u32 pl_flag, u64 *gpu_addr)
+{
+	int i, ret;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,15,0)
+	struct ttm_operation_ctx ctx = { false, false };
+#endif
+
+	if (bo->pin_count) {
+		bo->pin_count++;
+		if (gpu_addr)
+			*gpu_addr = smi_bo_gpu_offset(bo);
+	}
+
+	smi_ttm_placement(bo, pl_flag);
+	for (i = 0; i < bo->placement.num_placement; i++)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0) // Loongson backport from 3.18
+		bo->placements[i].flags |= TTM_PL_FLAG_NO_EVICT;
+#else
+		bo->placements[i] |= TTM_PL_FLAG_NO_EVICT;
+#endif		
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,15,0)
+	ret = ttm_bo_validate(&bo->bo, &bo->placement, &ctx);
+#else
+	ret = ttm_bo_validate(&bo->bo, &bo->placement, false, false);
+#endif
+	if (ret)
+		return ret;
+
+	bo->pin_count = 1;
+	if (gpu_addr)
+		*gpu_addr = smi_bo_gpu_offset(bo);
+	return 0;
+}
+
+int smi_bo_unpin(struct smi_bo *bo)
+{
+	int i, ret;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,15,0)
+	struct ttm_operation_ctx ctx = { false, false };
+#endif
+	if (!bo->pin_count) {
+		dbg_msg("unpin bad %p\n", bo);
+		return 0;
+	}
+	bo->pin_count--;
+	if (bo->pin_count)
+		return 0;
+
+	for (i = 0; i < bo->placement.num_placement ; i++)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0) // Loongson backport from 3.18
+		bo->placements[i].flags &= ~TTM_PL_FLAG_NO_EVICT;
+#else
+		bo->placements[i] &= ~TTM_PL_FLAG_NO_EVICT;
+#endif		
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,15,0)
+	ret = ttm_bo_validate(&bo->bo, &bo->placement, &ctx);
+#else
+	ret = ttm_bo_validate(&bo->bo, &bo->placement, false, false);
+#endif
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+
+int smi_mmap(struct file *filp, struct vm_area_struct *vma)
+{
+	struct drm_file *file_priv;
+	struct smi_device *smi;
+
+	if (unlikely(vma->vm_pgoff < DRM_FILE_PAGE_OFFSET))
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3,14,0)	
+		return -EINVAL;
+#else
+		return drm_mmap(filp, vma);
+#endif		
+
+	file_priv = filp->private_data;
+	smi = file_priv->minor->dev->dev_private;
+	return ttm_bo_mmap(filp, vma, &smi->ttm.bdev);
+}
+
-- 
2.31.1

