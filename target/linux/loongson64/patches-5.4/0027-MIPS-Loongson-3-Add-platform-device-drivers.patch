From 7bc88ba023340a1650ca2650ac2dbb81fd6359d5 Mon Sep 17 00:00:00 2001
From: Huacai Chen <chenhc@lemote.com>
Date: Thu, 1 Dec 2016 09:51:35 +0800
Subject: [PATCH 027/131] MIPS: Loongson 3: Add platform device drivers

Platform device drivers include temperature sensor (EMC1412, TMP75,
LM93), fan controllers (SB700/SB710/SB800 chipset, WPCE775L EC) and
laptop driver (Hot key, battery, etc.)

Signed-off-by: Huacai Chen <chenhc@lemote.com>
---
 .../asm/mach-loongson64/loongson_hwmon.h      |    6 +-
 arch/mips/loongson64/loongson-3/platform.c    |   57 +
 drivers/hwmon/lm93.c                          |   24 +-
 drivers/platform/mips/Kconfig                 |   16 +
 drivers/platform/mips/Makefile                |    3 +
 drivers/platform/mips/emc1412.c               |  454 +++++++
 drivers/platform/mips/lemote3a-laptop.c       | 1179 +++++++++++++++++
 drivers/platform/mips/sbx00_fan.c             |  767 +++++++++++
 drivers/platform/mips/sd5075.c                |  211 +++
 drivers/platform/mips/tmp75.c                 |   24 +
 drivers/platform/mips/wpce_fan.c              |  311 +++++
 11 files changed, 3049 insertions(+), 3 deletions(-)
 create mode 100644 drivers/platform/mips/emc1412.c
 create mode 100644 drivers/platform/mips/lemote3a-laptop.c
 create mode 100644 drivers/platform/mips/sbx00_fan.c
 create mode 100644 drivers/platform/mips/sd5075.c
 create mode 100644 drivers/platform/mips/tmp75.c
 create mode 100644 drivers/platform/mips/wpce_fan.c

diff --git a/arch/mips/include/asm/mach-loongson64/loongson_hwmon.h b/arch/mips/include/asm/mach-loongson64/loongson_hwmon.h
index 545f91f2ae16..c1fa61ad483b 100644
--- a/arch/mips/include/asm/mach-loongson64/loongson_hwmon.h
+++ b/arch/mips/include/asm/mach-loongson64/loongson_hwmon.h
@@ -36,7 +36,7 @@ struct temp_range {
 struct loongson_fan_policy {
 	u8	type;
 
-	/* percent only used when type is CONSTANT_SPEED_POLICY */
+	/* CONSTANT_SPEED_POLICY: actual perenct, STEP_SPEED_POLICY: maximum percent */
 	u8	percent;
 
 	/* period between two check. (Unit: S) */
@@ -53,4 +53,8 @@ struct loongson_fan_policy {
 	struct delayed_work work;
 };
 
+extern struct loongson_fan_policy kernel_helper_policy;
+extern struct loongson_fan_policy step_speed_policy;
+extern struct loongson_fan_policy constant_speed_policy;
+
 #endif /* __LOONGSON_HWMON_H_*/
diff --git a/arch/mips/loongson64/loongson-3/platform.c b/arch/mips/loongson64/loongson-3/platform.c
index 9674ae1361a8..397101b8ff34 100644
--- a/arch/mips/loongson64/loongson-3/platform.c
+++ b/arch/mips/loongson64/loongson-3/platform.c
@@ -14,6 +14,63 @@
 #include <loongson_hwmon.h>
 #include <workarounds.h>
 
+/*
+ * Kernel helper policy
+ *
+ * Fan is controlled by EC in laptop pruducts, but EC can not get the current
+ * cpu temperature which used for adjusting the current fan speed.
+ *
+ * So, kernel read the CPU temperature and notify it to EC per second,
+ * that's all!
+ */
+struct loongson_fan_policy kernel_helper_policy = {
+	.type = KERNEL_HELPER_POLICY,
+	.adjust_period = 1,
+	.depend_temp = loongson3_cpu_temp,
+};
+
+/*
+ * Policy at step mode
+ *
+ * up_step array    |   down_step array
+ *                  |
+ * [min, 50),  50%  |   (min, 45),  50%
+ * [50,  60),  60%  |   [45,  55),  60%
+ * [60,  70),  70%  |   [55,  65),  70%
+ * [70,  80),  80%  |   [65,  75),  80%
+ * [80,  max), 100% |   [75,  max), 100%
+ *
+ */
+struct loongson_fan_policy step_speed_policy = {
+	.type = STEP_SPEED_POLICY,
+	.adjust_period = 1,
+	.depend_temp = loongson3_cpu_temp,
+	.up_step_num = 5,
+	.down_step_num = 5,
+	.up_step = {
+			{MIN_TEMP, 50,    50},
+			{   50,    60,    60},
+			{   60,    70,    70},
+			{   70,    80,    80},
+			{   80, MAX_TEMP, 100},
+		   },
+	.down_step = {
+			{MIN_TEMP, 45,    50},
+			{   45,    55,    60},
+			{   55,    65,    70},
+			{   65,    75,    80},
+			{   75, MAX_TEMP, 100},
+		     },
+};
+
+/*
+ * Constant speed policy
+ *
+ */
+struct loongson_fan_policy constant_speed_policy = {
+	.type = CONSTANT_SPEED_POLICY,
+};
+
 static int __init loongson3_platform_init(void)
 {
 	int i;
diff --git a/drivers/hwmon/lm93.c b/drivers/hwmon/lm93.c
index cea8ea323271..6054cabceb12 100644
--- a/drivers/hwmon/lm93.c
+++ b/drivers/hwmon/lm93.c
@@ -2497,8 +2497,9 @@ ATTRIBUTE_GROUPS(lm93);
 
 static void lm93_init_client(struct i2c_client *client)
 {
-	int i;
-	u8 reg;
+	int i, nr;
+	u8 reg, ctl2, ctl4;
+	struct lm93_data *data = i2c_get_clientdata(client);
 
 	/* configure VID pin input thresholds */
 	reg = lm93_read_byte(client, LM93_REG_GPI_VID_CTL);
@@ -2529,6 +2530,25 @@ static void lm93_init_client(struct i2c_client *client)
 	reg = lm93_read_byte(client, LM93_REG_CONFIG);
 	lm93_write_byte(client, LM93_REG_CONFIG, reg | 0x01);
 
+	mutex_lock(&data->update_lock);
+	for (nr = 0; nr < 2; nr++) {
+		/* set manual mode */
+		ctl2 = lm93_read_byte(client, LM93_REG_PWM_CTL(nr, LM93_PWM_CTL2));
+		ctl2 |= 0x01;
+		lm93_write_byte(client, LM93_REG_PWM_CTL(nr, LM93_PWM_CTL2), ctl2);
+		/* set fanspeed 50% */
+		ctl2 = lm93_read_byte(client, LM93_REG_PWM_CTL(nr, LM93_PWM_CTL2));
+		ctl4 = lm93_read_byte(client, LM93_REG_PWM_CTL(nr, LM93_PWM_CTL4));
+		ctl2 = (ctl2 & 0x0f) | LM93_PWM_TO_REG(0x80, (ctl4 & 0x07) ?
+				LM93_PWM_MAP_LO_FREQ : LM93_PWM_MAP_HI_FREQ) << 4;
+		/* save user commanded value */
+		data->pwm_override[nr] = LM93_PWM_FROM_REG(ctl2 >> 4,
+				(ctl4 & 0x07) ?  LM93_PWM_MAP_LO_FREQ :
+				LM93_PWM_MAP_HI_FREQ);
+		lm93_write_byte(client, LM93_REG_PWM_CTL(nr, LM93_PWM_CTL2), ctl2);
+	}
+	mutex_unlock(&data->update_lock);
+
 	/* spin until ready */
 	for (i = 0; i < 20; i++) {
 		msleep(10);
diff --git a/drivers/platform/mips/Kconfig b/drivers/platform/mips/Kconfig
index 62ea1934fb6a..fc92b77240d2 100644
--- a/drivers/platform/mips/Kconfig
+++ b/drivers/platform/mips/Kconfig
@@ -24,4 +24,20 @@ config CPU_HWMON
 	help
 	  Loongson-3A/3B CPU Hwmon (temperature sensor) driver.
 
+config LEMOTE3A_LAPTOP
+	tristate "Lemote Loongson-3A Laptop Driver"
+	depends on LOONGSON_MACH3X
+	select BACKLIGHT_LCD_SUPPORT
+	select LCD_CLASS_DEVICE
+	select BACKLIGHT_CLASS_DEVICE
+	select POWER_SUPPLY
+	select HWMON
+	select VIDEO_OUTPUT_CONTROL
+	select INPUT_SPARSEKMAP
+	select INPUT_EVDEV
+	depends on INPUT
+	default y
+	help
+	  Lemote Loongson-3A/2Gq family laptops driver.
+
 endif # MIPS_PLATFORM_DEVICES
diff --git a/drivers/platform/mips/Makefile b/drivers/platform/mips/Makefile
index be8146c20dc8..417cf5e80470 100644
--- a/drivers/platform/mips/Makefile
+++ b/drivers/platform/mips/Makefile
@@ -1,2 +1,5 @@
 # SPDX-License-Identifier: GPL-2.0-only
 obj-$(CONFIG_CPU_HWMON) += cpu_hwmon.o
+obj-$(CONFIG_I2C_PIIX4) += emc1412.o sd5075.o tmp75.o
+obj-$(CONFIG_CPU_HWMON) += wpce_fan.o sbx00_fan.o
+obj-$(CONFIG_LEMOTE3A_LAPTOP) += lemote3a-laptop.o
diff --git a/drivers/platform/mips/emc1412.c b/drivers/platform/mips/emc1412.c
new file mode 100644
index 000000000000..02f2284743ed
--- /dev/null
+++ b/drivers/platform/mips/emc1412.c
@@ -0,0 +1,454 @@
+#include <linux/i2c.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/reboot.h>
+#include <linux/delay.h>
+#include <linux/jiffies.h>
+#include <linux/platform_device.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+#include <loongson.h>
+#include <boot_param.h>
+#include <loongson_hwmon.h>
+
+#define MAX_EMC1412_CLIENTS 4
+#define EMC1412_THERMAL_THRESHOLD 90000
+
+#define EMC1412_TEMP_EXT_HI_REG 0x01
+#define EMC1412_TEMP_EXT_LO_REG 0x10
+#define EMC1412_TEMP_INT_HI_REG 0x00
+#define EMC1412_TEMP_INT_LO_REG 0x29
+#define EMC1412_THERM_LIMIT_EXT_REG 0x19
+#define EMC1412_THERM_LIMIT_INT_REG 0x20
+#define EMC1412_THERM_LIMIT_HYS_REG 0x21
+
+struct i2c_client *emc1412_client[MAX_EMC1412_CLIENTS] = {NULL};
+
+static struct device *emc1412_hwmon_dev;
+
+static ssize_t get_hwmon_name(struct device *dev,
+			struct device_attribute *attr, char *buf);
+static ssize_t get_emc1412_label(struct device *dev,
+			struct device_attribute *attr, char *buf);
+static ssize_t get_emc1412_temp(struct device *dev,
+			struct device_attribute *attr, char *buf);
+
+static ssize_t get_emc1412_crit(struct device *dev,
+			struct device_attribute *attr, char *buf);
+static ssize_t set_emc1412_crit(struct device *dev,
+			struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t get_emc1412_crit_hyst(struct device *dev,
+			struct device_attribute *attr, char *buf);
+static ssize_t set_emc1412_crit_hyst(struct device *dev,
+			struct device_attribute *attr, const char *buf, size_t count);
+
+static SENSOR_DEVICE_ATTR(name, S_IRUGO, get_hwmon_name, NULL, 0);
+
+static struct attribute *emc1412_hwmon_attributes[] =
+{
+	&sensor_dev_attr_name.dev_attr.attr,
+	NULL
+};
+
+/* Hwmon device attribute group */
+static struct attribute_group emc1412_hwmon_attribute_group =
+{
+	.attrs = emc1412_hwmon_attributes,
+};
+
+/* Hwmon device get name */
+static ssize_t get_hwmon_name(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "emc1412\n");
+}
+
+static SENSOR_DEVICE_ATTR(temp1_input, S_IRUGO, get_emc1412_temp, NULL, 1);
+static SENSOR_DEVICE_ATTR(temp1_label, S_IRUGO, get_emc1412_label, NULL, 1);
+static SENSOR_DEVICE_ATTR(temp1_crit, S_IRUGO | S_IWUSR, get_emc1412_crit, set_emc1412_crit, 1);
+static SENSOR_DEVICE_ATTR(temp1_crit_hyst, S_IRUGO | S_IWUSR, get_emc1412_crit_hyst, set_emc1412_crit_hyst, 1);
+
+static SENSOR_DEVICE_ATTR(temp2_input, S_IRUGO, get_emc1412_temp, NULL, 2);
+static SENSOR_DEVICE_ATTR(temp2_label, S_IRUGO, get_emc1412_label, NULL, 2);
+static SENSOR_DEVICE_ATTR(temp2_crit, S_IRUGO | S_IWUSR, get_emc1412_crit, set_emc1412_crit, 2);
+static SENSOR_DEVICE_ATTR(temp2_crit_hyst, S_IRUGO | S_IWUSR, get_emc1412_crit_hyst, set_emc1412_crit_hyst, 2);
+
+static SENSOR_DEVICE_ATTR(temp3_input, S_IRUGO, get_emc1412_temp, NULL, 3);
+static SENSOR_DEVICE_ATTR(temp3_label, S_IRUGO, get_emc1412_label, NULL, 3);
+static SENSOR_DEVICE_ATTR(temp3_crit, S_IRUGO | S_IWUSR, get_emc1412_crit, set_emc1412_crit, 3);
+static SENSOR_DEVICE_ATTR(temp3_crit_hyst, S_IRUGO | S_IWUSR, get_emc1412_crit_hyst, set_emc1412_crit_hyst, 3);
+
+static SENSOR_DEVICE_ATTR(temp4_input, S_IRUGO, get_emc1412_temp, NULL, 4);
+static SENSOR_DEVICE_ATTR(temp4_label, S_IRUGO, get_emc1412_label, NULL, 4);
+static SENSOR_DEVICE_ATTR(temp4_crit, S_IRUGO | S_IWUSR, get_emc1412_crit, set_emc1412_crit, 4);
+static SENSOR_DEVICE_ATTR(temp4_crit_hyst, S_IRUGO | S_IWUSR, get_emc1412_crit_hyst, set_emc1412_crit_hyst, 4);
+
+static const struct attribute *emc1412_hwmon_temp[4][5] = {
+	{
+		&sensor_dev_attr_temp1_input.dev_attr.attr,
+		&sensor_dev_attr_temp1_label.dev_attr.attr,
+		&sensor_dev_attr_temp1_crit.dev_attr.attr,
+		&sensor_dev_attr_temp1_crit_hyst.dev_attr.attr,
+		NULL
+	},
+
+	{
+		&sensor_dev_attr_temp2_input.dev_attr.attr,
+		&sensor_dev_attr_temp2_label.dev_attr.attr,
+		&sensor_dev_attr_temp2_crit.dev_attr.attr,
+		&sensor_dev_attr_temp2_crit_hyst.dev_attr.attr,
+		NULL
+	},
+
+	{
+		&sensor_dev_attr_temp3_input.dev_attr.attr,
+		&sensor_dev_attr_temp3_label.dev_attr.attr,
+		&sensor_dev_attr_temp3_crit.dev_attr.attr,
+		&sensor_dev_attr_temp3_crit_hyst.dev_attr.attr,
+		NULL
+	},
+
+	{
+		&sensor_dev_attr_temp4_input.dev_attr.attr,
+		&sensor_dev_attr_temp4_label.dev_attr.attr,
+		&sensor_dev_attr_temp4_crit.dev_attr.attr,
+		&sensor_dev_attr_temp4_crit_hyst.dev_attr.attr,
+		NULL
+	}
+};
+
+static int emc1412_probe(struct platform_device *dev)
+{
+	struct i2c_adapter *adapter = NULL;
+	struct i2c_board_info info;
+	int i = 0, r = 0, found = 0, id = dev->id - 1;
+	struct sensor_device *sdev = (struct sensor_device *)dev->dev.platform_data;
+
+	memset(&info, 0, sizeof(struct i2c_board_info));
+
+	adapter = i2c_get_adapter(i++);
+	while (adapter) {
+		if (strncmp(adapter->name, "SMBus PIIX4", 11) == 0) {
+			found = 1;
+			break;
+		}
+
+		adapter = i2c_get_adapter(i++);
+	}
+
+	if (!found)
+		goto fail;
+
+	info.addr = sdev->base_addr;
+	info.platform_data = dev->dev.platform_data;
+	strncpy(info.type, "emc1412", I2C_NAME_SIZE);
+	emc1412_client[id] = i2c_new_device(adapter, &info);
+	if (emc1412_client[id] == NULL) {
+		printk(KERN_ERR "failed to attach EMC1412 sensor\n");
+		goto fail;
+	}
+
+	r = sysfs_create_files(&emc1412_hwmon_dev->kobj, emc1412_hwmon_temp[id]);
+	if (r)
+		goto fail;
+
+	i2c_smbus_write_byte_data(emc1412_client[id], EMC1412_THERM_LIMIT_EXT_REG, (EMC1412_THERMAL_THRESHOLD / 1000 + 10));
+	i2c_smbus_write_byte_data(emc1412_client[id], EMC1412_THERM_LIMIT_INT_REG, (EMC1412_THERMAL_THRESHOLD / 1000 + 10));
+
+	printk(KERN_INFO "Success to attach EMC1412 sensor\n");
+
+	return 0;
+
+fail:
+	printk(KERN_ERR "Fail to found smbus controller attach EMC1412 sensor\n");
+
+	return r;
+}
+
+static void emc1412_shutdown(struct platform_device *dev)
+{
+	int id = dev->id - 1;
+
+	emc1412_client[id] = NULL;
+	msleep(15); /* Release I2C/SMBus resources */
+}
+
+/*
+ * emc1412 provide 2 temprature data
+ * Internal temprature: reg0.reg29
+ * External temprature: reg1.reg10
+ * reg0 & reg1 from 0 to 127
+ * reg1 & reg10 between (0.125, 0.875)
+ * to avoid use float, temprature will mult 1000
+ */
+int emc1412_internal_temp(int id)
+{
+	u8 reg;
+	int temp;
+	struct i2c_client *client;
+
+	if (id < 0 || !(client = emc1412_client[id]))
+		return NOT_VALID_TEMP;
+
+	reg = i2c_smbus_read_byte_data(client, EMC1412_TEMP_INT_LO_REG);
+	temp = i2c_smbus_read_byte_data(client, EMC1412_TEMP_INT_HI_REG) * 1000;
+	temp += (reg >> 5) * 125;
+
+	return temp;
+}
+
+int emc1412_external_temp(int id)
+{
+	u8 reg;
+	int temp;
+	struct i2c_client *client;
+
+	/* not ready ??? */
+	if (id < 0 || !(client = emc1412_client[id]))
+		return NOT_VALID_TEMP;
+
+	reg = i2c_smbus_read_byte_data(client, EMC1412_TEMP_EXT_LO_REG);
+	temp = i2c_smbus_read_byte_data(client, EMC1412_TEMP_EXT_HI_REG) * 1000;
+	temp += (reg >> 5) * 125;
+
+	return temp;
+}
+
+static ssize_t get_emc1412_label(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	int id = (to_sensor_dev_attr(attr))->index - 1;
+	struct sensor_device *sdev = (struct sensor_device *)emc1412_client[id]->dev.platform_data;
+
+	return sprintf(buf, "%s\n", sdev->label);
+}
+
+static ssize_t get_emc1412_temp(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	int id = (to_sensor_dev_attr(attr))->index - 1;
+	int value = emc1412_external_temp(id);
+
+	return sprintf(buf, "%d\n", value);
+}
+
+static ssize_t get_emc1412_crit(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client;
+	int ext_limit, int_limit, ave_limit;
+	int id = (to_sensor_dev_attr(attr))->index - 1;
+
+	if (id < 0 || !(client = emc1412_client[id]))
+		return NOT_VALID_TEMP;
+
+	ext_limit = i2c_smbus_read_byte_data(client, EMC1412_THERM_LIMIT_EXT_REG);
+	int_limit = i2c_smbus_read_byte_data(client, EMC1412_THERM_LIMIT_INT_REG);
+	ave_limit = (ext_limit + int_limit) / 2;
+
+	return sprintf(buf, "%d\n", (ave_limit * 1000));
+}
+
+static ssize_t set_emc1412_crit(struct device *dev,
+			struct device_attribute *attr, const char *buf ,size_t count)
+{
+	unsigned long set_limit;
+	struct i2c_client *client;
+	int id = (to_sensor_dev_attr(attr))->index - 1;
+
+	if (id < 0 || !(client = emc1412_client[id]))
+		return NOT_VALID_TEMP;
+
+	if (kstrtoul(buf, 10, &set_limit))
+		return -EINVAL;
+
+	set_limit = clamp_val(set_limit, 0, 125000);
+	set_limit /= 1000;
+	i2c_smbus_write_byte_data(client, EMC1412_THERM_LIMIT_EXT_REG, set_limit);
+	i2c_smbus_write_byte_data(client, EMC1412_THERM_LIMIT_INT_REG, set_limit);
+
+	return count;
+}
+
+static ssize_t get_emc1412_crit_hyst(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client;
+	int ext_limit, int_limit, ave_limit, hyst;
+	int id = (to_sensor_dev_attr(attr))->index - 1;
+
+	if (id < 0 || !(client = emc1412_client[id]))
+		return NOT_VALID_TEMP;
+
+	ext_limit = i2c_smbus_read_byte_data(client, EMC1412_THERM_LIMIT_EXT_REG);
+	int_limit = i2c_smbus_read_byte_data(client, EMC1412_THERM_LIMIT_INT_REG);
+	ave_limit = (ext_limit + int_limit) / 2;
+
+	hyst = i2c_smbus_read_byte_data(client, EMC1412_THERM_LIMIT_HYS_REG);
+
+	return sprintf(buf, "%d\n", (ave_limit - hyst) * 1000);
+}
+
+static ssize_t set_emc1412_crit_hyst(struct device *dev,
+			struct device_attribute *attr, const char *buf ,size_t count)
+{
+	unsigned long set_limit;
+	int ext_limit, int_limit, ave_limit, hyst;
+	struct i2c_client *client;
+	int id = (to_sensor_dev_attr(attr))->index - 1;
+
+	if (id < 0 || !(client = emc1412_client[id]))
+		return NOT_VALID_TEMP;
+
+	if (kstrtoul(buf, 10, &set_limit))
+		return -EINVAL;
+
+	ext_limit = i2c_smbus_read_byte_data(client, EMC1412_THERM_LIMIT_EXT_REG);
+	int_limit = i2c_smbus_read_byte_data(client, EMC1412_THERM_LIMIT_INT_REG);
+	ave_limit = (ext_limit + int_limit) / 2;
+	set_limit = clamp_val(set_limit, 0, 125000);
+	set_limit /= 1000;
+	hyst = ave_limit - set_limit;
+
+	i2c_smbus_write_byte_data(client, EMC1412_THERM_LIMIT_HYS_REG, hyst);
+
+	return count;
+}
+
+static struct delayed_work thermal_work;
+
+static void do_thermal_timer(struct work_struct *work)
+{
+	int i, value, temp_max = 0;
+
+	for (i=0; i<MAX_EMC1412_CLIENTS; i++) {
+		value = emc1412_external_temp(i);
+		if (value > temp_max)
+			temp_max = value;
+	}
+
+	if (temp_max <= EMC1412_THERMAL_THRESHOLD)
+		schedule_delayed_work(&thermal_work, msecs_to_jiffies(5000));
+	else {
+		pr_emerg("Power off due to high EMC1412 temp: %d\n", temp_max);
+		orderly_poweroff(true);
+	}
+}
+
+int fixup_cpu_temp(int cpu, int cputemp)
+{
+	static int printed[MAX_PACKAGES] = {0, 0, 0, 0};
+	int i, value, temp_min = 50000, temp_max = -20000;
+
+	for (i=0; i<MAX_EMC1412_CLIENTS; i++) {
+		value = emc1412_internal_temp(i);
+		if (value == NOT_VALID_TEMP)
+			continue;
+		if (value < temp_min)
+			temp_min = value;
+		if (value > temp_max)
+			temp_max = value;
+	}
+	for (i=0; i<MAX_EMC1412_CLIENTS; i++) {
+		value = emc1412_external_temp(i);
+		if (value == NOT_VALID_TEMP)
+			continue;
+		if (value < temp_min)
+			temp_min = value;
+		if (value > temp_max)
+			temp_max = value;
+	}
+
+	if (temp_min > temp_max) {
+		printk_once("EMC1412: No valid reference.\n");
+		return cputemp;
+	}
+	if (cputemp < 0 && temp_max < 2000) {
+		printk_once("EMC1412: No valid reference.\n");
+		return cputemp;
+	}
+
+	if (cputemp < temp_min - 5000) {
+		if(!printed[cpu]) {
+			printed[cpu] = 1;
+			printk("EMC1412: Original CPU#%d temperature too low, "
+				"fixup with reference: (%d -> %d).\n",
+				cpu, cputemp, temp_min - 5000);
+		}
+		return temp_min - 5000;
+	}
+	if (cputemp > temp_max + 15000) {
+		if(!printed[cpu]) {
+			printed[cpu] = 1;
+			printk("EMC1412: Original CPU#%d temperature too high, "
+				"fixup with reference: (%d -> %d).\n",
+				cpu, cputemp, temp_max + 10000);
+		}
+		return temp_max + 15000;
+	}
+	if(!printed[cpu]) {
+		printed[cpu] = 1;
+		printk("EMC1412: Original CPU#%d temperature is OK: (%d:%d:%d).\n",
+			cpu, cputemp, temp_min, temp_max);
+	}
+
+	return cputemp;
+}
+
+static struct platform_driver emc1412_driver = {
+	.probe		= emc1412_probe,
+	.shutdown	= emc1412_shutdown,
+	.driver		= {
+		.name	= "emc1412",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init emc1412_init(void)
+{
+	int ret;
+
+	emc1412_hwmon_dev = hwmon_device_register(NULL);
+	if (IS_ERR(emc1412_hwmon_dev)) {
+		ret = -ENOMEM;
+		printk(KERN_ERR "hwmon_device_register fail!\n");
+		goto fail_hwmon_device_register;
+	}
+
+	ret = sysfs_create_group(&emc1412_hwmon_dev->kobj,
+				&emc1412_hwmon_attribute_group);
+	if (ret) {
+		printk(KERN_ERR "fail to create loongson hwmon!\n");
+		goto fail_sysfs_create_group_hwmon;
+	}
+
+	platform_driver_register(&emc1412_driver);
+	INIT_DEFERRABLE_WORK(&thermal_work, do_thermal_timer);
+	schedule_delayed_work(&thermal_work, msecs_to_jiffies(20000));
+
+	return 0;
+
+fail_sysfs_create_group_hwmon:
+	hwmon_device_unregister(emc1412_hwmon_dev);
+
+fail_hwmon_device_register:
+	return ret;
+}
+
+static void __exit emc1412_exit(void)
+{
+	cancel_delayed_work_sync(&thermal_work);
+	platform_driver_unregister(&emc1412_driver);
+	sysfs_remove_group(&emc1412_hwmon_dev->kobj,
+				&emc1412_hwmon_attribute_group);
+	hwmon_device_unregister(emc1412_hwmon_dev);
+}
+
+late_initcall(emc1412_init);
+module_exit(emc1412_exit);
+
+MODULE_AUTHOR("Yu Xiang <xiangy@lemote.com>");
+MODULE_AUTHOR("Huacai Chen <chenhc@lemote.com>");
+MODULE_DESCRIPTION("EMC1412 driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/platform/mips/lemote3a-laptop.c b/drivers/platform/mips/lemote3a-laptop.c
new file mode 100644
index 000000000000..b06e7b6ae97c
--- /dev/null
+++ b/drivers/platform/mips/lemote3a-laptop.c
@@ -0,0 +1,1179 @@
+/*
+ * Driver for Lemote Loongson-3A/2Gq Laptops with WPCE775l Embeded Controller
+ *
+ * Copyright (C) 2011 Lemote Inc.
+ * Author : Huang Wei <huangw@lemote.com>
+ *        : Wang Rui <wangr@lemote.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/io.h>
+#include <linux/pci.h>
+#include <linux/delay.h>
+#include <linux/uaccess.h>
+#include <linux/backlight.h>
+#include <linux/fb.h>
+#include <linux/interrupt.h>
+#include <linux/pm.h>
+#include <linux/power_supply.h>
+#include <linux/input.h>
+#include <linux/input/sparse-keymap.h>
+#include <linux/jiffies.h>
+#include <linux/miscdevice.h>
+#include <linux/platform_device.h>
+#include <asm/bootinfo.h>
+
+#include <ec_wpce775l.h>
+
+#define KEY_TOUCHPAD_SW	KEY_F21
+#define KEY_MODEM	KEY_F24
+
+/* Backlight */
+#define MAX_BRIGHTNESS	9
+
+/* Power supply */
+#define BIT_BAT_POWER_ACIN		(1 << 0)
+enum
+{
+	APM_AC_OFFLINE =	0,
+	APM_AC_ONLINE,
+	APM_AC_BACKUP,
+	APM_AC_UNKNOWN =	0xff
+};
+enum
+{
+	APM_BAT_STATUS_HIGH =		0,
+	APM_BAT_STATUS_LOW,
+	APM_BAT_STATUS_CRITICAL,
+	APM_BAT_STATUS_CHARGING,
+	APM_BAT_STATUS_NOT_PRESENT,
+	APM_BAT_STATUS_UNKNOWN =	0xff
+};
+
+enum /* bat_reg_flag */
+{
+	BAT_REG_TEMP_FLAG = 1,
+	BAT_REG_VOLTAGE_FLAG,
+	BAT_REG_CURRENT_FLAG,
+	BAT_REG_AC_FLAG,
+	BAT_REG_RC_FLAG,
+	BAT_REG_FCC_FLAG,
+	BAT_REG_ATTE_FLAG,
+	BAT_REG_ATTF_FLAG,
+	BAT_REG_RSOC_FLAG,
+	BAT_REG_CYCLCNT_FLAG
+};
+
+/* Power info cached timeout */
+#define POWER_INFO_CACHED_TIMEOUT	100	/* jiffies */
+
+/* SCI device */
+#define EC_SCI_DEV		"sci"	/* < 10 bytes. */
+#define SCI_IRQ_NUM		0x07
+#define GPIO_SIZE		256
+
+const char *version = EC_VERSION;
+
+/* Power information structure */
+struct lemote3a_power_info
+{
+	/* AC insert or not */
+	unsigned int ac_in;
+	/* Battery insert or not */
+	unsigned int bat_in;
+	unsigned int health;
+
+	/* Battery designed capacity */
+	unsigned int design_capacity;
+	/* Battery designed voltage */
+	unsigned int design_voltage;
+	/* Battery capacity after full charged */
+	unsigned int full_charged_capacity;
+	/* Battery Manufacture Date */
+	unsigned char manufacture_date[11];
+	/* Battery Serial number */
+	unsigned char serial_number[8];
+	/* Battery Manufacturer Name, max 11 + 1(length) bytes */
+	unsigned char manufacturer_name[12];
+	/* Battery Device Name, max 7 + 1(length) bytes */
+	unsigned char device_name[8];
+	/* Battery Technology */
+	unsigned int technology;
+	/* Battery cell count */
+	unsigned char cell_count;
+
+	/* Battery dynamic charge/discharge voltage */
+	unsigned int voltage_now;
+	/* Battery dynamic charge/discharge average current */
+	int current_now;
+	int current_sign;
+	int current_average;
+	/* Battery current remaining capacity */
+	unsigned int remain_capacity;
+	/* Battery current remaining capacity percent */
+	unsigned int remain_capacity_percent;
+	/* Battery current temperature */
+	unsigned int temperature;
+	/* Battery current remaining time (AverageTimeToEmpty) */
+	unsigned int remain_time;
+	/* Battery current full charging time (averageTimeToFull) */
+	unsigned int fullchg_time;
+	/* Battery Status */
+	unsigned int charge_status;
+	/* Battery current cycle count (CycleCount) */
+	unsigned int cycle_count;
+};
+
+/* SCI device structure */
+struct sci_device
+{
+	/* The sci number get from ec */
+	unsigned char number;
+	/* Sci count */
+	unsigned char parameter;
+	/* Irq relative */
+	unsigned char irq;
+	unsigned char irq_data;
+	/* Device name */
+	unsigned char name[10];
+};
+/* SCI device event structure */
+struct sci_event
+{
+	int index;
+	sci_handler handler;
+};
+
+/* Platform driver init handler */
+static int __init lemote3a_laptop_init(void);
+/* Platform driver exit handler */
+static void __exit lemote3a_laptop_exit(void);
+/* Platform device suspend handler */
+static int lemote3a_laptop_suspend(struct platform_device * pdev, pm_message_t state);
+/* Platform device resume handler */
+static int lemote3a_laptop_resume(struct platform_device * pdev);
+
+static ssize_t version_show(struct device_driver * driver, char * buf);
+
+/* Camera control misc device open handler */
+static int lemote3a_cam_misc_open(struct inode * inode, struct file * filp);
+/* Camera control misc device release handler */
+static int lemote3a_cam_misc_release(struct inode * inode, struct file * filp);
+/* Camera control misc device read handler */
+ssize_t lemote3a_cam_misc_read(struct file * filp,
+			char __user * buffer, size_t size, loff_t * offset);
+/* Camera control misc device write handler */
+static ssize_t lemote3a_cam_misc_write(struct file * filp,
+			const char __user * buffer, size_t size, loff_t * offset);
+
+/* Backlight device set brightness handler */
+static int lemote3a_set_brightness(struct backlight_device * pdev);
+/* Backlight device get brightness handler */
+static int lemote3a_get_brightness(struct backlight_device * pdev);
+
+/* >>>Power management operation */
+/* Update battery information handle function. */
+static void lemote3a_power_battery_info_update(unsigned char bat_reg_flag);
+/* Clear battery static information. */
+static void lemote3a_power_info_battery_static_clear(void);
+/* Get battery static information. */
+static void lemote3a_power_info_battery_static_update(void);
+/* Update power_status value */
+static void lemote3a_power_info_power_status_update(void);
+static void lemote3a_bat_get_string(unsigned char index, unsigned char *bat_string);
+/* Power supply Battery get property handler */
+static int lemote3a_bat_get_property(struct power_supply * pws,
+			enum power_supply_property psp, union power_supply_propval * val);
+/* Power supply AC get property handler */
+static int lemote3a_ac_get_property(struct power_supply * pws,
+			enum power_supply_property psp, union power_supply_propval * val);
+/* <<<End power management operation */
+
+/* SCI device pci driver init handler */
+static int sci_pci_driver_init(void);
+/* SCI device pci driver exit handler */
+static void sci_pci_driver_exit(void);
+/* SCI device pci driver init */
+static int sci_pci_init(void);
+/* SCI event routine handler */
+static irqreturn_t lemote3a_sci_int_routine(int irq, void * dev_id);
+/* SCI event handler */
+void lemote3a_sci_event_handler(int event);
+/* SCI device over temperature event handler */
+static int lemote3a_over_temp_handler(int status);
+/* SCI device Throttling the CPU event handler */
+static int lemote3a_throttling_CPU_handler(int status);
+/* SCI device AC event handler */
+static int lemote3a_ac_handler(int status);
+/* SCI device Battery event handler */
+static int lemote3a_bat_handler(int status);
+/* SCI device Battery low event handler */
+static int lemote3a_bat_low_handler(int status);
+/* SCI device Battery very low event handler */
+static int lemote3a_bat_very_low_handler(int status);
+/* SCI device LID event handler */
+static int lemote3a_lid_handler(int status);
+
+/* Hotkey device init handler */
+static int lemote3a_hotkey_init(void);
+/* Hotkey device exit handler */
+static void lemote3a_hotkey_exit(void);
+extern int ec_query_get_event_num(void);
+
+static int wpce775l_probe(struct platform_device *dev);
+
+/* Platform driver object */
+static struct platform_driver platform_driver =
+{
+	.probe	= wpce775l_probe,
+	.driver =
+	{
+		.name = "wpce775l",
+		.owner = THIS_MODULE,
+	},
+#ifdef CONFIG_PM
+	.suspend = lemote3a_laptop_suspend,
+	.resume  = lemote3a_laptop_resume,
+#endif /* CONFIG_PM */
+};
+static DRIVER_ATTR_RO(version);
+
+/* Camera control misc device object file operations */
+static const struct file_operations lemote3a_cam_misc_fops =
+{
+	.open = lemote3a_cam_misc_open,
+	.release = lemote3a_cam_misc_release,
+	.read = lemote3a_cam_misc_read,
+	.write = lemote3a_cam_misc_write
+};
+
+/* Camera control misc device object */
+static struct miscdevice lemote3a_cam_misc_dev =
+{
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "webcam",
+	.fops = &lemote3a_cam_misc_fops
+};
+
+/* Backlight device object */
+static struct backlight_device * lemote3a_backlight_dev = NULL;
+
+/* Backlight device operations table object */
+static struct backlight_ops lemote3a_backlight_ops =
+{
+	.get_brightness = lemote3a_get_brightness,
+	.update_status =  lemote3a_set_brightness,
+};
+
+/* Power info object */
+static struct lemote3a_power_info * power_info = NULL;
+/* Power supply Battery property object */
+static enum power_supply_property lemote3a_bat_props[] =
+{
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_TECHNOLOGY,
+	POWER_SUPPLY_PROP_CYCLE_COUNT,
+	POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN,
+	POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_CURRENT_AVG,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_CHARGE_FULL, /* in uAh */
+	POWER_SUPPLY_PROP_CHARGE_NOW,
+	POWER_SUPPLY_PROP_CAPACITY, /* in percents! */
+	POWER_SUPPLY_PROP_TEMP,
+	POWER_SUPPLY_PROP_TIME_TO_EMPTY_AVG,
+	POWER_SUPPLY_PROP_TIME_TO_FULL_AVG,
+	/* Properties of type `const char *' */
+	POWER_SUPPLY_PROP_MODEL_NAME,
+	POWER_SUPPLY_PROP_MANUFACTURER,
+	POWER_SUPPLY_PROP_SERIAL_NUMBER,
+};
+
+/* Power supply Battery device object */
+static struct power_supply_desc lemote3a_bat_desc =
+{
+	.name = "lemote3a-bat",
+	.type = POWER_SUPPLY_TYPE_BATTERY,
+	.properties = lemote3a_bat_props,
+	.num_properties = ARRAY_SIZE(lemote3a_bat_props),
+	.get_property = lemote3a_bat_get_property,
+};
+
+static struct power_supply *lemote3a_bat;
+
+/* Power supply AC property object */
+static enum power_supply_property lemote3a_ac_props[] =
+{
+	POWER_SUPPLY_PROP_ONLINE,
+};
+/* Power supply AC device object */
+static struct power_supply_desc lemote3a_ac_desc =
+{
+	.name = "lemote3a-ac",
+	.type = POWER_SUPPLY_TYPE_MAINS,
+	.properties = lemote3a_ac_props,
+	.num_properties = ARRAY_SIZE(lemote3a_ac_props),
+	.get_property = lemote3a_ac_get_property,
+};
+
+static struct power_supply *lemote3a_ac;
+
+/* SCI device object */
+static struct sci_device * lemote3a_sci_device = NULL;
+
+/* SCI device event handler table */
+static const struct sci_event se[] =
+{
+	[SCI_EVENT_NUM_LID] =			{INDEX_DEVICE_STATUS, lemote3a_lid_handler},
+	[SCI_EVENT_NUM_SLEEP] =			{0, NULL},
+	[SCI_EVENT_NUM_WLAN] =			{0, NULL},
+	[SCI_EVENT_NUM_BRIGHTNESS_DN] =		{0, NULL},
+	[SCI_EVENT_NUM_BRIGHTNESS_UP] =		{0, NULL},
+	[SCI_EVENT_NUM_AUDIO_MUTE] =		{0, NULL},
+	[SCI_EVENT_NUM_VOLUME_DN] =		{0, NULL},
+	[SCI_EVENT_NUM_VOLUME_UP] =		{0, NULL},
+	[SCI_EVENT_NUM_BLACK_SCREEN] =		{0, NULL},
+	[SCI_EVENT_NUM_DISPLAY_TOGGLE] =	{0, NULL},
+	[SCI_EVENT_NUM_3G] =			{0, NULL},
+	[SCI_EVENT_NUM_SIM] =			{0, NULL},
+	[SCI_EVENT_NUM_CAMERA] =		{0, NULL},
+	[SCI_EVENT_NUM_TP] =			{0, NULL},
+	[SCI_EVENT_NUM_OVERTEMP] =		{0, lemote3a_over_temp_handler},
+	[SCI_EVENT_NUM_AC] =			{0, lemote3a_ac_handler},
+	[SCI_EVENT_NUM_BAT] =			{INDEX_POWER_STATUS, lemote3a_bat_handler},
+	[SCI_EVENT_NUM_BATL] =			{0, lemote3a_bat_low_handler},
+	[SCI_EVENT_NUM_BATVL] =			{0, lemote3a_bat_very_low_handler},
+	[SCI_EVENT_NUM_THROT] =			{0, lemote3a_throttling_CPU_handler},
+	[SCI_EVENT_NUM_POWER] =			{0, NULL},
+	[SCI_EVENT_RESOLUTION_SETTING] = 	{0, NULL},
+	[SCI_EVENT_MEDIA_RUN_PAUSE] =		{0, NULL},
+	[SCI_EVENT_MEDIA_STOP] = 		{0, NULL},
+	[SCI_EVENT_MEDIA_LAST] = 		{0, NULL},
+	[SCI_EVENT_MEDIA_NEXT] = 		{0, NULL},
+	[SCI_EVENT_RECOVERY] =			{0, NULL},
+};
+/* Hotkey device object */
+static struct input_dev * lemote3a_hotkey_dev = NULL;
+/* Hotkey keymap object */
+static const struct key_entry lemote3a_keymap[] =
+{
+	{KE_SW,  SCI_EVENT_NUM_LID, { SW_LID } },
+	{KE_KEY, SCI_EVENT_NUM_SLEEP, { KEY_SLEEP } }, /* A1004: Fn + ESC; A1201: Fn + F10 */
+	{KE_KEY, SCI_EVENT_NUM_BRIGHTNESS_DN, { KEY_BRIGHTNESSDOWN } }, /* A1004: Fn + F2; A1201: Fn + F6 */
+	{KE_KEY, SCI_EVENT_NUM_BRIGHTNESS_UP, { KEY_BRIGHTNESSUP } }, /* A1004: Fn + F3; A1201: Fn + F5 */
+	{KE_KEY, SCI_EVENT_NUM_AUDIO_MUTE, { KEY_MUTE } }, /* A1004: Fn + F4; A1201: Fn + F7 */
+	{KE_KEY, SCI_EVENT_NUM_VOLUME_DN, { KEY_VOLUMEDOWN } }, /* A1004: Fn + F5; A1201: Fn + F4 */
+	{KE_KEY, SCI_EVENT_NUM_VOLUME_UP, { KEY_VOLUMEUP } }, /* A1004: Fn + F6; A1201: Fn + F3 */
+	{KE_KEY, SCI_EVENT_NUM_BLACK_SCREEN, { KEY_DISPLAYTOGGLE } }, /* A1004: Fn + F7 */
+	{KE_KEY, SCI_EVENT_NUM_DISPLAY_TOGGLE, { KEY_SWITCHVIDEOMODE } }, /* A1004: Fn + F8; A1201: Fn + F2 */
+	{KE_KEY, SCI_EVENT_NUM_3G, { KEY_MODEM } }, /* Fn + F9 */
+	{KE_KEY, SCI_EVENT_NUM_CAMERA, { KEY_CAMERA } }, /* Fn + F10 */
+	{KE_KEY, SCI_EVENT_NUM_TP, { KEY_TOUCHPAD_SW } }, /* Fn + F11 */
+	{KE_KEY, SCI_EVENT_NUM_POWER, { KEY_POWER } }, /* Power */
+	{KE_KEY, SCI_EVENT_RESOLUTION_SETTING, { KEY_SETUP } },
+	{KE_KEY, SCI_EVENT_MEDIA_RUN_PAUSE, { KEY_PLAYPAUSE } },
+	{KE_KEY, SCI_EVENT_MEDIA_STOP, { KEY_STOPCD } },
+	{KE_KEY, SCI_EVENT_MEDIA_LAST, { KEY_PREVIOUSSONG } },
+	{KE_KEY, SCI_EVENT_MEDIA_NEXT, { KEY_NEXTSONG } },
+	{KE_KEY, SCI_EVENT_RECOVERY, { KEY_PROG1 } },
+	{KE_END, 0 }
+};
+
+
+static int wpce775l_probe(struct platform_device *dev)
+{
+	int ret;
+
+	/* Register backlight START */
+	lemote3a_backlight_dev = backlight_device_register("lemote",
+				NULL, NULL, &lemote3a_backlight_ops, NULL);
+	if (IS_ERR(lemote3a_backlight_dev)) {
+		ret = PTR_ERR(lemote3a_backlight_dev);
+		goto fail_backlight_device_register;
+	}
+	lemote3a_backlight_dev->props.max_brightness = ec_read(INDEX_DISPLAY_MAXBRIGHTNESS_LEVEL);
+	lemote3a_backlight_dev->props.brightness = ec_read(INDEX_DISPLAY_BRIGHTNESS);
+	backlight_update_status(lemote3a_backlight_dev);
+	/* Register backlight END */
+
+	/* Register power supply START */
+	power_info = kzalloc(sizeof(struct lemote3a_power_info), GFP_KERNEL);
+	if (!power_info) {
+		printk(KERN_ERR "Lemote Laptop Platform Driver: Alloc memory for power_info failed!\n");
+		ret = -ENOMEM;
+		goto fail_power_info_alloc;
+	}
+
+	lemote3a_power_info_power_status_update();
+	if (power_info->bat_in) {
+		/* Get battery static information. */
+		lemote3a_power_info_battery_static_update();
+	}
+	else {
+		printk(KERN_ERR "Lemote Laptop Platform Driver: The battery does not exist!!\n");
+	}
+	lemote3a_bat = power_supply_register(NULL, &lemote3a_bat_desc, NULL);
+	if (IS_ERR(lemote3a_bat)) {
+		ret = -ENOMEM;
+		goto fail_bat_power_supply_register;
+	}
+
+	lemote3a_ac = power_supply_register(NULL, &lemote3a_ac_desc, NULL);
+	if (IS_ERR(lemote3a_ac)) {
+		ret = -ENOMEM;
+		goto fail_ac_power_supply_register;
+	}
+	/* Register power supply END */
+
+	/* Hotkey device START */
+	ret = lemote3a_hotkey_init();
+	if (ret) {
+		printk(KERN_ERR "Lemote Laptop Platform Driver : Fail to register hotkey device.\n");
+		goto fail_hotkey_init;
+	}
+	/* Hotkey device END */
+
+	/* SCI PCI Driver Init START  */
+	ret = sci_pci_driver_init();
+	if (ret) {
+		printk(KERN_ERR "LS3ANB Driver : Fail to register sci pci driver.\n");
+		goto fail_sci_pci_driver_init;
+	}
+	/* SCI PCI Driver Init END */
+
+	/* Camera control misc Device START */
+	ret = misc_register(&lemote3a_cam_misc_dev);
+	if (ret) {
+		printk(KERN_ERR "Lemote Laptop Platform Driver : Fail to register camera control misc device.\n");
+		goto fail_misc_register;
+	}
+	/* Camera control misc Device END */
+
+	/* Request control for backlight device START */
+	ec_write(INDEX_BACKLIGHT_CTRLMODE, BACKLIGHT_CTRL_BYHOST);
+	/* Request control for backlight device END */
+
+	return 0;
+
+fail_misc_register:
+	sci_pci_driver_exit();
+fail_sci_pci_driver_init:
+	lemote3a_hotkey_exit();
+fail_hotkey_init:
+	power_supply_unregister(lemote3a_ac);
+fail_ac_power_supply_register:
+	power_supply_unregister(lemote3a_bat);
+fail_bat_power_supply_register:
+	kfree(power_info);
+fail_power_info_alloc:
+	backlight_device_unregister(lemote3a_backlight_dev);
+fail_backlight_device_register:
+	platform_driver_unregister(&platform_driver);
+
+	return ret;
+}
+
+/* Platform driver init handler */
+static int __init lemote3a_laptop_init(void)
+{
+	int ret;
+
+	printk(KERN_INFO "Lemote Laptop Platform Driver version V%s\n", version);
+
+	ret = platform_driver_register(&platform_driver);
+	if(ret) {
+		printk(KERN_ERR "Lemote Laptop Platform Driver: Fail to register lemote laptop platform driver.\n");
+		return ret;
+	}
+	ret = driver_create_file(&platform_driver.driver, &driver_attr_version);
+
+	return ret;
+}
+
+/* Platform driver exit handler */
+static void __exit lemote3a_laptop_exit(void)
+{
+	free_irq(lemote3a_sci_device->irq, lemote3a_sci_device);
+
+	/* Return control for backlight device START */
+	ec_write(INDEX_BACKLIGHT_CTRLMODE, BACKLIGHT_CTRL_BYEC);
+	/* Return control for backlight device END */
+
+	/* Camera control misc device */
+	misc_deregister(&lemote3a_cam_misc_dev);
+
+	/* Hotkey & SCI device */
+	sci_pci_driver_exit();
+	lemote3a_hotkey_exit();
+
+	/* Power supply */
+	power_supply_unregister(lemote3a_ac);
+	power_supply_unregister(lemote3a_bat);
+	kfree(power_info);
+
+	/* Backlight */
+	backlight_device_unregister(lemote3a_backlight_dev);
+
+	/* Platform device & driver */
+	platform_driver_unregister(&platform_driver);
+
+	printk(KERN_INFO "Lemote Laptop Platform Driver : Unload Platform Specific Driver.\n");
+}
+
+#ifdef CONFIG_PM
+/* Platform device suspend handler */
+static int lemote3a_laptop_suspend(struct platform_device * pdev, pm_message_t state)
+{
+	struct pci_dev *dev;
+
+	dev = pci_get_device(PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_SBX00_SMBUS, NULL);
+	pci_disable_device(dev);
+
+	return 0;
+}
+
+/* Platform device resume handler */
+static int lemote3a_laptop_resume(struct platform_device * pdev)
+{
+	struct pci_dev *dev;
+
+	dev = pci_get_device(PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_SBX00_SMBUS, NULL);
+	pci_enable_device(dev);
+
+	/* Process LID event */
+	lemote3a_sci_event_handler(SCI_EVENT_NUM_LID);
+
+	/*
+	 * Clear sci status: GPM9Status field in bit14 of
+	 * EVENT_STATUS register for SB710, write 1 to clear
+	 *
+	 * Clear all SCI events when suspend
+	 */
+	clean_ec_event_status();
+
+	return 0;
+}
+#else
+static int lemote3a_laptop_suspend(struct platform_device * pdev, pm_message_t state)
+{
+	return 0;
+}
+
+static int lemote3a_laptop_resume(struct platform_device * pdev)
+{
+	return 0;
+}
+#endif /* CONFIG_PM */
+
+static ssize_t version_show(struct device_driver * driver, char * buf)
+{
+	return sprintf(buf, "%s\n", version);
+}
+
+/* Camera control misc device open handler */
+static int lemote3a_cam_misc_open(struct inode * inode, struct file * filp)
+{
+	return 0;
+}
+
+/* Camera control misc device release handler */
+static int lemote3a_cam_misc_release(struct inode * inode, struct file * filp)
+{
+	return 0;
+}
+
+/* Camera control misc device read handler */
+ssize_t lemote3a_cam_misc_read(struct file * filp,
+			char __user * buffer, size_t size, loff_t * offset)
+{
+	int ret = 0;
+
+	if (0 != *offset)
+		return 0;
+
+	ret = ec_read(INDEX_CAM_STSCTRL);
+	ret = sprintf(buffer, "%d\n", ret);
+	*offset = ret;
+
+	return ret;
+}
+
+/* Camera control misc device write handler */
+static ssize_t lemote3a_cam_misc_write(struct file * filp,
+			const char __user * buffer, size_t size, loff_t * offset)
+{
+	if (0 >= size)
+		return -EINVAL;
+
+	if ('0' == buffer[0])
+		ec_write(INDEX_CAM_STSCTRL, CAM_STSCTRL_OFF);
+	else
+		ec_write(INDEX_CAM_STSCTRL, CAM_STSCTRL_ON);
+
+	return size;
+}
+
+/* Backlight device set brightness handler */
+static int lemote3a_set_brightness(struct backlight_device * pdev)
+{
+	unsigned int level = 0;
+
+	level = ((FB_BLANK_UNBLANK==pdev->props.fb_blank) &&
+				(FB_BLANK_UNBLANK==pdev->props.power)) ?
+					pdev->props.brightness : 0;
+
+	if (MAX_BRIGHTNESS < level) {
+		level = MAX_BRIGHTNESS;
+	}
+	else if (level < 0) {
+		level = 0;
+	}
+
+	ec_write(INDEX_DISPLAY_BRIGHTNESS, level);
+
+	return 0;
+}
+
+/* Backlight device get brightness handler */
+static int lemote3a_get_brightness(struct backlight_device * pdev)
+{
+	/* Read level from ec */
+	return ec_read(INDEX_DISPLAY_BRIGHTNESS);
+}
+
+/* Update battery information handle function. */
+static void lemote3a_power_battery_info_update(unsigned char bat_reg_flag)
+{
+	short bat_info_value = 0;
+
+	switch (bat_reg_flag) {
+		/* Update power_info->temperature value */
+		case BAT_REG_TEMP_FLAG:
+			lemote3a_power_info_power_status_update();
+			bat_info_value = (ec_read(INDEX_BATTERY_TEMP_HIGH) << 8) | ec_read(INDEX_BATTERY_TEMP_LOW);
+			power_info->temperature = (power_info->bat_in) ? (bat_info_value / 10 - 273) : 0;
+			break;
+		/* Update power_info->voltage value */
+		case BAT_REG_VOLTAGE_FLAG:
+			lemote3a_power_info_power_status_update();
+			bat_info_value = (ec_read(INDEX_BATTERY_VOL_HIGH) << 8) | ec_read(INDEX_BATTERY_VOL_LOW);
+			power_info->voltage_now = (power_info->bat_in) ? bat_info_value : 0;
+			break;
+		/* Update power_info->current_now value */
+		case BAT_REG_CURRENT_FLAG:
+			lemote3a_power_info_power_status_update();
+			bat_info_value = (ec_read(INDEX_BATTERY_CURRENT_HIGH) << 8) | ec_read(INDEX_BATTERY_CURRENT_LOW);
+			power_info->current_now = (power_info->bat_in) ? bat_info_value : 0;
+			break;
+		/* Update power_info->current_avg value */
+		case BAT_REG_AC_FLAG:
+			lemote3a_power_info_power_status_update();
+			bat_info_value = (ec_read(INDEX_BATTERY_AC_HIGH) << 8) | ec_read(INDEX_BATTERY_AC_LOW);
+			power_info->current_average = (power_info->bat_in) ? bat_info_value : 0;
+			break;
+		/* Update power_info->remain_capacity value */
+		case BAT_REG_RC_FLAG:
+			power_info->remain_capacity = (ec_read(INDEX_BATTERY_RC_HIGH) << 8) | ec_read(INDEX_BATTERY_RC_LOW);
+			break;
+		/* Update power_info->full_charged_capacity value */
+		case BAT_REG_FCC_FLAG:
+			power_info->full_charged_capacity = (ec_read(INDEX_BATTERY_FCC_HIGH) << 8) | ec_read(INDEX_BATTERY_FCC_LOW);
+			break;
+		/* Update power_info->remain_time value */
+		case BAT_REG_ATTE_FLAG:
+			power_info->remain_time = (ec_read(INDEX_BATTERY_ATTE_HIGH) << 8) | ec_read(INDEX_BATTERY_ATTE_LOW);
+			break;
+		/* Update power_info->fullchg_time value */
+		case BAT_REG_ATTF_FLAG:
+			power_info->fullchg_time = (ec_read(INDEX_BATTERY_ATTF_HIGH) << 8) | ec_read(INDEX_BATTERY_ATTF_LOW);
+			break;
+		/* Update power_info->curr_cap value */
+		case BAT_REG_RSOC_FLAG:
+			power_info->remain_capacity_percent = ec_read(INDEX_BATTERY_CAPACITY);
+			break;
+		/* Update power_info->cycle_count value */
+		case BAT_REG_CYCLCNT_FLAG:
+			power_info->cycle_count = (ec_read(INDEX_BATTERY_CYCLECNT_HIGH) << 8) | ec_read(INDEX_BATTERY_CYCLECNT_LOW);
+			break;
+
+		default:
+			break;
+	}
+}
+
+/* Clear battery static information. */
+static void lemote3a_power_info_battery_static_clear(void)
+{
+	strcpy(power_info->manufacturer_name, "Unknown");
+	strcpy(power_info->device_name, "Unknown");
+	power_info->technology = POWER_SUPPLY_TECHNOLOGY_UNKNOWN;
+	strcpy(power_info->serial_number, "Unknown");
+	strcpy(power_info->manufacture_date, "Unknown");
+	power_info->cell_count = 0;
+	power_info->design_capacity = 0;
+	power_info->design_voltage = 0;
+}
+
+/* Get battery static information. */
+static void lemote3a_power_info_battery_static_update(void)
+{
+	unsigned int manufacture_date, bat_serial_number;
+	char device_chemistry[5];
+
+	manufacture_date = (ec_read(INDEX_BATTERY_MFD_HIGH) << 8) | ec_read(INDEX_BATTERY_MFD_LOW);
+	sprintf(power_info->manufacture_date, "%d-%d-%d", (manufacture_date >> 9) + 1980,
+            (manufacture_date & 0x01E0) >> 5, manufacture_date & 0x001F);
+	lemote3a_bat_get_string(INDEX_BATTERY_MFN_LENG, power_info->manufacturer_name);
+	lemote3a_bat_get_string(INDEX_BATTERY_DEVNAME_LENG, power_info->device_name);
+	lemote3a_bat_get_string(INDEX_BATTERY_DEVCHEM_LENG, device_chemistry);
+	if ((device_chemistry[2] == 'o') || (device_chemistry[2] == 'O')) {
+		power_info->technology = POWER_SUPPLY_TECHNOLOGY_LION;
+	}
+	else if (((device_chemistry[1] = 'h') && (device_chemistry[2] == 'm')) ||
+			((device_chemistry[1] = 'H') && (device_chemistry[2] == 'M'))) {
+		power_info->technology = POWER_SUPPLY_TECHNOLOGY_NiMH;
+	}
+	else if ((device_chemistry[2] == 'p') || (device_chemistry[2] == 'P')) {
+		power_info->technology = POWER_SUPPLY_TECHNOLOGY_LIPO;
+	}
+	else if ((device_chemistry[2] == 'f') || (device_chemistry[2] == 'F')) {
+		power_info->technology = POWER_SUPPLY_TECHNOLOGY_LiFe;
+	}
+	else if ((device_chemistry[2] == 'c') || (device_chemistry[2] == 'C')) {
+		power_info->technology = POWER_SUPPLY_TECHNOLOGY_NiCd;
+	}
+	else if (((device_chemistry[1] = 'n') && (device_chemistry[2] == 'm')) ||
+			((device_chemistry[1] = 'N') && (device_chemistry[2] == 'M'))) {
+		power_info->technology = POWER_SUPPLY_TECHNOLOGY_LiMn;
+	}
+	else {
+		power_info->technology = POWER_SUPPLY_TECHNOLOGY_UNKNOWN;
+	}
+
+	bat_serial_number = (ec_read(INDEX_BATTERY_SN_HIGH) << 8) | ec_read(INDEX_BATTERY_SN_LOW);
+	snprintf(power_info->serial_number, 8, "%x", bat_serial_number);
+
+	power_info->cell_count = ((ec_read(INDEX_BATTERY_CV_HIGH) << 8) | ec_read(INDEX_BATTERY_CV_LOW)) / 4200;
+
+	power_info->design_capacity = (ec_read(INDEX_BATTERY_DC_HIGH) << 8) | ec_read(INDEX_BATTERY_DC_LOW);
+	power_info->design_voltage = (ec_read(INDEX_BATTERY_DV_HIGH) << 8) | ec_read(INDEX_BATTERY_DV_LOW);
+	power_info->full_charged_capacity = (ec_read(INDEX_BATTERY_FCC_HIGH) << 8) | ec_read(INDEX_BATTERY_FCC_LOW);
+	printk(KERN_INFO "LS3ANB Battery Information:\nManufacturerName: %s, DeviceName: %s, DeviceChemistry: %s\n",
+			power_info->manufacturer_name, power_info->device_name, device_chemistry);
+	printk(KERN_INFO "SerialNumber: %s, ManufactureDate: %s, CellNumber: %d\n",
+			power_info->serial_number, power_info->manufacture_date, power_info->cell_count);
+	printk(KERN_INFO "DesignCapacity: %dmAh, DesignVoltage: %dmV, FullChargeCapacity: %dmAh\n",
+			power_info->design_capacity, power_info->design_voltage, power_info->full_charged_capacity);
+}
+
+/* Update power_status value */
+static void lemote3a_power_info_power_status_update(void)
+{
+	unsigned int power_status = 0;
+
+	power_status = ec_read(INDEX_POWER_STATUS);
+
+	power_info->ac_in = (power_status & MASK(BIT_POWER_ACPRES)) ?
+					APM_AC_ONLINE : APM_AC_OFFLINE;
+
+	power_info->bat_in = (power_status & MASK(BIT_POWER_BATPRES)) ? 1 : 0;
+	if( power_info->bat_in && ((ec_read(INDEX_BATTERY_DC_LOW) | (ec_read(INDEX_BATTERY_DC_HIGH) << 8)) == 0) )
+		power_info->bat_in = 0;
+
+	power_info->health = (power_info->bat_in) ?	POWER_SUPPLY_HEALTH_GOOD :
+							POWER_SUPPLY_HEALTH_UNKNOWN;
+	if (power_status & (MASK(BIT_POWER_BATL) | MASK(BIT_POWER_BATVL))) {
+		power_info->health = POWER_SUPPLY_HEALTH_DEAD;
+	}
+
+	if (!power_info->bat_in) {
+		power_info->charge_status = POWER_SUPPLY_STATUS_UNKNOWN;
+	}
+	else {
+		if (power_status & MASK(BIT_POWER_BATFCHG)) {
+			power_info->charge_status = POWER_SUPPLY_STATUS_FULL;
+		}
+		else if (power_status & MASK(BIT_POWER_BATCHG)) {
+			power_info->charge_status = POWER_SUPPLY_STATUS_CHARGING;
+		}
+		else if (power_status & MASK(BIT_POWER_TERMINATE)) {
+			power_info->charge_status = POWER_SUPPLY_STATUS_NOT_CHARGING;
+		}
+		else {
+			power_info->charge_status = POWER_SUPPLY_STATUS_DISCHARGING;
+		}
+	}
+}
+
+/* Get battery static information string */
+static void lemote3a_bat_get_string(unsigned char index, unsigned char *bat_string)
+{
+	unsigned char length, i;
+
+	length = ec_read(index);
+	for (i = 0; i < length; i++) {
+		*bat_string++ = ec_read(++index);
+	}
+	*bat_string = '\0';
+}
+
+/* Power supply Battery get property handler */
+static int lemote3a_bat_get_property(struct power_supply * pws,
+			enum power_supply_property psp, union power_supply_propval * val)
+{
+	switch (psp) {
+		/* Get battery static information. */
+		case POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:
+			val->intval = power_info->design_voltage * 1000; /* mV -> uV */
+			break;
+		case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
+			val->intval = power_info->design_capacity * 1000; /* mAh -> uAh */
+			break;
+		case POWER_SUPPLY_PROP_MODEL_NAME:
+			val->strval = power_info->device_name;
+			break;
+		case POWER_SUPPLY_PROP_MANUFACTURER:
+			val->strval = power_info->manufacturer_name;
+			break;
+		case POWER_SUPPLY_PROP_SERIAL_NUMBER:
+			val->strval = power_info->serial_number;
+			break;
+		case POWER_SUPPLY_PROP_TECHNOLOGY:
+			val->intval = power_info->technology;
+			break;
+
+		/* Get battery dynamic information. */
+		case POWER_SUPPLY_PROP_STATUS:
+			lemote3a_power_info_power_status_update();
+			val->intval = power_info->charge_status;
+			break;
+		case POWER_SUPPLY_PROP_PRESENT:
+			lemote3a_power_info_power_status_update();
+			val->intval = power_info->bat_in;
+			break;
+		case POWER_SUPPLY_PROP_HEALTH:
+			lemote3a_power_info_power_status_update();
+			val->intval = power_info->health;
+			break;
+		case POWER_SUPPLY_PROP_CURRENT_NOW:
+			lemote3a_power_battery_info_update(BAT_REG_CURRENT_FLAG);
+			val->intval = power_info->current_now * 1000; /* mA -> uA */
+			break;
+		case POWER_SUPPLY_PROP_CURRENT_AVG:
+			lemote3a_power_battery_info_update(BAT_REG_AC_FLAG);
+			val->intval = power_info->current_average * 1000; /* mA -> uA */
+			break;
+		case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+			lemote3a_power_battery_info_update(BAT_REG_VOLTAGE_FLAG);
+			val->intval =  power_info->voltage_now * 1000; /* mV -> uV */
+			break;
+		case POWER_SUPPLY_PROP_CHARGE_NOW:
+			lemote3a_power_battery_info_update(BAT_REG_RC_FLAG);
+			val->intval = power_info->remain_capacity * 1000; /* mAh -> uAh */
+			break;
+		case POWER_SUPPLY_PROP_CAPACITY:
+			lemote3a_power_battery_info_update(BAT_REG_RSOC_FLAG);
+			val->intval = power_info->remain_capacity_percent;	/* Percentage */
+			break;
+		case POWER_SUPPLY_PROP_TEMP:
+			lemote3a_power_battery_info_update(BAT_REG_TEMP_FLAG);
+			val->intval = power_info->temperature;	 /* Celcius */
+			break;
+		case POWER_SUPPLY_PROP_TIME_TO_EMPTY_AVG:
+			lemote3a_power_battery_info_update(BAT_REG_ATTE_FLAG);
+			if (power_info->remain_time == 0xFFFF) {
+				power_info->remain_time = 0;
+			}
+			val->intval = power_info->remain_time * 60;  /* seconds */
+			break;
+		case POWER_SUPPLY_PROP_TIME_TO_FULL_AVG:
+			lemote3a_power_battery_info_update(BAT_REG_ATTF_FLAG);
+			if (power_info->fullchg_time == 0xFFFF) {
+				power_info->fullchg_time = 0;
+			}
+			val->intval = power_info->fullchg_time * 60;  /* seconds */
+			break;
+		case POWER_SUPPLY_PROP_CHARGE_FULL:
+			lemote3a_power_battery_info_update(BAT_REG_FCC_FLAG);
+			val->intval = power_info->full_charged_capacity * 1000;/* mAh -> uAh */
+			break;
+		case POWER_SUPPLY_PROP_CYCLE_COUNT:
+			lemote3a_power_battery_info_update(BAT_REG_CYCLCNT_FLAG);
+			val->intval = power_info->cycle_count;
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+/* Power supply AC get property handler */
+static int lemote3a_ac_get_property(struct power_supply * pws,
+			enum power_supply_property psp, union power_supply_propval * val)
+{
+	switch (psp) {
+		case POWER_SUPPLY_PROP_ONLINE:
+			lemote3a_power_info_power_status_update();
+			val->intval = power_info->ac_in;
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+/* SCI device pci driver init handler */
+static int sci_pci_driver_init(void)
+{
+	int ret;
+
+	ret = sci_pci_init();
+	if (ret) {
+		printk(KERN_ERR "Lemote Laptop Platform Driver : Register pci driver error.\n");
+		return ret;
+	}
+
+	printk(KERN_INFO "Lemote Laptop Platform Driver : SCI event handler on WPCE775L Embedded Controller init.\n");
+
+	return ret;
+}
+
+/* SCI device pci driver exit handler */
+static void sci_pci_driver_exit(void)
+{
+	printk(KERN_INFO "Lemote Laptop Platform Driver : SCI event handler on WPCE775L Embedded Controll exit.\n");
+}
+
+/* SCI device pci driver init */
+static int sci_pci_init(void)
+{
+	int ret = -EIO;
+	struct pci_dev *pdev;
+
+	pdev = pci_get_device(PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_SBX00_SMBUS, NULL);
+
+	/* Create the sci device */
+	lemote3a_sci_device = kmalloc(sizeof(struct sci_device), GFP_KERNEL);
+	if (NULL == lemote3a_sci_device) {
+		printk(KERN_ERR "LS3ANB Drvier : Malloc memory for sci_device failed!\n");
+		return -ENOMEM;
+	}
+
+	/* Fill sci device */
+	lemote3a_sci_device->irq = SCI_IRQ_NUM;
+	lemote3a_sci_device->irq_data = 0x00;
+	lemote3a_sci_device->number = 0x00;
+	lemote3a_sci_device->parameter = 0x00;
+	strcpy(lemote3a_sci_device->name, EC_SCI_DEV);
+
+	/* Enable pci device and get the GPIO resources. */
+	ret = pci_enable_device(pdev);
+	if (ret) {
+		printk(KERN_ERR "Lemote Laptop Platform Driver : Enable pci device failed!\n");
+		ret = -ENODEV;
+		goto out_pdev;
+	}
+
+	/* Clear sci status: GPM9Status field in bit14 of
+	 * EVENT_STATUS register for SB710, write 1 to clear */
+	clean_ec_event_status();
+
+	/* Alloc the interrupt for sci not pci */
+	ret = request_irq(lemote3a_sci_device->irq, lemote3a_sci_int_routine,
+				IRQF_SHARED, lemote3a_sci_device->name, lemote3a_sci_device);
+	if (ret) {
+		printk(KERN_ERR "Lemote Laptop Platform Driver : Request irq %d failed!\n", lemote3a_sci_device->irq);
+		ret = -EFAULT;
+		goto out_irq;
+	}
+
+	ret = 0;
+	printk(KERN_DEBUG "Lemote Laptop Platform Driver : PCI Init successful!\n");
+	goto out;
+
+out_irq:
+	pci_disable_device(pdev);
+out_pdev:
+	kfree(lemote3a_sci_device);
+out:
+	return ret;
+}
+
+/* SCI event routine handler */
+static irqreturn_t lemote3a_sci_int_routine(int irq, void * dev_id)
+{
+	int event;
+
+	if (lemote3a_sci_device->irq != irq) {
+		return IRQ_NONE;
+	}
+
+	event = ec_query_get_event_num();
+	if ((SCI_EVENT_NUM_START > event) || (SCI_EVENT_NUM_END < event)) {
+		goto exit_event_action;
+	}
+
+	/* Do event action */
+	lemote3a_sci_event_handler(event);
+
+	/* Clear sci status: GPM9Status field in bit14 of
+	 * EVENT_STATUS register for SB710, write 1 to clear */
+	clean_ec_event_status();
+
+	return IRQ_HANDLED;
+
+exit_event_action:
+	clean_ec_event_status();
+	return IRQ_NONE;
+}
+
+/* SCI device event handler */
+void lemote3a_sci_event_handler(int event)
+{
+	int status = 0;
+	struct key_entry * ke = NULL;
+	struct sci_event * sep = NULL;
+
+	sep = (struct sci_event*)&(se[event]);
+	if (0 != sep->index) {
+		status = ec_read(sep->index);
+	}
+	if (NULL != sep->handler) {
+		status = sep->handler(status);
+	}
+
+	ke = sparse_keymap_entry_from_scancode(lemote3a_hotkey_dev, event);
+	if (ke) {
+		if (SW_LID == ke->keycode) {
+			/* report LID event. */
+			input_report_switch(lemote3a_hotkey_dev, SW_LID, status);
+			input_sync(lemote3a_hotkey_dev);
+		}
+		else {
+			sparse_keymap_report_entry(lemote3a_hotkey_dev, ke, 1, true);
+		}
+	}
+}
+
+/* SCI device over temperature event handler */
+static int lemote3a_over_temp_handler(int status)
+{
+	return 0;
+}
+
+/* SCI device Throttling the CPU event handler */
+static int lemote3a_throttling_CPU_handler(int status)
+{
+	return 0;
+}
+
+/* SCI device AC event handler */
+static int lemote3a_ac_handler(int status)
+{
+	/* Report status changed */
+	power_supply_changed(lemote3a_ac);
+
+	return 0;
+}
+
+/* SCI device Battery event handler */
+static int lemote3a_bat_handler(int status)
+{
+	/* Battery insert/pull-out to handle battery static information. */
+	if (status & MASK(BIT_POWER_BATPRES)) {
+		/* If battery is insert, get battery static information. */
+		lemote3a_power_info_battery_static_update();
+	}
+	else {
+		/* Else if battery is pull-out, clear battery static information. */
+		lemote3a_power_info_battery_static_clear();
+	}
+	/* Report status changed */
+	power_supply_changed(lemote3a_bat);
+
+	return 0;
+}
+
+/* SCI device Battery low event handler */
+static int lemote3a_bat_low_handler(int status)
+{
+	/* Report status changed */
+	power_supply_changed(lemote3a_bat);
+
+	return 0;
+}
+
+/* SCI device Battery very low event handler */
+static int lemote3a_bat_very_low_handler(int status)
+{
+	/* Report status changed */
+	power_supply_changed(lemote3a_bat);
+
+	return 0;
+}
+
+/* SCI device LID event handler */
+static int lemote3a_lid_handler(int status)
+{
+	if (status & BIT(BIT_DEVICE_LID)) {
+		return 1;
+	}
+
+	return 0;
+}
+
+/* Hotkey device init handler */
+static int lemote3a_hotkey_init(void)
+{
+	int ret;
+
+	lemote3a_hotkey_dev = input_allocate_device();
+	if (!lemote3a_hotkey_dev) {
+		return -ENOMEM;
+	}
+
+	lemote3a_hotkey_dev->name = "Lemote Laptop Hotkeys";
+	lemote3a_hotkey_dev->phys = "button/input0";
+	lemote3a_hotkey_dev->id.bustype = BUS_HOST;
+	lemote3a_hotkey_dev->dev.parent = NULL;
+
+	ret = sparse_keymap_setup(lemote3a_hotkey_dev, lemote3a_keymap, NULL);
+	if (ret) {
+		printk(KERN_ERR "Lemote Laptop Platform Driver : Fail to setup input device keymap\n");
+		input_free_device(lemote3a_hotkey_dev);
+		return ret;
+	}
+
+	ret = input_register_device(lemote3a_hotkey_dev);
+	if (ret) {
+		input_free_device(lemote3a_hotkey_dev);
+		return ret;
+	}
+	return 0;
+}
+
+/* Hotkey device exit handler */
+static void lemote3a_hotkey_exit(void)
+{
+	if (lemote3a_hotkey_dev) {
+		input_unregister_device(lemote3a_hotkey_dev);
+		lemote3a_hotkey_dev = NULL;
+	}
+}
+
+module_init(lemote3a_laptop_init);
+module_exit(lemote3a_laptop_exit);
+
+MODULE_ALIAS("platform:wpce775l");
+MODULE_AUTHOR("Huang Wei <huangw@lemote.com>; Wang Rui <wangr@lemote.com>");
+MODULE_DESCRIPTION("Lemote Loongson-3A/2Gq Laptop Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/platform/mips/sbx00_fan.c b/drivers/platform/mips/sbx00_fan.c
new file mode 100644
index 000000000000..6331e09722a1
--- /dev/null
+++ b/drivers/platform/mips/sbx00_fan.c
@@ -0,0 +1,767 @@
+/*
+ * SB700/SB710/SB800 series South Bridge provide 4 Fan controllers,
+ * Loongson products almost use 1/2 of them.
+ *
+ * Fan1 & Fan2 usage:
+ * 1. configure gpio3 as gpio48 to Fanout mode
+ * 2. configure fan controll mode(depmod on HW design)
+ * 3. set pwm freqency
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/workqueue.h>
+#include <linux/platform_device.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+
+#include <boot_param.h>
+#include <loongson_hwmon.h>
+
+/* PM regs */
+#define PM_OPTION_0	0x60
+#define FAN0_EN		(1 << 6)
+#define FAN1_EN		(1 << 2)
+#define FAN2_EN		(1 << 3)
+
+/* PM2 regs*/
+#define FAN_CNTR_REG	0
+
+#define FAN_MODE0	0
+#define FAN_MODE1	1
+#define FAN_MODE2	2
+#define FAN_MODE3	3
+#define FAN_MODE_MASK	3
+#define FAN0_CNTR_SHIFT	0
+#define FAN1_CNTR_SHIFT	2
+#define FAN2_CNTR_SHIFT	4
+#define FAN3_CNTR_SHIFT	6
+
+#define FAN_MISC0_REG	0x01
+#define FAN_MISC1_REG	0x0e
+#define FAN_MISC2_REG	0x1b
+#define AUTPMODE0	0
+#define LINEARMODE0	1
+#define FAN0POLARITY	2
+#define AUTPMODE1	0
+#define LINEARMODE1	1
+#define FAN1POLARITY	2
+
+#define FREQDIV0_REG	0x02
+#define FREQDIV1_REG	0x0f
+#define FREQDIV2_REG	0x1c
+#define PWM_28KHZ	0  /* 28.64KHz */
+#define PWM_25KHZ	1  /* 25.78KHz */
+#define PWM_23KHZ	2  /* 23.44KHz */
+#define PWM_21KHZ	3  /* 21.48KHz */
+#define PWM_19KHZ	4  /* 19.83KHz */
+#define PWM_18KHZ	5  /* 18.41KHz */
+
+#define LOWDUTY0	0x03
+#define LOWDUTY1	0x10
+#define LOWDUTY2	0x1d
+
+#define FAN0DETCONTROL  0x31
+#define FAN0SPEEDLIMLO  0x32
+#define FAN0SPEEDLIMHI  0x33
+#define FAN0SPEEDLO	0x34
+#define FAN0SPEEDHI	0x35
+
+#define FAN1DETCONTROL	0x36
+#define FAN1SPEEDLIMLO  0x37
+#define FAN1SPEEDLIMHI  0x38
+#define FAN1SPEEDLO	0x39
+#define FAN1SPEEDHI	0x3A
+
+#define FAN2DETCONTROL	0x3B
+#define FAN2SPEEDLIMLO  0x3C
+#define FAN2SPEEDLIMHI  0x3D
+#define FAN2SPEEDLO	0x3E
+#define FAN2SPEEDHI	0x3F
+
+#define FANSTATUS	1 /* bit 0 */
+#define FANTOOSLOW	1
+
+#define FANDET_EN	1 /* bit 0 */
+#define USEAVERAGE	2 /* bit 1 */
+#define ShutDown_EN	0x10 /* bit 4 */
+
+#define MAX_SBX00_FANS 3
+int sbx00_fan_enable[MAX_SBX00_FANS];
+static enum fan_control_mode sbx00_fan_mode[MAX_SBX00_FANS];
+static struct loongson_fan_policy fan_policy[MAX_SBX00_FANS];
+
+/* threshold = SpeedOfPWM(0)/SpeedOfPWM(255) */
+static int speed_percent_threshold[MAX_SBX00_FANS];
+
+extern u8 pm_ioread(u8 reg);
+extern u8 pm2_ioread(u8 reg);
+extern void pm_iowrite(u8 reg, u8 val);
+extern void pm2_iowrite(u8 reg, u8 val);
+
+/* up_temp & down_temp used in fan auto adjust */
+static u8 fan_up_temp[MAX_SBX00_FANS];
+static u8 fan_down_temp[MAX_SBX00_FANS];
+static u8 fan_up_temp_level[MAX_SBX00_FANS];
+static u8 fan_down_temp_level[MAX_SBX00_FANS];
+
+static void fan1_adjust(struct work_struct *work);
+static void fan2_adjust(struct work_struct *work);
+static void fan3_adjust(struct work_struct *work);
+
+static struct device *sbx00_hwmon_dev;
+
+static ssize_t get_hwmon_name(struct device *dev,
+			struct device_attribute *attr, char *buf);
+static SENSOR_DEVICE_ATTR(name, S_IRUGO, get_hwmon_name, NULL, 0);
+
+static struct attribute *sbx00_hwmon_attributes[] =
+{
+	&sensor_dev_attr_name.dev_attr.attr,
+	NULL
+};
+
+/* Hwmon device attribute group */
+static struct attribute_group sbx00_hwmon_attribute_group =
+{
+	.attrs = sbx00_hwmon_attributes,
+};
+
+/* Hwmon device get name */
+static ssize_t get_hwmon_name(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "sbx00-fan\n");
+}
+
+/* low-level fucntions */
+static void sbx00_set_fan_level(u8 level, int id)
+{
+	if (id == 0)
+		pm2_iowrite(LOWDUTY0, level);
+	if (id == 1)
+		pm2_iowrite(LOWDUTY1, level);
+	if (id == 2)
+		pm2_iowrite(LOWDUTY2, level);
+}
+
+static void get_up_temp(struct loongson_fan_policy *policy,
+			u8 current_temp, u8* up_temp, u8* up_temp_level)
+{
+	int i;
+
+	for (i = 0; i < policy->up_step_num; i++) {
+		if (current_temp <= policy->up_step[i].low) {
+			*up_temp = policy->up_step[i].low;
+			*up_temp_level = i;
+			return;
+		}
+	}
+
+	*up_temp = MAX_TEMP;
+	*up_temp_level = policy->up_step_num - 1;
+}
+
+static void get_down_temp(struct loongson_fan_policy *policy, u8 current_temp,
+				u8* down_temp, u8* down_temp_level)
+{
+	int i;
+
+	for (i = policy->down_step_num-1; i >= 0; i--) {
+		if (current_temp >= policy->down_step[i].high) {
+			*down_temp = policy->down_step[i].high;
+			*down_temp_level = i;
+			return;
+		}
+	}
+
+	*down_temp = MIN_TEMP;
+	*down_temp_level = 0;
+}
+
+static ssize_t get_fan_level(struct device *dev,
+			struct device_attribute *attr, char *buf);
+static ssize_t set_fan_level(struct device *dev,
+			struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t get_fan_mode(struct device *dev,
+			struct device_attribute *attr, char *buf);
+static ssize_t set_fan_mode(struct device *dev,
+			struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t get_fan_speed(struct device *dev,
+			struct device_attribute *attr, char *buf);
+
+static SENSOR_DEVICE_ATTR(pwm1, S_IWUSR | S_IRUGO,
+				get_fan_level, set_fan_level, 1);
+static SENSOR_DEVICE_ATTR(pwm1_enable, S_IWUSR | S_IRUGO,
+				get_fan_mode, set_fan_mode, 1);
+static SENSOR_DEVICE_ATTR(fan1_input, S_IRUGO, get_fan_speed, NULL, 1);
+
+static SENSOR_DEVICE_ATTR(pwm2, S_IWUSR | S_IRUGO,
+				get_fan_level, set_fan_level, 2);
+static SENSOR_DEVICE_ATTR(pwm2_enable, S_IWUSR | S_IRUGO,
+				get_fan_mode, set_fan_mode, 2);
+static SENSOR_DEVICE_ATTR(fan2_input, S_IRUGO, get_fan_speed, NULL, 2);
+
+static SENSOR_DEVICE_ATTR(pwm3, S_IWUSR | S_IRUGO,
+				get_fan_level, set_fan_level, 3);
+static SENSOR_DEVICE_ATTR(pwm3_enable, S_IWUSR | S_IRUGO,
+				get_fan_mode, set_fan_mode, 3);
+static SENSOR_DEVICE_ATTR(fan3_input, S_IRUGO, get_fan_speed, NULL, 3);
+
+static const struct attribute *sbx00_hwmon_fan[3][4] = {
+	{
+		&sensor_dev_attr_pwm1.dev_attr.attr,
+		&sensor_dev_attr_pwm1_enable.dev_attr.attr,
+		&sensor_dev_attr_fan1_input.dev_attr.attr,
+		NULL
+	},
+	{
+		&sensor_dev_attr_pwm2.dev_attr.attr,
+		&sensor_dev_attr_pwm2_enable.dev_attr.attr,
+		&sensor_dev_attr_fan2_input.dev_attr.attr,
+		NULL
+	},
+	{
+		&sensor_dev_attr_pwm3.dev_attr.attr,
+		&sensor_dev_attr_pwm3_enable.dev_attr.attr,
+		&sensor_dev_attr_fan3_input.dev_attr.attr,
+		NULL
+	}
+};
+
+static ssize_t get_fan_level(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	u8 val = 0;
+	int id = (to_sensor_dev_attr(attr))->index - 1;
+
+	if (id == 0)
+		val = pm2_ioread(LOWDUTY0);
+	if (id == 1)
+		val = pm2_ioread(LOWDUTY1);
+	if (id == 2)
+		val = pm2_ioread(LOWDUTY2);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t set_fan_level(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	u8 new_level;
+	int id = (to_sensor_dev_attr(attr))->index - 1;
+
+	new_level = clamp_val(simple_strtoul(buf, NULL, 10), 0, 255);
+	if (sbx00_fan_mode[id] == FAN_MANUAL_MODE) {
+		if (id == 0)
+			pm2_iowrite(LOWDUTY0, new_level);
+		if (id == 1)
+			pm2_iowrite(LOWDUTY1, new_level);
+		if (id == 2)
+			pm2_iowrite(LOWDUTY2, new_level);
+	}
+
+	return count;
+}
+
+static ssize_t get_fan_mode(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	int id = (to_sensor_dev_attr(attr))->index - 1;
+	return sprintf(buf, "%d\n", sbx00_fan_mode[id]);
+}
+
+static void sbx00_fan_step_mode(get_temp_fun fun,
+			struct loongson_fan_policy *policy, int id)
+{
+	u8 current_temp;
+	int init_temp_level, target_fan_level, bias;
+
+	current_temp = fun(0) / 1000;
+	get_up_temp(policy, current_temp, &fan_up_temp[id],
+			&fan_up_temp_level[id]);
+	get_down_temp(policy, current_temp, &fan_down_temp[id],
+			&fan_down_temp_level[id]);
+
+	/* current speed is not sure, setting now */
+	init_temp_level = (fan_up_temp_level[id] + fan_down_temp_level[id]) / 2;
+	target_fan_level = policy->up_step[init_temp_level].level * 255 / 100;
+	bias = (speed_percent_threshold[id] * 255) / 100; /* bias of pwm(0) */
+	bias = bias * (255 - target_fan_level) / 255;     /* bias of pwm(target) */
+	target_fan_level = (target_fan_level > bias) ? target_fan_level - bias : 0;
+	target_fan_level = target_fan_level * fan_policy[id].percent / 100;
+	sbx00_set_fan_level(target_fan_level, id);
+
+	schedule_delayed_work_on(0, &policy->work, policy->adjust_period * HZ);
+}
+
+static void sbx00_fan_start_auto(int id)
+{
+	u8 level;
+
+	switch (fan_policy[id].type) {
+	case CONSTANT_SPEED_POLICY:
+		level = fan_policy[id].percent * 255 / 100;
+		if (level > MAX_FAN_LEVEL)
+			level = MAX_FAN_LEVEL;
+		sbx00_set_fan_level(level, id);
+		break;
+	case STEP_SPEED_POLICY:
+		sbx00_fan_step_mode(fan_policy[id].depend_temp, &fan_policy[id], id);
+		break;
+	default:
+		printk(KERN_ERR "sbx00 fan not support fan policy id %d!\n", fan_policy[id].type);
+		sbx00_set_fan_level(MAX_FAN_LEVEL, id);
+	}
+
+	return;
+}
+
+static void sbx00_fan_stop_auto(int id)
+{
+	if ((fan_policy[id].type == STEP_SPEED_POLICY) &&
+			(sbx00_fan_mode[id] == FAN_AUTO_MODE)) {
+		cancel_delayed_work(&fan_policy[id].work);
+	}
+}
+
+static ssize_t set_fan_mode(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	u8 new_mode;
+	int id = (to_sensor_dev_attr(attr))->index - 1;
+
+	new_mode = clamp_val(simple_strtoul(buf, NULL, 10),
+					FAN_FULL_MODE, FAN_AUTO_MODE);
+	if (new_mode == sbx00_fan_mode[id])
+		return count;
+
+	switch (new_mode) {
+	case FAN_FULL_MODE:
+		sbx00_fan_stop_auto(id);
+		sbx00_set_fan_level(MAX_FAN_LEVEL, id);
+		break;
+	case FAN_MANUAL_MODE:
+		sbx00_fan_stop_auto(id);
+		break;
+	case FAN_AUTO_MODE:
+		sbx00_fan_start_auto(id);
+		break;
+	default:
+		break;
+	}
+
+	sbx00_fan_mode[id] = new_mode;
+
+	return count;
+}
+
+static u32 sbx00_get_fan_speed(int id, bool warn)
+{
+	int speed_lo = 0, speed_hi = 0, count = 1;
+
+	if (id == 0) {
+		speed_lo = pm2_ioread(FAN0SPEEDLO);
+		speed_hi = pm2_ioread(FAN0SPEEDHI);
+	}
+	if (id == 1) {
+		speed_lo = pm2_ioread(FAN1SPEEDLO);
+		speed_hi = pm2_ioread(FAN1SPEEDHI);
+	}
+	if (id == 2) {
+		speed_lo = pm2_ioread(FAN2SPEEDLO);
+		speed_hi = pm2_ioread(FAN2SPEEDHI);
+	}
+
+	if (speed_lo & FANTOOSLOW) {
+		if (warn)
+			pr_warn("FanSpeed too slow!\n");
+		return 0;
+	}
+	count = speed_hi << 8 | (speed_lo & ~FANSTATUS);
+	return 360000 / count;
+}
+
+static ssize_t get_fan_speed(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	int id = (to_sensor_dev_attr(attr))->index - 1;
+	u32 val = sbx00_get_fan_speed(id, true);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static void sbx00_fan1_init(struct work_struct *work)
+{
+	u8 reg;
+	int ret;
+	int speed_low, speed_high;
+
+	/* Configure gpio3 as FANOUT0 */
+	reg = pm_ioread(PM_OPTION_0);
+	pm_iowrite(PM_OPTION_0, reg | FAN0_EN);
+
+	/* setting FANOUT0 mode:
+	 * without temperuature input, controlled by software
+	 */
+	reg = pm2_ioread(FAN_CNTR_REG);
+	reg &= ~(FAN_MODE_MASK << FAN0_CNTR_SHIFT);
+	reg |= FAN_MODE1 << FAN0_CNTR_SHIFT;
+	pm2_iowrite(FAN_CNTR_REG, reg);
+
+	reg = pm2_ioread(FAN_MISC0_REG);
+	reg &= ~(1 << AUTPMODE0);   /* Disable auto mode*/
+	reg &= ~(1 << LINEARMODE0); /* Use step mode*/
+	reg |= (1 << FAN0POLARITY); /* Active High */
+	pm2_iowrite(FAN_MISC0_REG, reg);
+
+	/* Set PWM freqency*/
+	pm2_iowrite(FREQDIV0_REG, PWM_19KHZ);
+
+	/* Enable Speed Detect */
+	pm2_iowrite(FAN0DETCONTROL, FANDET_EN | USEAVERAGE);
+	pm2_iowrite(FAN0SPEEDLIMLO, 0xFF); /* Set limits register */
+	pm2_iowrite(FAN0SPEEDLIMHI, 0xFF);
+
+	sbx00_set_fan_level(255, 0);
+	msleep(250);
+	speed_high = sbx00_get_fan_speed(0, false);
+	sbx00_set_fan_level(0, 0);
+	msleep(5000);
+	speed_low = sbx00_get_fan_speed(0, false);
+	sbx00_set_fan_level(255, 0);
+	if (speed_high >= speed_low)
+		speed_percent_threshold[0] = speed_low * 100 / speed_high;
+	pr_info("SpeedPercentThreshold of FAN1 is %d%%\n", speed_percent_threshold[0]);
+
+	/* force fans in auto mode first */
+	work->func = fan1_adjust;
+	sbx00_fan_mode[0] = FAN_AUTO_MODE;
+	sbx00_fan_start_auto(0);
+
+	ret = sysfs_create_files(&sbx00_hwmon_dev->kobj, sbx00_hwmon_fan[0]);
+	if (ret)
+		printk(KERN_ERR "fail to create sysfs files\n");
+}
+
+static void fan1_adjust(struct work_struct *work)
+{
+	u8 current_temp;
+	int target_fan_level, bias;
+
+	current_temp = fan_policy[0].depend_temp(0) / 1000;
+
+	if ((current_temp <= fan_up_temp[0]) &&
+		(current_temp >= fan_down_temp[0]))
+		goto exit;
+
+	if (current_temp > fan_up_temp[0])
+		target_fan_level = fan_policy[0].up_step[fan_up_temp_level[0]].level * 255 / 100;
+
+	if (current_temp < fan_down_temp[0])
+		target_fan_level = fan_policy[0].down_step[fan_down_temp_level[0]].level * 255 / 100;
+
+	bias = (speed_percent_threshold[0] * 255) / 100;
+	bias = bias * (255 - target_fan_level) / 255;
+	target_fan_level = (target_fan_level > bias) ? target_fan_level - bias : 0;
+	target_fan_level = target_fan_level * fan_policy[0].percent / 100;
+	sbx00_set_fan_level(target_fan_level, 0);
+
+	get_up_temp(&fan_policy[0], current_temp, &fan_up_temp[0], &fan_up_temp_level[0]);
+	get_down_temp(&fan_policy[0], current_temp, &fan_down_temp[0], &fan_down_temp_level[0]);
+
+exit:
+        schedule_delayed_work_on(0, &fan_policy[0].work, fan_policy[0].adjust_period * HZ);
+}
+
+static void sbx00_fan2_init(struct work_struct *work)
+{
+	u8 reg;
+	int ret;
+	int speed_low, speed_high;
+
+	/* Configure gpio48 as FANOUT1 */
+	reg = pm_ioread(PM_OPTION_0);
+	pm_iowrite(PM_OPTION_0, reg | FAN1_EN);
+
+	/* setting FANOUT1 mode:
+	 * without temperuature input, controlled by software
+	 */
+	reg = pm2_ioread(FAN_CNTR_REG);
+	reg &= ~(FAN_MODE_MASK << FAN1_CNTR_SHIFT);
+	reg |= FAN_MODE1 << FAN1_CNTR_SHIFT;
+	pm2_iowrite(FAN_CNTR_REG, reg);
+
+	reg = pm2_ioread(FAN_MISC1_REG);
+	reg &= ~(1 << AUTPMODE1);   /* Disable auto mode*/
+	reg &= ~(1 << LINEARMODE1); /* Use step mode*/
+	reg |= (1 << FAN1POLARITY); /* Active High */
+	pm2_iowrite(FAN_MISC1_REG, reg);
+
+	/* Set PWM freqency at 19.83KHz*/
+	pm2_iowrite(FREQDIV1_REG, PWM_19KHZ);
+
+	/* Enable Speed Detect */
+	pm2_iowrite(FAN1DETCONTROL, FANDET_EN | USEAVERAGE);
+	pm2_iowrite(FAN1SPEEDLIMLO, 0xFF); /* Set limits register */
+	pm2_iowrite(FAN1SPEEDLIMHI, 0xFF);
+
+	sbx00_set_fan_level(255, 1);
+	msleep(250);
+	speed_high = sbx00_get_fan_speed(1, false);
+	sbx00_set_fan_level(0, 1);
+	msleep(5000);
+	speed_low = sbx00_get_fan_speed(1, false);
+	sbx00_set_fan_level(255, 1);
+	if (speed_high >= speed_low)
+		speed_percent_threshold[1] = speed_low * 100 / speed_high;
+	pr_info("SpeedPercentThreshold of FAN2 is %d%%\n", speed_percent_threshold[1]);
+
+	/* force fans in auto mode first */
+	work->func = fan2_adjust;
+	sbx00_fan_mode[1] = FAN_AUTO_MODE;
+	sbx00_fan_start_auto(1);
+
+	ret = sysfs_create_files(&sbx00_hwmon_dev->kobj, sbx00_hwmon_fan[1]);
+	if (ret)
+		printk(KERN_ERR "fail to create sysfs files\n");
+}
+
+static void fan2_adjust(struct work_struct *work)
+{
+	u8 current_temp;
+	int target_fan_level, bias;
+
+	current_temp = fan_policy[1].depend_temp(0) / 1000;
+
+	if ((current_temp <= fan_up_temp[1]) &&
+		(current_temp >= fan_down_temp[1]))
+		goto exit;
+
+	if (current_temp > fan_up_temp[1])
+		target_fan_level = fan_policy[1].up_step[fan_up_temp_level[1]].level * 255 / 100;
+
+	if (current_temp < fan_down_temp[1])
+		target_fan_level = fan_policy[1].down_step[fan_down_temp_level[1]].level * 255 / 100;
+
+	bias = (speed_percent_threshold[1] * 255) / 100;
+	bias = bias * (255 - target_fan_level) / 255;
+	target_fan_level = (target_fan_level > bias) ? target_fan_level - bias : 0;
+	target_fan_level = target_fan_level * fan_policy[1].percent / 100;
+	sbx00_set_fan_level(target_fan_level, 1);
+
+	get_up_temp(&fan_policy[1], current_temp, &fan_up_temp[1], &fan_up_temp_level[1]);
+	get_down_temp(&fan_policy[1], current_temp, &fan_down_temp[1], &fan_down_temp_level[1]);
+
+exit:
+        schedule_delayed_work_on(0, &fan_policy[1].work, fan_policy[1].adjust_period * HZ);
+}
+
+static void sbx00_fan3_init(struct work_struct *work)
+{
+	u8 reg;
+	int ret;
+	int speed_low, speed_high;
+
+	/* Configure gpio49 as FANOUT2 */
+	reg = pm_ioread(PM_OPTION_0);
+	pm_iowrite(PM_OPTION_0, reg | FAN2_EN);
+
+	/* setting FANOUT2 mode:
+	 * without temperuature input, controlled by software
+	 */
+	reg = pm2_ioread(FAN_CNTR_REG);
+	reg &= ~(FAN_MODE_MASK << FAN2_CNTR_SHIFT);
+	reg |= FAN_MODE1 << FAN2_CNTR_SHIFT;
+	pm2_iowrite(FAN_CNTR_REG, reg);
+
+	reg = pm2_ioread(FAN_MISC2_REG);
+	reg &= ~(1 << AUTPMODE1);   /* Disable auto mode*/
+	reg &= ~(1 << LINEARMODE1); /* Use step mode*/
+	reg |= (1 << FAN1POLARITY); /* Active High */
+	pm2_iowrite(FAN_MISC2_REG, reg);
+
+	/* Set PWM freqency at 19.83KHz*/
+	pm2_iowrite(FREQDIV2_REG, PWM_19KHZ);
+
+	/* Enable Speed Detect */
+	pm2_iowrite(FAN2DETCONTROL, FANDET_EN | USEAVERAGE);
+	pm2_iowrite(FAN2SPEEDLIMLO, 0xFF); /* Set limits register */
+	pm2_iowrite(FAN2SPEEDLIMHI, 0xFF);
+
+	sbx00_set_fan_level(255, 2);
+	msleep(250);
+	speed_high = sbx00_get_fan_speed(2, false);
+	sbx00_set_fan_level(0, 2);
+	msleep(5000);
+	speed_low = sbx00_get_fan_speed(2, false);
+	sbx00_set_fan_level(255, 2);
+	if (speed_high >= speed_low)
+		speed_percent_threshold[2] = speed_low * 100 / speed_high;
+	pr_info("SpeedPercentThreshold of FAN3 is %d%%\n", speed_percent_threshold[2]);
+
+	/* force fans in auto mode first */
+	work->func = fan3_adjust;
+	sbx00_fan_mode[2] = FAN_AUTO_MODE;
+	sbx00_fan_start_auto(2);
+
+	ret = sysfs_create_files(&sbx00_hwmon_dev->kobj, sbx00_hwmon_fan[2]);
+	if (ret)
+		printk(KERN_ERR "fail to create sysfs files\n");
+}
+
+static void fan3_adjust(struct work_struct *work)
+{
+	u8 current_temp;
+	int target_fan_level, bias;
+
+	current_temp =  fan_policy[2].depend_temp(0) / 1000;
+
+	if ((current_temp <= fan_up_temp[2]) &&
+		(current_temp >= fan_down_temp[2]))
+		goto exit;
+
+	if (current_temp > fan_up_temp[2])
+		target_fan_level = fan_policy[2].up_step[fan_up_temp_level[2]].level * 255 / 100;
+
+	if (current_temp < fan_down_temp[2])
+		target_fan_level = fan_policy[2].down_step[fan_down_temp_level[2]].level * 255 / 100;
+
+	bias = (speed_percent_threshold[2] * 255) / 100;
+	bias = bias * (255 - target_fan_level) / 255;
+	target_fan_level = (target_fan_level > bias) ? target_fan_level - bias : 0;
+	target_fan_level = target_fan_level * fan_policy[2].percent / 100;
+	sbx00_set_fan_level(target_fan_level, 2);
+
+	get_up_temp(&fan_policy[2], current_temp, &fan_up_temp[2], &fan_up_temp_level[2]);
+	get_down_temp(&fan_policy[2], current_temp, &fan_down_temp[2], &fan_down_temp_level[2]);
+
+exit:
+        schedule_delayed_work_on(0, &fan_policy[2].work, fan_policy[2].adjust_period * HZ);
+}
+
+static int sbx00_fan_probe(struct platform_device *dev)
+{
+	int id = dev->id - 1;
+	struct sensor_device *sdev = (struct sensor_device *)dev->dev.platform_data;
+
+	/* get fan policy */
+	switch (sdev->fan_policy) {
+	case KERNEL_HELPER_POLICY:
+		memcpy(&fan_policy[id], &kernel_helper_policy, sizeof(struct loongson_fan_policy));
+		break;
+	case STEP_SPEED_POLICY:
+		memcpy(&fan_policy[id], &step_speed_policy, sizeof(struct loongson_fan_policy));
+		fan_policy[id].percent = sdev->fan_percent;
+		if (fan_policy[id].percent == 0 || fan_policy[id].percent > 100)
+			fan_policy[id].percent = 100;
+		break;
+	case CONSTANT_SPEED_POLICY:
+	default:
+		memcpy(&fan_policy[id], &constant_speed_policy, sizeof(struct loongson_fan_policy));
+		fan_policy[id].percent = sdev->fan_percent;
+		if (fan_policy[id].percent == 0 || fan_policy[id].percent > 100)
+			fan_policy[id].percent = 100;
+		break;
+	}
+
+	if (id == 0) {
+		INIT_DEFERRABLE_WORK(&fan_policy[0].work, sbx00_fan1_init);
+		schedule_delayed_work_on(0, &fan_policy[0].work, 0);
+	}
+	if (id == 1) {
+		INIT_DEFERRABLE_WORK(&fan_policy[1].work, sbx00_fan2_init);
+		schedule_delayed_work_on(0, &fan_policy[1].work, 0);
+	}
+	if (id == 2) {
+		INIT_DEFERRABLE_WORK(&fan_policy[2].work, sbx00_fan3_init);
+		schedule_delayed_work_on(0, &fan_policy[2].work, 0);
+	}
+
+	sbx00_fan_enable[id] = 1;
+
+	return 0;
+}
+
+static struct platform_driver sbx00_fan_driver = {
+	.probe		= sbx00_fan_probe,
+	.driver		= {
+		.name	= "sbx00-fan",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init sbx00_fan_init(void)
+{
+	int ret;
+
+	sbx00_hwmon_dev = hwmon_device_register(NULL);
+	if (IS_ERR(sbx00_hwmon_dev)) {
+		ret = -ENOMEM;
+		printk(KERN_ERR "hwmon_device_register fail!\n");
+		goto fail_hwmon_device_register;
+	}
+
+	ret = sysfs_create_group(&sbx00_hwmon_dev->kobj,
+				&sbx00_hwmon_attribute_group);
+	if (ret) {
+		printk(KERN_ERR "fail to create loongson hwmon!\n");
+		goto fail_sysfs_create_group_hwmon;
+	}
+
+	ret = platform_driver_register(&sbx00_fan_driver);
+	if (ret) {
+		printk(KERN_ERR "fail to register fan driver!\n");
+		goto fail_register_fan;
+	}
+
+	return 0;
+
+fail_register_fan:
+	sysfs_remove_group(&sbx00_hwmon_dev->kobj,
+				&sbx00_hwmon_attribute_group);
+
+fail_sysfs_create_group_hwmon:
+	hwmon_device_unregister(sbx00_hwmon_dev);
+
+fail_hwmon_device_register:
+	return ret;
+}
+
+static void __exit sbx00_fan_exit(void)
+{
+	/* set fan at full speed before module exit */
+	if (sbx00_fan_enable[0]) {
+		sbx00_fan_mode[0] = FAN_FULL_MODE;
+		sbx00_fan_stop_auto(0);
+		sbx00_set_fan_level(MAX_FAN_LEVEL, 0);
+	}
+
+	if (sbx00_fan_enable[1]) {
+		sbx00_fan_mode[1] = FAN_FULL_MODE;
+		sbx00_fan_stop_auto(1);
+		sbx00_set_fan_level(MAX_FAN_LEVEL, 1);
+	}
+
+	if (sbx00_fan_enable[2]) {
+		sbx00_fan_mode[2] = FAN_FULL_MODE;
+		sbx00_fan_stop_auto(2);
+		sbx00_set_fan_level(MAX_FAN_LEVEL, 2);
+	}
+
+	platform_driver_unregister(&sbx00_fan_driver);
+	sysfs_remove_group(&sbx00_hwmon_dev->kobj,
+				&sbx00_hwmon_attribute_group);
+	hwmon_device_unregister(sbx00_hwmon_dev);
+}
+
+late_initcall(sbx00_fan_init);
+module_exit(sbx00_fan_exit);
+
+MODULE_AUTHOR("Yu Xiang <xiangy@lemote.com>");
+MODULE_AUTHOR("Huacai Chen <chenhc@lemote.com>");
+MODULE_DESCRIPTION("SB700/SB710/SB800 fan control driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/platform/mips/sd5075.c b/drivers/platform/mips/sd5075.c
new file mode 100644
index 000000000000..be42c5882290
--- /dev/null
+++ b/drivers/platform/mips/sd5075.c
@@ -0,0 +1,211 @@
+#include <linux/i2c.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/jiffies.h>
+#include <linux/delay.h>
+#include <boot_param.h>
+#include <loongson_hwmon.h>
+
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include <linux/platform_device.h>
+
+static struct i2c_client *sd5075_client = NULL;
+
+static struct device *sd5075_hwmon_dev;
+
+static ssize_t get_hwmon_name(struct device *dev,
+			struct device_attribute *attr, char *buf);
+static ssize_t get_sd5075_label(struct device *dev,
+			struct device_attribute *attr, char *buf);
+static ssize_t get_sd5075_temp(struct device *dev,
+			struct device_attribute *attr, char *buf);
+
+static SENSOR_DEVICE_ATTR(name, S_IRUGO, get_hwmon_name, NULL, 0);
+
+static struct attribute *sd5075_hwmon_attributes[] =
+{
+	&sensor_dev_attr_name.dev_attr.attr,
+	NULL
+};
+
+/* Hwmon device attribute group */
+static struct attribute_group sd5075_hwmon_attribute_group =
+{
+	.attrs = sd5075_hwmon_attributes,
+};
+
+/* Hwmon device get name */
+static ssize_t get_hwmon_name(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "sd5075\n");
+}
+
+static SENSOR_DEVICE_ATTR(temp1_input, S_IRUGO, get_sd5075_temp, NULL, 1);
+static SENSOR_DEVICE_ATTR(temp1_label, S_IRUGO, get_sd5075_label, NULL, 1);
+
+static const struct attribute *sd5075_hwmon_temp[1][3] = {
+	{
+		&sensor_dev_attr_temp1_input.dev_attr.attr,
+		&sensor_dev_attr_temp1_label.dev_attr.attr,
+		NULL
+	}
+};
+
+#define BUS_MASK  0xffffffff00000000ul
+#define ADDR_MASK 0x00000000fffffffful
+
+static int sd5075_probe(struct platform_device *dev)
+{
+	char i2c_name[16];
+	struct i2c_board_info info;
+	struct i2c_adapter *adapter = NULL;
+	int found = 0, i = 0, r = 0, i2c_bus;
+	struct sensor_device *sdev = (struct sensor_device *)dev->dev.platform_data;
+
+	memset(&info, 0, sizeof(struct i2c_board_info));
+
+	i2c_bus = ((sdev->base_addr & BUS_MASK) >> 32) - 1;
+	if (i2c_bus < 0)
+		sprintf(i2c_name, "SMBus PIIX4");
+	else 
+		sprintf(i2c_name, "LS2X I2C%d", i2c_bus);
+
+	/* get i2c_adapter */
+	adapter = i2c_get_adapter(i++);
+	while (adapter) {
+		if (strncmp(adapter->name, i2c_name, strlen(i2c_name)) == 0) {
+			found = 1;
+			break;
+		}
+
+		adapter = i2c_get_adapter(i++);
+	}
+
+	if (!found)
+		goto fail;
+
+	info.addr = sdev->base_addr & ADDR_MASK;
+	info.platform_data = dev->dev.platform_data;
+	strncpy(info.type, "sd5075", I2C_NAME_SIZE);
+	sd5075_client = i2c_new_device(adapter, &info);
+	if (sd5075_client == NULL) {
+		pr_err("failed to attach sd5075 sensor\n");
+		goto fail;
+	}
+
+	r = sysfs_create_files(&sd5075_hwmon_dev->kobj, sd5075_hwmon_temp[0]);
+	if (r)
+		goto fail;
+	
+	/* set alert mode */
+	i2c_smbus_write_byte_data(sd5075_client, 0x1, 0x80);
+
+	printk(KERN_INFO "Success to attach sd5075 sensor\n");
+
+	return 0;
+fail:
+	pr_err("Fail to found smbus controller attach sd5075 sensor\n");
+
+	return r;
+}
+
+static void sd5075_shutdown(struct platform_device *dev)
+{
+	sd5075_client = NULL;
+	msleep(15); /* Release I2C/SMBus resources */ 
+}
+
+static ssize_t get_sd5075_label(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct sensor_device *sdev = (struct sensor_device *)sd5075_client->dev.platform_data;
+	return sprintf(buf, "%s\n", sdev->label);
+}
+
+int sd5075_internal_temp(int id)
+{
+	int reg_value = 0, temp;
+	
+	reg_value = i2c_smbus_read_word_swapped(sd5075_client, 0x0);
+
+	if (reg_value & 0x8000)  
+	{
+		reg_value |= 0xffff0000;
+		temp = (reg_value >> 4) * 1000 / 16;
+
+	}
+	else 
+		temp = (reg_value >> 4) * 1000 / 16;
+
+	return temp;
+}
+
+static ssize_t get_sd5075_temp(struct device *dev, struct device_attribute *attr, char *buf) {
+	
+	int id = (to_sensor_dev_attr(attr))->index -1;
+	int value = sd5075_internal_temp(id);
+
+	return sprintf(buf, "%d\n", value);
+
+}
+
+static struct platform_driver sd5075_driver = {
+	.driver		= {
+		.name	= "sd5075",
+		.owner	= THIS_MODULE,
+	},
+	.probe		= sd5075_probe,
+	.shutdown   = sd5075_shutdown,
+};
+
+static int __init sd5075_init(void)
+{
+	int ret;
+	
+	sd5075_hwmon_dev = hwmon_device_register(NULL);
+	
+	if (IS_ERR(sd5075_hwmon_dev)) {
+		ret = -ENOMEM;
+		printk(KERN_ERR "hwmon_device_register fail!\n");
+		goto fail_hwmon_device_register;
+	}
+
+	ret = sysfs_create_group(&sd5075_hwmon_dev->kobj,
+				&sd5075_hwmon_attribute_group);
+	if (ret) {
+		printk(KERN_ERR "fail to create loongson hwmon!\n");
+		goto fail_sysfs_create_group_hwmon;
+	}
+
+	platform_driver_register(&sd5075_driver);
+
+	return 	0;
+
+fail_sysfs_create_group_hwmon:
+	hwmon_device_unregister(sd5075_hwmon_dev);
+
+fail_hwmon_device_register:
+	return ret;
+}
+
+static void __exit sd5075_exit(void)
+{
+	platform_driver_unregister(&sd5075_driver);
+	sysfs_remove_group(&sd5075_hwmon_dev->kobj,
+				&sd5075_hwmon_attribute_group);
+	hwmon_device_unregister(sd5075_hwmon_dev);
+}
+
+late_initcall(sd5075_init);
+module_exit(sd5075_exit);
+
+MODULE_AUTHOR("Huacai Chen <chenhc@lemote.com>");
+MODULE_AUTHOR("Liangliang Huang <huangll@lemote.com>");
+MODULE_DESCRIPTION("SD5075 driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/platform/mips/tmp75.c b/drivers/platform/mips/tmp75.c
new file mode 100644
index 000000000000..0582c8fa2e2b
--- /dev/null
+++ b/drivers/platform/mips/tmp75.c
@@ -0,0 +1,24 @@
+#include <linux/module.h>
+
+static int __init tmp75_init(void)
+{
+	printk("====Please use device-tree for TMP75 Driver====\n");
+	printk("You can put the tmp75 node under the i2c node:\n"
+	       "tmp75@4e {\n"
+	       "	compatible = \"ti,tmp75\"\n"
+	       "	reg = <0x4e>\n"
+	       "}\n");
+	printk("==================Thank you!===================\n");
+	return 0;
+}
+
+static void __exit tmp75_exit(void)
+{
+}
+
+late_initcall(tmp75_init);
+module_exit(tmp75_exit);
+
+MODULE_AUTHOR("Hongbing Hu <huhb@lemote.com>");
+MODULE_DESCRIPTION("TMP75 driver, based on the EMC1412 driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/platform/mips/wpce_fan.c b/drivers/platform/mips/wpce_fan.c
new file mode 100644
index 000000000000..ecef3158c59b
--- /dev/null
+++ b/drivers/platform/mips/wpce_fan.c
@@ -0,0 +1,311 @@
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/workqueue.h>
+#include <linux/platform_device.h>
+#include <linux/err.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+
+#include <boot_param.h>
+#include <ec_wpce775l.h>
+#include <loongson_hwmon.h>
+
+#ifdef MAX_FAN_LEVEL
+#undef MAX_FAN_LEVEL
+#endif
+#define MAX_FAN_LEVEL 5
+
+int fan_enable;
+enum fan_control_mode fan_mode;
+static struct loongson_fan_policy fan_policy;
+
+static struct device *wpce775l_hwmon_dev;
+
+static ssize_t get_hwmon_name(struct device *dev,
+			struct device_attribute *attr, char *buf);
+static SENSOR_DEVICE_ATTR(name, S_IRUGO, get_hwmon_name, NULL, 0);
+
+static struct attribute *wpce775l_hwmon_attributes[] =
+{
+	&sensor_dev_attr_name.dev_attr.attr,
+	NULL
+};
+
+/* Hwmon device attribute group */
+static struct attribute_group wpce775l_hwmon_attribute_group =
+{
+	.attrs = wpce775l_hwmon_attributes,
+};
+
+/* Hwmon device get name */
+static ssize_t get_hwmon_name(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "wpce775l-fan\n");
+}
+
+static ssize_t get_fan_level(struct device *dev,
+			struct device_attribute *attr, char *buf);
+static ssize_t set_fan_level(struct device *dev,
+			struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t get_fan_mode(struct device *dev,
+			struct device_attribute *attr, char *buf);
+static ssize_t set_fan_mode(struct device *dev,
+			struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t get_fan_speed(struct device *dev,
+			struct device_attribute *attr, char *buf);
+
+static SENSOR_DEVICE_ATTR(pwm1, S_IWUSR | S_IRUGO,
+				get_fan_level, set_fan_level, 1);
+static SENSOR_DEVICE_ATTR(pwm1_enable, S_IWUSR | S_IRUGO,
+				get_fan_mode, set_fan_mode, 1);
+static SENSOR_DEVICE_ATTR(fan1_input, S_IRUGO, get_fan_speed, NULL, 1);
+
+static const struct attribute *hwmon_fan1[] = {
+	&sensor_dev_attr_pwm1.dev_attr.attr,
+	&sensor_dev_attr_pwm1_enable.dev_attr.attr,
+	&sensor_dev_attr_fan1_input.dev_attr.attr,
+	NULL
+};
+
+static struct workqueue_struct *notify_workqueue;
+static void notify_temp(struct work_struct *work);
+static DECLARE_DELAYED_WORK(notify_work, notify_temp);
+
+static int wpce_set_fan_level(u8 level)
+{
+	if (level > MAX_FAN_LEVEL)
+		level = MAX_FAN_LEVEL;
+
+	ec_write(INDEX_FAN_SPEED_LEVEL, level);
+	return 0;
+}
+
+static ssize_t get_fan_level(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	u8 val;
+
+	val = ec_read(INDEX_FAN_SPEED_LEVEL);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t set_fan_level(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	u8 new_level;
+
+	new_level = clamp_val(simple_strtoul(buf, NULL, 10), 0, 255);
+	if (fan_mode == FAN_MANUAL_MODE)
+		wpce_set_fan_level(new_level);
+
+	return count;
+}
+
+static ssize_t get_fan_speed(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	u32 val;
+
+	val = (ec_read(INDEX_FAN_SPEED_HIGH) << 8) +
+			ec_read(INDEX_FAN_SPEED_LOW);
+	return sprintf(buf, "%d\n", val);
+}
+
+static void notify_temp(struct work_struct *work)
+{
+	u8 temp;
+
+	temp =  fan_policy.depend_temp(0) / 1000;
+
+	ec_write_noindex(0x4d, temp);
+
+	queue_delayed_work(notify_workqueue, &notify_work,
+				fan_policy.adjust_period * HZ);
+}
+
+static int notify_temp_to_EC(void)
+{
+	notify_workqueue = create_singlethread_workqueue("Temprature Notify");
+	queue_delayed_work(notify_workqueue, &notify_work, HZ);
+
+	return 0;
+}
+
+static int kernel_control_fan(void)
+{
+	ec_write(INDEX_FAN_CTRLMOD,FAN_CTRL_BYHOST);
+	return 0;
+}
+
+static int ec_control_fan(void)
+{
+	ec_write(INDEX_FAN_CTRLMOD,FAN_CTRL_BYEC);
+	return 0;
+}
+
+static void fan_start_auto(void)
+{
+	ec_control_fan();
+
+	switch (fan_policy.type) {
+	case KERNEL_HELPER_POLICY:
+		notify_temp_to_EC();
+		break;
+	default:
+		printk(KERN_ERR "wpce fan not support fan policy id %d!\n", fan_policy.type);
+		wpce_set_fan_level(MAX_FAN_LEVEL);
+	}
+
+	return;
+}
+
+static void fan_stop_auto(void)
+{
+	if ((fan_policy.type == KERNEL_HELPER_POLICY) &&
+		       (fan_mode == FAN_AUTO_MODE)) {
+			cancel_delayed_work(&notify_work);
+			destroy_workqueue(notify_workqueue);
+	}
+
+	kernel_control_fan();
+}
+
+static ssize_t set_fan_mode(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	u8 new_mode;
+
+	new_mode = clamp_val(simple_strtoul(buf, NULL, 10),
+					FAN_FULL_MODE, FAN_AUTO_MODE);
+
+	if (new_mode == fan_mode)
+		return count;
+
+	switch (new_mode) {
+	case FAN_FULL_MODE:
+		fan_stop_auto();
+		wpce_set_fan_level(MAX_FAN_LEVEL);
+		break;
+	case FAN_MANUAL_MODE:
+		fan_stop_auto();
+		break;
+	case FAN_AUTO_MODE:
+		fan_start_auto();
+		break;
+	default:
+		break;
+	}
+
+	fan_mode = new_mode;
+
+	return count;
+}
+
+static ssize_t get_fan_mode(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", fan_mode);
+}
+
+static int fan_probe(struct platform_device *dev)
+{
+	int ret;
+	struct sensor_device *sdev = (struct sensor_device *)dev->dev.platform_data;
+
+	/* get fan policy */
+	switch (sdev->fan_policy) {
+	case KERNEL_HELPER_POLICY:
+		memcpy(&fan_policy, &kernel_helper_policy, sizeof(fan_policy));
+		break;
+	case STEP_SPEED_POLICY:
+		memcpy(&fan_policy, &step_speed_policy, sizeof(fan_policy));
+		break;
+	case CONSTANT_SPEED_POLICY:
+	default:
+		memcpy(&fan_policy, &constant_speed_policy, sizeof(fan_policy));
+		fan_policy.percent = sdev->fan_percent;
+		if (fan_policy.percent == 0 || fan_policy.percent > 100)
+			fan_policy.percent = 100;
+		break;
+	}
+
+	/* force fan in auto mode first */
+	fan_mode = FAN_AUTO_MODE;
+	fan_start_auto();
+
+	ret = sysfs_create_files(&wpce775l_hwmon_dev->kobj, hwmon_fan1);
+	if (ret) {
+		printk(KERN_ERR "fail to create sysfs files\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static struct platform_driver fan_driver = {
+	.probe		= fan_probe,
+	.driver		= {
+		.name	= "wpce-fan",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init wpce_fan_init(void)
+{
+	int ret;
+
+	wpce775l_hwmon_dev = hwmon_device_register(NULL);
+	if (IS_ERR(wpce775l_hwmon_dev)) {
+		ret = -ENOMEM;
+		printk(KERN_ERR "hwmon_device_register fail!\n");
+		goto fail_hwmon_device_register;
+	}
+
+	ret = sysfs_create_group(&wpce775l_hwmon_dev->kobj,
+				&wpce775l_hwmon_attribute_group);
+	if (ret) {
+		printk(KERN_ERR "fail to create loongson hwmon!\n");
+		goto fail_sysfs_create_group_hwmon;
+	}
+
+	ret = platform_driver_register(&fan_driver);
+	if (ret) {
+		printk(KERN_ERR "fail to register fan driver!\n");
+		goto fail_register_fan;
+	}
+
+	return 0;
+
+fail_register_fan:
+	sysfs_remove_group(&wpce775l_hwmon_dev->kobj,
+				&wpce775l_hwmon_attribute_group);
+
+fail_sysfs_create_group_hwmon:
+	hwmon_device_unregister(wpce775l_hwmon_dev);
+
+fail_hwmon_device_register:
+	return ret;
+}
+
+static void __exit wpce_fan_exit(void)
+{
+	/* set fan at full speed mode before module exit */
+	if (fan_enable)
+		fan_mode = FAN_FULL_MODE;
+	fan_stop_auto();
+	wpce_set_fan_level(MAX_FAN_LEVEL);
+
+	platform_driver_unregister(&fan_driver);
+	sysfs_remove_group(&wpce775l_hwmon_dev->kobj,
+				&wpce775l_hwmon_attribute_group);
+	hwmon_device_unregister(wpce775l_hwmon_dev);
+}
+
+late_initcall(wpce_fan_init);
+module_exit(wpce_fan_exit);
+
+MODULE_AUTHOR("Yu Xiang <xiangy@lemote.com>");
+MODULE_AUTHOR("Huacai Chen <chenhc@lemote.com>");
+MODULE_DESCRIPTION("WPCE775L fan control driver");
+MODULE_LICENSE("GPL");
-- 
2.31.1

